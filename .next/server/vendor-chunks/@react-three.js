/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/index.cjs.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/index.cjs.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("Object.defineProperty(exports, \"__esModule\", ({value:!0}));var e=__webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\"),t=__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"),r=__webpack_require__(/*! react-dom/client */ \"(ssr)/./node_modules/next/dist/compiled/react-dom/client.js\"),n=__webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\"),a=__webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\"),o=__webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\"),i=__webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/index.js\"),s=__webpack_require__(/*! maath */ \"(ssr)/./node_modules/maath/dist/maath.cjs.js\"),l=__webpack_require__(/*! @react-spring/three */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.js\"),c=__webpack_require__(/*! @use-gesture/react */ \"(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.cjs.js\"),u=__webpack_require__(/*! zustand/middleware */ \"(ssr)/./node_modules/zustand/esm/middleware.js\"),d=__webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/index.cjs\"),m=__webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.js\"),f=__webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\"),p=__webpack_require__(/*! meshline */ \"(ssr)/./node_modules/meshline/dist/index.cjs\"),h=__webpack_require__(/*! lodash.pick */ \"(ssr)/./node_modules/lodash.pick/index.js\"),x=__webpack_require__(/*! lodash.omit */ \"(ssr)/./node_modules/lodash.omit/index.js\"),y=__webpack_require__(/*! camera-controls */ \"(ssr)/./node_modules/camera-controls/dist/camera-controls.js\"),v=__webpack_require__(/*! stats.js */ \"(ssr)/./node_modules/stats.js/build/stats.min.js\"),g=__webpack_require__(/*! stats-gl */ \"(ssr)/./node_modules/stats-gl/dist/main.cjs\"),z=__webpack_require__(/*! detect-gpu */ \"(ssr)/./node_modules/detect-gpu/dist/detect-gpu.umd.js\"),w=__webpack_require__(/*! three-mesh-bvh */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs\"),b=__webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\"),M=__webpack_require__(/*! react-composer */ \"(ssr)/./node_modules/react-composer/lib/index.js\"),E=__webpack_require__(/*! lodash.clamp */ \"(ssr)/./node_modules/lodash.clamp/index.js\");function S(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}function T(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if(\"default\"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var C=S(e),P=T(t),R=T(r),D=T(n),F=S(o),k=S(i),_=S(m),A=S(h),L=S(x),B=S(y),U=S(v),I=S(g),V=S(M),O=S(E);const N=new n.Vector3,j=new n.Vector3,W=new n.Vector3;function G(e,t,r){const n=N.setFromMatrixPosition(e.matrixWorld);n.project(t);const a=r.width/2,o=r.height/2;return[n.x*a+a,-n.y*o+o]}const H=e=>Math.abs(e)<1e-10?0:e;function $(e,t,r=\"\"){let n=\"matrix3d(\";for(let r=0;16!==r;r++)n+=H(t[r]*e.elements[r])+(15!==r?\",\":\")\");return r+n}const q=(X=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>$(e,X));var X;const Z=(e,t)=>{return $(e,[1/(r=t),1/r,1/r,1,-1/r,-1/r,-1/r,-1,1/r,1/r,1/r,1,1,1,1,1],\"translate(-50%,-50%)\");var r};const Y=P.forwardRef((({children:e,eps:t=.001,style:r,className:o,prepend:i,center:s,fullscreen:l,portal:c,distanceFactor:u,sprite:d=!1,transform:m=!1,occlude:f,onOcclude:p,castShadow:h,receiveShadow:x,material:y,geometry:v,zIndexRange:g=[16777271,0],calculatePosition:z=G,as:w=\"div\",wrapperClass:b,pointerEvents:M=\"auto\",...E},S)=>{const{gl:T,camera:D,scene:F,size:k,raycaster:_,events:A,viewport:L}=a.useThree(),[B]=P.useState((()=>document.createElement(w))),U=P.useRef(),I=P.useRef(null),V=P.useRef(0),O=P.useRef([0,0]),$=P.useRef(null),X=P.useRef(null),Y=(null==c?void 0:c.current)||A.connected||T.domElement.parentNode,Q=P.useRef(null),K=P.useRef(!1),J=P.useMemo((()=>f&&\"blending\"!==f||Array.isArray(f)&&f.length&&function(e){return e&&\"object\"==typeof e&&\"current\"in e}(f[0])),[f]);P.useLayoutEffect((()=>{const e=T.domElement;f&&\"blending\"===f?(e.style.zIndex=`${Math.floor(g[0]/2)}`,e.style.position=\"absolute\",e.style.pointerEvents=\"none\"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[f]),P.useLayoutEffect((()=>{if(I.current){const e=U.current=R.createRoot(B);if(F.updateMatrixWorld(),m)B.style.cssText=\"position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;\";else{const e=z(I.current,D,k);B.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Y&&(i?Y.prepend(B):Y.appendChild(B)),()=>{Y&&Y.removeChild(B),e.unmount()}}}),[Y,m]),P.useLayoutEffect((()=>{b&&(B.className=b)}),[b]);const ee=P.useMemo((()=>m?{position:\"absolute\",top:0,left:0,width:k.width,height:k.height,transformStyle:\"preserve-3d\",pointerEvents:\"none\"}:{position:\"absolute\",transform:s?\"translate3d(-50%,-50%,0)\":\"none\",...l&&{top:-k.height/2,left:-k.width/2,width:k.width,height:k.height},...r}),[r,s,l,k,m]),te=P.useMemo((()=>({position:\"absolute\",pointerEvents:M})),[M]);P.useLayoutEffect((()=>{var t,n;(K.current=!1,m)?null==(t=U.current)||t.render(P.createElement(\"div\",{ref:$,style:ee},P.createElement(\"div\",{ref:X,style:te},P.createElement(\"div\",{ref:S,className:o,style:r,children:e})))):null==(n=U.current)||n.render(P.createElement(\"div\",{ref:S,style:ee,className:o,children:e}))}));const re=P.useRef(!0);a.useFrame((e=>{if(I.current){D.updateMatrixWorld(),I.current.updateWorldMatrix(!0,!1);const e=m?O.current:z(I.current,D,k);if(m||Math.abs(V.current-D.zoom)>t||Math.abs(O.current[0]-e[0])>t||Math.abs(O.current[1]-e[1])>t){const t=function(e,t){const r=N.setFromMatrixPosition(e.matrixWorld),n=j.setFromMatrixPosition(t.matrixWorld),a=r.sub(n),o=t.getWorldDirection(W);return a.angleTo(o)>Math.PI/2}(I.current,D);let r=!1;J&&(Array.isArray(f)?r=f.map((e=>e.current)):\"blending\"!==f&&(r=[F]));const a=re.current;if(r){const e=function(e,t,r,n){const a=N.setFromMatrixPosition(e.matrixWorld),o=a.clone();o.project(t),r.setFromCamera(o,t);const i=r.intersectObjects(n,!0);if(i.length){const e=i[0].distance;return a.distanceTo(r.ray.origin)<e}return!0}(I.current,D,_,r);re.current=e&&!t}else re.current=!t;a!==re.current&&(p?p(!re.current):B.style.display=re.current?\"block\":\"none\");const o=Math.floor(g[0]/2),i=f?J?[g[0],o]:[o-1,0]:g;if(B.style.zIndex=`${function(e,t,r){if(t instanceof n.PerspectiveCamera||t instanceof n.OrthographicCamera){const n=N.setFromMatrixPosition(e.matrixWorld),a=j.setFromMatrixPosition(t.matrixWorld),o=n.distanceTo(a),i=(r[1]-r[0])/(t.far-t.near),s=r[1]-i*t.far;return Math.round(i*o+s)}}(I.current,D,i)}`,m){const[e,t]=[k.width/2,k.height/2],r=D.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:a,left:o,bottom:i,right:s}=D,l=q(D.matrixWorldInverse),c=n?`scale(${r})translate(${H(-(s+o)/2)}px,${H((a+i)/2)}px)`:`translateZ(${r}px)`;let m=I.current.matrixWorld;d&&(m=D.matrixWorldInverse.clone().transpose().copyPosition(m).scale(I.current.scale),m.elements[3]=m.elements[7]=m.elements[11]=0,m.elements[15]=1),B.style.width=k.width+\"px\",B.style.height=k.height+\"px\",B.style.perspective=n?\"\":`${r}px`,$.current&&X.current&&($.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,X.current.style.transform=Z(m,1/((u||10)/400)))}else{const t=void 0===u?1:function(e,t){if(t instanceof n.OrthographicCamera)return t.zoom;if(t instanceof n.PerspectiveCamera){const r=N.setFromMatrixPosition(e.matrixWorld),n=j.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,o=r.distanceTo(n);return 1/(2*Math.tan(a/2)*o)}return 1}(I.current,D)*u;B.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}O.current=e,V.current=D.zoom}}if(!J&&Q.current&&!K.current)if(m){if($.current){const e=$.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=D;if(t||v)E.scale&&(Array.isArray(E.scale)?E.scale instanceof n.Vector3?Q.current.scale.copy(E.scale.clone().divideScalar(1)):Q.current.scale.set(1/E.scale[0],1/E.scale[1],1/E.scale[2]):Q.current.scale.setScalar(1/E.scale));else{const t=(u||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;Q.current.scale.set(r,n,1)}K.current=!0}}}else{const t=B.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/L.factor,r=t.clientWidth*e,n=t.clientHeight*e;Q.current.scale.set(r,n,1),K.current=!0}Q.current.lookAt(e.camera.position)}}));const ne=P.useMemo((()=>({vertexShader:m?void 0:'\\n          /*\\n            This shader is from the THREE\\'s SpriteMaterial.\\n            We need to turn the backing plane into a Sprite\\n            (make it always face the camera) if \"transfrom\" \\n            is false. \\n          */\\n          #include <common>\\n\\n          void main() {\\n            vec2 center = vec2(0., 1.);\\n            float rotation = 0.0;\\n            \\n            // This is somewhat arbitrary, but it seems to work well\\n            // Need to figure out how to derive this dynamically if it even matters\\n            float size = 0.03;\\n\\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n            vec2 scale;\\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n            if ( isPerspective ) scale *= - mvPosition.z;\\n\\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\\n            vec2 rotatedPosition;\\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n            mvPosition.xy += rotatedPosition;\\n\\n            gl_Position = projectionMatrix * mvPosition;\\n          }\\n      ',fragmentShader:\"\\n        void main() {\\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\\n        }\\n      \"})),[m]);return P.createElement(\"group\",C.default({},E,{ref:I}),f&&!J&&P.createElement(\"mesh\",{castShadow:h,receiveShadow:x,ref:Q},v||P.createElement(\"planeGeometry\",null),y||P.createElement(\"shaderMaterial\",{side:n.DoubleSide,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))}));let Q=0;const K=F.default((e=>(n.DefaultLoadingManager.onStart=(t,r,n)=>{e({active:!0,item:t,loaded:r,total:n,progress:(r-Q)/(n-Q)*100})},n.DefaultLoadingManager.onLoad=()=>{e({active:!1})},n.DefaultLoadingManager.onError=t=>e((e=>({errors:[...e.errors,t]}))),n.DefaultLoadingManager.onProgress=(t,r,n)=>{r===n&&(Q=n),e({active:!0,item:t,loaded:r,total:n,progress:(r-Q)/(n-Q)*100||100})},{errors:[],active:!1,progress:0,item:\"\",loaded:0,total:0}))),J=e=>`Loading ${e.toFixed(2)}%`;const ee={container:{position:\"absolute\",top:0,left:0,width:\"100%\",height:\"100%\",background:\"#171717\",display:\"flex\",alignItems:\"center\",justifyContent:\"center\",transition:\"opacity 300ms ease\",zIndex:1e3},inner:{width:100,height:3,background:\"#272727\",textAlign:\"center\"},bar:{height:3,width:\"100%\",background:\"white\",transition:\"transform 200ms\",transformOrigin:\"left center\"},data:{display:\"inline-block\",position:\"relative\",fontVariantNumeric:\"tabular-nums\",marginTop:\"0.8em\",color:\"#f0f0f0\",fontSize:\"0.6em\",fontFamily:'-apple-system, BlinkMacSystemFont, \"Inter\", \"Segoe UI\", \"Helvetica Neue\", Helvetica, Arial, Roboto, Ubuntu, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\"',whiteSpace:\"nowrap\"}},te=P.createContext(null);function re(){return P.useContext(te)}const ne=P.forwardRef((({children:e},t)=>{const r=P.useRef(null),n=re(),{width:o,height:i}=a.useThree((e=>e.viewport));return a.useFrame((()=>{r.current.position.x=n.horizontal?-o*(n.pages-1)*n.offset:0,r.current.position.y=n.horizontal?0:i*(n.pages-1)*n.offset})),P.createElement(\"group\",{ref:k.default([t,r])},e)})),ae=P.forwardRef((({children:e,style:t,...r},n)=>{const o=re(),i=P.useRef(null),{width:s,height:l}=a.useThree((e=>e.size)),c=P.useContext(a.context),u=P.useMemo((()=>R.createRoot(o.fixed)),[o.fixed]);return a.useFrame((()=>{o.delta>o.eps&&(i.current.style.transform=`translate3d(${o.horizontal?-s*(o.pages-1)*o.offset:0}px,${o.horizontal?0:l*(o.pages-1)*-o.offset}px,0)`)})),u.render(P.createElement(\"div\",C.default({ref:k.default([n,i]),style:{...t,position:\"absolute\",top:0,left:0,willChange:\"transform\"}},r),P.createElement(te.Provider,{value:o},P.createElement(a.context.Provider,{value:c},e)))),null})),oe=P.forwardRef((({html:e,...t},r)=>{const n=e?ae:ne;return P.createElement(n,C.default({ref:r},t))}));const ie=P.createContext(null);const se=P.createContext([]);const le=P.forwardRef((function({children:e,follow:t=!0,lockX:r=!1,lockY:o=!1,lockZ:i=!1,...s},l){const c=P.useRef(null),u=P.useRef(null),d=new n.Quaternion;return a.useFrame((({camera:e})=>{if(!t||!u.current)return;const n=u.current.rotation.clone();u.current.updateMatrix(),u.current.updateWorldMatrix(!1,!1),u.current.getWorldQuaternion(d),e.getWorldQuaternion(c.current.quaternion).premultiply(d.invert()),r&&(u.current.rotation.x=n.x),o&&(u.current.rotation.y=n.y),i&&(u.current.rotation.z=n.z)})),P.useImperativeHandle(l,(()=>u.current),[]),P.createElement(\"group\",C.default({ref:u,matrixAutoUpdate:!1,matrixWorldAutoUpdate:!1},s),P.createElement(\"group\",{ref:c},e))})),ce=P.forwardRef((({children:e,depth:t=-1,...r},n)=>{const o=P.useRef(null);return a.useFrame((({camera:e})=>{o.current.quaternion.copy(e.quaternion),o.current.position.copy(e.position)})),P.createElement(\"group\",C.default({ref:k.default([n,o])},r),P.createElement(\"group\",{\"position-z\":-t},e))})),ue=P.forwardRef((function({points:e,color:t=\"black\",vertexColors:r,linewidth:o,lineWidth:i,segments:s,dashed:l,...c},u){const m=a.useThree((e=>e.size)),f=P.useMemo((()=>s?new d.LineSegments2:new d.Line2),[s]),[p]=P.useState((()=>new d.LineMaterial)),h=P.useMemo((()=>{const t=s?new d.LineSegmentsGeometry:new d.LineGeometry,a=e.map((e=>{const t=Array.isArray(e);return e instanceof n.Vector3?[e.x,e.y,e.z]:e instanceof n.Vector2?[e.x,e.y,0]:t&&3===e.length?[e[0],e[1],e[2]]:t&&2===e.length?[e[0],e[1],0]:e}));if(t.setPositions(a.flat()),r){const e=r.map((e=>e instanceof n.Color?e.toArray():e));t.setColors(e.flat())}return t}),[e,s,r]);return P.useLayoutEffect((()=>{f.computeLineDistances()}),[e,f]),P.useLayoutEffect((()=>{l?p.defines.USE_DASH=\"\":delete p.defines.USE_DASH,p.needsUpdate=!0}),[l,p]),P.useEffect((()=>()=>h.dispose()),[h]),P.createElement(\"primitive\",C.default({object:f,ref:u},c),P.createElement(\"primitive\",{object:h,attach:\"geometry\"}),P.createElement(\"primitive\",C.default({object:p,attach:\"material\",color:t,vertexColors:Boolean(r),resolution:[m.width,m.height],linewidth:null!=o?o:i,dashed:l},c)))})),de=new n.Vector3,me=P.forwardRef((function({start:e=[0,0,0],end:t=[0,0,0],mid:r,segments:a=20,...o},i){const s=P.useRef(null),[l]=P.useState((()=>new n.QuadraticBezierCurve3(void 0,void 0,void 0))),c=P.useCallback(((e,t,r,a=20)=>(e instanceof n.Vector3?l.v0.copy(e):l.v0.set(...e),t instanceof n.Vector3?l.v2.copy(t):l.v2.set(...t),r instanceof n.Vector3?l.v1.copy(r):Array.isArray(r)?l.v1.set(...r):l.v1.copy(l.v0.clone().add(l.v2.clone().sub(l.v0)).add(de.set(0,l.v0.y-l.v2.y,0))),l.getPoints(a))),[]);P.useLayoutEffect((()=>{s.current.setPoints=(e,t,r)=>{const n=c(e,t,r);s.current.geometry&&s.current.geometry.setPositions(n.map((e=>e.toArray())).flat())}}),[]);const u=P.useMemo((()=>c(e,t,r,a)),[e,t,r,a]);return P.createElement(ue,C.default({ref:k.default([s,i]),points:u},o))})),fe=P.forwardRef((function({start:e,end:t,midA:r,midB:a,segments:o=20,...i},s){const l=P.useMemo((()=>{const i=e instanceof n.Vector3?e:new n.Vector3(...e),s=t instanceof n.Vector3?t:new n.Vector3(...t),l=r instanceof n.Vector3?r:new n.Vector3(...r),c=a instanceof n.Vector3?a:new n.Vector3(...a);return new n.CubicBezierCurve3(i,l,c,s).getPoints(o)}),[e,t,r,a,o]);return P.createElement(ue,C.default({ref:s,points:l},i))})),pe=P.forwardRef((function({points:e,closed:t=!1,curveType:r=\"centripetal\",tension:a=.5,segments:o=20,vertexColors:i,...s},l){const c=P.useMemo((()=>{const o=e.map((e=>e instanceof n.Vector3?e:new n.Vector3(...e)));return new n.CatmullRomCurve3(o,t,r,a)}),[e,t,r,a]),u=P.useMemo((()=>c.getPoints(o)),[c,o]),d=P.useMemo((()=>{if(!i||i.length<2)return;if(i.length===o+1)return i;const e=i.map((e=>e instanceof n.Color?e:new n.Color(...e)));t&&e.push(e[0].clone());const r=[e[0]],a=o/(e.length-1);for(let t=1;t<o;t++){const n=t%a/a,o=Math.floor(t/a);r.push(e[o].clone().lerp(e[o+1],n))}return r.push(e[e.length-1]),r}),[i,o]);return P.createElement(ue,C.default({ref:l,points:u,vertexColors:d},s))})),he=P.forwardRef((({url:e,distance:t=1,loop:r=!0,autoplay:o,...i},s)=>{const l=P.useRef(),c=a.useThree((({camera:e})=>e)),[u]=P.useState((()=>new n.AudioListener)),d=a.useLoader(n.AudioLoader,e);return P.useEffect((()=>{const e=l.current;e&&(e.setBuffer(d),e.setRefDistance(t),e.setLoop(r),o&&!e.isPlaying&&e.play())}),[d,c,t,r]),P.useEffect((()=>{const e=l.current;return c.add(u),()=>{c.remove(u),e&&(e.isPlaying&&e.stop(),e.source&&e.source._connected&&e.disconnect())}}),[]),P.createElement(\"positionalAudio\",C.default({ref:k.default([l,s]),args:[u]},i))})),xe=P.forwardRef((({sdfGlyphSize:e=64,anchorX:t=\"center\",anchorY:r=\"middle\",font:n,fontSize:o=1,children:i,characters:s,onSync:l,...c},u)=>{const{Text:d,preloadFont:m}=f.suspend((async()=>Promise.resolve().then((function(){return T(__webpack_require__(/*! troika-three-text */ \"(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\"))}))),[]),p=a.useThree((({invalidate:e})=>e)),[h]=P.useState((()=>new d)),[x,y]=P.useMemo((()=>{const e=[];let t=\"\";return P.Children.forEach(i,(r=>{\"string\"==typeof r||\"number\"==typeof r?t+=r:e.push(r)})),[e,t]}),[i]);return f.suspend((()=>new Promise((e=>m({font:n,characters:s},e)))),[\"troika-text\",n,s]),P.useLayoutEffect((()=>{h.sync((()=>{p(),l&&l(h)}))})),P.useEffect((()=>()=>h.dispose()),[h]),P.createElement(\"primitive\",C.default({object:h,ref:u,font:n,text:y,anchorX:t,anchorY:r,fontSize:o,sdfGlyphSize:e},c),x)}));let ye=null;async function ve(e){ye||(ye=new d.FontLoader);let t=\"string\"==typeof e?await(await fetch(e)).json():e;return ye.parse(t)}function ge(e){return f.suspend(ve,[e])}ge.preload=e=>f.preload(ve,[e]),ge.clear=e=>f.clear([e]);const ze=[\"string\",\"number\"],we=P.forwardRef((({font:e,letterSpacing:r=0,lineHeight:n=1,size:o=1,height:i=.2,bevelThickness:s=.1,bevelSize:l=.01,bevelEnabled:c=!1,bevelOffset:u=0,bevelSegments:m=4,curveSegments:f=8,smooth:p,children:h,...x},y)=>{P.useMemo((()=>a.extend({RenamedTextGeometry:d.TextGeometry})),[]);const v=P.useRef(null),g=ge(e),z=t.useMemo((()=>({font:g,size:o,height:i,bevelThickness:s,bevelSize:l,bevelEnabled:c,bevelSegments:m,bevelOffset:u,curveSegments:f,letterSpacing:r,lineHeight:n})),[g,o,i,s,l,c,m,u,f,r,n]),[w,...b]=t.useMemo((()=>(e=>{let t=\"\";const r=[];return P.Children.forEach(e,(e=>{ze.includes(typeof e)?t+=e+\"\":r.push(e)})),[t,...r]})(h)),[h]),M=P.useMemo((()=>[w,z]),[w,z]);return P.useLayoutEffect((()=>{p&&(v.current.geometry=d.mergeVertices(v.current.geometry,p),v.current.geometry.computeVertexNormals())}),[M,p]),P.useImperativeHandle(y,(()=>v.current),[]),P.createElement(\"mesh\",C.default({},x,{ref:v}),P.createElement(\"renamedTextGeometry\",{args:M}),b)})),be=P.forwardRef((({children:e,multisamping:t=8,renderIndex:r=1,disableRender:o,disableGamma:i,disableRenderPass:s,depthBuffer:l=!0,stencilBuffer:c=!1,anisotropy:u=1,encoding:m,type:f,...p},h)=>{P.useMemo((()=>a.extend({EffectComposer:d.EffectComposer,RenderPass:d.RenderPass,ShaderPass:d.ShaderPass})),[]);const x=P.useRef(),{scene:y,camera:v,gl:g,size:z,viewport:w}=a.useThree(),[b]=P.useState((()=>{const e=new n.WebGLRenderTarget(z.width,z.height,{type:f||n.HalfFloatType,format:n.RGBAFormat,depthBuffer:l,stencilBuffer:c,anisotropy:u});return f===n.UnsignedByteType&&null!=m&&(\"colorSpace\"in e?e.texture.colorSpace=m:e.texture.encoding=m),e.samples=t,e}));P.useEffect((()=>{var e,t;null==(e=x.current)||e.setSize(z.width,z.height),null==(t=x.current)||t.setPixelRatio(w.dpr)}),[g,z,w.dpr]),a.useFrame((()=>{var e;o||null==(e=x.current)||e.render()}),r);const M=[];return s||M.push(P.createElement(\"renderPass\",{key:\"renderpass\",attach:`passes-${M.length}`,args:[y,v]})),i||M.push(P.createElement(\"shaderPass\",{attach:`passes-${M.length}`,key:\"gammapass\",args:[d.GammaCorrectionShader]})),P.Children.forEach(e,(e=>{e&&M.push(P.cloneElement(e,{key:M.length,attach:`passes-${M.length}`}))})),P.createElement(\"effectComposer\",C.default({ref:k.default([h,x]),args:[g,b]},p),M)}));let Me=function(e){return e.Linear=\"linear\",e.Radial=\"radial\",e}({});function Ee(e,t,r,n){const a=class extends D.ShaderMaterial{constructor(a={}){const o=Object.entries(e);super({uniforms:o.reduce(((e,[t,r])=>({...e,...D.UniformsUtils.clone({[t]:{value:r}})})),{}),vertexShader:t,fragmentShader:r}),this.key=\"\",o.forEach((([e])=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t}))),Object.assign(this,a),n&&n(this)}};return a.key=D.MathUtils.generateUUID(),a}const Se=e=>e===Object(e)&&!Array.isArray(e)&&\"function\"!=typeof e;function Te(e,r){const o=a.useThree((e=>e.gl)),i=a.useLoader(n.TextureLoader,Se(e)?Object.values(e):e);if(t.useLayoutEffect((()=>{null==r||r(i)}),[r]),t.useEffect((()=>{if(\"initTexture\"in o){(Array.isArray(i)?i:[i]).forEach(o.initTexture)}}),[o,i]),Se(e)){const t={};let r=0;for(const n in e)t[n]=i[r++];return t}return i}Te.preload=e=>a.useLoader.preload(n.TextureLoader,e),Te.clear=e=>a.useLoader.clear(n.TextureLoader,e);const Ce=(()=>parseInt(n.REVISION.replace(/\\D+/g,\"\")))(),Pe=Ee({color:new D.Color(\"white\"),scale:new D.Vector2(1,1),imageBounds:new D.Vector2(1,1),map:null,zoom:1,grayscale:0,opacity:1},\"\\n  varying vec2 vUv;\\n  void main() {\\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n    vUv = uv;\\n  }\\n\",`\\n  // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44\\n  varying vec2 vUv;\\n  uniform vec2 scale;\\n  uniform vec2 imageBounds;\\n  uniform vec3 color;\\n  uniform sampler2D map;\\n  uniform float zoom;\\n  uniform float grayscale;\\n  uniform float opacity;\\n  const vec3 luma = vec3(.299, 0.587, 0.114);\\n  vec4 toGrayscale(vec4 color, float intensity) {\\n    return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);\\n  }\\n  vec2 aspect(vec2 size) {\\n    return size / min(size.x, size.y);\\n  }\\n  void main() {\\n    vec2 s = aspect(scale);\\n    vec2 i = aspect(imageBounds);\\n    float rs = s.x / s.y;\\n    float ri = i.x / i.y;\\n    vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);\\n    vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;\\n    vec2 uv = vUv * s / new + offset;\\n    vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);\\n    gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity), grayscale);\\n    \\n    #include <tonemapping_fragment>\\n    #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n  }\\n`),Re=P.forwardRef((({children:e,color:t,segments:r=1,scale:n=1,zoom:o=1,grayscale:i=0,opacity:s=1,texture:l,toneMapped:c,transparent:u,side:d,...m},f)=>{a.extend({ImageMaterial:Pe});const p=P.useRef(null),h=Array.isArray(n)?[n[0],n[1]]:[n,n],x=[l.image.width,l.image.height];return P.useImperativeHandle(f,(()=>p.current),[]),P.useLayoutEffect((()=>{p.current.geometry.parameters&&p.current.material.scale.set(h[0]*p.current.geometry.parameters.width,h[1]*p.current.geometry.parameters.height)}),[]),P.createElement(\"mesh\",C.default({ref:p,scale:Array.isArray(n)?[...n,1]:n},m),P.createElement(\"planeGeometry\",{args:[1,1,r,r]}),P.createElement(\"imageMaterial\",{color:t,map:l,zoom:o,grayscale:i,opacity:s,scale:h,imageBounds:x,toneMapped:c,transparent:u,side:d}),e)})),De=P.forwardRef((({url:e,...t},r)=>{const n=Te(e);return P.createElement(Re,C.default({},t,{texture:n,ref:r}))})),Fe=P.forwardRef((({url:e,...t},r)=>P.createElement(Re,C.default({},t,{ref:r})))),ke=P.forwardRef(((e,t)=>{if(e.url)return P.createElement(De,C.default({},e,{ref:t}));if(e.texture)return P.createElement(Fe,C.default({},e,{ref:t}));throw new Error(\"<Image /> requires a url or texture\")})),_e=P.forwardRef((({userData:e,children:t,geometry:r,threshold:n=15,color:a=\"black\",...o},i)=>{const s=P.useRef(null);return P.useLayoutEffect((()=>{const e=s.current.parent;if(e){const t=r||e.geometry;t===s.current.userData.currentGeom&&n===s.current.userData.currentThreshold||(s.current.userData.currentGeom=t,s.current.userData.currentThreshold=n,s.current.geometry=new D.EdgesGeometry(t,n))}})),P.useImperativeHandle(i,(()=>s.current)),P.createElement(\"lineSegments\",C.default({ref:s,raycast:()=>null},o),t||P.createElement(\"lineBasicMaterial\",{color:a}))})),Ae=Ee({screenspace:!1,color:new D.Color(\"black\"),opacity:1,thickness:.05,size:new D.Vector2},\"#include <common>\\n   #include <morphtarget_pars_vertex>\\n   #include <skinning_pars_vertex>\\n   uniform float thickness;\\n   uniform float screenspace;\\n   uniform vec2 size;\\n   void main() {\\n     #if defined (USE_SKINNING)\\n\\t     #include <beginnormal_vertex>\\n       #include <morphnormal_vertex>\\n       #include <skinbase_vertex>\\n       #include <skinnormal_vertex>\\n       #include <defaultnormal_vertex>\\n     #endif\\n     #include <begin_vertex>\\n\\t   #include <morphtarget_vertex>\\n\\t   #include <skinning_vertex>\\n     #include <project_vertex>\\n     vec4 tNormal = vec4(normal, 0.0);\\n     vec4 tPosition = vec4(transformed, 1.0);\\n     #ifdef USE_INSTANCING\\n       tNormal = instanceMatrix * tNormal;\\n       tPosition = instanceMatrix * tPosition;\\n     #endif\\n     if (screenspace == 0.0) {\\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \\n     } else {\\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\\n       clipPosition.xy += offset;\\n       gl_Position = clipPosition;\\n     }\\n   }\",`uniform vec3 color;\\n   uniform float opacity;\\n   void main(){\\n     gl_FragColor = vec4(color, opacity);\\n     #include <tonemapping_fragment>\\n     #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`);const Le={width:.2,length:1,decay:1,local:!1,stride:0,interval:1},Be=(e,t=1)=>(e.set(e.subarray(t)),e.fill(-1/0,-t),e);function Ue(e,t){const{length:r,local:o,decay:i,interval:s,stride:l}={...Le,...t},c=P.useRef(),[u]=P.useState((()=>new n.Vector3));P.useLayoutEffect((()=>{e&&(c.current=Float32Array.from({length:10*r*3},((t,r)=>e.position.getComponent(r%3))))}),[r,e]);const d=P.useRef(new n.Vector3),m=P.useRef(0);return a.useFrame((()=>{if(e&&c.current){if(0===m.current){let t;o?t=e.position:(e.getWorldPosition(u),t=u);const r=1*i;for(let e=0;e<r;e++)t.distanceTo(d.current)<l||(Be(c.current,3),c.current.set(t.toArray(),c.current.length-3));d.current.copy(t)}m.current++,m.current=m.current%s}})),c}const Ie=P.forwardRef(((e,t)=>{const{children:r}=e,{width:o,length:i,decay:s,local:l,stride:c,interval:u}={...Le,...e},{color:d=\"hotpink\",attenuation:m,target:f}=e,h=a.useThree((e=>e.size)),x=a.useThree((e=>e.scene)),y=P.useRef(null),[v,g]=P.useState(null),z=Ue(v,{length:i,decay:s,local:l,stride:c,interval:u});P.useEffect((()=>{const e=(null==f?void 0:f.current)||y.current.children.find((e=>e instanceof n.Object3D));e&&g(e)}),[z,f]);const w=P.useMemo((()=>new p.MeshLineGeometry),[]),b=P.useMemo((()=>{var e;const t=new p.MeshLineMaterial({lineWidth:.1*o,color:d,sizeAttenuation:1,resolution:new n.Vector2(h.width,h.height)});let a;if(r)if(Array.isArray(r))a=r.find((e=>{const t=e;return\"string\"==typeof t.type&&\"meshLineMaterial\"===t.type}));else{const e=r;\"string\"==typeof e.type&&\"meshLineMaterial\"===e.type&&(a=e)}return\"object\"==typeof(null==(e=a)?void 0:e.props)&&t.setValues(a.props),t}),[o,d,h,r]);return P.useEffect((()=>{b.uniforms.resolution.value.set(h.width,h.height)}),[h]),a.useFrame((()=>{z.current&&w.setPoints(z.current,m)})),P.createElement(\"group\",null,a.createPortal(P.createElement(\"mesh\",{ref:t,geometry:w,material:b}),x),P.createElement(\"group\",{ref:y},r))}));function Ve(e,t=16,r,a,o){const[i,s]=P.useState((()=>{const e=Array.from({length:t},(()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])).flat();return new n.InstancedBufferAttribute(Float32Array.from(e),16)}));return P.useLayoutEffect((()=>{if(void 0===e.current)return;const l=new d.MeshSurfaceSampler(e.current);a&&l.setWeightAttribute(a),l.build();const c=new n.Vector3,u=new n.Vector3,m=new n.Color,f=new n.Object3D;e.current.updateMatrixWorld(!0);for(let n=0;n<t;n++)l.sample(c,u,m),\"function\"==typeof r?r({dummy:f,sampledMesh:e.current,position:c,normal:u,color:m},n):f.position.copy(c),f.updateMatrix(),null!=o&&o.current&&o.current.setMatrixAt(n,f.matrix),f.matrix.toArray(i.array,16*n);null!=o&&o.current&&(o.current.instanceMatrix.needsUpdate=!0),i.needsUpdate=!0,s(i.clone())}),[e,o,a,t,r]),i}const Oe=P.forwardRef((({isChild:e=!1,object:t,children:r,deep:n,castShadow:a,receiveShadow:o,inject:i,keys:s,...l},c)=>{var u;const m={keys:s,deep:n,inject:i,castShadow:a,receiveShadow:o};if(t=P.useMemo((()=>{if(!1===e&&!Array.isArray(t)){let e=!1;if(t.traverse((t=>{t.isSkinnedMesh&&(e=!0)})),e)return d.SkeletonUtils.clone(t)}return t}),[t,e]),Array.isArray(t))return P.createElement(\"group\",C.default({},l,{ref:c}),t.map((e=>P.createElement(Oe,C.default({key:e.uuid,object:e},m)))),r);const{children:f,...p}=function(e,{keys:t=[\"near\",\"far\",\"color\",\"distance\",\"decay\",\"penumbra\",\"angle\",\"intensity\",\"skeleton\",\"visible\",\"castShadow\",\"receiveShadow\",\"morphTargetDictionary\",\"morphTargetInfluences\",\"name\",\"geometry\",\"material\",\"position\",\"rotation\",\"scale\",\"up\",\"userData\",\"bindMode\",\"bindMatrix\",\"bindMatrixInverse\",\"skeleton\"],deep:r,inject:n,castShadow:a,receiveShadow:o}){let i=A.default(e,t);return r&&(i.geometry&&\"materialsOnly\"!==r&&(i.geometry=i.geometry.clone()),i.material&&\"geometriesOnly\"!==r&&(i.material=i.material.clone())),n&&(i=\"function\"==typeof n?{...i,children:n(e)}:P.isValidElement(n)?{...i,children:n}:{...i,...n}),e instanceof D.Mesh&&(a&&(i.castShadow=!0),o&&(i.receiveShadow=!0)),i}(t,m),h=t.type[0].toLowerCase()+t.type.slice(1);return P.createElement(h,C.default({},p,l,{ref:c}),(null==(u=t)?void 0:u.children).map((e=>\"Bone\"===e.type?P.createElement(\"primitive\",C.default({key:e.uuid,object:e},m)):P.createElement(Oe,C.default({key:e.uuid,object:e},m,{isChild:!0})))),r,f)})),Ne=P.createContext(null),je=P.forwardRef((({resolution:e=28,maxPolyCount:t=1e4,enableUvs:r=!1,enableColors:n=!1,children:o,...i},s)=>{const l=P.useRef(null),c=P.useMemo((()=>new d.MarchingCubes(e,null,r,n,t)),[e,t,r,n]),u=P.useMemo((()=>({getParent:()=>l})),[]);return a.useFrame((()=>{c.update(),c.reset()}),-1),P.createElement(P.Fragment,null,P.createElement(\"primitive\",C.default({object:c,ref:k.default([l,s])},i),P.createElement(Ne.Provider,{value:u},o)))})),We=P.forwardRef((({strength:e=.5,subtract:t=12,color:r,...n},o)=>{const{getParent:i}=P.useContext(Ne),s=P.useMemo((()=>i()),[i]),l=P.useRef(),c=new D.Vector3;return a.useFrame((n=>{s.current&&l.current&&(l.current.getWorldPosition(c),s.current.addBall(.5+.5*c.x,.5+.5*c.y,.5+.5*c.z,e,t,r))})),P.createElement(\"group\",C.default({ref:k.default([o,l])},n))})),Ge=P.forwardRef((({planeType:e=\"x\",strength:t=.5,subtract:r=12,...n},o)=>{const{getParent:i}=P.useContext(Ne),s=P.useMemo((()=>i()),[i]),l=P.useRef(),c=P.useMemo((()=>\"x\"===e?\"addPlaneX\":\"y\"===e?\"addPlaneY\":\"addPlaneZ\"),[e]);return a.useFrame((()=>{s.current&&l.current&&s.current[c](t,r)})),P.createElement(\"group\",C.default({ref:k.default([o,l])},n))}));function He(e=[0,0,0]){return function(e){return Array.isArray(e)}(e)?e:e instanceof D.Vector3||e instanceof D.Euler?[e.x,e.y,e.z]:[e,e,e]}const $e=P.forwardRef((function({debug:e,depthTest:t=!1,polygonOffsetFactor:r=-10,map:n,mesh:o,children:i,position:s,rotation:l,scale:c,...u},m){const f=P.useRef(null);P.useImperativeHandle(m,(()=>f.current));const p=P.useRef(null);return P.useLayoutEffect((()=>{const e=(null==o?void 0:o.current)||f.current.parent,t=f.current;if(!(e instanceof D.Mesh))throw new Error('Decal must have a Mesh as parent or specify its \"mesh\" prop');const r={position:new D.Vector3,rotation:new D.Euler,scale:new D.Vector3(1,1,1)};if(e){a.applyProps(r,{position:s,scale:c});const n=e.matrixWorld.clone();if(e.matrixWorld.identity(),l&&\"number\"!=typeof l)a.applyProps(r,{rotation:l});else{const t=new D.Object3D;t.position.copy(r.position),t.lookAt(e.position),\"number\"==typeof l&&t.rotateZ(l),a.applyProps(r,{rotation:t.rotation})}return t.geometry=new d.DecalGeometry(e,r.position,r.rotation,r.scale),p.current&&(a.applyProps(p.current,r),p.current.traverse((e=>e.raycast=()=>null))),e.matrixWorld=n,()=>{t.geometry.dispose()}}}),[o,...He(s),...He(c),...He(l)]),P.createElement(\"mesh\",C.default({ref:f,\"material-transparent\":!0,\"material-polygonOffset\":!0,\"material-polygonOffsetFactor\":r,\"material-depthTest\":t,\"material-map\":n},u),i,e&&P.createElement(\"mesh\",{ref:p},P.createElement(\"boxGeometry\",null),P.createElement(\"meshNormalMaterial\",{wireframe:!0}),P.createElement(\"axesHelper\",null)))})),qe=t.forwardRef((function({src:e,skipFill:r,skipStrokes:o,fillMaterial:i,strokeMaterial:s,fillMeshProps:l,strokeMeshProps:c,...u},m){const f=a.useLoader(d.SVGLoader,e.startsWith(\"<svg\")?`data:image/svg+xml;utf8,${e}`:e),p=t.useMemo((()=>o?[]:f.paths.map((e=>{var t;return void 0===(null==(t=e.userData)?void 0:t.style.stroke)||\"none\"===e.userData.style.stroke?null:e.subPaths.map((t=>d.SVGLoader.pointsToStroke(t.getPoints(),e.userData.style)))}))),[f,o]);return t.useEffect((()=>()=>p.forEach((e=>e&&e.map((e=>e.dispose()))))),[p]),P.createElement(\"object3D\",C.default({ref:m},u),P.createElement(\"object3D\",{scale:[1,-1,1]},f.paths.map(((e,a)=>{var u,m;return P.createElement(t.Fragment,{key:a},!r&&void 0!==(null==(u=e.userData)?void 0:u.style.fill)&&\"none\"!==e.userData.style.fill&&d.SVGLoader.createShapes(e).map(((t,r)=>P.createElement(\"mesh\",C.default({key:r},l),P.createElement(\"shapeGeometry\",{args:[t]}),P.createElement(\"meshBasicMaterial\",C.default({color:e.userData.style.fill,opacity:e.userData.style.fillOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},i))))),!o&&void 0!==(null==(m=e.userData)?void 0:m.style.stroke)&&\"none\"!==e.userData.style.stroke&&e.subPaths.map(((t,r)=>P.createElement(\"mesh\",C.default({key:r,geometry:p[a][r]},c),P.createElement(\"meshBasicMaterial\",C.default({color:e.userData.style.stroke,opacity:e.userData.style.strokeOpacity,transparent:!0,side:n.DoubleSide,depthWrite:!1},s))))))}))))}));let Xe=null,Ze=\"https://www.gstatic.com/draco/versioned/decoders/1.5.5/\";function Ye(e,t,r){return n=>{r&&r(n),e&&(Xe||(Xe=new d.DRACOLoader),Xe.setDecoderPath(\"string\"==typeof e?e:Ze),n.setDRACOLoader(Xe)),t&&n.setMeshoptDecoder(\"function\"==typeof d.MeshoptDecoder?d.MeshoptDecoder():d.MeshoptDecoder)}}function Qe(e,t=!0,r=!0,n){return a.useLoader(d.GLTFLoader,e,Ye(t,r,n))}Qe.preload=(e,t=!0,r=!0,n)=>a.useLoader.preload(d.GLTFLoader,e,Ye(t,r,n)),Qe.clear=e=>a.useLoader.clear(d.GLTFLoader,e),Qe.setDecoderPath=e=>{Ze=e};const Ke=P.forwardRef((({src:e,...t},r)=>{const{scene:n}=Qe(e);return P.createElement(Oe,C.default({ref:r},t,{object:n}))}));const Je=Ee({alphaTest:0,viewport:new D.Vector2(1980,1080),focal:1e3,centerAndScaleTexture:null,covAndColorTexture:null},\"\\n    precision highp sampler2D;\\n    precision highp usampler2D;\\n    out vec4 vColor;\\n    out vec3 vPosition;\\n    uniform vec2 resolution;\\n    uniform vec2 viewport;\\n    uniform float focal;\\n    attribute uint splatIndex;\\n    uniform sampler2D centerAndScaleTexture;\\n    uniform usampler2D covAndColorTexture;    \\n\\n    vec2 unpackInt16(in uint value) {\\n      int v = int(value);\\n      int v0 = v >> 16;\\n      int v1 = (v & 0xFFFF);\\n      if((v & 0x8000) != 0)\\n        v1 |= 0xFFFF0000;\\n      return vec2(float(v1), float(v0));\\n    }\\n\\n    void main () {\\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\\n      vec4 camspace = modelViewMatrix * center;\\n      vec4 pos2d = projectionMatrix * camspace;\\n\\n      float bounds = 1.2 * pos2d.w;\\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\\n        || pos2d.y < -bounds || pos2d.y > bounds) {\\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n        return;\\n      }\\n\\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\\n      mat3 Vrk = mat3(\\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\\n      );\\n\\n      mat3 J = mat3(\\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\\n        0., 0., 0.\\n      );\\n\\n      mat3 W = transpose(mat3(modelViewMatrix));\\n      mat3 T = W * J;\\n      mat3 cov = transpose(T) * Vrk * T;\\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\\n      float diagonal1 = cov[0][0] + 0.3;\\n      float offDiagonal = cov[0][1];\\n      float diagonal2 = cov[1][1] + 0.3;\\n      float mid = 0.5 * (diagonal1 + diagonal2);\\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\\n      float lambda1 = mid + radius;\\n      float lambda2 = max(mid - radius, 0.1);\\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\\n      uint colorUint = covAndColorData.w;\\n      vColor = vec4(\\n        float(colorUint & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\\n        float(colorUint >> uint(24)) / 255.0\\n      );\\n      vPosition = position;\\n\\n      gl_Position = vec4(\\n        vCenter \\n          + position.x * v2 / viewport * 2.0 \\n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\\n    }\\n    \",`\\n    #include <alphatest_pars_fragment>\\n    #include <alphahash_pars_fragment>\\n    in vec4 vColor;\\n    in vec3 vPosition;\\n    void main () {\\n      float A = -dot(vPosition.xy, vPosition.xy);\\n      if (A < -4.0) discard;\\n      float B = exp(A) * vColor.a;\\n      vec4 diffuseColor = vec4(vColor.rgb, B);\\n      #include <alphatest_fragment>\\n      #include <alphahash_fragment>\\n      gl_FragColor = diffuseColor;\\n      #include <tonemapping_fragment>\\n      #include <${parseInt(D.REVISION.replace(/\\D+/g,\"\"))>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n    }\\n  `);function et(e){let t=null,r=0;e.onmessage=n=>{if(\"push\"==n.data.method){0===r&&(t=new Float32Array(n.data.length));const e=new Float32Array(n.data.matrices);t.set(e,r),r+=e.length}else if(\"sort\"==n.data.method&&null!==t){const r=function(e,r=!1){const n=t.length/16;let a=-1/0,o=1/0;const i=new Float32Array(n),s=new Int32Array(i.buffer),l=new Int32Array(n);let c=0;for(let s=0;s<n;s++){const n=e[0]*t[16*s+12]+e[1]*t[16*s+13]+e[2]*t[16*s+14]+e[3];(r||n<0&&t[16*s+15]>-1e-4*n)&&(i[c]=n,l[c]=s,c++,n>a&&(a=n),n<o&&(o=n))}const u=65535/(a-o),d=new Uint32Array(65536);for(let e=0;e<c;e++)s[e]=(i[e]-o)*u|0,d[s[e]]++;const m=new Uint32Array(65536);for(let e=1;e<65536;e++)m[e]=m[e-1]+d[e-1];const f=new Uint32Array(c);for(let e=0;e<c;e++)f[m[s[e]]++]=l[e];return f}(new Float32Array(n.data.view),n.data.hashed);e.postMessage({indices:r,key:n.data.key},[r.buffer])}}}class tt extends D.Loader{constructor(...e){super(...e),this.gl=null,this.chunkSize=25e3}load(e,t,r,n){const a={gl:this.gl,url:this.manager.resolveURL(e),worker:new Worker(URL.createObjectURL(new Blob([\"(\",et.toString(),\")(self)\"],{type:\"application/javascript\"}))),manager:this.manager,update:(e,t,r)=>function(e,t,r,n){if(e.updateMatrixWorld(),t.gl.getCurrentViewport(r.viewport),r.material.viewport.x=r.viewport.z,r.material.viewport.y=r.viewport.w,r.material.focal=r.viewport.w/2*Math.abs(e.projectionMatrix.elements[5]),r.ready){if(n&&r.sorted)return;r.ready=!1;const e=new Float32Array([r.modelViewMatrix.elements[2],-r.modelViewMatrix.elements[6],r.modelViewMatrix.elements[10],r.modelViewMatrix.elements[14]]);t.worker.postMessage({method:\"sort\",src:t.url,key:r.uuid,view:e.buffer,hashed:n},[e.buffer]),n&&t.loaded&&(r.sorted=!0)}}(t,a,e,r),connect:e=>function(e,t){e.loading||async function(e){e.loading=!0;let t=0,r=0;const n=[];let a=0;const o=0!==e.totalDownloadBytes;for(;;)try{const{value:i,done:s}=await e.stream.read();if(s)break;if(t+=i.length,null!=e.totalDownloadBytes){const r=t/e.totalDownloadBytes*100;if(e.onProgress&&r-a>1){const n=new ProgressEvent(\"progress\",{lengthComputable:o,loaded:t,total:e.totalDownloadBytes});e.onProgress(n),a=r}}n.push(i);const l=t-r;if(null!=e.totalDownloadBytes&&l>e.rowLength*e.chunkSize){let t=Math.floor(l/e.rowLength);const a=new Uint8Array(l);let i=0;for(const e of n)a.set(e,i),i+=e.length;if(n.length=0,l>t*e.rowLength){const r=new Uint8Array(l-t*e.rowLength);r.set(a.subarray(l-r.length,l),0),n.push(r)}const s=new Uint8Array(t*e.rowLength);s.set(a.subarray(0,s.byteLength),0);const c=rt(e,s.buffer,t);if(e.worker.postMessage({method:\"push\",src:e.url,length:16*e.numVertices,matrices:c.buffer},[c.buffer]),r+=t*e.rowLength,e.onProgress){const t=new ProgressEvent(\"progress\",{lengthComputable:o,loaded:e.totalDownloadBytes,total:e.totalDownloadBytes});e.onProgress(t)}}}catch(e){console.error(e);break}if(t-r>0){let t=new Uint8Array(n.reduce(((e,t)=>e+t.length),0)),r=0;for(const e of n)t.set(e,r),r+=e.length;let a=Math.floor(t.byteLength/e.rowLength);const o=rt(e,t.buffer,a);e.worker.postMessage({method:\"push\",src:e.url,length:16*a,matrices:o.buffer},[o.buffer])}e.loaded=!0,e.manager.itemEnd(e.url)}(e);t.ready=!1,t.pm=new D.Matrix4,t.vm1=new D.Matrix4,t.vm2=new D.Matrix4,t.viewport=new D.Vector4;let r=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight);const n=new D.InstancedBufferAttribute(r,1,!1);n.setUsage(D.DynamicDrawUsage);const a=t.geometry=new D.InstancedBufferGeometry,o=new Float32Array(18),i=new D.BufferAttribute(o,3);function s(e){if(t&&e.data.key===t.uuid){let r=new Uint32Array(e.data.indices);a.attributes.splatIndex.set(r),a.attributes.splatIndex.needsUpdate=!0,a.instanceCount=r.length,t.ready=!0}}async function l(){for(;;){const t=e.gl.properties.get(e.centerAndScaleTexture),r=e.gl.properties.get(e.covAndColorTexture);if(null!=t&&t.__webglTexture&&null!=r&&r.__webglTexture&&e.loadedVertexCount>0)break;await new Promise((e=>setTimeout(e,10)))}t.ready=!0}return a.setAttribute(\"position\",i),i.setXYZ(2,-2,2,0),i.setXYZ(1,2,2,0),i.setXYZ(0,-2,-2,0),i.setXYZ(5,-2,-2,0),i.setXYZ(4,2,2,0),i.setXYZ(3,2,-2,0),i.needsUpdate=!0,a.setAttribute(\"splatIndex\",n),a.instanceCount=1,e.worker.addEventListener(\"message\",s),l(),()=>e.worker.removeEventListener(\"message\",s)}(a,e),loading:!1,loaded:!1,loadedVertexCount:0,chunkSize:this.chunkSize,totalDownloadBytes:0,numVertices:0,rowLength:32,maxVertexes:0,bufferTextureWidth:0,bufferTextureHeight:0,stream:null,centerAndScaleData:null,covAndColorData:null,covAndColorTexture:null,centerAndScaleTexture:null,onProgress:r};(async function(e){e.manager.itemStart(e.url);const t=await fetch(e.url);if(null===t.body)throw\"Failed to fetch file\";let r=t.headers.get(\"Content-Length\");const n=r?parseInt(r):void 0;if(null==n)throw\"Failed to get content length\";e.stream=t.body.getReader(),e.totalDownloadBytes=n,e.numVertices=Math.floor(e.totalDownloadBytes/e.rowLength);const a=e.gl.getContext();let o=a.getParameter(a.MAX_TEXTURE_SIZE);e.maxVertexes=o*o,e.numVertices>e.maxVertexes&&(e.numVertices=e.maxVertexes);return e.bufferTextureWidth=o,e.bufferTextureHeight=Math.floor((e.numVertices-1)/o)+1,e.centerAndScaleData=new Float32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.covAndColorData=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.centerAndScaleTexture=new D.DataTexture(e.centerAndScaleData,e.bufferTextureWidth,e.bufferTextureHeight,D.RGBAFormat,D.FloatType),e.centerAndScaleTexture.needsUpdate=!0,e.covAndColorTexture=new D.DataTexture(e.covAndColorData,e.bufferTextureWidth,e.bufferTextureHeight,D.RGBAIntegerFormat,D.UnsignedIntType),e.covAndColorTexture.internalFormat=\"RGBA32UI\",e.covAndColorTexture.needsUpdate=!0,e})(a).then(t).catch((e=>{null==n||n(e),a.manager.itemError(a.url)}))}}function rt(e,t,r){const n=e.gl.getContext();if(e.loadedVertexCount+r>e.maxVertexes&&(r=e.maxVertexes-e.loadedVertexCount),r<=0)throw\"Failed to parse file\";const a=new Uint8Array(t),o=new Float32Array(t),i=new Float32Array(16*r),s=new Uint8Array(e.covAndColorData.buffer),l=new Int16Array(e.covAndColorData.buffer);for(let t=0;t<r;t++){const r=new D.Quaternion(-(a[32*t+28+1]-128)/128,(a[32*t+28+2]-128)/128,(a[32*t+28+3]-128)/128,-(a[32*t+28+0]-128)/128);r.invert();const n=new D.Vector3(o[8*t+0],o[8*t+1],-o[8*t+2]),c=new D.Vector3(o[8*t+3+0],o[8*t+3+1],o[8*t+3+2]),u=new D.Matrix4;u.makeRotationFromQuaternion(r),u.transpose(),u.scale(c);const d=u.clone();u.transpose(),u.premultiply(d),u.setPosition(n);const m=[0,1,2,5,6,10];let f=0;for(let e=0;e<m.length;e++)Math.abs(u.elements[m[e]])>f&&(f=Math.abs(u.elements[m[e]]));let p=4*e.loadedVertexCount+4*t;e.centerAndScaleData[p+0]=n.x,e.centerAndScaleData[p+1]=-n.y,e.centerAndScaleData[p+2]=n.z,e.centerAndScaleData[p+3]=f/32767,p=8*e.loadedVertexCount+4*t*2;for(let e=0;e<m.length;e++)l[p+e]=32767*u.elements[m[e]]/f;p=16*e.loadedVertexCount+4*(4*t+3);const h=new D.Color(a[32*t+24+0]/255,a[32*t+24+1]/255,a[32*t+24+2]/255);h.convertSRGBToLinear(),s[p+0]=255*h.r,s[p+1]=255*h.g,s[p+2]=255*h.b,s[p+3]=a[32*t+24+3],u.elements[15]=Math.max(c.x,c.y,c.z)*a[32*t+24+3]/255;for(let e=0;e<16;e++)i[16*t+e]=u.elements[e]}for(;r>0;){let t=0,a=0;const o=e.loadedVertexCount%e.bufferTextureWidth,i=Math.floor(e.loadedVertexCount/e.bufferTextureWidth);e.loadedVertexCount%e.bufferTextureWidth!=0?(t=Math.min(e.bufferTextureWidth,o+r)-o,a=1):Math.floor(r/e.bufferTextureWidth)>0?(t=e.bufferTextureWidth,a=Math.floor(r/e.bufferTextureWidth)):(t=r%e.bufferTextureWidth,a=1);const s=e.gl.properties.get(e.centerAndScaleTexture);n.bindTexture(n.TEXTURE_2D,s.__webglTexture),n.texSubImage2D(n.TEXTURE_2D,0,o,i,t,a,n.RGBA,n.FLOAT,e.centerAndScaleData,4*e.loadedVertexCount);const l=e.gl.properties.get(e.covAndColorTexture);n.bindTexture(n.TEXTURE_2D,l.__webglTexture),n.texSubImage2D(n.TEXTURE_2D,0,o,i,t,a,n.RGBA_INTEGER,n.UNSIGNED_INT,e.covAndColorData,4*e.loadedVertexCount),e.gl.resetState(),e.loadedVertexCount+=t*a,r-=t*a}return i}function nt(e,t,r){const n=a.useThree((e=>e.size)),o=a.useThree((e=>e.viewport)),i=\"number\"==typeof e?e:n.width*o.dpr,s=\"number\"==typeof t?t:n.height*o.dpr,l=(\"number\"==typeof e?r:e)||{},{samples:c=0,depth:u,...d}=l,m=P.useMemo((()=>{const e=new D.WebGLRenderTarget(i,s,{minFilter:D.LinearFilter,magFilter:D.LinearFilter,type:D.HalfFloatType,...d});return u&&(e.depthTexture=new D.DepthTexture(i,s,D.FloatType)),e.samples=c,e}),[]);return P.useLayoutEffect((()=>{m.setSize(i,s),c&&(m.samples=c)}),[c,m,i,s]),P.useEffect((()=>()=>m.dispose()),[]),m}const at=P.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,children:n,makeDefault:o,...i},s)=>{const l=a.useThree((({set:e})=>e)),c=a.useThree((({camera:e})=>e)),u=a.useThree((({size:e})=>e)),d=P.useRef(null),m=P.useRef(null),f=nt(t);P.useLayoutEffect((()=>{i.manual||d.current.updateProjectionMatrix()}),[u,i]),P.useLayoutEffect((()=>{d.current.updateProjectionMatrix()})),P.useLayoutEffect((()=>{if(o){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,o,l]);let p=0,h=null;const x=\"function\"==typeof n;return a.useFrame((t=>{x&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),P.createElement(P.Fragment,null,P.createElement(\"orthographicCamera\",C.default({left:u.width/-2,right:u.width/2,top:u.height/2,bottom:u.height/-2,ref:k.default([d,s])},i),!x&&n),P.createElement(\"group\",{ref:m},x&&n(f.texture)))})),ot=P.forwardRef((({envMap:e,resolution:t=256,frames:r=1/0,makeDefault:n,children:o,...i},s)=>{const l=a.useThree((({set:e})=>e)),c=a.useThree((({camera:e})=>e)),u=a.useThree((({size:e})=>e)),d=P.useRef(null),m=P.useRef(null),f=nt(t);P.useLayoutEffect((()=>{i.manual||(d.current.aspect=u.width/u.height)}),[u,i]),P.useLayoutEffect((()=>{d.current.updateProjectionMatrix()}));let p=0,h=null;const x=\"function\"==typeof o;return a.useFrame((t=>{x&&(r===1/0||p<r)&&(m.current.visible=!1,t.gl.setRenderTarget(f),h=t.scene.background,e&&(t.scene.background=e),t.gl.render(t.scene,d.current),t.scene.background=h,t.gl.setRenderTarget(null),m.current.visible=!0,p++)})),P.useLayoutEffect((()=>{if(n){const e=c;return l((()=>({camera:d.current}))),()=>l((()=>({camera:e})))}}),[d,n,l]),P.createElement(P.Fragment,null,P.createElement(\"perspectiveCamera\",C.default({ref:k.default([d,s])},i),!x&&o),P.createElement(\"group\",{ref:m},x&&o(f.texture)))}));function it({resolution:e=256,near:r=.1,far:o=1e3,envMap:i,fog:s}={}){const l=a.useThree((({gl:e})=>e)),c=a.useThree((({scene:e})=>e)),u=t.useMemo((()=>{const t=new n.WebGLCubeRenderTarget(e);return t.texture.type=n.HalfFloatType,t}),[e]);t.useEffect((()=>()=>{u.dispose()}),[u]);const d=t.useMemo((()=>new D.CubeCamera(r,o,u)),[r,o,u]);let m,f;const p=P.useCallback((()=>{m=c.fog,f=c.background,c.background=i||f,c.fog=s||m,d.update(l,c),c.fog=m,c.background=f}),[l,c,d]);return{fbo:u,camera:d,update:p}}const st=P.forwardRef(((e,t)=>{const{camera:r,onChange:n,makeDefault:o,...i}=e,s=a.useThree((e=>e.camera)),l=a.useThree((e=>e.invalidate)),c=a.useThree((e=>e.get)),u=a.useThree((e=>e.set)),m=r||s,f=P.useMemo((()=>new d.DeviceOrientationControls(m)),[m]);return P.useEffect((()=>{const e=e=>{l(),n&&n(e)};return null==f||null==f.addEventListener||f.addEventListener(\"change\",e),()=>null==f||null==f.removeEventListener?void 0:f.removeEventListener(\"change\",e)}),[n,f,l]),a.useFrame((()=>null==f?void 0:f.update()),-1),P.useEffect((()=>{const e=f;return null==e||e.connect(),()=>null==e?void 0:e.dispose()}),[f]),P.useEffect((()=>{if(o){const e=c().controls;return u({controls:f}),()=>u({controls:e})}}),[o,f]),f?P.createElement(\"primitive\",C.default({ref:t,object:f},i)):null})),lt=P.forwardRef((({domElement:e,...t},r)=>{const{onChange:n,makeDefault:o,...i}=t,s=a.useThree((e=>e.invalidate)),l=a.useThree((e=>e.camera)),c=a.useThree((e=>e.gl)),u=a.useThree((e=>e.events)),m=a.useThree((e=>e.get)),f=a.useThree((e=>e.set)),p=e||u.connected||c.domElement,h=P.useMemo((()=>new d.FlyControls(l)),[l]);return P.useEffect((()=>(h.connect(p),()=>{h.dispose()})),[p,h,s]),P.useEffect((()=>{const e=e=>{s(),n&&n(e)};return null==h.addEventListener||h.addEventListener(\"change\",e),()=>null==h.removeEventListener?void 0:h.removeEventListener(\"change\",e)}),[n,s]),P.useEffect((()=>{if(o){const e=m().controls;return f({controls:h}),()=>f({controls:e})}}),[o,h]),a.useFrame(((e,t)=>h.update(t))),P.createElement(\"primitive\",C.default({ref:r,object:h,args:[l,p]},i))})),ct=P.forwardRef(((e={enableDamping:!0},t)=>{const{domElement:r,camera:n,makeDefault:o,onChange:i,onStart:s,onEnd:l,...c}=e,u=a.useThree((e=>e.invalidate)),m=a.useThree((e=>e.camera)),f=a.useThree((e=>e.gl)),p=a.useThree((e=>e.events)),h=a.useThree((e=>e.set)),x=a.useThree((e=>e.get)),y=r||p.connected||f.domElement,v=n||m,g=P.useMemo((()=>new d.MapControls(v)),[v]);return P.useEffect((()=>{g.connect(y);const e=e=>{u(),i&&i(e)};return g.addEventListener(\"change\",e),s&&g.addEventListener(\"start\",s),l&&g.addEventListener(\"end\",l),()=>{g.dispose(),g.removeEventListener(\"change\",e),s&&g.removeEventListener(\"start\",s),l&&g.removeEventListener(\"end\",l)}}),[i,s,l,g,u,y]),P.useEffect((()=>{if(o){const e=x().controls;return h({controls:g}),()=>h({controls:e})}}),[o,g]),a.useFrame((()=>g.update()),-1),P.createElement(\"primitive\",C.default({ref:t,object:g,enableDamping:!0},c))})),ut=P.forwardRef((({makeDefault:e,camera:t,regress:r,domElement:n,enableDamping:o=!0,keyEvents:i=!1,onChange:s,onStart:l,onEnd:c,...u},m)=>{const f=a.useThree((e=>e.invalidate)),p=a.useThree((e=>e.camera)),h=a.useThree((e=>e.gl)),x=a.useThree((e=>e.events)),y=a.useThree((e=>e.setEvents)),v=a.useThree((e=>e.set)),g=a.useThree((e=>e.get)),z=a.useThree((e=>e.performance)),w=t||p,b=n||x.connected||h.domElement,M=P.useMemo((()=>new d.OrbitControls(w)),[w]);return a.useFrame((()=>{M.enabled&&M.update()}),-1),P.useEffect((()=>(i&&M.connect(!0===i?b:i),M.connect(b),()=>{M.dispose()})),[i,b,r,M,f]),P.useEffect((()=>{const e=e=>{f(),r&&z.regress(),s&&s(e)},t=e=>{l&&l(e)},n=e=>{c&&c(e)};return M.addEventListener(\"change\",e),M.addEventListener(\"start\",t),M.addEventListener(\"end\",n),()=>{M.removeEventListener(\"start\",t),M.removeEventListener(\"end\",n),M.removeEventListener(\"change\",e)}}),[s,l,c,M,f,y]),P.useEffect((()=>{if(e){const e=g().controls;return v({controls:M}),()=>v({controls:e})}}),[e,M]),P.createElement(\"primitive\",C.default({ref:m,object:M,enableDamping:o},u))})),dt=P.forwardRef((({makeDefault:e,camera:t,domElement:r,regress:n,onChange:o,onStart:i,onEnd:s,...l},c)=>{const{invalidate:u,camera:m,gl:f,events:p,set:h,get:x,performance:y,viewport:v}=a.useThree(),g=t||m,z=r||p.connected||f.domElement,w=P.useMemo((()=>new d.TrackballControls(g)),[g]);return a.useFrame((()=>{w.enabled&&w.update()}),-1),P.useEffect((()=>(w.connect(z),()=>{w.dispose()})),[z,n,w,u]),P.useEffect((()=>{const e=e=>{u(),n&&y.regress(),o&&o(e)};return w.addEventListener(\"change\",e),i&&w.addEventListener(\"start\",i),s&&w.addEventListener(\"end\",s),()=>{i&&w.removeEventListener(\"start\",i),s&&w.removeEventListener(\"end\",s),w.removeEventListener(\"change\",e)}}),[o,i,s,w,u]),P.useEffect((()=>{w.handleResize()}),[v]),P.useEffect((()=>{if(e){const e=x().controls;return h({controls:w}),()=>h({controls:e})}}),[e,w]),P.createElement(\"primitive\",C.default({ref:c,object:w},l))})),mt=t.forwardRef((({camera:e,makeDefault:r,regress:n,domElement:o,onChange:i,onStart:s,onEnd:l,...c},u)=>{const m=a.useThree((e=>e.invalidate)),f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.events)),x=a.useThree((e=>e.set)),y=a.useThree((e=>e.get)),v=a.useThree((e=>e.performance)),g=e||f,z=o||h.connected||p.domElement,w=t.useMemo((()=>new d.ArcballControls(g)),[g]);return a.useFrame((()=>{w.enabled&&w.update()}),-1),t.useEffect((()=>(w.connect(z),()=>{w.dispose()})),[z,n,w,m]),t.useEffect((()=>{const e=e=>{m(),n&&v.regress(),i&&i(e)};return w.addEventListener(\"change\",e),s&&w.addEventListener(\"start\",s),l&&w.addEventListener(\"end\",l),()=>{w.removeEventListener(\"change\",e),s&&w.removeEventListener(\"start\",s),l&&w.removeEventListener(\"end\",l)}}),[i,s,l]),t.useEffect((()=>{if(r){const e=y().controls;return x({controls:w}),()=>x({controls:e})}}),[r,w]),P.createElement(\"primitive\",C.default({ref:u,object:w},c))})),ft=P.forwardRef((({children:e,domElement:t,onChange:r,onMouseDown:n,onMouseUp:o,onObjectChange:i,object:s,makeDefault:l,...c},u)=>{const m=[\"enabled\",\"axis\",\"mode\",\"translationSnap\",\"rotationSnap\",\"scaleSnap\",\"space\",\"size\",\"showX\",\"showY\",\"showZ\"],{camera:f,...p}=c,h=A.default(p,m),x=L.default(p,m),y=a.useThree((e=>e.controls)),v=a.useThree((e=>e.gl)),g=a.useThree((e=>e.events)),z=a.useThree((e=>e.camera)),w=a.useThree((e=>e.invalidate)),b=a.useThree((e=>e.get)),M=a.useThree((e=>e.set)),E=f||z,S=t||g.connected||v.domElement,T=P.useMemo((()=>new d.TransformControls(E,S)),[E,S]),R=P.useRef();P.useLayoutEffect((()=>(s?T.attach(s instanceof D.Object3D?s:s.current):R.current instanceof D.Object3D&&T.attach(R.current),()=>{T.detach()})),[s,e,T]),P.useEffect((()=>{if(y){const e=e=>y.enabled=!e.value;return T.addEventListener(\"dragging-changed\",e),()=>T.removeEventListener(\"dragging-changed\",e)}}),[T,y]);const F=P.useRef(),k=P.useRef(),_=P.useRef(),B=P.useRef();return P.useLayoutEffect((()=>{F.current=r}),[r]),P.useLayoutEffect((()=>{k.current=n}),[n]),P.useLayoutEffect((()=>{_.current=o}),[o]),P.useLayoutEffect((()=>{B.current=i}),[i]),P.useEffect((()=>{const e=e=>{w(),null==F.current||F.current(e)},t=e=>null==k.current?void 0:k.current(e),r=e=>null==_.current?void 0:_.current(e),n=e=>null==B.current?void 0:B.current(e);return T.addEventListener(\"change\",e),T.addEventListener(\"mouseDown\",t),T.addEventListener(\"mouseUp\",r),T.addEventListener(\"objectChange\",n),()=>{T.removeEventListener(\"change\",e),T.removeEventListener(\"mouseDown\",t),T.removeEventListener(\"mouseUp\",r),T.removeEventListener(\"objectChange\",n)}}),[w,T]),P.useEffect((()=>{if(l){const e=b().controls;return M({controls:T}),()=>M({controls:e})}}),[l,T]),T?P.createElement(P.Fragment,null,P.createElement(\"primitive\",C.default({ref:u,object:T},h)),P.createElement(\"group\",C.default({ref:R},x),e)):null})),pt=P.forwardRef((({domElement:e,selector:t,onChange:r,onLock:n,onUnlock:o,enabled:i=!0,makeDefault:s,...l},c)=>{const{camera:u,...m}=l,f=a.useThree((e=>e.setEvents)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.camera)),x=a.useThree((e=>e.invalidate)),y=a.useThree((e=>e.events)),v=a.useThree((e=>e.get)),g=a.useThree((e=>e.set)),z=u||h,w=e||y.connected||p.domElement,b=P.useMemo((()=>new d.PointerLockControls(z)),[z]);return P.useEffect((()=>{if(i){b.connect(w);const e=v().events.compute;return f({compute(e,t){const r=t.size.width/2,n=t.size.height/2;t.pointer.set(r/t.size.width*2-1,-n/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{b.disconnect(),f({compute:e})}}}),[i,b]),P.useEffect((()=>{const e=e=>{x(),r&&r(e)};b.addEventListener(\"change\",e),n&&b.addEventListener(\"lock\",n),o&&b.addEventListener(\"unlock\",o);const a=()=>b.lock(),i=t?Array.from(document.querySelectorAll(t)):[document];return i.forEach((e=>e&&e.addEventListener(\"click\",a))),()=>{b.removeEventListener(\"change\",e),n&&b.removeEventListener(\"lock\",n),o&&b.removeEventListener(\"unlock\",o),i.forEach((e=>e?e.removeEventListener(\"click\",a):void 0))}}),[r,n,o,t,b,x]),P.useEffect((()=>{if(s){const e=v().controls;return g({controls:b}),()=>g({controls:e})}}),[s,b]),P.createElement(\"primitive\",C.default({ref:c,object:b},m))})),ht=P.forwardRef((({domElement:e,makeDefault:t,...r},n)=>{const o=a.useThree((e=>e.camera)),i=a.useThree((e=>e.gl)),s=a.useThree((e=>e.events)),l=a.useThree((e=>e.get)),c=a.useThree((e=>e.set)),u=e||s.connected||i.domElement,[m]=P.useState((()=>new d.FirstPersonControls(o,u)));return P.useEffect((()=>{if(t){const e=l().controls;return c({controls:m}),()=>c({controls:e})}}),[t,m]),a.useFrame(((e,t)=>{m.update(t)}),-1),m?P.createElement(\"primitive\",C.default({ref:n,object:m},r)):null})),xt=t.forwardRef(((e,r)=>{t.useMemo((()=>{const e={Box3:n.Box3,MathUtils:{clamp:n.MathUtils.clamp},Matrix4:n.Matrix4,Quaternion:n.Quaternion,Raycaster:n.Raycaster,Sphere:n.Sphere,Spherical:n.Spherical,Vector2:n.Vector2,Vector3:n.Vector3,Vector4:n.Vector4};B.default.install({THREE:e}),a.extend({CameraControlsImpl:B.default})}),[]);const{camera:o,domElement:i,makeDefault:s,onStart:l,onEnd:c,onChange:u,regress:d,...m}=e,f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.gl)),h=a.useThree((e=>e.invalidate)),x=a.useThree((e=>e.events)),y=a.useThree((e=>e.setEvents)),v=a.useThree((e=>e.set)),g=a.useThree((e=>e.get)),z=a.useThree((e=>e.performance)),w=o||f,b=i||x.connected||p.domElement,M=t.useMemo((()=>new B.default(w)),[w]);return a.useFrame(((e,t)=>{M.enabled&&M.update(t)}),-1),t.useEffect((()=>(M.connect(b),()=>{M.disconnect()})),[b,M]),t.useEffect((()=>{const e=e=>{h(),d&&z.regress(),u&&u(e)},t=e=>{l&&l(e)},r=e=>{c&&c(e)};return M.addEventListener(\"update\",e),M.addEventListener(\"controlstart\",t),M.addEventListener(\"controlend\",r),M.addEventListener(\"control\",e),M.addEventListener(\"transitionstart\",e),M.addEventListener(\"wake\",e),()=>{M.removeEventListener(\"update\",e),M.removeEventListener(\"controlstart\",t),M.removeEventListener(\"controlend\",r),M.removeEventListener(\"control\",e),M.removeEventListener(\"transitionstart\",e),M.removeEventListener(\"wake\",e)}}),[M,l,c,h,y,d,u]),t.useEffect((()=>{if(s){const e=g().controls;return v({controls:M}),()=>v({controls:e})}}),[s,M]),P.createElement(\"primitive\",C.default({ref:r,object:M},m))}));function yt(e,r){const{unsuspend:n,start:o,crossOrigin:i,muted:s,loop:l,...c}={unsuspend:\"loadedmetadata\",crossOrigin:\"Anonymous\",muted:!0,loop:!0,start:!0,playsInline:!0,...r},u=a.useThree((e=>e.gl)),d=f.suspend((()=>new Promise(((t,r)=>{const a=Object.assign(document.createElement(\"video\"),{src:\"string\"==typeof e&&e||void 0,srcObject:e instanceof MediaStream&&e||void 0,crossOrigin:i,loop:l,muted:s,...c}),o=new D.VideoTexture(a);\"colorSpace\"in o?o.colorSpace=u.outputColorSpace:o.encoding=u.outputEncoding,a.addEventListener(n,(()=>t(o)))}))),[e]);return t.useEffect((()=>{if(o)return d.image.play(),()=>d.image.pause()}),[d,o]),d}const vt=new D.Vector3(0,0,-1),gt=function(){const e=new D.Vector3,t=new D.Vector3,r=new D.Vector3,n=new D.Vector3,a=new D.Vector3;return function(o,i,s,l){return e.copy(o),t.copy(i),r.copy(s),n.copy(t).sub(e),a.copy(r).sub(e),l.crossVectors(a,n).normalize()}}();const zt=P.forwardRef((({points:e=Mt.SAMPLE_FACELANDMARKER_RESULT.faceLandmarks[0],face:t,facialTransformationMatrix:r,faceBlendshapes:n,offset:o,offsetScalar:i=80,width:s,height:l,depth:c=1,verticalTri:u=[159,386,152],origin:d,eyes:m=!0,eyesAsOrigin:f=!1,debug:p=!1,children:h,...x},y)=>{var v;t&&(e=t.keypoints,console.warn(\"Facemesh `face` prop is deprecated: use `points` instead\"));const g=P.useRef(null),z=P.useRef(null),w=P.useRef(null),b=P.useRef(null),M=P.useRef(null),E=P.useRef(null),S=P.useRef(null),[T]=P.useState((()=>new D.Vector3)),[C]=P.useState((()=>new D.Object3D)),[R]=P.useState((()=>new D.Quaternion)),[F]=P.useState((()=>new D.Vector3)),{invalidate:k}=a.useThree();P.useEffect((()=>{var e;null==(e=M.current)||e.geometry.setIndex(Mt.TRIANGULATION)}),[]);const[_]=P.useState((()=>new D.Vector3));P.useEffect((()=>{var t,a;const h=null==(t=M.current)?void 0:t.geometry;if(!h)return;var x,y;(h.setFromPoints(e),h.setDrawRange(0,Mt.TRIANGULATION.length),r)?(C.matrix.fromArray(r.data),C.matrix.decompose(C.position,C.quaternion,C.scale),C.rotation.y*=-1,C.rotation.z*=-1,R.setFromEuler(C.rotation),o?(C.position.y*=-1,C.position.z*=-1,null==(x=g.current)||x.position.copy(C.position.divideScalar(i))):null==(y=g.current)||y.position.set(0,0,0)):(gt(e[u[0]],e[u[1]],e[u[2]],T),R.setFromUnitVectors(vt,T));const v=R.clone().invert();if(h.computeBoundingBox(),p&&k(),h.center(),h.applyQuaternion(v),null==(a=b.current)||a.setRotationFromQuaternion(R),m)if(n){if(E.current&&S.current&&w.current)if(f){const e=E.current._computeSphere(h),t=S.current._computeSphere(h),r=function(e,t){return e.clone().add(t).multiplyScalar(.5)}(e.center,t.center);d=r.negate(),E.current._update(h,n,e),S.current._update(h,n,t)}else E.current._update(h,n),S.current._update(h,n)}else console.warn(\"Facemesh `eyes` option only works if `faceBlendshapes` is provided: skipping.\");if(w.current){if(void 0!==d)if(\"number\"==typeof d){const e=h.getAttribute(\"position\");F.set(-e.getX(d),-e.getY(d),-e.getZ(d))}else d.isVector3&&F.copy(d);else F.setScalar(0);w.current.position.copy(F)}if(z.current){let e=1;(s||l||c)&&(h.boundingBox.getSize(_),s&&(e=s/_.x),l&&(e=l/_.y),c&&(e=c/_.z)),z.current.scale.setScalar(1!==e?e:1)}h.computeVertexNormals(),h.attributes.position.needsUpdate=!0}),[e,r,n,C,o,i,s,l,c,u,d,m,p,k,T,R,_,F]);const A=P.useMemo((()=>({outerRef:b,meshRef:M,eyeRightRef:E,eyeLeftRef:S})),[]);P.useImperativeHandle(y,(()=>A),[A]);const[L]=P.useState((()=>new D.Vector3)),B=null==(v=M.current)?void 0:v.geometry.boundingBox,U=(null==B?void 0:B.getSize(L).z)||1;return P.createElement(\"group\",x,P.createElement(\"group\",{ref:g},P.createElement(\"group\",{ref:b},P.createElement(\"group\",{ref:z},p?P.createElement(P.Fragment,null,P.createElement(\"axesHelper\",{args:[U]}),P.createElement(ue,{points:[[0,0,0],[0,0,-U]],color:65535})):null,P.createElement(\"group\",{ref:w},m&&n&&P.createElement(\"group\",{name:\"eyes\"},P.createElement(bt,{side:\"left\",ref:E,debug:p}),P.createElement(bt,{side:\"right\",ref:S,debug:p})),P.createElement(\"mesh\",{ref:M,name:\"face\"},h,p?P.createElement(P.Fragment,null,B&&P.createElement(\"box3Helper\",{args:[B]})):null))))))})),wt={contourLandmarks:{right:[33,133,159,145,153],left:[263,362,386,374,380]},blendshapes:{right:[14,16,18,12],left:[13,15,17,11]},color:{right:\"red\",left:\"#00ff00\"},fov:{horizontal:100,vertical:90}},bt=P.forwardRef((({side:e,debug:t=!0},r)=>{const n=P.useRef(null),a=P.useRef(null),[o]=P.useState((()=>new D.Sphere)),i=P.useCallback((t=>{const r=t.getAttribute(\"position\"),n=wt.contourLandmarks[e].map((e=>new D.Vector3(r.getX(e),r.getY(e),r.getZ(e))));return o.center.set(0,0,0),n.forEach((e=>o.center.add(e))),o.center.divideScalar(n.length),o.radius=n[0].sub(n[1]).length()/2,o}),[o,e]),[s]=P.useState((()=>new D.Euler)),l=P.useCallback(((t,r,o)=>{var l;n.current&&(null!==(l=o)&&void 0!==l||(o=i(t)),n.current.position.copy(o.center),n.current.scale.setScalar(o.radius));if(r&&a.current){const t=wt.blendshapes[e],n=r.categories[t[0]].score,o=r.categories[t[1]].score,i=r.categories[t[2]].score,l=r.categories[t[3]].score,c=.5*(wt.fov.horizontal*D.MathUtils.DEG2RAD)*(l-i),u=.5*(wt.fov.vertical*D.MathUtils.DEG2RAD)*(n-o)*(\"left\"===e?1:-1);s.set(c,u,0),a.current.setRotationFromEuler(s)}}),[i,e,s]),c=P.useMemo((()=>({eyeMeshRef:n,irisDirRef:a,_computeSphere:i,_update:l})),[i,l]);P.useImperativeHandle(r,(()=>c),[c]);const u=wt.color[e];return P.createElement(\"group\",null,P.createElement(\"group\",{ref:n},t&&P.createElement(\"axesHelper\",null),P.createElement(\"group\",{ref:a},P.createElement(P.Fragment,null,t&&P.createElement(ue,{points:[[0,0,0],[0,0,-2]],lineWidth:1,color:u})))))})),Mt={TRIANGULATION:[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],SAMPLE_FACE:{keypoints:[{x:356.2804412841797,y:295.1960563659668,z:-23.786449432373047,name:\"lips\"},{x:354.8859405517578,y:264.69520568847656,z:-36.718435287475586},{x:355.2180862426758,y:275.3360366821289,z:-21.183712482452393},{x:347.349853515625,y:242.4400234222412,z:-25.093655586242676},{x:354.40135955810547,y:256.67933464050293,z:-38.23572635650635},{x:353.7689971923828,y:247.54886627197266,z:-34.5475435256958},{x:352.1288299560547,y:227.34312057495117,z:-13.095386028289795},{x:303.5013198852539,y:234.67002868652344,z:12.500141859054565,name:\"rightEye\"},{x:351.09378814697266,y:211.87547206878662,z:-6.413471698760986},{x:350.7115936279297,y:202.1251630783081,z:-6.413471698760986},{x:348.33667755126953,y:168.7741756439209,z:6.483500003814697,name:\"faceOval\"},{x:356.4806365966797,y:299.2995357513428,z:-23.144519329071045},{x:356.5511703491211,y:302.66146659851074,z:-21.020312309265137},{x:356.6239547729492,y:304.1536331176758,z:-18.137459754943848,name:\"lips\"},{x:356.5807342529297,y:305.1840591430664,z:-18.767719268798828,name:\"lips\"},{x:356.8241500854492,y:308.25711250305176,z:-20.16829490661621},{x:357.113037109375,y:312.26277351379395,z:-22.10575819015503},{x:357.34962463378906,y:317.1123218536377,z:-21.837315559387207,name:\"lips\"},{x:357.6658630371094,y:325.51036834716797,z:-16.27002477645874},{x:355.0201416015625,y:269.36279296875,z:-33.73054027557373},{x:348.5237503051758,y:270.33411026000977,z:-24.93025302886963},{x:279.97331619262695,y:213.24176788330078,z:47.759642601013184,name:\"faceOval\"},{x:322.66529083251953,y:238.5027265548706,z:5.535193085670471},{x:316.0983657836914,y:239.94489669799805,z:5.777376294136047},{x:309.9431610107422,y:240.24518966674805,z:7.510589361190796},{x:301.31994247436523,y:237.86138534545898,z:13.118728399276733},{x:328.14266204833984,y:235.80496788024902,z:6.646900177001953},{x:313.7326431274414,y:222.11161136627197,z:3.9887237548828125},{x:320.45196533203125,y:221.87729358673096,z:4.601476192474365},{x:307.35679626464844,y:223.63793849945068,z:5.932023525238037},{x:303.0031204223633,y:226.3743782043457,z:8.479321002960205},{x:296.80023193359375,y:242.94299125671387,z:15.931552648544312},{x:332.2352981567383,y:340.77341079711914,z:-10.165848731994629},{x:301.38587951660156,y:233.46447944641113,z:14.764405488967896,name:\"rightEye\"},{x:279.0147018432617,y:244.37155723571777,z:45.77549457550049},{x:289.60548400878906,y:239.1807460784912,z:23.191204071044922},{x:320.32257080078125,y:267.1292781829834,z:-4.954537749290466},{x:347.64583587646484,y:294.4955062866211,z:-23.062820434570312,name:\"lips\"},{x:349.28138732910156,y:303.1095886230469,z:-20.238323211669922},{x:338.9453125,y:298.19186210632324,z:-19.456336498260498,name:\"lips\"},{x:333.36788177490234,y:302.6706790924072,z:-14.776077270507812,name:\"lips\"},{x:342.89188385009766,y:304.3561363220215,z:-17.752301692962646},{x:337.7375030517578,y:306.0098361968994,z:-13.410515785217285},{x:325.6159210205078,y:316.22995376586914,z:-6.681914925575256},{x:349.0104675292969,y:264.9818515777588,z:-36.274919509887695},{x:347.7138900756836,y:257.5664806365967,z:-37.67549514770508},{x:291.79357528686523,y:218.88171672821045,z:11.578094959259033,name:\"rightEyebrow\"},{x:332.2689437866211,y:247.56946563720703,z:-3.3730539679527283},{x:332.0074462890625,y:267.1201229095459,z:-19.969879388809204},{x:331.27952575683594,y:263.6967658996582,z:-17.47218608856201},{x:301.04373931884766,y:269.56552505493164,z:3.61815482378006},{x:347.4863815307617,y:249.0706443786621,z:-32.633421421051025},{x:307.26118087768555,y:208.2646894454956,z:1.1591226607561111,name:\"rightEyebrow\"},{x:297.91919708251953,y:212.22604751586914,z:5.914516448974609,name:\"rightEyebrow\"},{x:285.1651382446289,y:197.98450469970703,z:36.391637325286865,name:\"faceOval\"},{x:337.04097747802734,y:211.25229835510254,z:-4.548954665660858},{x:326.5912628173828,y:223.16698551177979,z:6.670243740081787},{x:320.05664825439453,y:309.5834255218506,z:-4.055835008621216},{x:289.6866226196289,y:314.617395401001,z:53.875489234924316,name:\"faceOval\"},{x:337.4256896972656,y:270.8755302429199,z:-17.67060160636902},{x:343.69922637939453,y:273.0000400543213,z:-18.756048679351807},{x:327.4242401123047,y:309.22399520874023,z:-4.703601002693176,name:\"lips\"},{x:330.37220001220703,y:308.3323001861572,z:-6.442649960517883},{x:293.87027740478516,y:207.7961826324463,z:9.821539521217346,name:\"rightEyebrow\"},{x:332.11437225341797,y:271.22812271118164,z:-16.64351224899292},{x:320.1197814941406,y:207.40366458892822,z:-2.48164564371109,name:\"rightEyebrow\"},{x:318.59575271606445,y:201.07443809509277,z:-3.110446035861969,name:\"rightEyebrow\"},{x:310.72303771972656,y:175.75075149536133,z:13.328815698623657,name:\"faceOval\"},{x:289.67578887939453,y:202.29835510253906,z:21.370456218719482},{x:315.30879974365234,y:187.35260009765625,z:5.0304025411605835},{x:287.8936767578125,y:216.54793739318848,z:17.81065821647644,name:\"rightEyebrow\"},{x:283.9391899108887,y:215.01142501831055,z:32.04984903335571},{x:348.35330963134766,y:299.4155788421631,z:-22.47924566268921},{x:341.1790466308594,y:301.8221855163574,z:-18.977805376052856},{x:335.69713592529297,y:304.4266891479492,z:-14.682706594467163},{x:339.4615173339844,y:272.3654365539551,z:-16.38674020767212},{x:328.99600982666016,y:308.86685371398926,z:-5.616893768310547},{x:332.00313568115234,y:309.1875743865967,z:-10.335084199905396},{x:331.0068130493164,y:307.9274368286133,z:-6.681914925575256,name:\"lips\"},{x:341.13792419433594,y:266.4876937866211,z:-26.56425952911377},{x:339.02950286865234,y:305.6663703918457,z:-12.33674168586731,name:\"lips\"},{x:344.22935485839844,y:304.9452781677246,z:-15.161235332489014,name:\"lips\"},{x:350.1844024658203,y:304.374303817749,z:-17.5305438041687,name:\"lips\"},{x:348.52630615234375,y:325.9562301635742,z:-16.164982318878174},{x:348.6581802368164,y:317.1624183654785,z:-21.510512828826904,name:\"lips\"},{x:348.9766311645508,y:312.1923065185547,z:-21.708929538726807},{x:349.2427444458008,y:308.0660820007324,z:-19.643079042434692},{x:349.67491149902344,y:305.42747497558594,z:-18.16080331802368,name:\"lips\"},{x:337.95589447021484,y:306.6535949707031,z:-12.803598642349243,name:\"lips\"},{x:337.06878662109375,y:307.63169288635254,z:-14.274203777313232},{x:335.77449798583984,y:309.8449516296387,z:-15.698124170303345},{x:334.6099090576172,y:312.7997016906738,z:-14.764405488967896,name:\"lips\"},{x:327.2330856323242,y:293.80866050720215,z:-11.864047050476074},{x:280.97679138183594,y:279.79928970336914,z:68.90834331512451,name:\"faceOval\"},{x:355.13843536376953,y:271.7875671386719,z:-25.350427627563477},{x:334.7235870361328,y:307.4656391143799,z:-9.302158951759338,name:\"lips\"},{x:333.5293960571289,y:307.89782524108887,z:-10.200862884521484},{x:346.29688262939453,y:276.4256286621094,z:-19.748122692108154},{x:335.16246795654297,y:276.22097969055176,z:-12.313398122787476},{x:345.09132385253906,y:274.7082996368408,z:-19.304605722427368},{x:325.4267883300781,y:252.95130729675293,z:-1.6661019623279572},{x:315.347843170166,y:259.05200958251953,z:-.25604281574487686},{x:330.44933319091797,y:267.7570152282715,z:-14.017432928085327},{x:294.96768951416016,y:185.26001930236816,z:23.903164863586426,name:\"faceOval\"},{x:299.63531494140625,y:192.7913761138916,z:12.640198469161987},{x:304.5452117919922,y:202.4142837524414,z:3.244667649269104,name:\"rightEyebrow\"},{x:331.6915512084961,y:320.0467872619629,z:-10.632705688476562},{x:334.5911407470703,y:201.27566814422607,z:-6.133356094360352,name:\"rightEyebrow\"},{x:331.4815902709961,y:185.44180870056152,z:.6627205014228821},{x:328.05816650390625,y:170.8385467529297,z:7.358860373497009,name:\"faceOval\"},{x:304.49764251708984,y:239.76297855377197,z:10.387605428695679},{x:290.6382179260254,y:248.85257720947266,z:19.03616428375244},{x:331.5682601928711,y:233.20727348327637,z:7.837390303611755},{x:295.5115509033203,y:228.9834451675415,z:14.41426157951355},{x:336.94332122802734,y:241.8259334564209,z:-5.27842104434967},{x:336.2792205810547,y:262.7049922943115,z:-26.12074375152588},{x:284.4102478027344,y:255.3262710571289,z:25.467140674591064},{x:295.1420593261719,y:253.02655220031738,z:12.430112361907959},{x:303.5196113586426,y:254.20703887939453,z:6.139191389083862},{x:315.73450088500977,y:251.64799690246582,z:3.3788898587226868},{x:324.69661712646484,y:247.56494522094727,z:2.3328344523906708},{x:331.57970428466797,y:243.02241325378418,z:1.1423448473215103},{x:345.6210708618164,y:229.9976634979248,z:-10.825285911560059},{x:286.26644134521484,y:270.37991523742676,z:21.708929538726807},{x:290.2525520324707,y:228.4921360015869,z:17.71728754043579},{x:351.65367126464844,y:269.3400764465332,z:-33.450424671173096},{x:333.1378936767578,y:253.88388633728027,z:-7.230473756790161},{x:277.8318977355957,y:246.95331573486328,z:68.20805549621582,name:\"faceOval\"},{x:336.6680908203125,y:238.10003757476807,z:.7688578963279724},{x:329.95800018310547,y:269.18323516845703,z:-7.207130789756775},{x:299.17491912841797,y:234.13324356079102,z:15.95489501953125},{x:335.61729431152344,y:258.71752738952637,z:-23.016133308410645},{x:284.1079330444336,y:297.0343494415283,z:63.25934886932373,name:\"faceOval\"},{x:331.44542694091797,y:230.6892442703247,z:9.92658257484436,name:\"rightEye\"},{x:341.41536712646484,y:253.01264762878418,z:-29.038610458374023},{x:303.5472869873047,y:327.5896739959717,z:16.725212335586548},{x:304.7756576538086,y:337.4389457702637,z:27.38126277923584,name:\"faceOval\"},{x:280.80501556396484,y:275.32050132751465,z:45.0752067565918},{x:295.43582916259766,y:318.4501647949219,z:26.2608003616333},{x:281.4303207397461,y:228.7355661392212,z:40.94350814819336},{x:331.2549591064453,y:349.4216537475586,z:-7.376367449760437},{x:352.4247741699219,y:271.7330074310303,z:-24.953596591949463},{x:327.5672912597656,y:260.41900634765625,z:-5.456410646438599},{x:284.5432472229004,y:241.7647933959961,z:29.668869972229004},{x:310,y:235.66174507141113,z:8.502663969993591,name:\"rightEye\"},{x:315.7071113586426,y:235.7572603225708,z:6.938687562942505,name:\"rightEye\"},{x:330.41088104248047,y:311.04143142700195,z:-9.325502514839172,name:\"lips\"},{x:288.5377502441406,y:285.31983375549316,z:21.837315559387207},{x:344.55039978027344,y:359.4300842285156,z:-6.705257892608643,name:\"faceOval\"},{x:323.41880798339844,y:351.67362213134766,z:7.802375555038452,name:\"faceOval\"},{x:314.64088439941406,y:346.11894607543945,z:16.36339783668518,name:\"faceOval\"},{x:349.4945526123047,y:184.8434829711914,z:-.21847527474164963},{x:359.24694061279297,y:359.8348903656006,z:-8.403456211090088,name:\"faceOval\"},{x:321.26182556152344,y:234.64492321014404,z:6.90950870513916,name:\"rightEye\"},{x:326.318359375,y:232.90250301361084,z:8.029969334602356,name:\"rightEye\"},{x:329.6211624145508,y:231.6195774078369,z:9.722331762313843,name:\"rightEye\"},{x:285.9398078918457,y:228.2351303100586,z:24.650139808654785},{x:325.79288482666016,y:227.88007736206055,z:7.469738721847534,name:\"rightEye\"},{x:320.1699447631836,y:227.5934886932373,z:6.168370842933655,name:\"rightEye\"},{x:314.85408782958984,y:227.85282611846924,z:6.2675780057907104,name:\"rightEye\"},{x:309.3084907531738,y:229.1516876220703,z:7.7031683921813965,name:\"rightEye\"},{x:305.5621337890625,y:230.92366218566895,z:9.722331762313843,name:\"rightEye\"},{x:277.8681945800781,y:228.5354232788086,z:59.71122741699219,name:\"faceOval\"},{x:306.1444664001465,y:235.1954698562622,z:10.603528022766113,name:\"rightEye\"},{x:355.4478454589844,y:281.96210861206055,z:-20.565123558044434},{x:333.02661895751953,y:288.0105400085449,z:-14.72939133644104},{x:337.15728759765625,y:269.2059516906738,z:-19.8414945602417},{x:345.9898376464844,y:283.5453128814697,z:-20.4834246635437},{x:351.48963928222656,y:219.98916149139404,z:-7.0378947257995605},{x:312.39574432373047,y:336.50628089904785,z:8.671900033950806},{x:321.32152557373047,y:343.1755256652832,z:.9067271649837494},{x:343.78379821777344,y:353.2975959777832,z:-14.355905055999756},{x:296.8791389465332,y:327.91497230529785,z:41.01353645324707,name:\"faceOval\"},{x:329.6939468383789,y:229.27897453308105,z:8.934508562088013,name:\"rightEye\"},{x:341.6905212402344,y:241.4073657989502,z:-14.589333534240723},{x:359.03079986572266,y:353.48859786987305,z:-15.803166627883911},{x:333.1861877441406,y:356.43213272094727,z:-1.0234417766332626,name:\"faceOval\"},{x:283.97483825683594,y:291.4318656921387,z:41.94725513458252},{x:343.33770751953125,y:305.830135345459,z:-15.756480693817139,name:\"lips\"},{x:342.40283966064453,y:307.7453899383545,z:-17.4021577835083},{x:341.53621673583984,y:311.0595703125,z:-19.047834873199463},{x:340.9107208251953,y:315.4837703704834,z:-18.5576331615448,name:\"lips\"},{x:339.1478729248047,y:323.42233657836914,z:-14.367576837539673},{x:333.3201599121094,y:307.4406337738037,z:-9.617288708686829},{x:331.2411117553711,y:306.9811820983887,z:-9.669809937477112},{x:329.23255920410156,y:306.0508346557617,z:-9.582273960113525,name:\"lips\"},{x:322.4586486816406,y:301.33323669433594,z:-7.720675468444824},{x:297.1712112426758,y:286.9552803039551,z:8.240055441856384},{x:341.3060760498047,y:235.4432201385498,z:-7.504753470420837},{x:336.9318389892578,y:224.3451976776123,z:5.829898118972778},{x:332.65323638916016,y:226.70403957366943,z:8.105834126472473},{x:334.67357635498047,y:306.4397621154785,z:-8.981193900108337,name:\"lips\"},{x:297.4601936340332,y:306.29210472106934,z:15.476365089416504},{x:342.9119110107422,y:222.37077713012695,z:-2.754466235637665},{x:335.4629898071289,y:332.20250129699707,z:-11.823196411132812},{x:353.2412338256836,y:240.56339263916016,z:-27.147831916809082},{x:346.3080596923828,y:236.41446590423584,z:-18.452589511871338},{x:352.6475143432617,y:234.1420555114746,z:-19.748122692108154},{x:337.3209762573242,y:253.39937210083008,z:-16.024924516677856},{x:358.6122131347656,y:344.90861892700195,z:-18.592647314071655},{x:358.1117248535156,y:334.64990615844727,z:-17.49552845954895},{x:346.4450454711914,y:335.0321102142334,z:-16.32838249206543},{x:319.17640686035156,y:320.2833938598633,z:-3.276764452457428},{x:325.2540588378906,y:276.2369728088379,z:-6.460157036781311},{x:326.7214584350586,y:327.3939514160156,z:-7.417217493057251},{x:310.7190132141113,y:277.2265148162842,z:-3.5452082753181458},{x:319.78355407714844,y:284.8238182067871,z:-6.4543211460113525},{x:305.773983001709,y:290.83580017089844,z:.06907138042151928},{x:344.4001770019531,y:344.85408782958984,z:-16.946970224380493},{x:333.1879425048828,y:258.74256134033203,z:-11.90489649772644},{x:313.80598068237305,y:327.08919525146484,z:2.2277912497520447},{x:322.9637908935547,y:334.6819496154785,z:-3.3643004298210144},{x:313.4055519104004,y:311.2166690826416,z:-1.1175429821014404},{x:291.0865783691406,y:298.2831001281738,z:22.467575073242188},{x:305.6580924987793,y:313.3707904815674,z:5.561453700065613},{x:288.23760986328125,y:305.9941864013672,z:36.765122413635254},{x:315.10692596435547,y:296.26991271972656,z:-4.604393839836121},{x:337.50518798828125,y:247.5944423675537,z:-10.597691535949707},{x:338.8450622558594,y:265.47778129577637,z:-27.778091430664062},{x:334.25254821777344,y:269.0671920776367,z:-20.938611030578613},{x:341.64512634277344,y:259.6387195587158,z:-32.189905643463135},{x:331.44081115722656,y:219.0976095199585,z:4.207563698291779},{x:320.56339263916016,y:216.49658203125,z:2.930997312068939},{x:311.21912002563477,y:216.57853603363037,z:2.9674705862998962},{x:303.46256256103516,y:218.54614734649658,z:5.357203483581543},{x:297.99999237060547,y:222.505202293396,z:9.325502514839172},{x:294.93839263916016,y:236.39654159545898,z:18.534289598464966},{x:278.87489318847656,y:259.7095584869385,z:45.68212032318115},{x:300.3782653808594,y:245.38593292236328,z:12.278382778167725},{x:307.06348419189453,y:246.36857986450195,z:8.164191246032715},{x:315.5229187011719,y:245.3949737548828,z:5.503097176551819},{x:323.71395111083984,y:242.75178909301758,z:4.6335723996162415},{x:330.2785873413086,y:239.34658527374268,z:4.937030673027039},{x:334.6982192993164,y:236.0460376739502,z:4.823233783245087},{x:279.3412208557129,y:263.5196113586426,z:70.91583728790283,name:\"faceOval\"},{x:334.65972900390625,y:271.6648578643799,z:-17.775644063949585},{x:342.05677032470703,y:246.99846267700195,z:-20.84523916244507},{x:344.0357971191406,y:264.5701503753662,z:-32.936880588531494},{x:348.25531005859375,y:268.6645030975342,z:-30.695960521697998},{x:344.12227630615234,y:266.34212493896484,z:-29.808926582336426},{x:337.12318420410156,y:274.2556858062744,z:-15.768152475357056},{x:349.49047088623047,y:269.071683883667,z:-32.51670837402344},{x:350.1683044433594,y:271.4691352844238,z:-24.93025302886963},{x:333.9634704589844,y:230.56639194488525,z:8.89949381351471},{x:338.2147979736328,y:231.4807891845703,z:4.6715047955513},{x:340.4712677001953,y:231.74463272094727,z:-.34996166825294495},{x:303.28975677490234,y:232.24980354309082,z:11.916568279266357,name:\"rightEye\"},{x:299.4649124145508,y:229.53842639923096,z:12.325069904327393},{x:359.09618377685547,y:241.77349090576172,z:-24.650139808654785},{x:399.46216583251953,y:229.89503860473633,z:15.919880867004395,name:\"leftEye\"},{x:361.38919830322266,y:269.6129894256592,z:-24.510080814361572},{x:416.9973373413086,y:206.0895538330078,z:53.26857566833496,name:\"faceOval\"},{x:381.32179260253906,y:235.5476474761963,z:7.6214683055877686},{x:387.8068542480469,y:236.25958442687988,z:8.345099091529846},{x:393.95751953125,y:235.8660364151001,z:10.475142002105713},{x:401.84600830078125,y:232.77019500732422,z:16.760226488113403},{x:375.70568084716797,y:233.48456382751465,z:8.234220147132874},{x:388.17752838134766,y:218.94717693328857,z:6.810300946235657},{x:381.64928436279297,y:219.2656660079956,z:6.711093783378601},{x:394.4760513305664,y:219.66821193695068,z:9.173773527145386},{x:398.8843536376953,y:221.8837022781372,z:12.03328251838684},{x:406.5454864501953,y:237.12156772613525,z:19.7131085395813},{x:383.87447357177734,y:337.6932907104492,z:-8.631049990653992},{x:401.2682342529297,y:228.5916566848755,z:18.359217643737793,name:\"leftEye\"},{x:422.0449447631836,y:236.73934936523438,z:51.16771221160889},{x:412.69153594970703,y:232.80198097229004,z:27.52131938934326},{x:387.3497772216797,y:263.298397064209,z:-2.8609684109687805},{x:364.5124053955078,y:293.39221000671387,z:-22.397546768188477,name:\"lips\"},{x:363.62987518310547,y:302.1291446685791,z:-19.643079042434692},{x:373.2334518432617,y:295.8647060394287,z:-18.125789165496826,name:\"lips\"},{x:378.83365631103516,y:299.5177745819092,z:-13.153743743896484,name:\"lips\"},{x:369.91477966308594,y:302.5704002380371,z:-16.65518283843994},{x:374.9167251586914,y:303.5416603088379,z:-11.963253021240234},{x:387.58888244628906,y:312.2716999053955,z:-4.680258631706238},{x:360.6635284423828,y:264.31986808776855,z:-35.94811677932739},{x:361.04564666748047,y:256.8225860595703,z:-37.278664112091064},{x:408.3855438232422,y:213.52088928222656,z:15.756480693817139,name:\"leftEyebrow\"},{x:373.2946014404297,y:245.38101196289062,z:-1.9316278398036957},{x:376.83860778808594,y:264.3721103668213,z:-18.510947227478027},{x:376.9546127319336,y:261.0010528564453,z:-15.989909172058105},{x:406.1498260498047,y:263.5030174255371,z:7.072908878326416},{x:360.07205963134766,y:248.3631706237793,z:-32.16656446456909},{x:393.11119079589844,y:205.10473251342773,z:3.7786373496055603,name:\"leftEyebrow\"},{x:402.12791442871094,y:207.89000988006592,z:9.383859634399414,name:\"leftEyebrow\"},{x:410.8693313598633,y:191.6182279586792,z:41.27030849456787,name:\"faceOval\"},{x:364.9509811401367,y:210.40483474731445,z:-3.758212625980377},{x:375.94444274902344,y:221.1331844329834,z:8.368442058563232},{x:392.1904754638672,y:305.0360298156738,z:-1.752179116010666},{x:419.50225830078125,y:307.25592613220215,z:58.96425247192383,name:\"faceOval\"},{x:372.0027160644531,y:268.7212657928467,z:-16.631840467453003},{x:366.1614227294922,y:271.6237449645996,z:-18.219159841537476},{x:385.00938415527344,y:305.3863334655762,z:-2.567722797393799},{x:381.99771881103516,y:304.9723720550537,z:-4.575215280056},{x:405.078125,y:203.21216583251953,z:13.713973760604858,name:\"leftEyebrow\"},{x:377.13207244873047,y:268.4710121154785,z:-15.266278982162476},{x:380.9713363647461,y:205.36980628967285,z:-.7250899076461792,name:\"leftEyebrow\"},{x:381.7788314819336,y:198.9268398284912,z:-1.184653863310814,name:\"leftEyebrow\"},{x:385.5204772949219,y:172.1484375,z:16.04826807975769,name:\"faceOval\"},{x:407.94189453125,y:196.76236152648926,z:25.723915100097656},{x:383.03890228271484,y:184.5157527923584,z:7.393874526023865},{x:411.61781311035156,y:210.79241752624512,z:22.315845489501953,name:\"leftEyebrow\"},{x:414.30870056152344,y:208.4643030166626,z:37.021894454956055},{x:364.28722381591797,y:298.35777282714844,z:-21.86065673828125},{x:371.3682556152344,y:299.78848457336426,z:-17.834001779556274},{x:376.88201904296875,y:301.6696071624756,z:-13.153743743896484},{x:370.2193832397461,y:270.49095153808594,z:-15.569736957550049},{x:383.5081100463867,y:305.2726364135742,z:-3.673594295978546},{x:380.73760986328125,y:305.96869468688965,z:-8.660228252410889},{x:381.2334442138672,y:304.63574409484863,z:-4.820316135883331,name:\"lips\"},{x:368.1698989868164,y:264.8884963989258,z:-25.653886795043945},{x:373.5087203979492,y:303.4233856201172,z:-10.95950722694397,name:\"lips\"},{x:368.4544372558594,y:303.29601287841797,z:-14.169161319732666,name:\"lips\"},{x:362.76554107666016,y:303.5735607147217,z:-16.911956071853638,name:\"lips\"},{x:366.60980224609375,y:324.8870658874512,z:-15.616422891616821},{x:365.7067108154297,y:315.95678329467773,z:-20.903596878051758,name:\"lips\"},{x:365.0083923339844,y:311.2232208251953,z:-21.066999435424805},{x:364.1508102416992,y:307.0583438873291,z:-18.907777070999146},{x:363.37512969970703,y:304.5721435546875,z:-17.42550015449524,name:\"lips\"},{x:374.580078125,y:304.3059539794922,z:-11.40302300453186,name:\"lips\"},{x:375.55362701416016,y:305.0998020172119,z:-12.861957550048828},{x:377.2437286376953,y:307.1674346923828,z:-14.215847253799438},{x:378.68587493896484,y:309.9015712738037,z:-13.223772048950195,name:\"lips\"},{x:383.8992691040039,y:290.29629707336426,z:-9.97326910495758},{x:423.3871841430664,y:271.91688537597656,z:74.37058925628662,name:\"faceOval\"},{x:377.68043518066406,y:304.62209701538086,z:-7.603961229324341,name:\"lips\"},{x:379.00428771972656,y:304.9314594268799,z:-8.57852816581726},{x:364.00279998779297,y:275.2813911437988,z:-19.25792098045349},{x:374.68231201171875,y:273.82555961608887,z:-11.28047227859497},{x:365.0354766845703,y:273.4548568725586,z:-18.791062831878662},{x:380.61901092529297,y:249.8848056793213,z:.15501167625188828},{x:391.14158630371094,y:254.7934627532959,z:2.0906515419483185},{x:378.1761169433594,y:264.9612236022949,z:-12.605184316635132},{x:400.9540557861328,y:179.99592304229736,z:27.82477855682373,name:\"faceOval\"},{x:398.0038833618164,y:188.50656509399414,z:16.094952821731567},{x:394.8717498779297,y:199.0359592437744,z:6.226727366447449,name:\"leftEyebrow\"},{x:382.10926055908203,y:316.83926582336426,z:-8.946179747581482},{x:366.51588439941406,y:200.32583713531494,z:-5.24632453918457,name:\"leftEyebrow\"},{x:367.4893569946289,y:183.87210845947266,z:1.9039081037044525},{x:368.6243438720703,y:168.8127565383911,z:8.736093044281006,name:\"faceOval\"},{x:398.96175384521484,y:234.9675178527832,z:13.713973760604858},{x:412.9645538330078,y:242.23042488098145,z:23.272905349731445},{x:372.05257415771484,y:231.41919136047363,z:9.226294755935669},{x:406.0722351074219,y:223.58965873718262,z:18.370890617370605},{x:368.27442169189453,y:240.2039337158203,z:-4.166713654994965},{x:372.3575210571289,y:260.66442489624023,z:-24.976940155029297},{x:419.2244338989258,y:247.9079246520996,z:30.299127101898193},{x:409.43885803222656,y:246.60913467407227,z:16.398411989212036},{x:401.69139862060547,y:248.76328468322754,z:9.395531415939331},{x:389.7608184814453,y:247.56915092468262,z:5.841569304466248},{x:380.5461883544922,y:244.55984115600586,z:4.263003468513489},{x:373.25817108154297,y:240.80214500427246,z:2.5356262922286987},{x:358.77086639404297,y:229.35615062713623,z:-10.387605428695679},{x:419.5793914794922,y:262.8478717803955,z:26.5175724029541},{x:410.8808898925781,y:222.51372814178467,z:22.199130058288574},{x:358.45714569091797,y:268.91467094421387,z:-33.17030906677246},{x:373.4129333496094,y:251.6385841369629,z:-5.771540403366089},{x:422.5408172607422,y:239.23919677734375,z:74.04378890991211,name:\"faceOval\"},{x:367.8171920776367,y:236.58040523529053,z:1.820748895406723},{x:378.51959228515625,y:266.2532329559326,z:-5.74819803237915},{x:403.3472442626953,y:229.05112266540527,z:19.689764976501465},{x:372.34840393066406,y:256.6451168060303,z:-21.872329711914062},{x:422.54566192626953,y:289.1587829589844,z:68.67491245269775,name:\"faceOval\"},{x:371.9297409057617,y:228.90116214752197,z:11.432201862335205,name:\"leftEye\"},{x:366.21360778808594,y:251.6158962249756,z:-28.19826364517212},{x:409.1571807861328,y:321.3156223297119,z:20.2266526222229},{x:408.52943420410156,y:331.44238471984863,z:31.09278917312622,name:\"faceOval\"},{x:424.2788314819336,y:267.1992301940918,z:50.467424392700195},{x:415.60352325439453,y:311.6528606414795,z:30.579242706298828},{x:418.12793731689453,y:221.59927368164062,z:46.26569747924805},{x:385.68286895751953,y:346.0184955596924,z:-5.70151150226593},{x:357.82936096191406,y:271.3758373260498,z:-24.836881160736084},{x:379.588623046875,y:257.5071716308594,z:-3.755294680595398},{x:417.4592590332031,y:234.71948146820068,z:34.5475435256958},{x:393.4684371948242,y:231.58967971801758,z:11.408859491348267,name:\"leftEye\"},{x:387.8864288330078,y:232.14245796203613,z:9.51808214187622,name:\"leftEye\"},{x:382.4981689453125,y:307.5654888153076,z:-7.522260546684265,name:\"lips\"},{x:419.00169372558594,y:277.8332805633545,z:26.424202919006348},{x:373.62953186035156,y:357.6375102996826,z:-5.75986921787262,name:\"faceOval\"},{x:392.8708267211914,y:347.72446632385254,z:10.154176950454712,name:\"faceOval\"},{x:400.3953552246094,y:341.0005187988281,z:19.39797878265381,name:\"faceOval\"},{x:382.25440979003906,y:231.66935920715332,z:8.998700976371765,name:\"leftEye\"},{x:377.14550018310547,y:230.4228687286377,z:9.804032444953918,name:\"leftEye\"},{x:373.8358688354492,y:229.64950561523438,z:11.292144060134888,name:\"leftEye\"},{x:414.5794677734375,y:221.67891025543213,z:29.412097930908203},{x:377.00672149658203,y:225.66201210021973,z:9.360517263412476,name:\"leftEye\"},{x:382.29530334472656,y:224.8431158065796,z:8.32175612449646,name:\"leftEye\"},{x:387.5133514404297,y:224.49507236480713,z:8.917000889778137,name:\"leftEye\"},{x:393.15906524658203,y:225.24795055389404,z:10.737749338150024,name:\"leftEye\"},{x:397.05554962158203,y:226.55359268188477,z:13.002015352249146,name:\"leftEye\"},{x:420.5299377441406,y:221.014666557312,z:65.40690422058105,name:\"faceOval\"},{x:397.06920623779297,y:230.6661558151245,z:13.807345628738403,name:\"leftEye\"},{x:377.94647216796875,y:285.1647090911865,z:-13.305472135543823},{x:372.1118927001953,y:267.1267318725586,z:-18.83774757385254},{x:364.9968719482422,y:282.24411964416504,z:-19.818150997161865},{x:401.973876953125,y:331.20131492614746,z:11.566424369812012},{x:394.3083190917969,y:338.86693954467773,z:3.142542541027069},{x:373.9820861816406,y:351.4504623413086,z:-13.50388765335083},{x:414.3888854980469,y:321.24735832214355,z:45.51872253417969,name:\"faceOval\"},{x:373.44234466552734,y:227.33163356781006,z:10.626870393753052,name:\"leftEye\"},{x:364.0731430053711,y:240.31539916992188,z:-13.807345628738403},{x:384.2658233642578,y:353.3793067932129,z:.7385850697755814,name:\"faceOval\"},{x:423.20526123046875,y:283.5176181793213,z:47.152724266052246},{x:369.42798614501953,y:304.0898895263672,z:-14.647691249847412,name:\"lips\"},{x:370.63812255859375,y:305.90051651000977,z:-16.211668252944946},{x:371.91192626953125,y:309.0167713165283,z:-17.84567356109619},{x:373.0583953857422,y:313.3545398712158,z:-17.378815412521362,name:\"lips\"},{x:375.39905548095703,y:321.09289169311523,z:-13.118728399276733},{x:379.2567825317383,y:304.3582534790039,z:-7.924926280975342},{x:381.18797302246094,y:303.7031364440918,z:-7.843226194381714},{x:383.0918502807617,y:302.4884605407715,z:-7.6506465673446655,name:\"lips\"},{x:389.09461975097656,y:297.1475315093994,z:-5.5497825145721436},{x:411.6408920288086,y:280.24898529052734,z:12.02161192893982},{x:363.3110809326172,y:234.27620887756348,z:-6.775286793708801},{x:366.0474395751953,y:223.29872131347656,z:6.827808618545532},{x:370.34427642822266,y:225.1457118988037,z:9.558931589126587},{x:377.5371551513672,y:303.60079765319824,z:-7.358860373497009,name:\"lips\"},{x:412.9557800292969,y:299.53579902648926,z:19.39797878265381},{x:360.0810241699219,y:221.72012329101562,z:-2.153385728597641},{x:379.82784271240234,y:329.47723388671875,z:-10.48097848892212},{x:359.08477783203125,y:235.7911491394043,z:-18.079102039337158},{x:369.6688461303711,y:251.5407943725586,z:-14.962821006774902},{x:369.5555114746094,y:333.5307312011719,z:-15.67478060722351},{x:394.0193176269531,y:315.6973171234131,z:-.9920747578144073},{x:383.78997802734375,y:272.7268695831299,z:-4.689012169837952},{x:387.67765045166016,y:323.6722755432129,z:-5.640236139297485},{x:397.8769302368164,y:272.1331214904785,z:-.9395531564950943},{x:389.87476348876953,y:280.5630111694336,z:-4.29218202829361},{x:403.83888244628906,y:285.1167869567871,z:3.0229100584983826},{x:372.5467300415039,y:343.1070327758789,z:-16.153310537338257},{x:374.1112518310547,y:256.3721466064453,z:-10.574349164962769},{x:399.73785400390625,y:321.77515983581543,z:4.849494695663452},{x:392.03365325927734,y:330.56447982788086,z:-1.3407598435878754},{x:398.59134674072266,y:305.93902587890625,z:1.517290621995926},{x:417.95997619628906,y:290.9716987609863,z:26.89105987548828},{x:406.04541778564453,y:307.35154151916504,z:8.666064143180847},{x:420.75328826904297,y:298.40752601623535,z:41.78385257720947},{x:395.4522705078125,y:291.4153575897217,z:-2.1752697229385376},{x:368.6452102661133,y:245.8882999420166,z:-9.453888535499573},{x:370.34900665283203,y:263.56690406799316,z:-26.75100326538086},{x:374.98477935791016,y:266.6126346588135,z:-19.77146625518799},{x:366.99840545654297,y:258.12140464782715,z:-31.372904777526855},{x:371.00616455078125,y:217.63479709625244,z:5.60522198677063},{x:381.30577087402344,y:214.14087295532227,z:4.983716309070587},{x:390.1496124267578,y:213.38221549987793,z:5.593550801277161},{x:397.7696990966797,y:214.3659782409668,z:8.57852816581726},{x:403.1652069091797,y:217.65509605407715,z:13.013685941696167},{x:407.3551940917969,y:230.72525024414062,z:22.444231510162354},{x:424.0876770019531,y:251.7839241027832,z:51.16771221160889},{x:403.50196838378906,y:239.88757610321045,z:15.803166627883911},{x:397.31719970703125,y:241.49806022644043,z:11.233787536621094},{x:388.99425506591797,y:241.4366912841797,z:7.948269248008728},{x:380.7804489135742,y:239.78078842163086,z:6.600214838981628},{x:374.01336669921875,y:237.11946487426758,z:6.349278092384338},{x:369.39125061035156,y:234.35351371765137,z:5.987462401390076},{x:422.9730987548828,y:255.76455116271973,z:76.61150932312012,name:\"faceOval\"},{x:374.73915100097656,y:269.24214363098145,z:-16.608498096466064},{x:364.61681365966797,y:245.71088790893555,z:-20.02823829650879},{x:365.3834533691406,y:263.34174156188965,z:-32.32996463775635},{x:361.58252716064453,y:267.8273677825928,z:-30.345816612243652},{x:365.37208557128906,y:265.0249671936035,z:-29.178667068481445},{x:372.72605895996094,y:272.05135345458984,z:-14.834434986114502},{x:360.48614501953125,y:268.34827423095703,z:-32.189905643463135},{x:359.9516296386719,y:270.8049201965332,z:-24.650139808654785},{x:369.5049285888672,y:229.01945114135742,z:10.107489824295044},{x:365.5447769165039,y:230.24096488952637,z:5.593550801277161},{x:363.50669860839844,y:230.6208372116089,z:.43622106313705444},{x:399.3529510498047,y:227.65677452087402,z:15.35965085029602,name:\"leftEye\"},{x:402.5693130493164,y:224.60190296173096,z:15.931552648544312}],box:{xMin:277.8318977355957,yMin:168.7741756439209,xMax:424.2788314819336,yMax:359.8348903656006,width:146.4469337463379,height:191.0607147216797}},SAMPLE_FACELANDMARKER_RESULT:{faceLandmarks:[[{x:.5760777592658997,y:.8639070391654968,z:-.030997956171631813},{x:.572094738483429,y:.7886289358139038,z:-.07189624011516571},{x:.5723551511764526,y:.8075382709503174,z:-.03578168898820877},{x:.5548420548439026,y:.7188365459442139,z:-.057787876576185226},{x:.5706077814102173,y:.7674974799156189,z:-.07740399986505508},{x:.5681378245353699,y:.7387768030166626,z:-.07356284558773041},{x:.5621535181999207,y:.6681165099143982,z:-.04189874976873398},{x:.46613582968711853,y:.6679812073707581,z:.011289681307971478},{x:.5579932928085327,y:.6174106597900391,z:-.03502821549773216},{x:.5563451647758484,y:.5905600190162659,z:-.03928658738732338},{x:.5487832427024841,y:.4900572597980499,z:-.029898937791585922},{x:.5765544176101685,y:.8692144751548767,z:-.02831427752971649},{x:.5771114230155945,y:.873644232749939,z:-.02345779910683632},{x:.5771905779838562,y:.877016007900238,z:-.016658689826726913},{x:.5778058767318726,y:.8770116567611694,z:-.014505492523312569},{x:.5783766508102417,y:.8835000991821289,z:-.015996402129530907},{x:.5792440176010132,y:.8913810849189758,z:-.01924579218029976},{x:.5796768069267273,y:.8996334671974182,z:-.018261712044477463},{x:.5817288160324097,y:.9255813956260681,z:-.007126849144697189},{x:.5726592540740967,y:.7992473244667053,z:-.0643521398305893},{x:.5579419136047363,y:.7996989488601685,z:-.04566684365272522},{x:.4216199815273285,y:.5958762764930725,z:.06776496022939682},{x:.5052269697189331,y:.6796539425849915,z:-.0010737782577052712},{x:.49243026971817017,y:.6838865876197815,z:-.0005227324436418712},{x:.4796970784664154,y:.6856290102005005,z:.002684245817363262},{x:.4618356227874756,y:.6764569878578186,z:.013439622707664967},{x:.5160380601882935,y:.6737282276153564,z:-17607348127057776e-21},{x:.48070961236953735,y:.6255870461463928,z:-.008339674212038517},{x:.49719780683517456,y:.6256808042526245,z:-.008027955889701843},{x:.46674346923828125,y:.6317623853683472,z:-.004460199736058712},{x:.4582492709159851,y:.641118049621582,z:.0011905613355338573},{x:.45408669114112854,y:.6911458969116211,z:.020514748990535736},{x:.535312294960022,y:.9619986414909363,z:.012499462813138962},{x:.4608460068702698,y:.6628725528717041,z:.01517564244568348},{x:.4206731915473938,y:.6828458309173584,z:.07848648726940155},{x:.4390624463558197,y:.6796106696128845,z:.03283142298460007},{x:.5029968619346619,y:.7701570391654968,z:-.009734481573104858},{x:.5595027208328247,y:.8607323169708252,z:-.030043255537748337},{x:.5621269941329956,y:.8738374710083008,z:-.021709579974412918},{x:.5451499819755554,y:.865527331829071,z:-.022014077752828598},{x:.5351184010505676,y:.8705098032951355,z:-.011602800339460373},{x:.5495014190673828,y:.8744956254959106,z:-.016490943729877472},{x:.5395170450210571,y:.8759440779685974,z:-.007333362940698862},{x:.5183624029159546,y:.8959754705429077,z:.010520773939788342},{x:.5604349374771118,y:.7895449995994568,z:-.07082037627696991},{x:.557381272315979,y:.7687489986419678,z:-.07590588927268982},{x:.4432901442050934,y:.6308897733688354,z:.0027153254486620426},{x:.5258325338363647,y:.7151225805282593,z:-.014676518738269806},{x:.5271827578544617,y:.7833116054534912,z:-.037643320858478546},{x:.5257382988929749,y:.7717816233634949,z:-.03401920944452286},{x:.46516409516334534,y:.7705106735229492,z:.0065747760236263275},{x:.5558893084526062,y:.7420997619628906,z:-.0694495290517807},{x:.4720408320426941,y:.6066038608551025,z:-.021204356104135513},{x:.45432573556900024,y:.6158540844917297,z:-.011054684408009052},{x:.4305151402950287,y:.5608053803443909,z:.0396830290555954},{x:.5310865640640259,y:.6157484650611877,z:-.03081176057457924},{x:.5114666223526001,y:.6329749226570129,z:-.00335998204536736},{x:.506435751914978,y:.8786543607711792,z:.012980876490473747},{x:.4480472207069397,y:.8640613555908203,z:.12569651007652283},{x:.5372058153152466,y:.7942581176757812,z:-.03168361634016037},{x:.5488379597663879,y:.8001630306243896,z:-.03280917927622795},{x:.5213388204574585,y:.8794381618499756,z:.011892606504261494},{x:.5242055654525757,y:.8789222240447998,z:.008370225317776203},{x:.4477175176143646,y:.6039950251579285,z:-.0050799972377717495},{x:.526964008808136,y:.7916748523712158,z:-.02968614175915718},{x:.4971255660057068,y:.6050706505775452,z:-.028175678104162216},{x:.4938119053840637,y:.5882453918457031,z:-.03210941329598427},{x:.4757143557071686,y:.5094879865646362,z:-.01300730835646391},{x:.43947282433509827,y:.5816648006439209,z:.01415177434682846},{x:.485664039850235,y:.5477864146232605,z:-.023685332387685776},{x:.43635931611061096,y:.6226438283920288,z:.013606148771941662},{x:.42910251021385193,y:.6102726459503174,z:.03926564007997513},{x:.5605402588844299,y:.8680099248886108,z:-.027318159118294716},{x:.5474816560745239,y:.8702861070632935,z:-.019686367362737656},{x:.5373021364212036,y:.8728838562965393,z:-.010484928265213966},{x:.540735125541687,y:.7979167103767395,z:-.029073253273963928},{x:.5228585004806519,y:.87913578748703,z:.009915109723806381},{x:.530497670173645,y:.8815253973007202,z:.0020524784922599792},{x:.5259912610054016,y:.8790552616119385,z:.007895970717072487},{x:.5433906316757202,y:.7882310748100281,z:-.05121905356645584},{x:.541388213634491,y:.8777219653129578,z:-.00466804439201951},{x:.5515822172164917,y:.8767023086547852,z:-.010475946590304375},{x:.5637003779411316,y:.877059817314148,z:-.015273625031113625},{x:.5640299320220947,y:.9263423085212708,z:-.00658724969252944},{x:.5642300248146057,y:.8993074893951416,z:-.017653480172157288},{x:.5637336373329163,y:.8910360932350159,z:-.01852807030081749},{x:.5637134313583374,y:.8837276697158813,z:-.01482592523097992},{x:.564205527305603,y:.8768964409828186,z:-.01331155002117157},{x:.5419867634773254,y:.8778373599052429,z:-.0037720394320786},{x:.5404468774795532,y:.880696177482605,z:-.005610354244709015},{x:.5392338633537292,y:.8845721483230591,z:-.007352025713771582},{x:.538469672203064,y:.8891173601150513,z:-.005154991988092661},{x:.5189250111579895,y:.8452741503715515,z:-.009755070321261883},{x:.4258975088596344,y:.7662280797958374,z:.1387351155281067},{x:.5725725293159485,y:.8041572570800781,z:-.04583907872438431},{x:.5342061519622803,y:.8785833120346069,z:.002659974154084921},{x:.5324031114578247,y:.8804071545600891,z:.0017832003068178892},{x:.5538818836212158,y:.8078407645225525,z:-.03254539892077446},{x:.5325431823730469,y:.8026832938194275,z:-.019140373915433884},{x:.5514076948165894,y:.8043903112411499,z:-.03313535451889038},{x:.5131856203079224,y:.7284771800041199,z:-.009399853646755219},{x:.49331504106521606,y:.7443980574607849,z:-.005225230939686298},{x:.5239617824554443,y:.7807451486587524,z:-.025881027802824974},{x:.4473606050014496,y:.5315827131271362,z:.011164786294102669},{x:.45718759298324585,y:.5604941248893738,z:-.005943301599472761},{x:.4670005738735199,y:.5909327268600464,z:-.019681761041283607},{x:.5311570167541504,y:.9076261520385742,z:.00389476353302598},{x:.5249923467636108,y:.5893563628196716,z:-.037981919944286346},{x:.5166932344436646,y:.5429551005363464,z:-.03319704160094261},{x:.5085030198097229,y:.49676206707954407,z:-.02691275253891945},{x:.4687720239162445,y:.6834565997123718,z:.008113506250083447},{x:.4426414966583252,y:.7069531679153442,z:.028577271848917007},{x:.5230373740196228,y:.6675713658332825,z:.001773772411979735},{x:.4481240212917328,y:.6527872085571289,z:.012414850294589996},{x:.5339856743812561,y:.7012367844581604,z:-.020220188423991203},{x:.5347223281860352,y:.7761190533638,z:-.05141595005989075},{x:.4315067231655121,y:.7211957573890686,z:.04381405934691429},{x:.45203351974487305,y:.7206180095672607,z:.017288070172071457},{x:.46892452239990234,y:.7265436053276062,z:.005602988880127668},{x:.49314674735069275,y:.7202282547950745,z:-.0006408205372281373},{x:.5104925632476807,y:.7091827392578125,z:-.00362918758764863},{x:.5232142210006714,y:.698553740978241,z:-.00787867046892643},{x:.5497883558273315,y:.6743605136871338,z:-.036349106580019},{x:.43658503890037537,y:.7627100348472595,z:.042555369436740875},{x:.4397648870944977,y:.6528646349906921,z:.017956094816327095},{x:.5653332471847534,y:.7992802858352661,z:-.06365057826042175},{x:.5285563468933105,y:.736810564994812,z:-.018836988136172295},{x:.4180678725242615,y:.6792560815811157,z:.12284679710865021},{x:.5328429937362671,y:.6865872144699097,z:-.010484723374247551},{x:.5230283141136169,y:.7809416055679321,z:-.011922398582100868},{x:.4551771283149719,y:.6650775074958801,z:.01774493046104908},{x:.5337203741073608,y:.7618928551673889,z:-.04697106033563614},{x:.43463975191116333,y:.8133478164672852,z:.1354849934577942},{x:.5225707292556763,y:.6605283617973328,z:.004980515688657761},{x:.5441933870315552,y:.7497199773788452,z:-.06091512367129326},{x:.4774007797241211,y:.9159183502197266,z:.059622734785079956},{x:.48068761825561523,y:.9364941716194153,z:.08404944837093353},{x:.4268292486667633,y:.7657528519630432,z:.09051097184419632},{x:.46051913499832153,y:.8880485892295837,z:.0738474428653717},{x:.4243420660495758,y:.6434382200241089,z:.06230505183339119},{x:.5342157483100891,y:.9835634231567383,z:.021662971004843712},{x:.5668109655380249,y:.8042187094688416,z:-.044937074184417725},{x:.5176341533660889,y:.7530587315559387,z:-.012967454269528389},{x:.430206298828125,y:.6835605502128601,z:.04612284153699875},{x:.4794231951236725,y:.6732114553451538,z:.003970044665038586},{x:.49073347449302673,y:.6722435355186462,z:.0008692514384165406},{x:.5294116139411926,y:.884677529335022,z:.004413890186697245},{x:.4430122375488281,y:.80235356092453,z:.04987282305955887},{x:.5603825449943542,y:1.0092442035675049,z:.026417359709739685},{x:.5186598300933838,y:.9828659892082214,z:.0513598807156086},{x:.5010536909103394,y:.9640932679176331,z:.06591596454381943},{x:.5524769425392151,y:.539441704750061,z:-.035816047340631485},{x:.5879997611045837,y:1.0091472864151,z:.02285068854689598},{x:.5016193985939026,y:.6684437990188599,z:.00028415941051207483},{x:.511952817440033,y:.6642197370529175,z:.0021144719794392586},{x:.5194343328475952,y:.6623469591140747,z:.004674181342124939},{x:.4321230351924896,y:.6496355533599854,z:.03124697133898735},{x:.508686363697052,y:.6479565501213074,z:-.00044765998609364033},{x:.4963986277580261,y:.6431032419204712,z:-.0032507688738405704},{x:.4845542013645172,y:.6430778503417969,z:-.002903624437749386},{x:.4733612537384033,y:.647506833076477,z:.00023347247042693198},{x:.4668654501438141,y:.653346598148346,z:.004762572236359119},{x:.41815051436424255,y:.633708119392395,z:.09809435904026031},{x:.47159942984580994,y:.6711485385894775,z:.007849935442209244},{x:.5734396576881409,y:.8256140351295471,z:-.03155219927430153},{x:.5306524038314819,y:.8337990641593933,z:-.018351426348090172},{x:.5371729135513306,y:.7910830974578857,z:-.037286680191755295},{x:.5549534559249878,y:.8275275826454163,z:-.030664825811982155},{x:.5597432255744934,y:.6418541669845581,z:-.03318847343325615},{x:.4958484172821045,y:.9429569244384766,z:.048340678215026855},{x:.5140507817268372,y:.9634028077125549,z:.03589847311377525},{x:.5587693452835083,y:.9951097369194031,z:.00908728688955307},{x:.46411189436912537,y:.9051855206489563,z:.10601935535669327},{x:.5181609392166138,y:.6554316878318787,z:.002546071307733655},{x:.5436590909957886,y:.7085841298103333,z:-.03844436630606651},{x:.5872187614440918,y:.9960382580757141,z:.0063423276878893375},{x:.5379653573036194,y:.9989125728607178,z:.03636329993605614},{x:.4350326955318451,y:.8088565468788147,z:.09147704392671585},{x:.5523084998130798,y:.8773422837257385,z:-.009068487212061882},{x:.5510149598121643,y:.8816931843757629,z:-.011043853126466274},{x:.5503793954849243,y:.88776695728302,z:-.01348799467086792},{x:.5501549243927002,y:.8954370617866516,z:-.012142189778387547},{x:.546072781085968,y:.9192524552345276,z:-.003157563041895628},{x:.5314661860466003,y:.8771666884422302,z:.0005075141089037061},{x:.5293324589729309,y:.8762547969818115,z:.00039177737198770046},{x:.5275698900222778,y:.8750609755516052,z:47732755774632096e-21},{x:.5104271173477173,y:.8607332110404968,z:.0012934643309563398},{x:.45938700437545776,y:.8134918212890625,z:.023569690063595772},{x:.5418947339057922,y:.6864100694656372,z:-.027333909645676613},{x:.531914234161377,y:.6456130743026733,z:-.005434140563011169},{x:.523697018623352,y:.647885262966156,z:-.0002466466394253075},{x:.5338191390037537,y:.8783687353134155,z:.002268768846988678},{x:.46226605772972107,y:.8610277771949768,z:.04718952998518944},{x:.5434442758560181,y:.6456181406974792,z:-.02327350154519081},{x:.5399754643440247,y:.940219521522522,z:.005075343884527683},{x:.5661457777023315,y:.71457839012146,z:-.06242101639509201},{x:.5523148775100708,y:.6974870562553406,z:-.04863070324063301},{x:.5639959573745728,y:.6923378109931946,z:-.05180761218070984},{x:.5367592573165894,y:.7423217296600342,z:-.03623027727007866},{x:.5853689908981323,y:.9752064943313599,z:-.002361974213272333},{x:.5835235118865967,y:.9493685960769653,z:-.003941743168979883},{x:.5615018606185913,y:.949194610118866,z:-.0015953965485095978},{x:.5068561434745789,y:.9048219323158264,z:.01862684078514576},{x:.5134067535400391,y:.7971825003623962,z:-.008485661819577217},{x:.5223897099494934,y:.925589919090271,z:.01249657291918993},{x:.48500555753707886,y:.7959478497505188,z:-.0032065745908766985},{x:.5037734508514404,y:.8184596300125122,z:-.004932103678584099},{x:.4766361117362976,y:.828806459903717,z:.01027688942849636},{x:.5589827299118042,y:.974656343460083,z:.0009666886180639267},{x:.5294582843780518,y:.7541216611862183,z:-.025603046640753746},{x:.4973002076148987,y:.9208990931510925,z:.031931452453136444},{x:.5163551568984985,y:.9432790875434875,z:.024321340024471283},{x:.49399662017822266,y:.8814862370491028,z:.018687399104237556},{x:.44948166608810425,y:.836137592792511,z:.05702034756541252},{x:.47898444533348083,y:.8836610913276672,z:.03150695189833641},{x:.4454479217529297,y:.8499438166618347,z:.08868525922298431},{x:.49572959542274475,y:.8452823758125305,z:.0036111653316766024},{x:.5362502336502075,y:.7222585678100586,z:-.027912352234125137},{x:.5393770337104797,y:.7850722074508667,z:-.05415399745106697},{x:.531399667263031,y:.7898418307304382,z:-.03883346915245056},{x:.5451627373695374,y:.7717036604881287,z:-.06480253487825394},{x:.5206395983695984,y:.6287745833396912,z:-.010521138086915016},{x:.4974782466888428,y:.6191938519477844,z:-.014098240062594414},{x:.4774145185947418,y:.6193130612373352,z:-.013643337413668633},{x:.4616098403930664,y:.6259890198707581,z:-.008448202162981033},{x:.4516478478908539,y:.6368461847305298,z:9050309745362028e-20},{x:.4485096037387848,y:.6719120740890503,z:.022984720766544342},{x:.42177659273147583,y:.7240667343139648,z:.08511673659086227},{x:.4616215229034424,y:.6988231539726257,z:.014238474890589714},{x:.4755798876285553,y:.7034608721733093,z:.00625590980052948},{x:.4924992024898529,y:.7005885243415833,z:.0009391739731654525},{x:.5082254409790039,y:.693384051322937,z:-.0009464038303121924},{x:.5203112959861755,y:.6849707961082458,z:-.0022114769089967012},{x:.52867591381073,y:.6779075860977173,z:-.002962538506835699},{x:.4213953912258148,y:.7219811677932739,z:.1350894570350647},{x:.5320829749107361,y:.794858992099762,z:-.03181503340601921},{x:.5452795028686523,y:.7286570072174072,z:-.04771539941430092},{x:.5496407747268677,y:.7866933345794678,z:-.06452003121376038},{x:.557040274143219,y:.7962084412574768,z:-.05837344378232956},{x:.549176812171936,y:.7895247936248779,z:-.057761140167713165},{x:.5362890362739563,y:.8005836606025696,z:-.026903774589300156},{x:.560200035572052,y:.7983731031417847,z:-.06172555685043335},{x:.5616944432258606,y:.8022753596305847,z:-.045200999826192856},{x:.5273328423500061,y:.6611284017562866,z:.0029021520167589188},{x:.534850537776947,y:.6660012006759644,z:-.005215510260313749},{x:.5394860506057739,y:.6701375246047974,z:-.014931917190551758},{x:.4634307324886322,y:.658291757106781,z:.009295716881752014},{x:.4538393020629883,y:.6519932150840759,z:.00930330716073513},{x:.5776031613349915,y:.7159298658370972,z:-.057365912944078445},{x:.6504855155944824,y:.6461779475212097,z:.014184834435582161},{x:.5860154032707214,y:.7962266206741333,z:-.04522843658924103},{x:.6842049360275269,y:.5631637573242188,z:.07207967340946198},{x:.6152560710906982,y:.6674962639808655,z:.0007529259892180562},{x:.6280948519706726,y:.6684326529502869,z:.0016892586136236787},{x:.6408625245094299,y:.6663892269134521,z:.005331226624548435},{x:.6557814478874207,y:.6534678936004639,z:.01646413467824459},{x:.6035663485527039,y:.6639701724052429,z:.0013799630105495453},{x:.6329053044319153,y:.608010470867157,z:-.006195899099111557},{x:.6167260408401489,y:.6117533445358276,z:-.006319951266050339},{x:.6471013426780701,y:.6112449765205383,z:-.0017843559617176652},{x:.6560901999473572,y:.6185776591300964,z:.004047257360070944},{x:.6666946411132812,y:.6651176810264587,z:.023647578433156013},{x:.6311345100402832,y:.9495396018028259,z:.014004078693687916},{x:.6544655561447144,y:.6397901773452759,z:.01809609681367874},{x:.6965808868408203,y:.6482675075531006,z:.08304904401302338},{x:.679817259311676,y:.650188148021698,z:.03632688894867897},{x:.6336516737937927,y:.7541458010673523,z:-.007742783520370722},{x:.5921701192855835,y:.8567668199539185,z:-.029399123042821884},{x:.591663658618927,y:.870215654373169,z:-.02103729173541069},{x:.6068367958068848,y:.8584195375442505,z:-.020668085664510727},{x:.6176617741584778,y:.860965371131897,z:-.009790095500648022},{x:.6040634512901306,y:.8686612844467163,z:-.015289564616978168},{x:.6143736839294434,y:.8671170473098755,z:-.005712216719985008},{x:.6373105049133301,y:.8815656900405884,z:.012672550976276398},{x:.5832505822181702,y:.7866312861442566,z:-.07051534950733185},{x:.5836675763130188,y:.7658692598342896,z:-.07566110789775848},{x:.6709531545639038,y:.604898989200592,z:.005951565690338612},{x:.6029891967773438,y:.705652117729187,z:-.013388276100158691},{x:.6131622195243835,y:.7728396058082581,z:-.036248479038476944},{x:.6123163104057312,y:.7612020373344421,z:-.03264721855521202},{x:.6696187853813171,y:.744706928730011,z:.009673702530562878},{x:.5803102254867554,y:.7385968565940857,z:-.0689152330160141},{x:.6404349207878113,y:.5877999663352966,z:-.01929756999015808},{x:.6588467955589294,y:.5929454565048218,z:-.008487257175147533},{x:.6720337867736816,y:.530631422996521,z:.043437421321868896},{x:.584305465221405,y:.6099005341529846,z:-.030301367864012718},{x:.6034283638000488,y:.6217452883720398,z:-.001970183802768588},{x:.6460927724838257,y:.8608663082122803,z:.015541625209152699},{x:.6957815289497375,y:.8326103091239929,z:.13015234470367432},{x:.6043362617492676,y:.7861682772636414,z:-.030476901680231094},{x:.594293475151062,y:.7942103147506714,z:-.032218821346759796},{x:.6324057579040527,y:.8665139675140381,z:.014255806803703308},{x:.6296147704124451,y:.8667733669281006,z:.010388285852968693},{x:.663644552230835,y:.5798642635345459,z:-.0022301070857793093},{x:.6140630841255188,y:.7809288501739502,z:-.02835679054260254},{x:.615908145904541,y:.5921698212623596,z:-.026804860681295395},{x:.617181122303009,y:.5748661756515503,z:-.03060605563223362},{x:.6222207546234131,y:.49137672781944275,z:-.011151673272252083},{x:.6669357419013977,y:.5541607141494751,z:.017466170713305473},{x:.6182981729507446,y:.5320425629615784,z:-.021793590858578682},{x:.6760554313659668,y:.595052182674408,z:.017115700989961624},{x:.6801463961601257,y:.5800720453262329,z:.043127160519361496},{x:.5922210812568665,y:.8644017577171326,z:-.02662893570959568},{x:.6054555177688599,y:.8637874722480774,z:-.018363753333687782},{x:.6161889433860779,y:.8641164898872375,z:-.008808949030935764},{x:.6017249822616577,y:.7901403307914734,z:-.028126630932092667},{x:.631446123123169,y:.8664817810058594,z:.012112865224480629},{x:.6249198913574219,y:.8716511130332947,z:.003882825840264559},{x:.6281915903091431,y:.867301881313324,z:.009891441091895103},{x:.5986843109130859,y:.7813931703567505,z:-.050227612257003784},{x:.6126407384872437,y:.869275689125061,z:-.0031255714129656553},{x:.6027271151542664,y:.8711842894554138,z:-.009324162267148495},{x:.59088134765625,y:.8742044568061829,z:-.014608660712838173},{x:.5984604358673096,y:.9216185212135315,z:-.005981989670544863},{x:.5950398445129395,y:.8964707255363464,z:-.01703473925590515},{x:.5941568613052368,y:.8882410526275635,z:-.017784785479307175},{x:.5928806662559509,y:.8803883194923401,z:-.014153128489851952},{x:.5909661054611206,y:.8748103976249695,z:-.012609979137778282},{x:.6128016710281372,y:.8702545762062073,z:-.0022550546564161777},{x:.6150846481323242,y:.8726804256439209,z:-.00414019962772727},{x:.6173093914985657,y:.8770190477371216,z:-.005970994010567665},{x:.619335412979126,y:.8814800977706909,z:-.0036864024586975574},{x:.6292637586593628,y:.8314558267593384,z:-.007714875973761082},{x:.702275276184082,y:.7320667505264282,z:.1433621346950531},{x:.6204835176467896,y:.8689177632331848,z:.0044869170524179935},{x:.6223508715629578,y:.8704851269721985,z:.00352082890458405},{x:.590448260307312,y:.8029727935791016,z:-.03200828656554222},{x:.6097423434257507,y:.7933741211891174,z:-.018042555078864098},{x:.59229576587677,y:.7993767261505127,z:-.032564569264650345},{x:.6171364188194275,y:.7153720259666443,z:-.007672437466681004},{x:.6389747858047485,y:.726390540599823,z:-.002999067772179842},{x:.6151940226554871,y:.769412100315094,z:-.024427521973848343},{x:.6526776552200317,y:.505868136882782,z:.01412637997418642},{x:.6475822329521179,y:.5375454425811768,z:-.0033899128902703524},{x:.6433356404304504,y:.5714520215988159,z:-.017428796738386154},{x:.626949667930603,y:.8962116837501526,z:.005602736957371235},{x:.5868416428565979,y:.5829002261161804,z:-.03727729618549347},{x:.5877229571342468,y:.5345035791397095,z:-.032396964728832245},{x:.5887066125869751,y:.48655083775520325,z:-.025856535881757736},{x:.6507197618484497,y:.6612282991409302,z:.011114613153040409},{x:.6803066730499268,y:.677992045879364,z:.032125361263751984},{x:.5963194370269775,y:.6598632335662842,z:.002976928371936083},{x:.667536199092865,y:.6274255514144897,z:.015618261881172657},{x:.5930740833282471,y:.6940041780471802,z:-.019217798486351967},{x:.6053346395492554,y:.7676517963409424,z:-.050308309495449066},{x:.6934473514556885,y:.6884298920631409,z:.04794462397694588},{x:.6738007664680481,y:.6934011578559875,z:.020697161555290222},{x:.6588084697723389,y:.7033141851425171,z:.008462334051728249},{x:.6346072554588318,y:.7029502391815186,z:.001542167621664703},{x:.6157816648483276,y:.6966525912284851,z:-.002009218093007803},{x:.6015574336051941,y:.688928484916687,z:-.006588225718587637},{x:.5746836066246033,y:.6711069345474243,z:-.03597589209675789},{x:.6947521567344666,y:.7309479117393494,z:.046707939356565475},{x:.6759101152420044,y:.6249120831489563,z:.021654341369867325},{x:.5794773101806641,y:.7971615195274353,z:-.06339326500892639},{x:.6041849851608276,y:.727514922618866,z:-.017512541264295578},{x:.6968844532966614,y:.6440950036048889,z:.12727996706962585},{x:.5910853147506714,y:.679325520992279,z:-.009497715160250664},{x:.6157375574111938,y:.7695677280426025,z:-.010624290443956852},{x:.6606494784355164,y:.6410489678382874,z:.0208158977329731},{x:.6040687561035156,y:.7531470656394958,z:-.045887019485235214},{x:.7012156248092651,y:.780247151851654,z:.14028730988502502},{x:.595149576663971,y:.6527782678604126,z:.006308757700026035},{x:.5925500392913818,y:.7436665892601013,z:-.060151755809783936},{x:.6780198812484741,y:.8905693888664246,z:.0626060739159584},{x:.676746666431427,y:.9113880395889282,z:.08726003766059875},{x:.7030686140060425,y:.7312687635421753,z:.09529774636030197},{x:.688987135887146,y:.8588417172431946,z:.07752864807844162},{x:.6883691549301147,y:.6109960675239563,z:.06669612973928452},{x:.6358906030654907,y:.9702065587043762,z:.023120900616049767},{x:.5781539678573608,y:.8023634552955627,z:-.044763918966054916},{x:.6170316934585571,y:.7408350706100464,z:-.011375460773706436},{x:.688542366027832,y:.6516284346580505,z:.050206027925014496},{x:.6385149359703064,y:.6540714502334595,z:.006462941411882639},{x:.6279382109642029,y:.6563615798950195,z:.003062846139073372},{x:.6268895268440247,y:.8736732006072998,z:.00627936702221632},{x:.6944946050643921,y:.7709181308746338,z:.053824134171009064},{x:.614617109298706,y:1.0022112131118774,z:.02719894051551819},{x:.6493719220161438,y:.9665167927742004,z:.053563784807920456},{x:.6624587178230286,y:.943530797958374,z:.068605437874794},{x:.6162528991699219,y:.6558693051338196,z:.002187855076044798},{x:.6058168411254883,y:.654328465461731,z:.0036193584091961384},{x:.5987918972969055,y:.6536934971809387,z:.006134530063718557},{x:.6831037402153015,y:.6195642948150635,z:.03511790186166763},{x:.6062582731246948,y:.6356398463249207,z:.001280312892049551},{x:.6174948811531067,y:.62776118516922,z:-.0013642468256875873},{x:.6297246217727661,y:.6253792643547058,z:-.0007034156005829573},{x:.6407091617584229,y:.627578616142273,z:.0028144705574959517},{x:.6479622721672058,y:.6322650909423828,z:.00750273372977972},{x:.6915091276168823,y:.5990704298019409,z:.10270945727825165},{x:.6457163095474243,y:.6504453420639038,z:.010696077719330788},{x:.6164222955703735,y:.8231936097145081,z:-.016772059723734856},{x:.6042401194572449,y:.7830976843833923,z:-.03630910441279411},{x:.5922216773033142,y:.8228387236595154,z:-.029992375522851944},{x:.6646111011505127,y:.92097008228302,z:.050967294722795486},{x:.651232898235321,y:.9460107088088989,z:.038000158965587616},{x:.6140977144241333,y:.9882472157478333,z:.009882091544568539},{x:.6870781183242798,y:.8768675327301025,z:.10980932414531708},{x:.5986856818199158,y:.6456438899040222,z:.003999010659754276},{x:.585981547832489,y:.7034481763839722,z:-.0377722829580307},{x:.6342031359672546,y:.9867448806762695,z:.03786521404981613},{x:.7013950943946838,y:.776049017906189,z:.09598205983638763},{x:.6030206680297852,y:.8719133138656616,z:-.007931148633360863},{x:.6050592064857483,y:.8767156004905701,z:-.009791925549507141},{x:.6073468923568726,y:.8831382393836975,z:-.012361008673906326},{x:.6087977290153503,y:.890143632888794,z:-.01098148338496685},{x:.6147705316543579,y:.9110084772109985,z:-.0018823575228452682},{x:.622577965259552,y:.8670604825019836,z:.002609190298244357},{x:.6241236329078674,y:.8651344180107117,z:.0025534380692988634},{x:.6257084608078003,y:.8638408184051514,z:.0023300074972212315},{x:.639931321144104,y:.8449671268463135,z:.0038123116828501225},{x:.6810906529426575,y:.7856625318527222,z:.02717764675617218},{x:.583532452583313,y:.6811994910240173,z:-.026588857173919678},{x:.5855660438537598,y:.6393819451332092,z:-.004512844607234001},{x:.5932201743125916,y:.6398029327392578,z:.0008020466193556786},{x:.6200879812240601,y:.8683351874351501,z:.00417016725987196},{x:.6842559576034546,y:.8330534100532532,z:.050836317241191864},{x:.5754412412643433,y:.6418221592903137,z:-.022838059812784195},{x:.6232790350914001,y:.9295297265052795,z:.006339520215988159},{x:.5764067769050598,y:.694546639919281,z:-.04825803264975548},{x:.59778892993927,y:.7343927621841431,z:-.035004377365112305},{x:.6042810678482056,y:.9441440105438232,z:-.0010970570147037506},{x:.6496372222900391,y:.8869078159332275,z:.021036235615611076},{x:.6274012327194214,y:.7830310463905334,z:-.006658440921455622},{x:.637792706489563,y:.9104999899864197,z:.014290250837802887},{x:.6549934148788452,y:.7748609185218811,z:-.0006672973395325243},{x:.6404005289077759,y:.801220715045929,z:-.0026642554439604282},{x:.6671456694602966,y:.8045546412467957,z:.013180811889469624},{x:.6107483506202698,y:.9680658578872681,z:.001778992242179811},{x:.6060343980789185,y:.744587242603302,z:-.024382334202528},{x:.6602751612663269,y:.8998945355415344,z:.0344940721988678},{x:.6463775038719177,y:.9262562394142151,z:.02617623284459114},{x:.6579852104187012,y:.8602304458618164,z:.021586716175079346},{x:.6926165223121643,y:.8053340315818787,z:.061075080186128616},{x:.6724731922149658,y:.8594399690628052,z:.03457934781908989},{x:.6975721716880798,y:.8183245062828064,z:.09300774335861206},{x:.6512877941131592,y:.8258221745491028,z:.006324059329926968},{x:.594887375831604,y:.7148372530937195,z:-.026898479089140892},{x:.6017440557479858,y:.7773507833480835,z:-.05312420800328255},{x:.6096571683883667,y:.7806998491287231,z:-.037646256387233734},{x:.5952993035316467,y:.7654367685317993,z:-.06398405134677887},{x:.5950021147727966,y:.6201304793357849,z:-.009297547861933708},{x:.6165438890457153,y:.6052900552749634,z:-.012455573305487633},{x:.6362661719322205,y:.6015968918800354,z:-.011649220250546932},{x:.6522727608680725,y:.6046400666236877,z:-.005903332494199276},{x:.6625409722328186,y:.6128141283988953,z:.0030042496509850025},{x:.6688099503517151,y:.6457712054252625,z:.026322703808546066},{x:.7013440728187561,y:.6893666386604309,z:.08984331786632538},{x:.6608623266220093,y:.6749406456947327,z:.0172116681933403},{x:.6482325196266174,y:.6823726296424866,z:.008881398476660252},{x:.6313265562057495,y:.6842025518417358,z:.0031308617908507586},{x:.6147016286849976,y:.6809731721878052,z:.0007630771724507213},{x:.6018834114074707,y:.6755372285842896,z:-.0008834321051836014},{x:.5925027132034302,y:.670681357383728,z:-.001968748401850462},{x:.700127363204956,y:.6871103644371033,z:.13980500400066376},{x:.6095665693283081,y:.7853189706802368,z:-.03074747882783413},{x:.5880423784255981,y:.7229287028312683,z:-.04691500961780548},{x:.5930182337760925,y:.7811514139175415,z:-.06398335844278336},{x:.5867722034454346,y:.7922660112380981,z:-.05794971063733101},{x:.5933279991149902,y:.7842848896980286,z:-.05714067071676254},{x:.6063535809516907,y:.7920218706130981,z:-.02590685710310936},{x:.5839452743530273,y:.794978141784668,z:-.0615212507545948},{x:.5828126072883606,y:.8000800013542175,z:-.0449722595512867},{x:.5909603834152222,y:.6541213393211365,z:.003991890233010054},{x:.5852181911468506,y:.6602938771247864,z:-.004428438376635313},{x:.5825737714767456,y:.6651063561439514,z:-.014345290139317513},{x:.6517343521118164,y:.6362385153770447,z:.012151890434324741},{x:.6615052819252014,y:.6281577944755554,z:.0123682152479887},{x:.4856873154640198,y:.6568945646286011,z:.000720038078725338},{x:.49988406896591187,y:.6547410488128662,z:.0006949726957827806},{x:.48438939452171326,y:.6392973065376282,z:.000705525919329375},{x:.47143134474754333,y:.6589511632919312,z:.0006980331381782889},{x:.48704618215560913,y:.6752797961235046,z:.0006921177846379578},{x:.6243702173233032,y:.640461802482605,z:-6592126737814397e-20},{x:.6390967965126038,y:.6385173797607422,z:-.00016105435497593135},{x:.6230536699295044,y:.6224825382232666,z:-.00016136496560648084},{x:.6095397472381592,y:.641917884349823,z:-.0001803556369850412},{x:.6250996589660645,y:.6586247682571411,z:-.0001785515050869435}]],faceBlendshapes:[{categories:[{index:0,score:5187174338061595e-21,categoryName:\"_neutral\",displayName:\"\"},{index:1,score:.24521504342556,categoryName:\"browDownLeft\",displayName:\"\"},{index:2,score:.1987743377685547,categoryName:\"browDownRight\",displayName:\"\"},{index:3,score:.013400448486208916,categoryName:\"browInnerUp\",displayName:\"\"},{index:4,score:.012361560948193073,categoryName:\"browOuterUpLeft\",displayName:\"\"},{index:5,score:.019305096939206123,categoryName:\"browOuterUpRight\",displayName:\"\"},{index:6,score:28426356948330067e-21,categoryName:\"cheekPuff\",displayName:\"\"},{index:7,score:3.4500112633395474e-7,categoryName:\"cheekSquintLeft\",displayName:\"\"},{index:8,score:4.83789051486383e-7,categoryName:\"cheekSquintRight\",displayName:\"\"},{index:9,score:.07650448381900787,categoryName:\"eyeBlinkLeft\",displayName:\"\"},{index:10,score:.05070012807846069,categoryName:\"eyeBlinkRight\",displayName:\"\"},{index:11,score:.13978900015354156,categoryName:\"eyeLookDownLeft\",displayName:\"\"},{index:12,score:.14198613166809082,categoryName:\"eyeLookDownRight\",displayName:\"\"},{index:13,score:.2177766114473343,categoryName:\"eyeLookInLeft\",displayName:\"\"},{index:14,score:.014739357866346836,categoryName:\"eyeLookInRight\",displayName:\"\"},{index:15,score:.02361512929201126,categoryName:\"eyeLookOutLeft\",displayName:\"\"},{index:16,score:.19679604470729828,categoryName:\"eyeLookOutRight\",displayName:\"\"},{index:17,score:.04874616861343384,categoryName:\"eyeLookUpLeft\",displayName:\"\"},{index:18,score:.049392376095056534,categoryName:\"eyeLookUpRight\",displayName:\"\"},{index:19,score:.34944331645965576,categoryName:\"eyeSquintLeft\",displayName:\"\"},{index:20,score:.2939716875553131,categoryName:\"eyeSquintRight\",displayName:\"\"},{index:21,score:.005955042317509651,categoryName:\"eyeWideLeft\",displayName:\"\"},{index:22,score:.006776117719709873,categoryName:\"eyeWideRight\",displayName:\"\"},{index:23,score:16942436559475027e-21,categoryName:\"jawForward\",displayName:\"\"},{index:24,score:.0045165494084358215,categoryName:\"jawLeft\",displayName:\"\"},{index:25,score:.07803940027952194,categoryName:\"jawOpen\",displayName:\"\"},{index:26,score:2090057751047425e-20,categoryName:\"jawRight\",displayName:\"\"},{index:27,score:.06032035872340202,categoryName:\"mouthClose\",displayName:\"\"},{index:28,score:.00228882092051208,categoryName:\"mouthDimpleLeft\",displayName:\"\"},{index:29,score:.00781762320548296,categoryName:\"mouthDimpleRight\",displayName:\"\"},{index:30,score:.0017093931091949344,categoryName:\"mouthFrownLeft\",displayName:\"\"},{index:31,score:.0019319106359034777,categoryName:\"mouthFrownRight\",displayName:\"\"},{index:32,score:8485237776767462e-20,categoryName:\"mouthFunnel\",displayName:\"\"},{index:33,score:.0009051355300471187,categoryName:\"mouthLeft\",displayName:\"\"},{index:34,score:.0003630454302765429,categoryName:\"mouthLowerDownLeft\",displayName:\"\"},{index:35,score:.00017601238505449146,categoryName:\"mouthLowerDownRight\",displayName:\"\"},{index:36,score:.12865161895751953,categoryName:\"mouthPressLeft\",displayName:\"\"},{index:37,score:.20137207210063934,categoryName:\"mouthPressRight\",displayName:\"\"},{index:38,score:.0022203284315764904,categoryName:\"mouthPucker\",displayName:\"\"},{index:39,score:.0009096377179957926,categoryName:\"mouthRight\",displayName:\"\"},{index:40,score:.34189721941947937,categoryName:\"mouthRollLower\",displayName:\"\"},{index:41,score:.11409689486026764,categoryName:\"mouthRollUpper\",displayName:\"\"},{index:42,score:.17172536253929138,categoryName:\"mouthShrugLower\",displayName:\"\"},{index:43,score:.004038424696773291,categoryName:\"mouthShrugUpper\",displayName:\"\"},{index:44,score:.00023205230536404997,categoryName:\"mouthSmileLeft\",displayName:\"\"},{index:45,score:.00019313619122840464,categoryName:\"mouthSmileRight\",displayName:\"\"},{index:46,score:.0018571305554360151,categoryName:\"mouthStretchLeft\",displayName:\"\"},{index:47,score:.0023813238367438316,categoryName:\"mouthStretchRight\",displayName:\"\"},{index:48,score:24323100660694763e-21,categoryName:\"mouthUpperUpLeft\",displayName:\"\"},{index:49,score:3161552012898028e-20,categoryName:\"mouthUpperUpRight\",displayName:\"\"},{index:50,score:1.08198406678639e-7,categoryName:\"noseSneerLeft\",displayName:\"\"},{index:51,score:12652527630052646e-22,categoryName:\"noseSneerRight\",displayName:\"\"}],headIndex:-1,headName:\"\"}],facialTransformationMatrixes:[{rows:4,columns:4,data:[.9947517514228821,.10230544209480286,.0013679931871592999,0,-.10230997204780579,.9947447776794434,.003816320328041911,0,-.000970348424743861,-.0039362297393381596,.9999914169311523,0,2.8888821601867676,-7.808934211730957,-30.52109146118164,1]}]}},Et=t.createContext({}),St={basePath:\"https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm\",options:{baseOptions:{modelAssetPath:\"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task\",delegate:\"GPU\"},runningMode:\"VIDEO\",outputFaceBlendshapes:!0,outputFacialTransformationMatrixes:!0}};function Tt(){return t.useContext(Et)}function Ct(e,t){return e.clone().add(t).multiplyScalar(.5)}function Pt(e,t,r){const n=e.localToWorld(t);return r.worldToLocal(n)}const Rt=t.createContext({}),Dt=t.forwardRef((({camera:e,autostart:r=!0,webcam:n=!0,webcamVideoTextureSrc:o,manualUpdate:i=!1,manualDetect:l=!1,onVideoFrame:c,smoothTime:u=.25,offset:d=!0,offsetScalar:m=80,eyes:f=!1,eyesAsOrigin:p=!0,depth:h=.15,debug:x=!1,facemesh:y,makeDefault:v},g)=>{var z,w;const b=a.useThree((e=>e.scene)),M=a.useThree((e=>e.camera)),E=a.useThree((e=>e.set)),S=a.useThree((e=>e.get)),T=e||M,R=t.useRef(null),F=t.useRef(null),[k]=t.useState((()=>new D.Object3D)),[_]=t.useState((()=>new D.Vector3)),[A]=t.useState((()=>new D.Vector3)),[L]=t.useState((()=>new D.Vector3)),[B]=t.useState((()=>new D.Vector3)),U=t.useCallback((()=>{k.parent=T.parent;const e=F.current;if(e){const{outerRef:t,eyeRightRef:r,eyeLeftRef:n}=e;if(r.current&&n.current){const{irisDirRef:e}=r.current,{irisDirRef:a}=n.current;e.current&&a.current&&t.current&&(_.copy(Pt(e.current,new D.Vector3(0,0,0),t.current)),A.copy(Pt(a.current,new D.Vector3(0,0,0),t.current)),k.position.copy(Pt(t.current,Ct(_,A),T.parent||b)),L.copy(Pt(e.current,new D.Vector3(0,0,1),t.current)),B.copy(Pt(a.current,new D.Vector3(0,0,1),t.current)),k.lookAt(t.current.localToWorld(Ct(L,B))))}else t.current&&(k.position.copy(Pt(t.current,new D.Vector3(0,0,0),T.parent||b)),k.lookAt(t.current.localToWorld(new D.Vector3(0,0,1))))}return k}),[T,A,B,_,L,b,k]),[I]=t.useState((()=>new D.Object3D)),V=t.useCallback((function(e,t){if(T){var r;if(null!==(r=t)&&void 0!==r||(t=U()),u>0){const r=1e-9;s.easing.damp3(I.position,t.position,u,e,void 0,void 0,r),s.easing.dampE(I.rotation,t.rotation,u,e,void 0,void 0,r)}else I.position.copy(t.position),I.rotation.copy(t.rotation);T.position.copy(I.position),T.rotation.copy(I.rotation)}}),[T,U,u,I.position,I.rotation]),[O,N]=t.useState(),j=Tt(),W=t.useCallback(((e,t)=>{const r=null==j?void 0:j.detectForVideo(e,t);N(r)}),[j]);a.useFrame(((e,t)=>{i||V(t)}));const G=t.useMemo((()=>Object.assign(Object.create(D.EventDispatcher.prototype),{detect:W,computeTarget:U,update:V,facemeshApiRef:F,webcamApiRef:R,play:()=>{var e;null==(e=R.current)||null==(e=e.videoTextureApiRef.current)||e.texture.source.data.play()},pause:()=>{var e;null==(e=R.current)||null==(e=e.videoTextureApiRef.current)||e.texture.source.data.pause()}})),[W,U,V]);t.useImperativeHandle(g,(()=>G),[G]),t.useEffect((()=>{const e=e=>{l||W(e.texture.source.data,e.time),c&&c(e)};return G.addEventListener(\"videoFrame\",e),()=>{G.removeEventListener(\"videoFrame\",e)}}),[G,W,j,l,c]),t.useEffect((()=>{if(v){const e=S().controls;return E({controls:G}),()=>E({controls:e})}}),[v,G,S,E]);const H=null==O?void 0:O.faceLandmarks[0],$=null==O||null==(z=O.facialTransformationMatrixes)?void 0:z[0],q=null==O||null==(w=O.faceBlendshapes)?void 0:w[0];return P.createElement(Rt.Provider,{value:G},n&&P.createElement(t.Suspense,{fallback:null},P.createElement(kt,{ref:R,autostart:r,videoTextureSrc:o})),P.createElement(zt,C.default({ref:F},y,{points:H,depth:h,facialTransformationMatrix:$,faceBlendshapes:q,eyes:f,eyesAsOrigin:p,offset:d,offsetScalar:m,debug:x,\"rotation-z\":Math.PI,visible:x}),P.createElement(\"meshBasicMaterial\",{side:D.DoubleSide})))})),Ft=()=>t.useContext(Rt),kt=t.forwardRef((({videoTextureSrc:e,autostart:r=!0},n)=>{const a=t.useRef(null),o=Ft(),i=f.suspend((async()=>e?Promise.resolve(null):await navigator.mediaDevices.getUserMedia({audio:!1,video:{facingMode:\"user\"}})),[e]);t.useEffect((()=>(o.dispatchEvent({type:\"stream\",stream:i}),()=>{null==i||i.getTracks().forEach((e=>e.stop())),f.clear([e])})),[i,o,e]);const s=t.useMemo((()=>({videoTextureApiRef:a})),[]);return t.useImperativeHandle(n,(()=>s),[s]),P.createElement(t.Suspense,{fallback:null},P.createElement(_t,{ref:a,src:e||i,start:r}))})),_t=t.forwardRef((({src:e,start:r},n)=>{const a=yt(e,{start:r}),o=a.source.data,i=Ft(),s=t.useCallback((e=>{i.dispatchEvent({type:\"videoFrame\",texture:a,time:e})}),[a,i]);At(o,s);const l=t.useMemo((()=>({texture:a})),[a]);return t.useImperativeHandle(n,(()=>l),[l]),P.createElement(P.Fragment,null)})),At=(e,r)=>{t.useEffect((()=>{if(!e||!e.requestVideoFrameCallback)return;let t;return e.requestVideoFrameCallback((function n(...a){r(...a),t=e.requestVideoFrameCallback(n)})),()=>e.cancelVideoFrameCallback(t)}),[e,r])},Lt=P.createContext(null);function Bt(){return P.useContext(Lt)}function Ut({points:e=50}){const{path:t}=Bt(),[r,n]=P.useState([]),[a]=P.useState((()=>new D.MeshBasicMaterial({color:\"black\"}))),[o]=P.useState((()=>new D.SphereGeometry(.025,16,16))),i=P.useRef([]);return P.useEffect((()=>{t.curves!==i.current&&(n(t.getPoints(e)),i.current=t.curves)})),P.createElement(P.Fragment,null,r.map(((e,t)=>P.createElement(\"mesh\",{key:t,material:a,geometry:o,position:[e.x,e.y,e.z]}))))}const It=P.forwardRef((({children:e,curves:t=[],object:r,debug:n=!1,smooth:o=!1,focus:i,offset:l,eps:c=1e-5,damping:u=.1,focusDamping:d=.1,maxSpeed:m=1/0,...f},p)=>{const{camera:h}=a.useThree(),x=P.useRef(),[y]=P.useState((()=>new D.CurvePath)),v=P.useRef(null!=l?l:0),g=P.useMemo((()=>({focus:i,object:(null==r?void 0:r.current)instanceof D.Object3D?r:{current:h},path:y,current:v.current,offset:v.current,point:new D.Vector3,tangent:new D.Vector3,next:new D.Vector3})),[i,r]);P.useLayoutEffect((()=>{var e;y.curves=[];const r=t.length>0?t:null==(e=x.current)?void 0:e.__r3f.objects;for(var n=0;n<r.length;n++)y.add(r[n]);if(o){const e=y.getPoints(\"number\"==typeof o?o:1),t=new D.CatmullRomCurve3(e);y.curves=[t]}y.updateArcLengths()})),P.useImperativeHandle(p,(()=>x.current),[]),P.useLayoutEffect((()=>{v.current=s.misc.repeat(v.current,1)}),[l]);let z=0;const[w]=P.useState((()=>new D.Vector3));return a.useFrame(((e,t)=>{if(z=g.offset,s.easing.damp(v,\"current\",void 0!==l?l:g.current,u,t,m,void 0,c),g.offset=s.misc.repeat(v.current,1),y.getCurveLengths().length>0){y.getPointAt(g.offset,g.point),y.getTangentAt(g.offset,g.tangent).normalize(),y.getPointAt(s.misc.repeat(v.current-(z-g.offset),1),g.next);const e=(null==r?void 0:r.current)instanceof D.Object3D?r.current:h;e.position.copy(g.point),i&&s.easing.dampLookAt(e,(e=>(null==e?void 0:e.current)instanceof D.Object3D)(i)?i.current.getWorldPosition(w):i,d,t,m,void 0,c)}})),P.createElement(\"group\",C.default({ref:x},f),P.createElement(Lt.Provider,{value:g},e,n&&P.createElement(Ut,null)))}));function Vt({defaultScene:e,defaultCamera:t,renderPriority:r=1}){const{gl:n,scene:o,camera:i}=a.useThree();let s;return a.useFrame((()=>{s=n.autoClear,1===r&&(n.autoClear=!0,n.render(e,t)),n.autoClear=!1,n.clearDepth(),n.render(o,i),n.autoClear=s}),r),P.createElement(\"group\",{onPointerOver:()=>null})}function Ot({children:e,renderPriority:t=1}){const{scene:r,camera:n}=a.useThree(),[o]=P.useState((()=>new D.Scene));return P.createElement(P.Fragment,null,a.createPortal(P.createElement(P.Fragment,null,e,P.createElement(Vt,{defaultScene:r,defaultCamera:n,renderPriority:t})),o,{events:{priority:t+1}}))}const Nt=P.createContext({}),jt=()=>P.useContext(Nt),Wt=2*Math.PI,Gt=new n.Object3D,Ht=new n.Matrix4,[$t,qt]=[new n.Quaternion,new n.Quaternion],Xt=new n.Vector3,Zt=new n.Vector3,Yt=\"#f0f0f0\",Qt=\"#999\",Kt=\"black\",Jt=\"black\",er=[\"Right\",\"Left\",\"Top\",\"Bottom\",\"Front\",\"Back\"],tr=e=>new n.Vector3(...e).multiplyScalar(.38),rr=[[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]].map(tr),nr=[.25,.25,.25],ar=[[1,1,0],[1,0,1],[1,0,-1],[1,-1,0],[0,1,1],[0,1,-1],[0,-1,1],[0,-1,-1],[-1,1,0],[-1,0,1],[-1,0,-1],[-1,-1,0]].map(tr),or=ar.map((e=>e.toArray().map((e=>0==e?.5:.25)))),ir=({hover:e,index:t,font:r=\"20px Inter var, Arial, sans-serif\",faces:o=er,color:i=Yt,hoverColor:s=Qt,textColor:l=Kt,strokeColor:c=Jt,opacity:u=1})=>{const d=a.useThree((e=>e.gl)),m=P.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=128,e.height=128;const a=e.getContext(\"2d\");return a.fillStyle=i,a.fillRect(0,0,e.width,e.height),a.strokeStyle=c,a.strokeRect(0,0,e.width,e.height),a.font=r,a.textAlign=\"center\",a.fillStyle=l,a.fillText(o[t].toUpperCase(),64,76),new n.CanvasTexture(e)}),[t,o,r,i,l,c]);return P.createElement(\"meshBasicMaterial\",{map:m,\"map-anisotropy\":d.capabilities.getMaxAnisotropy()||1,attach:`material-${t}`,color:e?s:\"white\",transparent:!0,opacity:u})},sr=e=>{const{tweenCamera:t}=jt(),[r,n]=P.useState(null);return P.createElement(\"mesh\",{onPointerOut:e=>{e.stopPropagation(),n(null)},onPointerMove:e=>{e.stopPropagation(),n(Math.floor(e.faceIndex/2))},onClick:e.onClick||(e=>{e.stopPropagation(),t(e.face.normal)})},[...Array(6)].map(((t,n)=>P.createElement(ir,C.default({key:n,index:n,hover:r===n},e)))),P.createElement(\"boxGeometry\",null))},lr=({onClick:e,dimensions:t,position:r,hoverColor:n=Qt})=>{const{tweenCamera:a}=jt(),[o,i]=P.useState(!1);return P.createElement(\"mesh\",{scale:1.01,position:r,onPointerOver:e=>{e.stopPropagation(),i(!0)},onPointerOut:e=>{e.stopPropagation(),i(!1)},onClick:e||(e=>{e.stopPropagation(),a(r)})},P.createElement(\"meshBasicMaterial\",{color:o?n:\"white\",transparent:!0,opacity:.6,visible:o}),P.createElement(\"boxGeometry\",{args:t}))};function cr({scale:e=[.8,.05,.05],color:t,rotation:r}){return P.createElement(\"group\",{rotation:r},P.createElement(\"mesh\",{position:[.4,0,0]},P.createElement(\"boxGeometry\",{args:e}),P.createElement(\"meshBasicMaterial\",{color:t,toneMapped:!1})))}function ur({onClick:e,font:t,disabled:r,arcStyle:o,label:i,labelColor:s,axisHeadScale:l=1,...c}){const u=a.useThree((e=>e.gl)),d=P.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=64,e.height=64;const r=e.getContext(\"2d\");return r.beginPath(),r.arc(32,32,16,0,2*Math.PI),r.closePath(),r.fillStyle=o,r.fill(),i&&(r.font=t,r.textAlign=\"center\",r.fillStyle=s,r.fillText(i,32,41)),new n.CanvasTexture(e)}),[o,i,s,t]),[m,f]=P.useState(!1),p=(i?1:.75)*(m?1.2:1)*l;return P.createElement(\"sprite\",C.default({scale:p,onPointerOver:r?void 0:e=>{e.stopPropagation(),f(!0)},onPointerOut:r?void 0:e||(e=>{e.stopPropagation(),f(!1)})},c),P.createElement(\"spriteMaterial\",{map:d,\"map-anisotropy\":u.capabilities.getMaxAnisotropy()||1,alphaTest:.3,opacity:i?1:.75,toneMapped:!1}))}const dr=Ee({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new D.Color,sectionColor:new D.Color,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new D.Vector3,worldPlanePosition:new D.Vector3},\"\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform vec3 worldPlanePosition;\\n    uniform float fadeDistance;\\n    uniform bool infiniteGrid;\\n    uniform bool followCamera;\\n\\n    void main() {\\n      localPosition = position.xzy;\\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\\n      \\n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\\n      if (followCamera) {\\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\\n      }\\n\\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\\n    }\\n  \",`\\n    varying vec3 localPosition;\\n    varying vec4 worldPosition;\\n\\n    uniform vec3 worldCamProjPosition;\\n    uniform float cellSize;\\n    uniform float sectionSize;\\n    uniform vec3 cellColor;\\n    uniform vec3 sectionColor;\\n    uniform float fadeDistance;\\n    uniform float fadeStrength;\\n    uniform float cellThickness;\\n    uniform float sectionThickness;\\n\\n    float getGrid(float size, float thickness) {\\n      vec2 r = localPosition.xz / size;\\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\\n      return 1.0 - min(line, 1.0);\\n    }\\n\\n    void main() {\\n      float g1 = getGrid(cellSize, cellThickness);\\n      float g2 = getGrid(sectionSize, sectionThickness);\\n\\n      float dist = distance(worldCamProjPosition, worldPosition.xyz);\\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\\n\\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\\n      if (gl_FragColor.a <= 0.0) discard;\\n\\n      #include <tonemapping_fragment>\\n      #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n    }\\n  `),mr=P.forwardRef((({args:e,cellColor:t=\"#000000\",sectionColor:r=\"#2080ff\",cellSize:n=.5,sectionSize:o=1,followCamera:i=!1,infiniteGrid:s=!1,fadeDistance:l=100,fadeStrength:c=1,cellThickness:u=.5,sectionThickness:d=1,side:m=D.BackSide,...f},p)=>{a.extend({GridMaterial:dr});const h=P.useRef(null),x=new D.Plane,y=new D.Vector3(0,1,0),v=new D.Vector3(0,0,0);a.useFrame((e=>{x.setFromNormalAndCoplanarPoint(y,v).applyMatrix4(h.current.matrixWorld);const t=h.current.material,r=t.uniforms.worldCamProjPosition,n=t.uniforms.worldPlanePosition;x.projectPoint(e.camera.position,r.value),n.value.set(0,0,0).applyMatrix4(h.current.matrixWorld)}));const g={cellSize:n,sectionSize:o,cellColor:t,sectionColor:r,cellThickness:u,sectionThickness:d},z={fadeDistance:l,fadeStrength:c,infiniteGrid:s,followCamera:i};return P.createElement(\"mesh\",C.default({ref:k.default([h,p]),frustumCulled:!1},f),P.createElement(\"gridMaterial\",C.default({transparent:!0,\"extensions-derivatives\":!0,side:m},g,z)),P.createElement(\"planeGeometry\",{args:e}))}));function fr(e,{path:t}){const[r]=a.useLoader(n.CubeTextureLoader,[e],(e=>e.setPath(t)));return r}function pr(e){return a.useLoader(d.FBXLoader,e)}fr.preload=(e,{path:t})=>a.useLoader.preload(n.CubeTextureLoader,[e],(e=>e.setPath(t))),pr.preload=e=>a.useLoader.preload(d.FBXLoader,e),pr.clear=e=>a.useLoader.clear(d.FBXLoader,e);const hr=\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master\";function xr(e,r=`${hr}/basis/`){const n=a.useThree((e=>e.gl)),o=a.useLoader(d.KTX2Loader,Se(e)?Object.values(e):e,(e=>{e.detectSupport(n),e.setTranscoderPath(r)}));if(t.useEffect((()=>{(Array.isArray(o)?o:[o]).forEach(n.initTexture)}),[n,o]),Se(e)){const t=Object.keys(e),r={};return t.forEach((e=>Object.assign(r,{[e]:o[t.indexOf(e)]}))),r}return o}function yr(e,t){\"function\"==typeof e?e(t):null!=e&&(e.current=t)}xr.preload=(e,t=`${hr}/basis/`)=>a.useLoader.preload(d.KTX2Loader,e,(e=>{e.setTranscoderPath(t)})),xr.clear=e=>a.useLoader.clear(d.KTX2Loader,e);function vr(e,t,...r){const n=P.useRef(),o=a.useThree((e=>e.scene));return P.useLayoutEffect((()=>{let a;if(e&&null!=e&&e.current&&t&&(n.current=a=new t(e.current,...r)),a)return a.traverse((e=>e.raycast=()=>null)),o.add(a),()=>{n.current=void 0,o.remove(a),null==a.dispose||a.dispose()}}),[o,t,e,...r]),a.useFrame((()=>{var e;null==(e=n.current)||null==e.update||e.update()})),n}const gr=e=>e.isMesh;const zr=P.forwardRef((({enabled:e=!0,firstHitOnly:t=!1,children:r,strategy:o=w.SAH,verbose:i=!1,setBoundingBox:s=!0,maxDepth:l=40,maxLeafTris:c=10,indirect:u=!1,...d},m)=>{const f=P.useRef(null),p=a.useThree((e=>e.raycaster));return P.useImperativeHandle(m,(()=>f.current),[]),P.useEffect((()=>{if(e){const e={strategy:o,verbose:i,setBoundingBox:s,maxDepth:l,maxLeafTris:c,indirect:u},r=f.current;return p.firstHitOnly=t,r.traverse((t=>{gr(t)&&!t.geometry.boundsTree&&t.raycast===n.Mesh.prototype.raycast&&(t.raycast=w.acceleratedRaycast,t.geometry.computeBoundsTree=w.computeBoundsTree,t.geometry.disposeBoundsTree=w.disposeBoundsTree,t.geometry.computeBoundsTree(e))})),()=>{delete p.firstHitOnly,r.traverse((e=>{gr(e)&&e.geometry.boundsTree&&(e.geometry.disposeBoundsTree(),e.raycast=n.Mesh.prototype.raycast)}))}}}),[]),P.createElement(\"group\",C.default({ref:f},d),r)}));function wr(e){const t=P.useRef(null),r=P.useRef(!1),n=P.useRef(!1),o=P.useRef(e);return P.useLayoutEffect((()=>{o.current=e}),[e]),P.useEffect((()=>{const e=t.current;if(e){const t=a.addEffect((()=>(r.current=!1,!0))),i=e.onBeforeRender;e.onBeforeRender=()=>r.current=!0;const s=a.addAfterEffect((()=>(r.current!==n.current&&(null==o.current||o.current(n.current=r.current)),!0)));return()=>{e.onBeforeRender=i,t(),s()}}}),[]),t}const br=\"\\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n  vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n  #ifdef BOX_PROJECTED_ENV_MAP\\n    vWorldPosition = worldPosition.xyz;\\n  #endif\\n#endif\\n\",Mr=\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  uniform vec3 envMapSize;\\n  uniform vec3 envMapPosition;\\n  varying vec3 vWorldPosition;\\n    \\n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\\n    vec3 nDir = normalize( v );\\n    vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\\n    vec3 rbminmax;\\n    rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\\n    rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\\n    rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\\n    float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\\n    vec3 boxIntersection = vWorldPosition + nDir * correction;    \\n    return boxIntersection - cubePos;\\n  }\\n#endif\\n\",Er=\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );\\n#endif\\n\",Sr=\"\\n#ifdef BOX_PROJECTED_ENV_MAP\\n  reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );\\n#endif\\n\";const Tr=new D.Box3,Cr=new D.Vector3;const Pr=e=>Math.sqrt(1-Math.pow(e-1,2));class Rr{constructor({size:e=256,maxAge:t=750,radius:r=.3,intensity:n=.2,interpolate:a=0,smoothing:o=0,minForce:i=.3,blend:s=\"screen\",ease:l=Pr}={}){this.size=e,this.maxAge=t,this.radius=r,this.intensity=n,this.ease=l,this.interpolate=a,this.smoothing=o,this.minForce=i,this.blend=s,this.trail=[],this.force=0,this.initTexture()}initTexture(){this.canvas=document.createElement(\"canvas\"),this.canvas.width=this.canvas.height=this.size,this.ctx=this.canvas.getContext(\"2d\"),this.ctx.fillStyle=\"black\",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.texture=new n.Texture(this.canvas),this.canvas.id=\"touchTexture\",this.canvas.style.width=this.canvas.style.height=`${this.canvas.width}px`}update(e){this.clear(),this.trail.forEach(((t,r)=>{t.age+=1e3*e,t.age>this.maxAge&&this.trail.splice(r,1)})),this.trail.length||(this.force=0),this.trail.forEach((e=>{this.drawTouch(e)})),this.texture.needsUpdate=!0}clear(){this.ctx.globalCompositeOperation=\"source-over\",this.ctx.fillStyle=\"black\",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height)}addTouch(e){const t=this.trail[this.trail.length-1];if(t){const r=t.x-e.x,n=t.y-e.y,a=r*r+n*n,o=Math.max(this.minForce,Math.min(1e4*a,1));if(this.force=function(e,t,r=.9){return t*r+e*(1-r)}(o,this.force,this.smoothing),this.interpolate){const e=Math.ceil(a/Math.pow(.5*this.radius/this.interpolate,2));if(e>1)for(let a=1;a<e;a++)this.trail.push({x:t.x-r/e*a,y:t.y-n/e*a,age:0,force:o})}}this.trail.push({x:e.x,y:e.y,age:0,force:this.force})}drawTouch(e){const t={x:e.x*this.size,y:(1-e.y)*this.size};let r=1;r=e.age<.3*this.maxAge?this.ease(e.age/(.3*this.maxAge)):this.ease(1-(e.age-.3*this.maxAge)/(.7*this.maxAge)),r*=e.force,this.ctx.globalCompositeOperation=this.blend;const n=this.size*this.radius*r,a=this.ctx.createRadialGradient(t.x,t.y,Math.max(0,.25*n),t.x,t.y,Math.max(0,n));a.addColorStop(0,`rgba(255, 255, 255, ${this.intensity})`),a.addColorStop(1,\"rgba(0, 0, 0, 0.0)\"),this.ctx.beginPath(),this.ctx.fillStyle=a,this.ctx.arc(t.x,t.y,Math.max(0,n),0,2*Math.PI),this.ctx.fill()}}const Dr=P.forwardRef((function({children:e,disable:t,disableX:r,disableY:a,disableZ:o,left:i,right:s,top:l,bottom:c,front:u,back:d,onCentered:m,precise:f=!0,cacheKey:p=0,...h},x){const y=P.useRef(null),v=P.useRef(null),g=P.useRef(null);return P.useLayoutEffect((()=>{v.current.matrixWorld.identity();const e=(new n.Box3).setFromObject(g.current,f),p=new n.Vector3,h=new n.Sphere,x=e.max.x-e.min.x,z=e.max.y-e.min.y,w=e.max.z-e.min.z;e.getCenter(p),e.getBoundingSphere(h);const b=l?z/2:c?-z/2:0,M=i?-x/2:s?x/2:0,E=u?w/2:d?-w/2:0;v.current.position.set(t||r?0:-p.x+M,t||a?0:-p.y+b,t||o?0:-p.z+E),void 0!==m&&m({parent:y.current.parent,container:y.current,width:x,height:z,depth:w,boundingBox:e,boundingSphere:h,center:p,verticalAlignment:b,horizontalAlignment:M,depthAlignment:E})}),[p,m,l,i,u,t,r,a,o,f,s,c,d]),P.useImperativeHandle(x,(()=>y.current),[]),P.createElement(\"group\",C.default({ref:y},h),P.createElement(\"group\",{ref:v},P.createElement(\"group\",{ref:g},e)))})),Fr=P.forwardRef((({font:e,color:t=\"#cbcbcb\",bevelSize:r=.04,debug:n=!1,children:a,...o},i)=>{const[s,l]=P.useState(0),c=P.useCallback(((e=1)=>l(s+e)),[s]),u=P.useCallback(((e=1)=>l(s-e)),[s]),d=P.useMemo((()=>({incr:c,decr:u})),[c,u]);return P.useImperativeHandle(i,(()=>d),[d]),P.createElement(\"group\",o,P.createElement(P.Suspense,{fallback:null},P.createElement(Dr,{top:!0,cacheKey:JSON.stringify({counter:s,font:e})},P.createElement(we,{bevelEnabled:!0,bevelSize:r,font:e},n?P.createElement(\"meshNormalMaterial\",{wireframe:!0}):P.createElement(\"meshStandardMaterial\",{color:t}),s))),a)})),kr=P.forwardRef((({startFrame:e,endFrame:t,fps:r,frameName:n,textureDataURL:o,textureImageURL:i,loop:s,numberOfFrames:l,autoPlay:c,animationNames:u,onStart:d,onEnd:m,onLoopEnd:f,onFrame:p,play:h,pause:x,flipX:y,alphaTest:v,children:g,asSprite:z,resetOnEnd:w,...b},M)=>{const E=P.useRef(null),[S,T]=P.useState(!1),R=P.useRef(!1),F=P.useRef(),k=P.useRef(),_=P.useRef(window.performance.now()),A=P.useRef(),L=P.useRef(e||0),B=P.useRef(n||\"\"),U=1e3/(r||30),[I,V]=P.useState(new D.Texture),O=P.useRef(0),[N,j]=P.useState([1,1,1]),W=y?-1:1,[G,H]=P.useState(null==z||z),$=P.useRef(x);const q=(e,t)=>{const r=t/e;return k.current&&k.current.scale.set(1,r,1),[1,r,1]};P.useEffect((()=>{if(o&&i)!function(e,t,r){const n=new D.TextureLoader,a=fetch(e).then((e=>e.json())),o=new Promise((e=>{n.load(t,e)}));Promise.all([a,o]).then((e=>{r(e[0],e[1])}))}(o,i,X);else if(i){const e=new D.TextureLoader;new Promise((t=>{e.load(i,t)})).then((e=>{X(null,e)}))}}),[]),P.useEffect((()=>{H(null==z||z)}),[z]),P.useLayoutEffect((()=>{Y()}),[I,y]),P.useEffect((()=>{c&&($.current=!1)}),[c]),P.useEffect((()=>{if(B.current!==n&&n&&(L.current=0,B.current=n,R.current=!1,Y(),E.current)){const{w:e,h:t}=K(E.current.frames).sourceSize,r=q(e,t);j(r)}}),[n]);const X=(e,t)=>{if(null===e){if(l){const e=t.image.width,r=t.image.height,n=e/l,a=r;if(A.current=t,O.current=l,E.current={frames:[],meta:{version:\"1.0\",size:{w:e,h:r},scale:\"1\"}},parseInt(n.toString(),10)===n)for(let e=0;e<l;e++)E.current.frames.push({frame:{x:e*n,y:0,w:n,h:a},rotated:!1,trimmed:!1,spriteSourceSize:{x:0,y:0,w:n,h:a},sourceSize:{w:n,h:r}})}}else{E.current=e,E.current.frames=Array.isArray(e.frames)?e.frames:Z(),O.current=Array.isArray(e.frames)?e.frames.length:Object.keys(e.frames).length,A.current=t;const{w:r,h:n}=K(e.frames).sourceSize,a=q(r,n);j(a),F.current&&(F.current.map=t)}t.premultiplyAlpha=!1,V(t)},Z=()=>{const e={},t=E.current,r=u;if(r){for(let n=0;n<r.length;n++){e[r[n]]=[];for(const a in t.frames){const o=t.frames[a],i=o.frame,s=i.x,l=i.y,c=i.w,u=i.h,d=o.sourceSize.w,m=o.sourceSize.h;-1!==a.toLowerCase().indexOf(r[n].toLowerCase())&&e[r[n]].push({x:s,y:l,w:c,h:u,frame:i,sourceSize:{w:d,h:m}})}}return e}if(n){const e=[];for(const r in t.frames)e.push(t.frames[r]);return e}},Y=()=>{if(!E.current)return;const{meta:{size:e},frames:t}=E.current,{w:r,h:a}=Array.isArray(t)?t[0].sourceSize:n&&t[n]?t[n][0].sourceSize:{w:0,h:0};F.current.map.wrapS=F.current.map.wrapT=D.RepeatWrapping,F.current.map.center.set(0,0),F.current.map.repeat.set(1*W/(e.w/r),1/(e.h/a));const o=1/((e.h-1)/a);F.current.map.offset.x=0,F.current.map.offset.y=1-o,T(!0),d&&d({currentFrameName:n,currentFrame:L.current})},Q=(e,t,r,n)=>{let a=0,o=0;q(e,t);const i=(r.w-1)/e,s=(r.h-1)/t,{frame:{x:l,y:c},sourceSize:{w:u,h:d}}=n[L.current],m=1/i,f=1/s;a=W>0?m*(l/u):m*(l/u)-F.current.map.repeat.x,o=Math.abs(1-f)-f*(c/d),F.current.map.offset.x=a,F.current.map.offset.y=o};a.useFrame(((r,a)=>{var o,i;null!=(o=E.current)&&o.frames&&null!=(i=F.current)&&i.map&&($.current||R.current||!c&&!h||((()=>{const r=window.performance.now(),a=r-_.current,{meta:{size:o},frames:i}=E.current,{w:l,h:c}=K(i).sourceSize,u=Array.isArray(i)?i:n?i[n]:[],d=t||u.length-1;L.current>d&&(L.current=s&&null!=e?e:0,s?null==f||f({currentFrameName:n,currentFrame:L.current}):(null==m||m({currentFrameName:n,currentFrame:L.current}),R.current=!w,w&&($.current=!0)),!s)||a<=U||(_.current=r-a%U,Q(l,c,o,u),L.current+=1)})(),p&&p({currentFrameName:B.current,currentFrame:L.current})))}));const K=e=>{if(Array.isArray(e))return e[0];if(\"object\"==typeof e&&null!==e){const t=Object.keys(e);return n?e[n][0]:e[t[0]][0]}return{w:0,h:0}};return P.createElement(\"group\",C.default({ref:M},b),P.createElement(P.Suspense,{fallback:null},G&&P.createElement(\"sprite\",{ref:k,scale:N},P.createElement(\"spriteMaterial\",{toneMapped:!1,ref:F,map:I,transparent:!0,alphaTest:null!=v?v:0})),!G&&P.createElement(\"mesh\",{ref:k,scale:N},P.createElement(\"planeGeometry\",{args:[1,1]}),P.createElement(\"meshBasicMaterial\",{toneMapped:!1,side:D.DoubleSide,ref:F,map:I,transparent:!0,alphaTest:null!=v?v:0}))),g)})),_r=P.forwardRef((({children:e,curve:t},r)=>{const[n]=P.useState((()=>new D.Scene)),[o,i]=P.useState(),s=P.useRef();return P.useEffect((()=>{s.current=new d.Flow(n.children[0]),i(s.current.object3D)}),[e]),P.useEffect((()=>{var e;t&&(null==(e=s.current)||e.updateCurve(0,t))}),[t]),P.useImperativeHandle(r,(()=>({moveAlongCurve:e=>{var t;null==(t=s.current)||t.moveAlongCurve(e)}}))),P.createElement(P.Fragment,null,a.createPortal(e,n),o&&P.createElement(\"primitive\",{object:o}))}));class Ar extends n.MeshPhysicalMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._distort={value:.4},this._radius={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.radius=this._radius,e.uniforms.distort=this._distort,e.vertexShader=`\\n      uniform float time;\\n      uniform float radius;\\n      uniform float distort;\\n      #define GLSLIFY 1\\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\\n      ${e.vertexShader}\\n    `,e.vertexShader=e.vertexShader.replace(\"#include <begin_vertex>\",\"\\n        float updateTime = time / 50.0;\\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\\n        \")}get time(){return this._time.value}set time(e){this._time.value=e}get distort(){return this._distort.value}set distort(e){this._distort.value=e}get radius(){return this._radius.value}set radius(e){this._radius.value=e}}const Lr=P.forwardRef((({speed:e=1,...t},r)=>{const[n]=P.useState((()=>new Ar));return a.useFrame((t=>n&&(n.time=t.clock.getElapsedTime()*e))),P.createElement(\"primitive\",C.default({object:n,ref:r,attach:\"material\"},t))}));class Br extends n.MeshStandardMaterial{constructor(e={}){super(e),this.setValues(e),this._time={value:0},this._factor={value:1}}onBeforeCompile(e){e.uniforms.time=this._time,e.uniforms.factor=this._factor,e.vertexShader=`\\n      uniform float time;\\n      uniform float factor;\\n      ${e.vertexShader}\\n    `,e.vertexShader=e.vertexShader.replace(\"#include <begin_vertex>\",\"float theta = sin( time + position.y ) / 2.0 * factor;\\n        float c = cos( theta );\\n        float s = sin( theta );\\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\\n        vec3 transformed = vec3( position ) * m;\\n        vNormal = vNormal * m;\")}get time(){return this._time.value}set time(e){this._time.value=e}get factor(){return this._factor.value}set factor(e){this._factor.value=e}}const Ur=P.forwardRef((({speed:e=1,...t},r)=>{const[n]=P.useState((()=>new Br));return a.useFrame((t=>n&&(n.time=t.clock.getElapsedTime()*e))),P.createElement(\"primitive\",C.default({object:n,ref:r,attach:\"material\"},t))}));class Ir extends D.ShaderMaterial{constructor(e=new D.Vector2){super({uniforms:{inputBuffer:new D.Uniform(null),depthBuffer:new D.Uniform(null),resolution:new D.Uniform(new D.Vector2),texelSize:new D.Uniform(new D.Vector2),halfTexelSize:new D.Uniform(new D.Vector2),kernel:new D.Uniform(0),scale:new D.Uniform(1),cameraNear:new D.Uniform(0),cameraFar:new D.Uniform(1),minDepthThreshold:new D.Uniform(0),maxDepthThreshold:new D.Uniform(1),depthScale:new D.Uniform(0),depthToBlurRatioBias:new D.Uniform(.25)},fragmentShader:`#include <common>\\n        #include <dithering_pars_fragment>      \\n        uniform sampler2D inputBuffer;\\n        uniform sampler2D depthBuffer;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          float depthFactor = 0.0;\\n          \\n          #ifdef USE_DEPTH\\n            vec4 depth = texture2D(depthBuffer, vUv);\\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n            depthFactor *= depthScale;\\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\\n          #endif\\n          \\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\\n          gl_FragColor = sum * 0.25 ;\\n\\n          #include <dithering_fragment>\\n          #include <tonemapping_fragment>\\n          #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n        }`,vertexShader:\"uniform vec2 texelSize;\\n        uniform vec2 halfTexelSize;\\n        uniform float kernel;\\n        uniform float scale;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          vec2 uv = position.xy * 0.5 + 0.5;\\n          vUv = uv;\\n\\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\n\\n          gl_Position = vec4(position.xy, 1.0, 1.0);\\n        }\",blending:D.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(e.x,e.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class Vr{constructor({gl:e,resolution:t,width:r=500,height:a=500,minDepthThreshold:o=0,maxDepthThreshold:i=1,depthScale:s=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new n.WebGLRenderTarget(t,t,{minFilter:n.LinearFilter,magFilter:n.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:n.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new Ir,this.convolutionMaterial.setTexelSize(1/r,1/a),this.convolutionMaterial.setResolution(new n.Vector2(r,a)),this.scene=new n.Scene,this.camera=new n.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=o,this.convolutionMaterial.uniforms.maxDepthThreshold.value=i,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),d=new n.BufferGeometry;d.setAttribute(\"position\",new n.BufferAttribute(c,3)),d.setAttribute(\"uv\",new n.BufferAttribute(u,2)),this.screen=new n.Mesh(d,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,r){const n=this.scene,a=this.camera,o=this.renderTargetA,i=this.renderTargetB;let s=this.convolutionMaterial,l=s.uniforms;l.depthBuffer.value=t.depthTexture;const c=s.kernel;let u,d,m,f=t;for(d=0,m=c.length-1;d<m;++d)u=0==(1&d)?o:i,l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(u),e.render(n,a),f=u;l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:r),e.render(n,a)}}class Or extends n.MeshStandardMaterial{constructor(e={}){super(e),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=\"\"),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\\n        uniform mat4 textureMatrix;\\n        varying vec4 my_vUv;\\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace(\"#include <project_vertex>\",\"#include <project_vertex>\\n        my_vUv = textureMatrix * vec4( position, 1.0 );\\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\"),e.fragmentShader=`\\n        uniform sampler2D tDiffuse;\\n        uniform sampler2D tDiffuseBlur;\\n        uniform sampler2D tDepth;\\n        uniform sampler2D distortionMap;\\n        uniform float distortion;\\n        uniform float cameraNear;\\n\\t\\t\\t  uniform float cameraFar;\\n        uniform bool hasBlur;\\n        uniform float mixBlur;\\n        uniform float mirror;\\n        uniform float mixStrength;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float mixContrast;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec4 my_vUv;\\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace(\"#include <emissivemap_fragment>\",\"#include <emissivemap_fragment>\\n\\n      float distortionFactor = 0.0;\\n      #ifdef USE_DISTORTION\\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\\n      #endif\\n\\n      vec4 new_vUv = my_vUv;\\n      new_vUv.x += distortionFactor;\\n      new_vUv.y += distortionFactor;\\n\\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\\n\\n      vec4 merge = base;\\n\\n      #ifdef USE_NORMALMAP\\n        vec2 normal_uv = vec2(0.0);\\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n        vec3 coord = new_vUv.xyz / new_vUv.w;\\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\\n        merge = base_normal;\\n        blur = blur_normal;\\n      #endif\\n\\n      float depthFactor = 0.0001;\\n      float blurFactor = 0.0;\\n\\n      #ifdef USE_DEPTH\\n        vec4 depth = texture2DProj(tDepth, new_vUv);\\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n        depthFactor *= depthScale;\\n        depthFactor = max(0.0001, min(1.0, depthFactor));\\n\\n        #ifdef USE_BLUR\\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\\n          merge = merge * min(1.0, depthFactor + 0.5);\\n        #else\\n          merge = merge * depthFactor;\\n        #endif\\n\\n      #endif\\n\\n      float reflectorRoughnessFactor = roughness;\\n      #ifdef USE_ROUGHNESSMAP\\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\\n      #endif\\n\\n      #ifdef USE_BLUR\\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\\n        merge = mix(merge, blur, blurFactor);\\n      #endif\\n\\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\\n\\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\\n      \")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}const Nr=P.forwardRef((({mixBlur:e=0,mixStrength:t=1,resolution:r=256,blur:o=[0,0],minDepthThreshold:i=.9,maxDepthThreshold:s=1,depthScale:l=0,depthToBlurRatioBias:c=.25,mirror:u=0,distortion:d=1,mixContrast:m=1,distortionMap:f,reflectorOffset:p=0,...h},x)=>{a.extend({MeshReflectorMaterialImpl:Or});const y=a.useThree((({gl:e})=>e)),v=a.useThree((({camera:e})=>e)),g=a.useThree((({scene:e})=>e)),z=(o=Array.isArray(o)?o:[o,o])[0]+o[1]>0,w=P.useRef(null),[b]=P.useState((()=>new n.Plane)),[M]=P.useState((()=>new n.Vector3)),[E]=P.useState((()=>new n.Vector3)),[S]=P.useState((()=>new n.Vector3)),[T]=P.useState((()=>new n.Matrix4)),[R]=P.useState((()=>new n.Vector3(0,0,-1))),[D]=P.useState((()=>new n.Vector4)),[F]=P.useState((()=>new n.Vector3)),[_]=P.useState((()=>new n.Vector3)),[A]=P.useState((()=>new n.Vector4)),[L]=P.useState((()=>new n.Matrix4)),[B]=P.useState((()=>new n.PerspectiveCamera)),U=P.useCallback((()=>{var e;const t=w.current.parent||(null==(e=w.current)?void 0:e.__r3f.parent);if(!t)return;if(E.setFromMatrixPosition(t.matrixWorld),S.setFromMatrixPosition(v.matrixWorld),T.extractRotation(t.matrixWorld),M.set(0,0,1),M.applyMatrix4(T),E.addScaledVector(M,p),F.subVectors(E,S),F.dot(M)>0)return;F.reflect(M).negate(),F.add(E),T.extractRotation(v.matrixWorld),R.set(0,0,-1),R.applyMatrix4(T),R.add(S),_.subVectors(E,R),_.reflect(M).negate(),_.add(E),B.position.copy(F),B.up.set(0,1,0),B.up.applyMatrix4(T),B.up.reflect(M),B.lookAt(_),B.far=v.far,B.updateMatrixWorld(),B.projectionMatrix.copy(v.projectionMatrix),L.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),L.multiply(B.projectionMatrix),L.multiply(B.matrixWorldInverse),L.multiply(t.matrixWorld),b.setFromNormalAndCoplanarPoint(M,E),b.applyMatrix4(B.matrixWorldInverse),D.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const r=B.projectionMatrix;A.x=(Math.sign(D.x)+r.elements[8])/r.elements[0],A.y=(Math.sign(D.y)+r.elements[9])/r.elements[5],A.z=-1,A.w=(1+r.elements[10])/r.elements[14],D.multiplyScalar(2/D.dot(A)),r.elements[2]=D.x,r.elements[6]=D.y,r.elements[10]=D.z+1,r.elements[14]=D.w}),[v,p]),[I,V,O,N]=P.useMemo((()=>{const a={minFilter:n.LinearFilter,magFilter:n.LinearFilter,type:n.HalfFloatType},p=new n.WebGLRenderTarget(r,r,a);p.depthBuffer=!0,p.depthTexture=new n.DepthTexture(r,r),p.depthTexture.format=n.DepthFormat,p.depthTexture.type=n.UnsignedShortType;const h=new n.WebGLRenderTarget(r,r,a);return[p,h,new Vr({gl:y,resolution:r,width:o[0],height:o[1],minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c}),{mirror:u,textureMatrix:L,mixBlur:e,tDiffuse:p.texture,tDepth:p.depthTexture,tDiffuseBlur:h.texture,hasBlur:z,mixStrength:t,minDepthThreshold:i,maxDepthThreshold:s,depthScale:l,depthToBlurRatioBias:c,distortion:d,distortionMap:f,mixContrast:m,\"defines-USE_BLUR\":z?\"\":void 0,\"defines-USE_DEPTH\":l>0?\"\":void 0,\"defines-USE_DISTORTION\":f?\"\":void 0}]}),[y,o,L,r,u,z,e,t,i,s,l,c,d,f,m]);return a.useFrame((()=>{var e;const t=w.current.parent||(null==(e=w.current)?void 0:e.__r3f.parent);if(!t)return;t.visible=!1;const r=y.xr.enabled,n=y.shadowMap.autoUpdate;U(),y.xr.enabled=!1,y.shadowMap.autoUpdate=!1,y.setRenderTarget(I),y.state.buffers.depth.setMask(!0),y.autoClear||y.clear(),y.render(g,B),z&&O.render(y,I,V),y.xr.enabled=r,y.shadowMap.autoUpdate=n,t.visible=!0,y.setRenderTarget(null)})),P.createElement(\"meshReflectorMaterialImpl\",C.default({attach:\"material\",key:\"key\"+N[\"defines-USE_BLUR\"]+N[\"defines-USE_DEPTH\"]+N[\"defines-USE_DISTORTION\"],ref:k.default([w,x])},N,h))})),jr=Ee({envMap:null,bounces:3,ior:2.4,correctMips:!0,aberrationStrength:.01,fresnel:0,bvh:new w.MeshBVHUniformStruct,color:new D.Color(\"white\"),resolution:new D.Vector2,viewMatrixInverse:new D.Matrix4,projectionMatrixInverse:new D.Matrix4},\"\\n  uniform mat4 viewMatrixInverse;\\n\\n  varying vec3 vWorldPosition;  \\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #ifdef USE_INSTANCING_COLOR\\n    varying vec3 vInstanceColor;\\n  #endif\\n\\n  void main() {        \\n    vec4 transformedNormal = vec4(normal, 0.0);\\n    vec4 transformedPosition = vec4(position, 1.0);\\n    #ifdef USE_INSTANCING\\n      transformedNormal = instanceMatrix * transformedNormal;\\n      transformedPosition = instanceMatrix * transformedPosition;\\n    #endif\\n\\n    #ifdef USE_INSTANCING\\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\\n    #else\\n      vModelMatrixInverse = inverse(modelMatrix);\\n    #endif\\n\\n    #ifdef USE_INSTANCING_COLOR\\n      vInstanceColor = instanceColor.rgb;\\n    #endif\\n\\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\\n  }\",`\\n  #define ENVMAP_TYPE_CUBE_UV\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  varying vec3 vWorldPosition;\\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #ifdef USE_INSTANCING_COLOR\\n    varying vec3 vInstanceColor;\\n  #endif\\n    \\n  #ifdef ENVMAP_TYPE_CUBEM\\n    uniform samplerCube envMap;\\n  #else\\n    uniform sampler2D envMap;\\n  #endif\\n    \\n  uniform float bounces;\\n  ${w.shaderStructs}\\n  ${w.shaderIntersectFunction}\\n  uniform BVH bvh;\\n  uniform float ior;\\n  uniform bool correctMips;\\n  uniform vec2 resolution;\\n  uniform float fresnel;\\n  uniform mat4 modelMatrix;\\n  uniform mat4 projectionMatrixInverse;\\n  uniform mat4 viewMatrixInverse;\\n  uniform float aberrationStrength;\\n  uniform vec3 color;\\n  \\n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\\n  }\\n    \\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\\n    vec3 rayOrigin = ro;\\n    vec3 rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\\n    for(float i = 0.0; i < bounces; i++) {\\n      uvec4 faceIndices = uvec4( 0u );\\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\\n      vec3 barycoord = vec3( 0.0 );\\n      float side = 1.0;\\n      float dist = 0.0;\\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      \\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\\n      if (length(tempDir) != 0.0) {\\n        rayDirection = tempDir;\\n        break;\\n      }\\n      rayDirection = reflect(rayDirection, faceNormal);\\n      rayOrigin = hitPos + rayDirection * 0.01;\\n    }\\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\\n    return rayDirection;\\n  }\\n    \\n  #include <common>\\n  #include <cube_uv_reflection_fragment>\\n    \\n  #ifdef ENVMAP_TYPE_CUBEM\\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\\n    }\\n  #else\\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      vec2 uvv = equirectUv( rayDirection );\\n      vec2 smoothUv = equirectUv( directionCamPerfect );\\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\\n    }\\n  #endif\\n  \\n  void main() {\\n    vec2 uv = gl_FragCoord.xy / resolution;\\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\\n    directionCamPerfect = normalize(directionCamPerfect);\\n    vec3 normal = vNormal;\\n    vec3 rayOrigin = cameraPosition;\\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\\n    vec3 finalColor;\\n    #ifdef CHROMATIC_ABERRATIONS\\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      #ifdef FAST_CHROMA \\n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\\n      #else\\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\\n      #endif\\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\\n      finalColor = vec3(finalColorR, finalColorG, finalColorB);\\n    #else\\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    \\n    #endif\\n\\n    finalColor *= color;\\n    #ifdef USE_INSTANCING_COLOR\\n      finalColor *= vInstanceColor;\\n    #endif\\n\\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      \\n    #include <tonemapping_fragment>\\n    #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n  }`);const Wr=Ee({},\"void main() { }\",\"void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }\");class Gr extends D.MeshPhysicalMaterial{constructor(e=6,t=!1){super(),this.uniforms={chromaticAberration:{value:.05},transmission:{value:0},_transmission:{value:1},transmissionMap:{value:null},roughness:{value:0},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:1/0},attenuationColor:{value:new D.Color(\"white\")},anisotropicBlur:{value:.1},time:{value:0},distortion:{value:0},distortionScale:{value:.5},temporalDistortion:{value:0},buffer:{value:null}},this.onBeforeCompile=r=>{r.uniforms={...r.uniforms,...this.uniforms},this.anisotropy>0&&(r.defines.USE_ANISOTROPY=\"\"),t?r.defines.USE_SAMPLER=\"\":r.defines.USE_TRANSMISSION=\"\",r.fragmentShader=\"\\n      uniform float chromaticAberration;         \\n      uniform float anisotropicBlur;      \\n      uniform float time;\\n      uniform float distortion;\\n      uniform float distortionScale;\\n      uniform float temporalDistortion;\\n      uniform sampler2D buffer;\\n\\n      vec3 random3(vec3 c) {\\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\\n        vec3 r;\\n        r.z = fract(512.0*j);\\n        j *= .125;\\n        r.x = fract(512.0*j);\\n        j *= .125;\\n        r.y = fract(512.0*j);\\n        return r-0.5;\\n      }\\n\\n      float seed = 0.0;\\n      uint hash( uint x ) {\\n        x += ( x << 10u );\\n        x ^= ( x >>  6u );\\n        x += ( x <<  3u );\\n        x ^= ( x >> 11u );\\n        x += ( x << 15u );\\n        return x;\\n      }\\n\\n      // Compound versions of the hashing algorithm I whipped together.\\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\\n\\n      // Construct a float with half-open range [0:1] using low 23 bits.\\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\\n      float floatConstruct( uint m ) {\\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\\n        m |= ieeeOne;                          // Add fractional part to 1.0\\n        float  f = uintBitsToFloat( m );       // Range [1:2]\\n        return f - 1.0;                        // Range [0:1]\\n      }\\n\\n      // Pseudo-random value in half-open range [0:1].\\n      float random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\\n      float random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n      float random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n      float random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\\n\\n      float rand() {\\n        float result = random(vec3(gl_FragCoord.xy, seed));\\n        seed += 1.0;\\n        return result;\\n      }\\n\\n      const float F3 =  0.3333333;\\n      const float G3 =  0.1666667;\\n\\n      float snoise(vec3 p) {\\n        vec3 s = floor(p + dot(p, vec3(F3)));\\n        vec3 x = p - s + dot(s, vec3(G3));\\n        vec3 e = step(vec3(0.0), x - x.yzx);\\n        vec3 i1 = e*(1.0 - e.zxy);\\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\\n        vec3 x1 = x - i1 + G3;\\n        vec3 x2 = x - i2 + 2.0*G3;\\n        vec3 x3 = x - 1.0 + 3.0*G3;\\n        vec4 w, d;\\n        w.x = dot(x, x);\\n        w.y = dot(x1, x1);\\n        w.z = dot(x2, x2);\\n        w.w = dot(x3, x3);\\n        w = max(0.6 - w, 0.0);\\n        d.x = dot(random3(s), x);\\n        d.y = dot(random3(s + i1), x1);\\n        d.z = dot(random3(s + i2), x2);\\n        d.w = dot(random3(s + 1.0), x3);\\n        w *= w;\\n        w *= w;\\n        d *= w;\\n        return dot(d, vec4(52.0));\\n      }\\n\\n      float snoiseFractal(vec3 m) {\\n        return 0.5333333* snoise(m)\\n              +0.2666667* snoise(2.0*m)\\n              +0.1333333* snoise(4.0*m)\\n              +0.0666667* snoise(8.0*m);\\n      }\\n\"+r.fragmentShader,r.fragmentShader=r.fragmentShader.replace(\"#include <transmission_pars_fragment>\",\"\\n        #ifdef USE_TRANSMISSION\\n          // Transmission code is based on glTF-Sampler-Viewer\\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\\n          uniform float _transmission;\\n          uniform float thickness;\\n          uniform float attenuationDistance;\\n          uniform vec3 attenuationColor;\\n          #ifdef USE_TRANSMISSIONMAP\\n            uniform sampler2D transmissionMap;\\n          #endif\\n          #ifdef USE_THICKNESSMAP\\n            uniform sampler2D thicknessMap;\\n          #endif\\n          uniform vec2 transmissionSamplerSize;\\n          uniform sampler2D transmissionSamplerMap;\\n          uniform mat4 modelMatrix;\\n          uniform mat4 projectionMatrix;\\n          varying vec3 vWorldPosition;\\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n            // Direction of refracted light.\\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n            // Compute rotation-independant scaling of the model matrix.\\n            vec3 modelScale;\\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n            // The thickness is specified in local space.\\n            return normalize( refractionVector ) * thickness * modelScale;\\n          }\\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n          }\\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \\n            #ifdef USE_SAMPLER\\n              #ifdef texture2DLodEXT\\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\\n              #else\\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\\n              #endif\\n            #else\\n              return texture2D(buffer, fragCoord.xy);\\n            #endif\\n          }\\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n            if ( isinf( attenuationDistance ) ) {\\n              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\\n              return radiance;\\n            } else {\\n              // Compute light attenuation using Beer's law.\\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\\n              return transmittance * radiance;\\n            }\\n          }\\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n            vec3 refractedRayExit = position + transmissionRay;\\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n            refractionCoords += 1.0;\\n            refractionCoords /= 2.0;\\n            // Sample framebuffer to get pixel the refracted ray hits.\\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\\n            // Get the specular component.\\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\\n          }\\n        #endif\\n\"),r.fragmentShader=r.fragmentShader.replace(\"#include <transmission_fragment>\",`  \\n        // Improve the refraction to use the world pos\\n        material.transmission = _transmission;\\n        material.transmissionAlpha = 1.0;\\n        material.thickness = thickness;\\n        material.attenuationDistance = attenuationDistance;\\n        material.attenuationColor = attenuationColor;\\n        #ifdef USE_TRANSMISSIONMAP\\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\\n        #endif\\n        #ifdef USE_THICKNESSMAP\\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\\n        #endif\\n        \\n        vec3 pos = vWorldPosition;\\n        vec3 v = normalize( cameraPosition - pos );\\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\\n        vec3 transmission = vec3(0.0);\\n        float transmissionR, transmissionB, transmissionG;\\n        float randomCoords = rand();\\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\\n        vec3 distortionNormal = vec3(0.0);\\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\\n        if (distortion > 0.0) {\\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\\n        }\\n        for (float i = 0.0; i < ${e}.0; i ++) {\\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand() - 0.5, rand() - 0.5, rand() - 0.5)) * pow(rand(), 0.33) + distortionNormal);\\n          transmissionR = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).r;\\n          transmissionG = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).g;\\n          transmissionB = getIBLVolumeRefraction(\\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\\n            material.attenuationColor, material.attenuationDistance\\n          ).b;\\n          transmission.r += transmissionR;\\n          transmission.g += transmissionG;\\n          transmission.b += transmissionB;\\n        }\\n        transmission /= ${e}.0;\\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\\n`)},Object.keys(this.uniforms).forEach((e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})))}}const Hr=P.forwardRef((({buffer:e,transmissionSampler:t=!1,backside:r=!1,side:n=D.FrontSide,transmission:o=1,thickness:i=0,backsideThickness:s=0,samples:l=10,resolution:c,backsideResolution:u,background:d,anisotropy:m,anisotropicBlur:f,...p},h)=>{a.extend({MeshTransmissionMaterial:Gr});const x=P.useRef(null),[y]=P.useState((()=>new Wr)),v=nt(u||c),g=nt(c);let z,w,b;return a.useFrame((e=>{x.current.time=e.clock.getElapsedTime(),x.current.buffer!==g.texture||t||(b=x.current.__r3f.parent,b&&(w=e.gl.toneMapping,z=e.scene.background,e.gl.toneMapping=D.NoToneMapping,d&&(e.scene.background=d),b.material=y,r&&(e.gl.setRenderTarget(v),e.gl.render(e.scene,e.camera),b.material=x.current,b.material.buffer=v.texture,b.material.thickness=s,b.material.side=D.BackSide),e.gl.setRenderTarget(g),e.gl.render(e.scene,e.camera),b.material=x.current,b.material.thickness=i,b.material.side=n,b.material.buffer=g.texture,e.scene.background=z,e.gl.setRenderTarget(null),e.gl.toneMapping=w))})),P.useImperativeHandle(h,(()=>x.current),[]),P.createElement(\"meshTransmissionMaterial\",C.default({args:[l,t],ref:x},p,{buffer:e||g.texture,_transmission:o,anisotropicBlur:null!=f?f:m,transmission:t?o:0,thickness:i,side:n}))})),$r=P.forwardRef(((e,t)=>(a.extend({DiscardMaterialImpl:Wr}),P.createElement(\"discardMaterialImpl\",C.default({ref:t},e))))),qr=Ce>=154?\"opaque_fragment\":\"output_fragment\";class Xr extends D.PointsMaterial{constructor(e){super(e),this.onBeforeCompile=(e,t)=>{const{isWebGL2:r}=t.capabilities;e.fragmentShader=e.fragmentShader.replace(`#include <${qr}>`,`\\n        ${r?`#include <${qr}>`:`#extension GL_OES_standard_derivatives : enable\\n#include <${qr}>`}\\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\\n      float r = dot(cxy, cxy);\\n      float delta = fwidth(r);     \\n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\\n      #include <tonemapping_fragment>\\n      #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n      `)}}}const Zr=P.forwardRef(((e,t)=>{const[r]=P.useState((()=>new Xr(null)));return P.createElement(\"primitive\",C.default({},e,{object:r,ref:t,attach:\"material\"}))}));function Yr(e,t,r){t.traverse((t=>{t.material&&(e.properties.remove(t.material),null==t.material.dispose||t.material.dispose())})),e.info.programs.length=0,e.compile(t,r)}function Qr(e,t){const r=e+\"Geometry\";return P.forwardRef((({args:e,children:n,...a},o)=>{const i=P.useRef(null);return P.useImperativeHandle(o,(()=>i.current)),P.useLayoutEffect((()=>{null==t||t(i.current)})),P.createElement(\"mesh\",C.default({ref:i},a),P.createElement(r,{attach:\"geometry\",args:e}),n)}))}const Kr=Qr(\"box\"),Jr=Qr(\"circle\"),en=Qr(\"cone\"),tn=Qr(\"cylinder\"),rn=Qr(\"sphere\"),nn=Qr(\"plane\"),an=Qr(\"tube\"),on=Qr(\"torus\"),sn=Qr(\"torusKnot\"),ln=Qr(\"tetrahedron\"),cn=Qr(\"ring\"),un=Qr(\"polyhedron\"),dn=Qr(\"icosahedron\"),mn=Qr(\"octahedron\"),fn=Qr(\"dodecahedron\"),pn=Qr(\"extrude\"),hn=Qr(\"lathe\"),xn=Qr(\"capsule\"),yn=Qr(\"shape\",(({geometry:e})=>{const t=e.attributes.position,r=(new D.Box3).setFromBufferAttribute(t),n=new D.Vector3;r.getSize(n);const a=[];let o=0,i=0,s=0,l=0;for(let e=0;e<t.count;e++)o=t.getX(e),i=t.getY(e),s=(o-r.min.x)/n.x,l=(i-r.min.y)/n.y,a.push(s,l);e.setAttribute(\"uv\",new D.Float32BufferAttribute(a,2))})),vn=1e-5;const gn=P.forwardRef((function({args:[e=1,t=1,r=1]=[],radius:a=.05,steps:o=1,smoothness:i=4,bevelSegments:s=4,creaseAngle:l=.4,children:c,...u},m){const f=P.useMemo((()=>function(e,t,r){const a=new n.Shape,o=r-vn;return a.absarc(vn,vn,vn,-Math.PI/2,-Math.PI,!0),a.absarc(vn,t-2*o,vn,Math.PI,Math.PI/2,!0),a.absarc(e-2*o,t-2*o,vn,Math.PI/2,0,!0),a.absarc(e-2*o,vn,vn,0,-Math.PI/2,!0),a}(e,t,a)),[e,t,a]),p=P.useMemo((()=>({depth:r-2*a,bevelEnabled:!0,bevelSegments:2*s,steps:o,bevelSize:a-vn,bevelThickness:a,curveSegments:i})),[r,a,i]),h=P.useRef(null);return P.useLayoutEffect((()=>{h.current&&(h.current.center(),d.toCreasedNormals(h.current,l))}),[f,p]),P.createElement(\"mesh\",C.default({ref:m},u),P.createElement(\"extrudeGeometry\",{ref:h,args:[f,p]}),c)}));function zn(){const e=new D.BufferGeometry,t=new Float32Array([-1,-1,3,-1,-1,3]);return e.boundingSphere=new D.Sphere,e.boundingSphere.set(new D.Vector3,1/0),e.setAttribute(\"position\",new D.BufferAttribute(t,2)),e}const wn=P.forwardRef((function({children:e,...t},r){const n=P.useMemo(zn,[]);return P.createElement(\"mesh\",C.default({ref:r,geometry:n,frustumCulled:!1},t),e)})),bn=P.forwardRef((({children:e,width:t,height:r,depth:n,box3:a,precise:o=!0,...i},s)=>{const l=P.useRef(null),c=P.useRef(null),u=P.useRef(null);return P.useLayoutEffect((()=>{c.current.matrixWorld.identity();let e=a||(new D.Box3).setFromObject(u.current,o);const i=e.max.x-e.min.x,s=e.max.y-e.min.y,l=e.max.z-e.min.z;let d=Math.max(i,s,l);t&&(d=i),r&&(d=s),n&&(d=l),c.current.scale.setScalar(1/d)}),[t,r,n,a,o]),P.useImperativeHandle(s,(()=>l.current),[]),P.createElement(\"group\",C.default({ref:l},i),P.createElement(\"group\",{ref:c},P.createElement(\"group\",{ref:u},e)))}));var Mn=function(e){return e[e.NONE=0]=\"NONE\",e[e.START=1]=\"START\",e[e.ACTIVE=2]=\"ACTIVE\",e}(Mn||{});const En=e=>e&&e.isOrthographicCamera,Sn=e=>e&&e.isBox3,Tn=e=>1-Math.exp(-5*e)+.007*e,Cn=P.createContext(null);function Pn({children:e,maxDuration:t=1,margin:r=1.2,observe:n,fit:o,clip:i,interpolateFunc:s=Tn,onFit:l}){const c=P.useRef(null),{camera:u,size:d,invalidate:m}=a.useThree(),f=a.useThree((e=>e.controls)),p=P.useRef(l);p.current=l;const h=P.useRef({camPos:new D.Vector3,camRot:new D.Quaternion,camZoom:1}),x=P.useRef({camPos:void 0,camRot:void 0,camZoom:void 0,camUp:void 0,target:void 0}),y=P.useRef(Mn.NONE),v=P.useRef(0),[g]=P.useState((()=>new D.Box3)),z=P.useMemo((()=>{function e(){const e=g.getSize(new D.Vector3),t=g.getCenter(new D.Vector3),n=Math.max(e.x,e.y,e.z),a=En(u)?4*n:n/(2*Math.atan(Math.PI*u.fov/360)),o=En(u)?4*n:a/u.aspect,i=r*Math.max(a,o);return{box:g,size:e,center:t,distance:i}}return{getSize:e,refresh(e){if(Sn(e))g.copy(e);else{const t=e||c.current;if(!t)return this;t.updateWorldMatrix(!0,!0),g.setFromObject(t)}if(g.isEmpty()){const e=u.position.length()||10;g.setFromCenterAndSize(new D.Vector3,new D.Vector3(e,e,e))}return h.current.camPos.copy(u.position),h.current.camRot.copy(u.quaternion),En(u)&&(h.current.camZoom=u.zoom),x.current.camPos=void 0,x.current.camRot=void 0,x.current.camZoom=void 0,x.current.camUp=void 0,x.current.target=void 0,this},reset(){const{center:t,distance:r}=e(),n=u.position.clone().sub(t).normalize();x.current.camPos=t.clone().addScaledVector(n,r),x.current.target=t.clone();const a=(new D.Matrix4).lookAt(x.current.camPos,x.current.target,u.up);return x.current.camRot=(new D.Quaternion).setFromRotationMatrix(a),y.current=Mn.START,v.current=0,this},moveTo(e){return x.current.camPos=Array.isArray(e)?new D.Vector3(...e):e.clone(),y.current=Mn.START,v.current=0,this},lookAt({target:e,up:t}){x.current.target=Array.isArray(e)?new D.Vector3(...e):e.clone(),x.current.camUp=t?Array.isArray(t)?new D.Vector3(...t):t.clone():u.up.clone();const r=(new D.Matrix4).lookAt(x.current.camPos||u.position,x.current.target,x.current.camUp);return x.current.camRot=(new D.Quaternion).setFromRotationMatrix(r),y.current=Mn.START,v.current=0,this},to({position:e,target:t}){return this.moveTo(e).lookAt({target:t})},fit(){if(!En(u))return this.reset();let e=0,t=0;const n=[new D.Vector3(g.min.x,g.min.y,g.min.z),new D.Vector3(g.min.x,g.max.y,g.min.z),new D.Vector3(g.min.x,g.min.y,g.max.z),new D.Vector3(g.min.x,g.max.y,g.max.z),new D.Vector3(g.max.x,g.max.y,g.max.z),new D.Vector3(g.max.x,g.max.y,g.min.z),new D.Vector3(g.max.x,g.min.y,g.max.z),new D.Vector3(g.max.x,g.min.y,g.min.z)],a=x.current.camPos||u.position,o=x.current.target||(null==f?void 0:f.target),i=x.current.camUp||u.up,s=o?(new D.Matrix4).lookAt(a,o,i).setPosition(a).invert():u.matrixWorldInverse;for(const r of n)r.applyMatrix4(s),e=Math.max(e,Math.abs(r.y)),t=Math.max(t,Math.abs(r.x));e*=2,t*=2;const l=(u.top-u.bottom)/e,c=(u.right-u.left)/t;return x.current.camZoom=Math.min(l,c)/r,y.current=Mn.START,v.current=0,p.current&&p.current(this.getSize()),this},clip(){const{distance:t}=e();return u.near=t/100,u.far=100*t,u.updateProjectionMatrix(),f&&(f.maxDistance=10*t,f.update()),m(),this}}}),[g,u,f,r,m]);P.useLayoutEffect((()=>{if(f){const e=()=>{if(f&&x.current.target&&y.current!==Mn.NONE){const e=(new D.Vector3).setFromMatrixColumn(u.matrix,2),t=h.current.camPos.distanceTo(f.target),r=(x.current.camPos||h.current.camPos).distanceTo(x.current.target),n=(1-v.current)*t+v.current*r;f.target.copy(u.position).addScaledVector(e,-n),f.update()}y.current=Mn.NONE};return f.addEventListener(\"start\",e),()=>f.removeEventListener(\"start\",e)}}),[f]);const w=P.useRef(0);return P.useLayoutEffect((()=>{(n||0==w.current++)&&(z.refresh(),o&&z.reset().fit(),i&&z.clip())}),[d,i,o,n,u,f]),a.useFrame(((e,r)=>{if(y.current===Mn.START)y.current=Mn.ACTIVE,m();else if(y.current===Mn.ACTIVE){if(v.current+=r/t,v.current>=1)x.current.camPos&&u.position.copy(x.current.camPos),x.current.camRot&&u.quaternion.copy(x.current.camRot),x.current.camUp&&u.up.copy(x.current.camUp),x.current.camZoom&&En(u)&&(u.zoom=x.current.camZoom),u.updateMatrixWorld(),u.updateProjectionMatrix(),f&&x.current.target&&(f.target.copy(x.current.target),f.update()),y.current=Mn.NONE;else{const e=s(v.current);x.current.camPos&&u.position.lerpVectors(h.current.camPos,x.current.camPos,e),x.current.camRot&&u.quaternion.slerpQuaternions(h.current.camRot,x.current.camRot,e),x.current.camUp&&u.up.set(0,1,0).applyQuaternion(u.quaternion),x.current.camZoom&&En(u)&&(u.zoom=(1-e)*h.current.camZoom+e*x.current.camZoom),u.updateMatrixWorld(),u.updateProjectionMatrix()}m()}})),P.createElement(\"group\",{ref:c},P.createElement(Cn.Provider,{value:z},e))}function Rn(){return P.useContext(Cn)}const Dn=P.forwardRef((({intensity:e=1,decay:t,decayRate:r=.65,maxYaw:n=.1,maxPitch:o=.1,maxRoll:i=.1,yawFrequency:s=.1,pitchFrequency:l=.1,rollFrequency:c=.1},u)=>{const m=a.useThree((e=>e.camera)),f=a.useThree((e=>e.controls)),p=P.useRef(e),h=P.useRef(m.rotation.clone()),[x]=P.useState((()=>new d.SimplexNoise)),[y]=P.useState((()=>new d.SimplexNoise)),[v]=P.useState((()=>new d.SimplexNoise)),g=()=>{(p.current<0||p.current>1)&&(p.current=p.current<0?0:1)};return P.useImperativeHandle(u,(()=>({getIntensity:()=>p.current,setIntensity:e=>{p.current=e,g()}})),[]),P.useEffect((()=>{if(f){const e=()=>{h.current=m.rotation.clone()};return f.addEventListener(\"change\",e),e(),()=>{f.removeEventListener(\"change\",e)}}}),[m,f]),a.useFrame(((e,a)=>{const u=Math.pow(p.current,2),d=n*u*x.noise(e.clock.elapsedTime*s,1),f=o*u*y.noise(e.clock.elapsedTime*l,1),z=i*u*v.noise(e.clock.elapsedTime*c,1);m.rotation.set(h.current.x+f,h.current.y+d,h.current.z+z),t&&p.current>0&&(p.current-=r*a,g())})),null})),Fn=P.forwardRef((({children:e,enabled:t=!0,speed:r=1,rotationIntensity:n=1,floatIntensity:o=1,floatingRange:i=[-.1,.1],...s},l)=>{const c=P.useRef(null),u=P.useRef(1e4*Math.random());return a.useFrame((e=>{var a,s;if(!t||0===r)return;const l=u.current+e.clock.getElapsedTime();c.current.rotation.x=Math.cos(l/4*r)/8*n,c.current.rotation.y=Math.sin(l/4*r)/8*n,c.current.rotation.z=Math.sin(l/4*r)/20*n;let d=Math.sin(l/4*r)/10;d=D.MathUtils.mapLinear(d,-.1,.1,null!==(a=null==i?void 0:i[0])&&void 0!==a?a:-.1,null!==(s=null==i?void 0:i[1])&&void 0!==s?s:.1),c.current.position.y=d*o,c.current.updateMatrix()})),P.createElement(\"group\",s,P.createElement(\"group\",{ref:k.default([c,l]),matrixAutoUpdate:!1},e))})),kn={apartment:\"lebombo_1k.hdr\",city:\"potsdamer_platz_1k.hdr\",dawn:\"kiara_1_dawn_1k.hdr\",forest:\"forest_slope_1k.hdr\",lobby:\"st_fagans_interior_1k.hdr\",night:\"dikhololo_night_1k.hdr\",park:\"rooitou_park_1k.hdr\",studio:\"studio_small_03_1k.hdr\",sunset:\"venice_sunset_1k.hdr\",warehouse:\"empty_warehouse_01_1k.hdr\"},_n=\"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\",An=e=>Array.isArray(e);function Ln({files:e=[\"/px.png\",\"/nx.png\",\"/py.png\",\"/ny.png\",\"/pz.png\",\"/nz.png\"],path:t=\"\",preset:r,encoding:o,extensions:i}={}){var s;let l,c=null,u=!1;if(r){if(!(r in kn))throw new Error(\"Preset must be one of: \"+Object.keys(kn).join(\", \"));e=kn[r],t=_n}if(u=An(e),l=An(e)?\"cube\":e.startsWith(\"data:application/exr\")?\"exr\":e.startsWith(\"data:application/hdr\")?\"hdr\":null==(s=e.split(\".\").pop())||null==(s=s.split(\"?\"))||null==(s=s.shift())?void 0:s.toLowerCase(),c=u?n.CubeTextureLoader:\"hdr\"===l?d.RGBELoader:\"exr\"===l?d.EXRLoader:null,!c)throw new Error(\"useEnvironment: Unrecognized file extension: \"+e);const m=a.useLoader(c,u?[e]:e,(e=>{null==e.setPath||e.setPath(t),i&&i(e)})),f=u?m[0]:m;f.mapping=u?n.CubeReflectionMapping:n.EquirectangularReflectionMapping;return\"colorSpace\"in f?f.colorSpace=(null!=o?o:u)?\"srgb\":\"srgb-linear\":f.encoding=(null!=o?o:u)?3001:3e3,f}const Bn=e=>{return(t=e).current&&t.current.isScene?e.current:e;var t};function Un(e,t,r,n,a=0){const o=Bn(t||r),i=o.background,s=o.environment,l=o.backgroundBlurriness||0;return\"only\"!==e&&(o.environment=n),e&&(o.background=n),e&&void 0!==o.backgroundBlurriness&&(o.backgroundBlurriness=a),()=>{\"only\"!==e&&(o.environment=s),e&&(o.background=i),e&&void 0!==o.backgroundBlurriness&&(o.backgroundBlurriness=l)}}function In({scene:e,background:t=!1,blur:r,map:n}){const o=a.useThree((e=>e.scene));return P.useLayoutEffect((()=>{if(n)return Un(t,e,o,n,r)}),[o,e,n,t,r]),null}function Vn({background:e=!1,scene:t,blur:r,...n}){const o=Ln(n),i=a.useThree((e=>e.scene));return P.useLayoutEffect((()=>Un(e,t,i,o,r)),[o,e,t,i,r]),null}function On({children:e,near:t=1,far:r=1e3,resolution:o=256,frames:i=1,map:s,background:l=!1,blur:c,scene:u,files:d,path:m,preset:f,extensions:p}){const h=a.useThree((e=>e.gl)),x=a.useThree((e=>e.scene)),y=P.useRef(null),[v]=P.useState((()=>new n.Scene)),g=P.useMemo((()=>{const e=new n.WebGLCubeRenderTarget(o);return e.texture.type=n.HalfFloatType,e}),[o]);P.useLayoutEffect((()=>(1===i&&y.current.update(h,v),Un(l,u,x,g.texture,c))),[e,v,g.texture,u,x,l,i,h]);let z=1;return a.useFrame((()=>{(i===1/0||z<i)&&(y.current.update(h,v),z++)})),P.createElement(P.Fragment,null,a.createPortal(P.createElement(P.Fragment,null,e,P.createElement(\"cubeCamera\",{ref:y,args:[t,r,g]}),d||f?P.createElement(Vn,{background:!0,files:d,preset:f,path:m,extensions:p}):s?P.createElement(In,{background:!0,map:s,extensions:p}):null),v))}function Nn(e){var t,r,n,o;const i=Ln(e),s=e.map||i;P.useMemo((()=>a.extend({GroundProjectedEnvImpl:d.GroundProjectedEnv})),[]);const l=P.useMemo((()=>[s]),[s]),c=null==(t=e.ground)?void 0:t.height,u=null==(r=e.ground)?void 0:r.radius,m=null!==(n=null==(o=e.ground)?void 0:o.scale)&&void 0!==n?n:1e3;return P.createElement(P.Fragment,null,P.createElement(In,C.default({},e,{map:s})),P.createElement(\"groundProjectedEnvImpl\",{args:l,scale:m,height:c,radius:u}))}function jn(e){return e.ground?P.createElement(Nn,e):e.map?P.createElement(In,e):e.children?P.createElement(On,e):P.createElement(Vn,e)}const Wn=P.forwardRef((({scale:e=10,frames:t=1/0,opacity:r=1,width:n=1,height:o=1,blur:i=1,near:s=0,far:l=10,resolution:c=512,smooth:u=!0,color:m=\"#000000\",depthWrite:f=!1,renderOrder:p,...h},x)=>{const y=P.useRef(null),v=a.useThree((e=>e.scene)),g=a.useThree((e=>e.gl)),z=P.useRef(null);n*=Array.isArray(e)?e[0]:e||1,o*=Array.isArray(e)?e[1]:e||1;const[w,b,M,E,S,T,R]=P.useMemo((()=>{const e=new D.WebGLRenderTarget(c,c),t=new D.WebGLRenderTarget(c,c);t.texture.generateMipmaps=e.texture.generateMipmaps=!1;const r=new D.PlaneGeometry(n,o).rotateX(Math.PI/2),a=new D.Mesh(r),i=new D.MeshDepthMaterial;i.depthTest=i.depthWrite=!1,i.onBeforeCompile=e=>{e.uniforms={...e.uniforms,ucolor:{value:new D.Color(m)}},e.fragmentShader=e.fragmentShader.replace(\"void main() {\",\"uniform vec3 ucolor;\\n           void main() {\\n          \"),e.fragmentShader=e.fragmentShader.replace(\"vec4( vec3( 1.0 - fragCoordZ ), opacity );\",\"vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );\")};const s=new D.ShaderMaterial(d.HorizontalBlurShader),l=new D.ShaderMaterial(d.VerticalBlurShader);return l.depthTest=s.depthTest=!1,[e,r,i,a,s,l,t]}),[c,n,o,e,m]),F=e=>{E.visible=!0,E.material=S,S.uniforms.tDiffuse.value=w.texture,S.uniforms.h.value=1*e/256,g.setRenderTarget(R),g.render(E,z.current),E.material=T,T.uniforms.tDiffuse.value=R.texture,T.uniforms.v.value=1*e/256,g.setRenderTarget(w),g.render(E,z.current),E.visible=!1};let k,_,A=0;return a.useFrame((()=>{z.current&&(t===1/0||A<t)&&(A++,k=v.background,_=v.overrideMaterial,y.current.visible=!1,v.background=null,v.overrideMaterial=M,g.setRenderTarget(w),g.render(v,z.current),F(i),u&&F(.4*i),g.setRenderTarget(null),y.current.visible=!0,v.overrideMaterial=_,v.background=k)})),P.useImperativeHandle(x,(()=>y.current),[]),P.createElement(\"group\",C.default({\"rotation-x\":Math.PI/2},h,{ref:y}),P.createElement(\"mesh\",{renderOrder:p,geometry:b,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},P.createElement(\"meshBasicMaterial\",{transparent:!0,map:w.texture,opacity:r,depthWrite:f})),P.createElement(\"orthographicCamera\",{ref:z,args:[-n/2,n/2,o/2,-o/2,s,l]}))}));const Gn=P.createContext(null),Hn=Ee({color:new D.Color,blend:2,alphaTest:.75,opacity:0,map:null},\"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vUv = uv;\\n   }\",`varying vec2 vUv;\\n   uniform sampler2D map;\\n   uniform vec3 color;\\n   uniform float opacity;\\n   uniform float alphaTest;\\n   uniform float blend;\\n   void main() {\\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\\n     #include <tonemapping_fragment>\\n     #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),$n=P.forwardRef((({children:e,temporal:t,frames:r=40,limit:n=1/0,blend:o=20,scale:i=10,opacity:s=1,alphaTest:l=.75,color:c=\"black\",colorBlend:u=2,resolution:d=1024,toneMapped:m=!0,...f},p)=>{a.extend({SoftShadowMaterial:Hn});const h=a.useThree((e=>e.gl)),x=a.useThree((e=>e.scene)),y=a.useThree((e=>e.camera)),v=a.useThree((e=>e.invalidate)),g=P.useRef(null),z=P.useRef(null),[w]=P.useState((()=>new Xn(h,x,d)));P.useLayoutEffect((()=>{w.configure(g.current)}),[]);const b=P.useMemo((()=>({lights:new Map,temporal:!!t,frames:Math.max(2,r),blend:Math.max(2,r===1/0?o:r),count:0,getMesh:()=>g.current,reset:()=>{w.clear();const e=g.current.material;e.opacity=0,e.alphaTest=0,b.count=0},update:(e=1)=>{const t=g.current.material;b.temporal?(t.opacity=Math.min(s,t.opacity+s/b.blend),t.alphaTest=Math.min(l,t.alphaTest+l/b.blend)):(t.opacity=s,t.alphaTest=l),z.current.visible=!0,w.prepare();for(let t=0;t<e;t++)b.lights.forEach((e=>e.update())),w.update(y,b.blend);z.current.visible=!1,w.finish()}})),[w,y,x,t,r,o,s,l]);return P.useLayoutEffect((()=>{b.reset(),b.temporal||b.frames===1/0||b.update(b.blend)})),P.useImperativeHandle(p,(()=>b),[b]),a.useFrame((()=>{(b.temporal||b.frames===1/0)&&b.count<b.frames&&b.count<n&&(v(),b.update(),b.count++)})),P.createElement(\"group\",f,P.createElement(\"group\",{traverse:()=>null,ref:z},P.createElement(Gn.Provider,{value:b},e)),P.createElement(\"mesh\",{receiveShadow:!0,ref:g,scale:i,rotation:[-Math.PI/2,0,0]},P.createElement(\"planeGeometry\",null),P.createElement(\"softShadowMaterial\",{transparent:!0,depthWrite:!1,toneMapped:m,color:c,blend:u,map:w.progressiveLightMap2.texture})))})),qn=P.forwardRef((({castShadow:e=!0,bias:t=.001,mapSize:r=512,size:n=5,near:a=.5,far:o=500,frames:i=1,position:s=[0,0,0],radius:l=1,amount:c=8,intensity:u=(Ce>=155?Math.PI:1),ambient:d=.5,...m},f)=>{const p=P.useRef(null),h=new D.Vector3(...s).length(),x=P.useContext(Gn),y=P.useCallback((()=>{let e;if(p.current)for(let t=0;t<p.current.children.length;t++)if(e=p.current.children[t],Math.random()>d)e.position.set(s[0]+D.MathUtils.randFloatSpread(l),s[1]+D.MathUtils.randFloatSpread(l),s[2]+D.MathUtils.randFloatSpread(l));else{let t=Math.acos(2*Math.random()-1)-Math.PI/2,r=2*Math.PI*Math.random();e.position.set(Math.cos(t)*Math.cos(r)*h,Math.abs(Math.cos(t)*Math.sin(r)*h),Math.sin(t)*h)}}),[l,d,h,...s]),v=P.useMemo((()=>({update:y})),[y]);return P.useImperativeHandle(f,(()=>v),[v]),P.useLayoutEffect((()=>{var e;const t=p.current;return x&&(null==(e=x.lights)||e.set(t.uuid,v)),()=>{var e;null==x||null==(e=x.lights)||e.delete(t.uuid)}}),[x,v]),P.createElement(\"group\",C.default({ref:p},m),Array.from({length:c},((i,s)=>P.createElement(\"directionalLight\",{key:s,castShadow:e,\"shadow-bias\":t,\"shadow-mapSize\":[r,r],intensity:u/c},P.createElement(\"orthographicCamera\",{attach:\"shadow-camera\",args:[-n,n,n,-n,a,o]})))))}));class Xn{constructor(e,t,r=1024){this.renderer=e,this.res=r,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new D.Color,this.clearAlpha=0;const n={type:D.HalfFloatType,magFilter:D.NearestFilter,minFilter:D.NearestFilter};this.progressiveLightMap1=new D.WebGLRenderTarget(this.res,this.res,n),this.progressiveLightMap2=new D.WebGLRenderTarget(this.res,this.res,n),this.discardMat=new Wr,this.targetMat=new D.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader=\"varying vec2 vUv;\\n\"+e.vertexShader.slice(0,-1)+\"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";const t=e.fragmentShader.indexOf(\"void main() {\");e.fragmentShader=\"varying vec2 vUv;\\n\"+e.fragmentShader.slice(0,t)+\"uniform sampler2D previousShadowMap;\\n\\tuniform float averagingWindow;\\n\"+e.fragmentShader.slice(t-1,-1)+\"\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\\n      }\",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor(\"black\",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse((e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})}))}prepare(){this.lights.forEach((e=>e.object.intensity=0)),this.meshes.forEach((e=>e.object.material=this.discardMat))}finish(){this.lights.forEach((e=>e.object.intensity=e.intensity)),this.meshes.forEach((e=>e.object.material=e.material))}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const r=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,n=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,a=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(r),this.previousShadowMap.value=n.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=a}}const Zn={rembrandt:{main:[1,2,1],fill:[-2,-.5,-2]},portrait:{main:[-1,2,.5],fill:[-1,.5,-1.5]},upfront:{main:[0,2,1],fill:[-1,.5,-1.5]},soft:{main:[-2,4,4],fill:[-1,.5,-1.5]}};function Yn({radius:e,adjustCamera:t}){const r=Rn();return P.useEffect((()=>{t&&r.refresh().clip().fit()}),[e,t]),null}const Qn=e=>0===e?0:Math.pow(2,10*e-10);const Kn=P.forwardRef((({fog:e=!1,renderOrder:t,depthWrite:r=!1,colorStop:a=0,color:o=\"black\",opacity:i=.5,...s},l)=>{const c=P.useMemo((()=>{const e=document.createElement(\"canvas\");e.width=128,e.height=128;const t=e.getContext(\"2d\"),r=t.createRadialGradient(e.width/2,e.height/2,0,e.width/2,e.height/2,e.width/2);return r.addColorStop(a,new n.Color(o).getStyle()),r.addColorStop(1,\"rgba(0,0,0,0)\"),t.fillStyle=r,t.fillRect(0,0,e.width,e.height),e}),[o,a]);return P.createElement(\"mesh\",C.default({renderOrder:t,ref:l,\"rotation-x\":-Math.PI/2},s),P.createElement(\"planeGeometry\",null),P.createElement(\"meshBasicMaterial\",{transparent:!0,opacity:i,fog:e,depthWrite:r,side:n.DoubleSide},P.createElement(\"canvasTexture\",{attach:\"map\",args:[c]})))}));function Jn(e=D.FrontSide){const t={value:new D.Matrix4};return Object.assign(new D.MeshNormalMaterial({side:e}),{viewMatrix:t,onBeforeCompile:e=>{e.uniforms.viewMatrix=t,e.fragmentShader=\"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n         }\\n\"+e.fragmentShader.replace(\"#include <normal_fragment_maps>\",\"#include <normal_fragment_maps>\\n           normal = inverseTransformDirection( normal, viewMatrix );\\n\")}})}const ea=Ee({causticsTexture:null,causticsTextureB:null,color:new D.Color,lightProjMatrix:new D.Matrix4,lightViewMatrix:new D.Matrix4},\"varying vec3 vWorldPosition;   \\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\\n     vWorldPosition = worldPosition.xyz;\\n   }\",`varying vec3 vWorldPosition;\\n  uniform vec3 color;\\n  uniform sampler2D causticsTexture; \\n  uniform sampler2D causticsTextureB; \\n  uniform mat4 lightProjMatrix;\\n  uniform mat4 lightViewMatrix;\\n   void main() {\\n    // Apply caustics  \\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\\n    lightSpacePos.xyz /= lightSpacePos.w;\\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\\n    gl_FragColor = vec4((front + back) * color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),ta=Ee({cameraMatrixWorld:new D.Matrix4,cameraProjectionMatrixInv:new D.Matrix4,normalTexture:null,depthTexture:null,lightDir:new D.Vector3(0,1,0),lightPlaneNormal:new D.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new D.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},\"\\n  varying vec2 vUv;\\n  void main() {\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n  }\",\"  \\n  uniform mat4 cameraMatrixWorld;\\n  uniform mat4 cameraProjectionMatrixInv;\\n  uniform vec3 lightDir;\\n  uniform vec3 lightPlaneNormal;\\n  uniform float lightPlaneConstant;\\n  uniform float near;\\n  uniform float far;\\n  uniform float time;\\n  uniform float worldRadius;\\n  uniform float resolution;\\n  uniform float size;\\n  uniform float intensity;\\n  uniform float ior;\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  uniform sampler2D normalTexture;\\n  uniform sampler2D depthTexture;\\n  uniform float bounces;\\n  varying vec2 vUv;\\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\\n    float z = depth * 2.0 - 1.0;\\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\\n    return worldSpacePosition.xyz;\\n  }                  \\n  float sdPlane( vec3 p, vec3 n, float h ) {\\n    // n must be normalized\\n    return dot(p,n) + h;\\n  }\\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\n  }\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\\n    rayOrigin = ro;\\n    rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = pos + rayDirection * 0.1;\\n    return rayDirection;\\n  }\\n  void main() {\\n    // Each sample consists of random offset in the x and y direction\\n    float caustic = 0.0;\\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\\n    float texelsNeeded = worldRadius / causticTexelSize;\\n    float sampleRadius = texelsNeeded / resolution;\\n    float sum = 0.0;\\n    if (texture2D(depthTexture, vUv).x == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 uv1 = vUv + offset1 * sampleRadius;\\n    vec2 uv2 = vUv + offset2 * sampleRadius;\\n    vec2 uv3 = vUv + offset3 * sampleRadius;\\n    vec2 uv4 = vUv + offset4 * sampleRadius;\\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\\n    // Sanity check the depths\\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\\n    vec3 endPos1, endPos2, endPos3, endPos4;\\n    vec3 endDir1, endDir2, endDir3, endDir4;\\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\\n    caustic += intensity * (lightPosArea / finalArea);\\n    // Calculate the area of the triangle in light spaces\\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\\n  }\"),ra={depth:!0,minFilter:D.LinearFilter,magFilter:D.LinearFilter,type:D.UnsignedByteType},na={minFilter:D.LinearMipmapLinearFilter,magFilter:D.LinearFilter,type:D.FloatType,generateMipmaps:!0},aa=P.forwardRef((({debug:e,children:t,frames:r=1,ior:n=1.1,color:o=\"white\",causticsOnly:i=!1,backside:s=!1,backsideIOR:l=1.1,worldRadius:c=.3125,intensity:u=.05,resolution:m=2024,lightSource:f=[5,5,5],...p},h)=>{a.extend({CausticsProjectionMaterial:ea});const x=P.useRef(null),y=P.useRef(null),v=P.useRef(null),g=P.useRef(null),z=a.useThree((e=>e.gl)),w=vr(e&&y,D.CameraHelper),b=nt(m,m,ra),M=nt(m,m,ra),E=nt(m,m,na),S=nt(m,m,na),[T]=P.useState((()=>Jn())),[R]=P.useState((()=>Jn(D.BackSide))),[F]=P.useState((()=>new ta)),[k]=P.useState((()=>new d.FullScreenQuad(F)));P.useLayoutEffect((()=>{x.current.updateWorldMatrix(!1,!0)}));let _=0;const A=new D.Vector3,L=new D.Frustum,B=new D.Matrix4,U=new D.Plane,I=new D.Vector3,V=new D.Vector3,O=new D.Box3,N=new D.Vector3,j=[],W=[],G=[],H=[],$=new D.Vector3;for(let e=0;e<8;e++)j.push(new D.Vector3),W.push(new D.Vector3),G.push(new D.Vector3),H.push(new D.Vector3);return a.useFrame((()=>{if(r===1/0||_++<r){var t,a;Array.isArray(f)?I.fromArray(f).normalize():I.copy(x.current.worldToLocal(f.current.getWorldPosition(A)).normalize()),V.copy(I).multiplyScalar(-1),null==(t=v.current.parent)||t.matrixWorld.identity(),O.setFromObject(v.current,!0),j[0].set(O.min.x,O.min.y,O.min.z),j[1].set(O.min.x,O.min.y,O.max.z),j[2].set(O.min.x,O.max.y,O.min.z),j[3].set(O.min.x,O.max.y,O.max.z),j[4].set(O.max.x,O.min.y,O.min.z),j[5].set(O.max.x,O.min.y,O.max.z),j[6].set(O.max.x,O.max.y,O.min.z),j[7].set(O.max.x,O.max.y,O.max.z);for(let e=0;e<8;e++)W[e].copy(j[e]);O.getCenter(N),j.map((e=>e.sub(N)));const r=U.set(V,0);j.map(((e,t)=>r.projectPoint(e,G[t])));const o=G.reduce(((e,t)=>e.add(t)),A.set(0,0,0)).divideScalar(G.length),d=G.map((e=>e.distanceTo(o))).reduce(((e,t)=>Math.max(e,t))),p=j.map((e=>e.dot(I))).reduce(((e,t)=>Math.max(e,t)));y.current.position.copy($.copy(I).multiplyScalar(p).add(N)),y.current.lookAt(v.current.localToWorld(N));const h=B.lookAt(y.current.position,N,A.set(0,1,0));y.current.left=-d,y.current.right=d,y.current.top=d,y.current.bottom=-d;const C=A.set(0,d,0).applyMatrix4(h),P=(y.current.position.y+C.y)/I.y;y.current.near=.1,y.current.far=P,y.current.updateProjectionMatrix(),y.current.updateMatrixWorld();const D=W.map(((e,t)=>e.add(H[t].copy(I).multiplyScalar(-e.y/I.y)))),_=D.reduce(((e,t)=>e.add(t)),A.set(0,0,0)).divideScalar(D.length),q=2*D.map((e=>Math.hypot(e.x-_.x,e.z-_.z))).reduce(((e,t)=>Math.max(e,t)));g.current.scale.setScalar(q),g.current.position.copy(_),e&&(null==(a=w.current)||a.update()),R.viewMatrix.value=T.viewMatrix.value=y.current.matrixWorldInverse;const X=L.setFromProjectionMatrix(B.multiplyMatrices(y.current.projectionMatrix,y.current.matrixWorldInverse)).planes[4];F.cameraMatrixWorld=y.current.matrixWorld,F.cameraProjectionMatrixInv=y.current.projectionMatrixInverse,F.lightDir=V,F.lightPlaneNormal=X.normal,F.lightPlaneConstant=X.constant,F.near=y.current.near,F.far=y.current.far,F.resolution=m,F.size=d,F.intensity=u,F.worldRadius=c,v.current.visible=!0,z.setRenderTarget(b),z.clear(),v.current.overrideMaterial=T,z.render(v.current,y.current),z.setRenderTarget(M),z.clear(),s&&(v.current.overrideMaterial=R,z.render(v.current,y.current)),v.current.overrideMaterial=null,F.ior=n,g.current.material.lightProjMatrix=y.current.projectionMatrix,g.current.material.lightViewMatrix=y.current.matrixWorldInverse,F.normalTexture=b.texture,F.depthTexture=b.depthTexture,z.setRenderTarget(E),z.clear(),k.render(z),F.ior=l,F.normalTexture=M.texture,F.depthTexture=M.depthTexture,z.setRenderTarget(S),z.clear(),s&&k.render(z),z.setRenderTarget(null),i&&(v.current.visible=!1)}})),P.useImperativeHandle(h,(()=>x.current),[]),P.createElement(\"group\",C.default({ref:x},p),P.createElement(\"scene\",{ref:v},P.createElement(\"orthographicCamera\",{ref:y,up:[0,1,0]}),t),P.createElement(\"mesh\",{renderOrder:2,ref:g,\"rotation-x\":-Math.PI/2},P.createElement(\"planeGeometry\",null),P.createElement(\"causticsProjectionMaterial\",{transparent:!0,color:o,causticsTexture:E.texture,causticsTextureB:S.texture,blending:D.CustomBlending,blendSrc:D.OneFactor,blendDst:D.SrcAlphaFactor,depthWrite:!1}),e&&P.createElement(_e,null,P.createElement(\"lineBasicMaterial\",{color:\"#ffff00\",toneMapped:!1}))))})),oa=P.forwardRef((({mixBlur:e=0,mixStrength:t=.5,resolution:r=256,blur:o=[0,0],args:i=[1,1],minDepthThreshold:s=.9,maxDepthThreshold:l=1,depthScale:c=0,depthToBlurRatioBias:u=.25,mirror:d=0,children:m,debug:f=0,distortion:p=1,mixContrast:h=1,distortionMap:x,...y},v)=>{a.extend({MeshReflectorMaterial:Or}),P.useEffect((()=>{console.warn(\"Reflector has been deprecated and will be removed next major. Replace it with <MeshReflectorMaterial />!\")}),[]);const g=a.useThree((({gl:e})=>e)),z=a.useThree((({camera:e})=>e)),w=a.useThree((({scene:e})=>e)),b=(o=Array.isArray(o)?o:[o,o])[0]+o[1]>0,M=P.useRef(null),[E]=P.useState((()=>new n.Plane)),[S]=P.useState((()=>new n.Vector3)),[T]=P.useState((()=>new n.Vector3)),[R]=P.useState((()=>new n.Vector3)),[D]=P.useState((()=>new n.Matrix4)),[F]=P.useState((()=>new n.Vector3(0,0,-1))),[_]=P.useState((()=>new n.Vector4)),[A]=P.useState((()=>new n.Vector3)),[L]=P.useState((()=>new n.Vector3)),[B]=P.useState((()=>new n.Vector4)),[U]=P.useState((()=>new n.Matrix4)),[I]=P.useState((()=>new n.PerspectiveCamera)),V=P.useCallback((()=>{if(T.setFromMatrixPosition(M.current.matrixWorld),R.setFromMatrixPosition(z.matrixWorld),D.extractRotation(M.current.matrixWorld),S.set(0,0,1),S.applyMatrix4(D),A.subVectors(T,R),A.dot(S)>0)return;A.reflect(S).negate(),A.add(T),D.extractRotation(z.matrixWorld),F.set(0,0,-1),F.applyMatrix4(D),F.add(R),L.subVectors(T,F),L.reflect(S).negate(),L.add(T),I.position.copy(A),I.up.set(0,1,0),I.up.applyMatrix4(D),I.up.reflect(S),I.lookAt(L),I.far=z.far,I.updateMatrixWorld(),I.projectionMatrix.copy(z.projectionMatrix),U.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),U.multiply(I.projectionMatrix),U.multiply(I.matrixWorldInverse),U.multiply(M.current.matrixWorld),E.setFromNormalAndCoplanarPoint(S,T),E.applyMatrix4(I.matrixWorldInverse),_.set(E.normal.x,E.normal.y,E.normal.z,E.constant);const e=I.projectionMatrix;B.x=(Math.sign(_.x)+e.elements[8])/e.elements[0],B.y=(Math.sign(_.y)+e.elements[9])/e.elements[5],B.z=-1,B.w=(1+e.elements[10])/e.elements[14],_.multiplyScalar(2/_.dot(B)),e.elements[2]=_.x,e.elements[6]=_.y,e.elements[10]=_.z+1,e.elements[14]=_.w}),[]),[O,N,j,W]=P.useMemo((()=>{const a={type:n.HalfFloatType,minFilter:n.LinearFilter,magFilter:n.LinearFilter},i=new n.WebGLRenderTarget(r,r,a);i.depthBuffer=!0,i.depthTexture=new n.DepthTexture(r,r),i.depthTexture.format=n.DepthFormat,i.depthTexture.type=n.UnsignedShortType;const m=new n.WebGLRenderTarget(r,r,a);return[i,m,new Vr({gl:g,resolution:r,width:o[0],height:o[1],minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u}),{mirror:d,textureMatrix:U,mixBlur:e,tDiffuse:i.texture,tDepth:i.depthTexture,tDiffuseBlur:m.texture,hasBlur:b,mixStrength:t,minDepthThreshold:s,maxDepthThreshold:l,depthScale:c,depthToBlurRatioBias:u,transparent:!0,debug:f,distortion:p,distortionMap:x,mixContrast:h,\"defines-USE_BLUR\":b?\"\":void 0,\"defines-USE_DEPTH\":c>0?\"\":void 0,\"defines-USE_DISTORTION\":x?\"\":void 0}]}),[g,o,U,r,d,b,e,t,s,l,c,u,f,p,x,h]);return a.useFrame((()=>{if(null==M||!M.current)return;M.current.visible=!1;const e=g.xr.enabled,t=g.shadowMap.autoUpdate;V(),g.xr.enabled=!1,g.shadowMap.autoUpdate=!1,g.setRenderTarget(O),g.state.buffers.depth.setMask(!0),g.autoClear||g.clear(),g.render(w,I),b&&j.render(g,O,N),g.xr.enabled=e,g.shadowMap.autoUpdate=t,M.current.visible=!0,g.setRenderTarget(null)})),P.createElement(\"mesh\",C.default({ref:k.default([M,v])},y),P.createElement(\"planeGeometry\",{args:i}),m?m(\"meshReflectorMaterial\",W):P.createElement(\"meshReflectorMaterial\",W))}));class ia extends D.ShaderMaterial{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new D.Vector3(0,0,0)},lightColor:{value:new D.Color(\"white\")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new D.Vector2(0,0)}},transparent:!0,depthWrite:!1,vertexShader:\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n        uniform vec3 spotPosition;\\n        uniform float attenuation;\\n\\n        #include <common>\\n        #include <logdepthbuf_pars_vertex>\\n\\n        void main() {\\n          // compute intensity\\n          vNormal = normalize(normalMatrix * normal);\\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\\n          vec4 viewPosition = viewMatrix * worldPosition;\\n          vViewZ = viewPosition.z;\\n\\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\\n\\n          gl_Position = projectionMatrix * viewPosition;\\n\\n          #include <logdepthbuf_vertex>\\n        }\\n      \",fragmentShader:`\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n\\n        uniform vec3 lightColor;\\n        uniform float anglePower;\\n        uniform sampler2D depth;\\n        uniform vec2 resolution;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float opacity;\\n\\n        #include <packing>\\n        #include <logdepthbuf_pars_fragment>\\n\\n        float readDepth(sampler2D depthSampler, vec2 uv) {\\n          float fragCoordZ = texture(depthSampler, uv).r;\\n\\n          // https://github.com/mrdoob/three.js/issues/23072\\n          #ifdef USE_LOGDEPTHBUF\\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\\n          #else\\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n          #endif\\n\\n          return viewZ;\\n        }\\n\\n        void main() {\\n          #include <logdepthbuf_fragment>\\n\\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\\n          float intensity = vIntensity * angleIntensity;\\n\\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\n          if (isSoft) {\\n            vec2 uv = gl_FragCoord.xy / resolution;\\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\\n          }\\n\\n          gl_FragColor = vec4(lightColor, intensity * opacity);\\n\\n          #include <tonemapping_fragment>\\n          #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n        }\\n      `})}}var sa=\"#define GLSLIFY 1\\nvarying vec2 vUv;uniform sampler2D uShadowMap;uniform float uTime;void main(){vec3 color=texture2D(uShadowMap,vUv).xyz;gl_FragColor=vec4(color,1.);}\";const la=e=>null==e?void 0:e.isSpotLight;function ca({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:o,color:i=\"white\",distance:s=5,angle:l=.15,attenuation:c=5,anglePower:u=5}){const d=P.useRef(null),m=a.useThree((e=>e.size)),f=a.useThree((e=>e.camera)),p=a.useThree((e=>e.viewport.dpr)),[h]=P.useState((()=>new ia)),[x]=P.useState((()=>new n.Vector3));t=void 0===t?.1:t,r=void 0===r?7*l:r,a.useFrame((()=>{h.uniforms.spotPosition.value.copy(d.current.getWorldPosition(x)),d.current.lookAt(d.current.parent.target.getWorldPosition(x))}));const y=P.useMemo((()=>{const e=new n.CylinderGeometry(t,r,s,128,64,!0);return e.applyMatrix4((new n.Matrix4).makeTranslation(0,-s/2,0)),e.applyMatrix4((new n.Matrix4).makeRotationX(-Math.PI/2)),e}),[s,t,r]);return P.createElement(P.Fragment,null,P.createElement(\"mesh\",{ref:d,geometry:y,raycast:()=>null},P.createElement(\"primitive\",{object:h,attach:\"material\",\"uniforms-opacity-value\":e,\"uniforms-lightColor-value\":i,\"uniforms-attenuation-value\":c,\"uniforms-anglePower-value\":u,\"uniforms-depth-value\":o,\"uniforms-cameraNear-value\":f.near,\"uniforms-cameraFar-value\":f.far,\"uniforms-resolution-value\":o?[m.width*p,m.height*p]:[0,0]})))}function ua(e,t,r,o,i){const[[s,l]]=P.useState((()=>[new n.Vector3,new n.Vector3]));P.useLayoutEffect((()=>{if(!la(e.current))throw new Error(\"SpotlightShadow must be a child of a SpotLight\");e.current.shadow.mapSize.set(r,o),e.current.shadow.needsUpdate=!0}),[e,r,o]),a.useFrame((()=>{if(!e.current)return;const r=e.current.position,n=e.current.target.position;l.copy(n).sub(r);var a=l.length();l.normalize().multiplyScalar(a*i),s.copy(r).add(l),t.current.position.copy(s),t.current.lookAt(e.current.target.position)}))}function da({distance:e=.4,alphaTest:t=.5,map:r,shader:o=sa,width:i=512,height:s=512,scale:l=1,children:c,...u}){const m=P.useRef(null),f=u.spotlightRef,p=u.debug;ua(f,m,i,s,e);const h=P.useMemo((()=>new n.WebGLRenderTarget(i,s,{format:n.RGBAFormat,encoding:n.LinearEncoding,stencilBuffer:!1})),[i,s]),x=P.useRef({uShadowMap:{value:r},uTime:{value:0}});P.useEffect((()=>{x.current.uShadowMap.value=r}),[r]);const y=P.useMemo((()=>new d.FullScreenQuad(new n.ShaderMaterial({uniforms:x.current,vertexShader:\"\\n          varying vec2 vUv;\\n\\n          void main() {\\n            vUv = uv;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          }\\n          \",fragmentShader:o}))),[o]);return P.useEffect((()=>()=>{y.material.dispose(),y.dispose()}),[y]),P.useEffect((()=>()=>h.dispose()),[h]),a.useFrame((({gl:e},t)=>{x.current.uTime.value+=t,e.setRenderTarget(h),y.render(e),e.setRenderTarget(null)})),P.createElement(P.Fragment,null,P.createElement(\"mesh\",{ref:m,scale:l,castShadow:!0},P.createElement(\"planeGeometry\",null),P.createElement(\"meshBasicMaterial\",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:h.texture,\"alphaMap-wrapS\":n.RepeatWrapping,\"alphaMap-wrapT\":n.RepeatWrapping,opacity:p?1:0},c)))}function ma({distance:e=.4,alphaTest:t=.5,map:r,width:a=512,height:o=512,scale:i,children:s,...l}){const c=P.useRef(null),u=l.spotlightRef,d=l.debug;return ua(u,c,a,o,e),P.createElement(P.Fragment,null,P.createElement(\"mesh\",{ref:c,scale:i,castShadow:!0},P.createElement(\"planeGeometry\",null),P.createElement(\"meshBasicMaterial\",{transparent:!0,side:n.DoubleSide,alphaTest:t,alphaMap:r,\"alphaMap-wrapS\":n.RepeatWrapping,\"alphaMap-wrapT\":n.RepeatWrapping,opacity:d?1:0},s)))}const fa=P.forwardRef((({opacity:e=1,radiusTop:t,radiusBottom:r,depthBuffer:n,color:a=\"white\",distance:o=5,angle:i=.15,attenuation:s=5,anglePower:l=5,volumetric:c=!0,debug:u=!1,children:d,...m},f)=>{const p=P.useRef(null);return P.createElement(\"group\",null,u&&p.current&&P.createElement(\"spotLightHelper\",{args:[p.current]}),P.createElement(\"spotLight\",C.default({ref:k.default([f,p]),angle:i,color:a,distance:o,castShadow:!0},m),c&&P.createElement(ca,{debug:u,opacity:e,radiusTop:t,radiusBottom:r,depthBuffer:n,color:a,distance:o,angle:i,attenuation:s,anglePower:l})),d&&P.cloneElement(d,{spotlightRef:p,debug:u}))})),pa=P.forwardRef((({args:e,map:t,toneMapped:r=!1,color:n=\"white\",form:o=\"rect\",intensity:i=1,scale:s=1,target:l,children:c,...u},d)=>{const m=P.useRef(null);return P.useLayoutEffect((()=>{c||u.material||(a.applyProps(m.current.material,{color:n}),m.current.material.color.multiplyScalar(i))}),[n,i,c,u.material]),P.useLayoutEffect((()=>{l&&m.current.lookAt(Array.isArray(l)?new D.Vector3(...l):l)}),[l]),s=Array.isArray(s)&&2===s.length?[s[0],s[1],1]:s,P.createElement(\"mesh\",C.default({ref:k.default([m,d]),scale:s},u),\"circle\"===o?P.createElement(\"ringGeometry\",{args:[0,1,64]}):\"ring\"===o?P.createElement(\"ringGeometry\",{args:[.5,1,64]}):\"rect\"===o?P.createElement(\"planeGeometry\",null):P.createElement(o,{args:e}),c||(u.material?null:P.createElement(\"meshBasicMaterial\",{toneMapped:r,map:t,side:D.DoubleSide})))}));function ha(e,t,r=new n.Vector3){const a=Math.PI*(e-.5),o=2*Math.PI*(t-.5);return r.x=Math.cos(o),r.y=Math.sin(a),r.z=Math.sin(o),r}const xa=P.forwardRef((({inclination:e=.6,azimuth:t=.1,distance:r=1e3,mieCoefficient:a=.005,mieDirectionalG:o=.8,rayleigh:i=.5,turbidity:s=10,sunPosition:l=ha(e,t),...c},u)=>{const m=P.useMemo((()=>(new n.Vector3).setScalar(r)),[r]),[f]=P.useState((()=>new d.Sky));return P.createElement(\"primitive\",C.default({object:f,ref:u,\"material-uniforms-mieCoefficient-value\":a,\"material-uniforms-mieDirectionalG-value\":o,\"material-uniforms-rayleigh-value\":i,\"material-uniforms-sunPosition-value\":l,\"material-uniforms-turbidity-value\":s,scale:m},c))}));class ya extends n.ShaderMaterial{constructor(){super({uniforms:{time:{value:0},fade:{value:1}},vertexShader:\"\\n      uniform float time;\\n      attribute float size;\\n      varying vec3 vColor;\\n      void main() {\\n        vColor = color;\\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(time + 100.0));\\n        gl_Position = projectionMatrix * mvPosition;\\n      }\",fragmentShader:`\\n      uniform sampler2D pointTexture;\\n      uniform float fade;\\n      varying vec3 vColor;\\n      void main() {\\n        float opacity = 1.0;\\n        if (fade == 1.0) {\\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\\n        }\\n        gl_FragColor = vec4(vColor, opacity);\\n\\n        #include <tonemapping_fragment>\\n\\t      #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n      }`})}}const va=e=>(new n.Vector3).setFromSpherical(new n.Spherical(e,Math.acos(1-2*Math.random()),2*Math.random()*Math.PI)),ga=P.forwardRef((({radius:e=100,depth:t=50,count:r=5e3,saturation:o=0,factor:i=4,fade:s=!1,speed:l=1},c)=>{const u=P.useRef(),[d,m,f]=P.useMemo((()=>{const a=[],s=[],l=Array.from({length:r},(()=>(.5+.5*Math.random())*i)),c=new n.Color;let u=e+t;const d=t/r;for(let e=0;e<r;e++)u-=d*Math.random(),a.push(...va(u).toArray()),c.setHSL(e/r,o,.9),s.push(c.r,c.g,c.b);return[new Float32Array(a),new Float32Array(s),new Float32Array(l)]}),[r,t,i,e,o]);a.useFrame((e=>u.current&&(u.current.uniforms.time.value=e.clock.getElapsedTime()*l)));const[p]=P.useState((()=>new ya));return P.createElement(\"points\",{ref:c},P.createElement(\"bufferGeometry\",null,P.createElement(\"bufferAttribute\",{attach:\"attributes-position\",args:[d,3]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-color\",args:[m,3]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-size\",args:[f,1]})),P.createElement(\"primitive\",{ref:u,object:p,attach:\"material\",blending:n.AdditiveBlending,\"uniforms-fade-value\":s,depthWrite:!1,transparent:!0,vertexColors:!0}))})),za=(e,t)=>{\"updateRanges\"in e?e.updateRanges[0]=t:e.updateRange=t},wa=new n.Matrix4,ba=new n.Vector3,Ma=new n.Quaternion,Ea=new n.Vector3,Sa=new n.Quaternion,Ta=new n.Vector3,Ca=P.createContext(null),Pa=P.forwardRef((({children:e,material:t=n.MeshLambertMaterial,texture:r=\"https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png\",range:o,limit:i=200,...s},l)=>{var c,u;const d=P.useMemo((()=>class extends t{constructor(){super();const e=parseInt(n.REVISION.replace(/\\D+/g,\"\"))>=154?\"opaque_fragment\":\"output_fragment\";this.onBeforeCompile=t=>{t.vertexShader=\"attribute float opacity;\\n               varying float vOpacity;\\n              \"+t.vertexShader.replace(\"#include <fog_vertex>\",\"#include <fog_vertex>\\n                 vOpacity = opacity;\\n                \"),t.fragmentShader=\"varying float vOpacity;\\n              \"+t.fragmentShader.replace(`#include <${e}>`,`#include <${e}>\\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\\n                `)}}}),[t]);a.extend({CloudMaterial:d});const m=P.useRef(null),f=P.useRef([]),p=P.useMemo((()=>new Float32Array(Array.from({length:i},(()=>1)))),[i]),h=P.useMemo((()=>new Float32Array(Array.from({length:i},(()=>[1,1,1])).flat())),[i]),x=Te(r);let y,v=0,g=0;const z=new n.Quaternion,w=new n.Vector3(0,0,1),b=new n.Vector3;a.useFrame(((e,t)=>{for(v=e.clock.getElapsedTime(),wa.copy(m.current.matrixWorld).invert(),e.camera.matrixWorld.decompose(Ea,Sa,Ta),g=0;g<f.current.length;g++)y=f.current[g],y.ref.current.matrixWorld.decompose(ba,Ma,Ta),ba.add(b.copy(y.position).applyQuaternion(Ma).multiply(Ta)),Ma.copy(Sa).multiply(z.setFromAxisAngle(w,y.rotation+=t*y.rotationFactor)),Ta.multiplyScalar(y.volume+(1+Math.sin(v*y.density*y.speed))/2*y.growth),y.matrix.compose(ba,Ma,Ta).premultiply(wa),y.dist=ba.distanceTo(Ea);for(f.current.sort(((e,t)=>t.dist-e.dist)),g=0;g<f.current.length;g++)y=f.current[g],p[g]=y.opacity*(y.dist<y.fade-1?y.dist/y.fade:1),m.current.setMatrixAt(g,y.matrix),m.current.setColorAt(g,y.color);m.current.geometry.attributes.opacity.needsUpdate=!0,m.current.instanceMatrix.needsUpdate=!0,m.current.instanceColor&&(m.current.instanceColor.needsUpdate=!0)})),P.useLayoutEffect((()=>{const e=Math.min(i,void 0!==o?o:i,f.current.length);m.current.count=e,za(m.current.instanceMatrix,{offset:0,count:16*e}),m.current.instanceColor&&za(m.current.instanceColor,{offset:0,count:3*e}),za(m.current.geometry.attributes.opacity,{offset:0,count:e})}));let M=[null!==(c=x.image.width)&&void 0!==c?c:1,null!==(u=x.image.height)&&void 0!==u?u:1],E=Math.max(M[0],M[1]);return M=[M[0]/E,M[1]/E],P.createElement(\"group\",C.default({ref:l},s),P.createElement(Ca.Provider,{value:f},e,P.createElement(\"instancedMesh\",{matrixAutoUpdate:!1,ref:m,args:[null,null,i]},P.createElement(\"instancedBufferAttribute\",{usage:n.DynamicDrawUsage,attach:\"instanceColor\",args:[h,3]}),P.createElement(\"planeGeometry\",{args:[...M]},P.createElement(\"instancedBufferAttribute\",{usage:n.DynamicDrawUsage,attach:\"attributes-opacity\",args:[p,1]})),P.createElement(\"cloudMaterial\",{key:t.name,map:x,transparent:!0,depthWrite:!1}))))})),Ra=P.forwardRef((({opacity:e=1,speed:t=0,bounds:r=[5,1,1],segments:o=20,color:i=\"#ffffff\",fade:s=10,volume:l=6,smallestVolume:c=.25,distribute:u=null,growth:d=4,concentrate:m=\"inside\",seed:f=Math.random(),...p},h)=>{function x(){const e=1e4*Math.sin(f++);return e-Math.floor(e)}const y=P.useContext(Ca),v=P.useRef(null),[g]=P.useState((()=>b.v4())),z=P.useMemo((()=>[...new Array(o)].map(((e,t)=>({segments:o,bounds:new n.Vector3(1,1,1),position:new n.Vector3,uuid:g,index:t,ref:v,dist:0,matrix:new n.Matrix4,color:new n.Color,rotation:t*(Math.PI/o)})))),[o,g]);return P.useLayoutEffect((()=>{z.forEach(((n,f)=>{var p;a.applyProps(n,{volume:l,color:i,speed:t,growth:d,opacity:e,fade:s,bounds:r,density:Math.max(.5,x()),rotationFactor:Math.max(.2,.5*x())*t});const h=null==u?void 0:u(n,f);(h||o>1)&&n.position.copy(n.bounds).multiply(null!==(p=null==h?void 0:h.point)&&void 0!==p?p:{x:2*x()-1,y:2*x()-1,z:2*x()-1});const y=Math.abs(n.position.x),v=Math.abs(n.position.y),g=Math.abs(n.position.z),z=Math.max(y,v,g);n.length=1,y===z&&(n.length-=y/n.bounds.x),v===z&&(n.length-=v/n.bounds.y),g===z&&(n.length-=g/n.bounds.z),n.volume=(void 0!==(null==h?void 0:h.volume)?h.volume:Math.max(Math.max(0,c),\"random\"===m?x():\"inside\"===m?n.length:1-n.length))*l}))}),[m,r,s,i,e,d,l,f,o,t]),P.useLayoutEffect((()=>{const e=z;return y.current=[...y.current,...e],()=>{y.current=y.current.filter((e=>e.uuid!==g))}}),[z]),P.useImperativeHandle(h,(()=>v.current),[]),P.createElement(\"group\",C.default({ref:v},p))})),Da=P.forwardRef(((e,t)=>P.useContext(Ca)?P.createElement(Ra,C.default({ref:t},e)):P.createElement(Pa,null,P.createElement(Ra,C.default({ref:t},e))))),Fa=Ee({time:0,pixelRatio:1},\" uniform float pixelRatio;\\n    uniform float time;\\n    attribute float size;  \\n    attribute float speed;  \\n    attribute float opacity;\\n    attribute vec3 noise;\\n    attribute vec3 color;\\n    varying vec3 vColor;\\n    varying float vOpacity;\\n    void main() {\\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\\n      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;\\n      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;\\n      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;\\n      vec4 viewPosition = viewMatrix * modelPosition;\\n      vec4 projectionPostion = projectionMatrix * viewPosition;\\n      gl_Position = projectionPostion;\\n      gl_PointSize = size * 25. * pixelRatio;\\n      gl_PointSize *= (1.0 / - viewPosition.z);\\n      vColor = color;\\n      vOpacity = opacity;\\n    }\",` varying vec3 vColor;\\n    varying float vOpacity;\\n    void main() {\\n      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\\n      float strength = 0.05 / distanceToCenter - 0.1;\\n      gl_FragColor = vec4(vColor, strength * vOpacity);\\n      #include <tonemapping_fragment>\\n      #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n    }`),ka=e=>e&&e.constructor===Float32Array,_a=e=>e instanceof D.Vector2||e instanceof D.Vector3||e instanceof D.Vector4,Aa=e=>Array.isArray(e)?e:_a(e)?e.toArray():[e,e,e];function La(e,t,r){return P.useMemo((()=>{if(void 0!==t){if(ka(t))return t;if(t instanceof D.Color){const r=Array.from({length:3*e},(()=>(e=>[e.r,e.g,e.b])(t))).flat();return Float32Array.from(r)}if(_a(t)||Array.isArray(t)){const r=Array.from({length:3*e},(()=>Aa(t))).flat();return Float32Array.from(r)}return Float32Array.from({length:e},(()=>t))}return Float32Array.from({length:e},r)}),[t])}const Ba=P.forwardRef((({noise:e=1,count:t=100,speed:r=1,opacity:n=1,scale:o=1,size:i,color:s,children:l,...c},u)=>{P.useMemo((()=>a.extend({SparklesImplMaterial:Fa})),[]);const d=P.useRef(null),m=a.useThree((e=>e.viewport.dpr)),f=Aa(o),p=P.useMemo((()=>Float32Array.from(Array.from({length:t},(()=>f.map(D.MathUtils.randFloatSpread))).flat())),[t,...f]),h=La(t,i,Math.random),x=La(t,n),y=La(t,r),v=La(3*t,e),g=La(void 0===s?3*t:t,ka(s)?s:new D.Color(s),(()=>1));return a.useFrame((e=>{d.current&&d.current.material&&(d.current.material.time=e.clock.elapsedTime)})),P.useImperativeHandle(u,(()=>d.current),[]),P.createElement(\"points\",C.default({key:`particle-${t}-${JSON.stringify(o)}`},c,{ref:d}),P.createElement(\"bufferGeometry\",null,P.createElement(\"bufferAttribute\",{attach:\"attributes-position\",args:[p,3]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-size\",args:[h,1]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-opacity\",args:[x,1]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-speed\",args:[y,1]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-color\",args:[g,3]}),P.createElement(\"bufferAttribute\",{attach:\"attributes-noise\",args:[v,3]})),l||P.createElement(\"sparklesImplMaterial\",{transparent:!0,pixelRatio:m,depthWrite:!1}))}));const Ua={uniforms:{strokeOpacity:1,fillOpacity:.25,fillMix:0,thickness:.05,colorBackfaces:!1,dashInvert:!0,dash:!1,dashRepeats:4,dashLength:.5,squeeze:!1,squeezeMin:.2,squeezeMax:1,stroke:new D.Color(\"#ff0000\"),backfaceStroke:new D.Color(\"#0000ff\"),fill:new D.Color(\"#00ff00\")},vertex:\"\\n\\t  attribute vec3 barycentric;\\n\\t\\n\\t\\tvarying vec3 v_edges_Barycentric;\\n\\t\\tvarying vec3 v_edges_Position;\\n\\n\\t\\tvoid initWireframe() {\\n\\t\\t\\tv_edges_Barycentric = barycentric;\\n\\t\\t\\tv_edges_Position = position.xyz;\\n\\t\\t}\\n\\t  \",fragment:\"\\n\\t\\t#ifndef PI\\n\\t  \\t#define PI 3.1415926535897932384626433832795\\n\\t\\t#endif\\n  \\n\\t  varying vec3 v_edges_Barycentric;\\n\\t  varying vec3 v_edges_Position;\\n  \\n\\t  uniform float strokeOpacity;\\n\\t  uniform float fillOpacity;\\n\\t  uniform float fillMix;\\n\\t  uniform float thickness;\\n\\t  uniform bool colorBackfaces;\\n  \\n\\t  // Dash\\n\\t  uniform bool dashInvert;\\n\\t  uniform bool dash;\\n\\t  uniform bool dashOnly;\\n\\t  uniform float dashRepeats;\\n\\t  uniform float dashLength;\\n  \\n\\t  // Squeeze\\n\\t  uniform bool squeeze;\\n\\t  uniform float squeezeMin;\\n\\t  uniform float squeezeMax;\\n  \\n\\t  // Colors\\n\\t  uniform vec3 stroke;\\n\\t  uniform vec3 backfaceStroke;\\n\\t  uniform vec3 fill;\\n  \\n\\t  // This is like\\n\\t  float wireframe_aastep(float threshold, float dist) {\\n\\t\\t  float afwidth = fwidth(dist) * 0.5;\\n\\t\\t  return smoothstep(threshold - afwidth, threshold + afwidth, dist);\\n\\t  }\\n  \\n\\t  float wireframe_map(float value, float min1, float max1, float min2, float max2) {\\n\\t\\t  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\\n\\t  }\\n  \\n\\t  float getWireframe() {\\n\\t\\t\\tvec3 barycentric = v_edges_Barycentric;\\n\\t\\t\\n\\t\\t\\t// Distance from center of each triangle to its edges.\\n\\t\\t\\tfloat d = min(min(barycentric.x, barycentric.y), barycentric.z);\\n\\n\\t\\t\\t// for dashed rendering, we can use this to get the 0 .. 1 value of the line length\\n\\t\\t\\tfloat positionAlong = max(barycentric.x, barycentric.y);\\n\\t\\t\\tif (barycentric.y < barycentric.x && barycentric.y < barycentric.z) {\\n\\t\\t\\t\\tpositionAlong = 1.0 - positionAlong;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// the thickness of the stroke\\n\\t\\t\\tfloat computedThickness = wireframe_map(thickness, 0.0, 1.0, 0.0, 0.34);\\n\\n\\t\\t\\t// if we want to shrink the thickness toward the center of the line segment\\n\\t\\t\\tif (squeeze) {\\n\\t\\t\\t\\tcomputedThickness *= mix(squeezeMin, squeezeMax, (1.0 - sin(positionAlong * PI)));\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Create dash pattern\\n\\t\\t\\tif (dash) {\\n\\t\\t\\t\\t// here we offset the stroke position depending on whether it\\n\\t\\t\\t\\t// should overlap or not\\n\\t\\t\\t\\tfloat offset = 1.0 / dashRepeats * dashLength / 2.0;\\n\\t\\t\\t\\tif (!dashInvert) {\\n\\t\\t\\t\\t\\toffset += 1.0 / dashRepeats / 2.0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we should animate the dash or not\\n\\t\\t\\t\\t// if (dashAnimate) {\\n\\t\\t\\t\\t// \\toffset += time * 0.22;\\n\\t\\t\\t\\t// }\\n\\n\\t\\t\\t\\t// create the repeating dash pattern\\n\\t\\t\\t\\tfloat pattern = fract((positionAlong + offset) * dashRepeats);\\n\\t\\t\\t\\tcomputedThickness *= 1.0 - wireframe_aastep(dashLength, pattern);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the anti-aliased stroke edge  \\n\\t\\t\\tfloat edge = 1.0 - wireframe_aastep(computedThickness, d);\\n\\n\\t\\t\\treturn edge;\\n\\t  }\\n\\t  \"},Ia=Ee(Ua.uniforms,Ua.vertex+\"\\n  \\tvoid main() {\\n\\t\\tinitWireframe();\\n\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n\\t}\\n  \",Ua.fragment+\"\\n  void main () {\\n\\t\\t// Compute color\\n\\n\\t\\tfloat edge = getWireframe();\\n\\t\\tvec4 colorStroke = vec4(stroke, edge);\\n\\n\\t\\t#ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t#endif\\n    \\n\\t\\tvec4 colorFill = vec4(fill, fillOpacity);\\n\\t\\tvec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\tgl_FragColor = outColor;\\n\\t}\\n  \");function Va(e){return void 0!==(null==e?void 0:e.current)}function Oa(e){return\"WireframeGeometry\"===e.type}function Na(e){const t=null!=(r=e)&&r.current?e.current:e;var r;if(function(e){return!(null==e||!e.isBufferGeometry)}(t))return t;{if(Oa(t))throw new Error(\"Wireframe: WireframeGeometry is not supported.\");const e=t.parent;if(function(e){return!(null==e||!e.geometry)}(e)){if(Oa(e.geometry))throw new Error(\"Wireframe: WireframeGeometry is not supported.\");return e.geometry}}}function ja(e,t){if(e.index){console.warn(\"Wireframe: Requires non-indexed geometry, converting to non-indexed geometry.\");const t=e.toNonIndexed();e.copy(t),e.setIndex(null)}const r=function(e,t){const r=e.getAttribute(\"position\").count,n=[];for(let e=0;e<r;e++){const r=t?1:0;e%2==0?n.push(0,0,1,0,1,0,1,0,r):n.push(0,1,0,0,0,1,1,0,r)}return new D.BufferAttribute(Float32Array.from(n),3)}(e,t);e.setAttribute(\"barycentric\",r)}function Wa({geometry:e,simplify:t=!1,...r}){a.extend({MeshWireframeMaterial:Ia});const[n,o]=P.useState(null);P.useLayoutEffect((()=>{const r=Na(e);if(!r)throw new Error(\"Wireframe: geometry prop must be a BufferGeometry or a ref to a BufferGeometry.\");ja(r,t),Va(e)&&o(r)}),[t,e]);const i=Va(e)?n:e;return P.createElement(P.Fragment,null,i&&P.createElement(\"mesh\",{geometry:i},P.createElement(\"meshWireframeMaterial\",C.default({attach:\"material\",transparent:!0,side:D.DoubleSide,polygonOffset:!0,polygonOffsetFactor:-4},r,{extensions:{derivatives:!0,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1}}))))}function Ga({simplify:e=!1,...t}){const r=P.useRef(null),n=P.useMemo((()=>function(){const e={};for(const t in Ua.uniforms)e[t]={value:Ua.uniforms[t]};return e}()),[Ua.uniforms]);return function(e,t){P.useEffect((()=>{var r;e.fillOpacity.value=null!==(r=t.fillOpacity)&&void 0!==r?r:e.fillOpacity.value}),[t.fillOpacity]),P.useEffect((()=>{var r;e.fillMix.value=null!==(r=t.fillMix)&&void 0!==r?r:e.fillMix.value}),[t.fillMix]),P.useEffect((()=>{var r;e.strokeOpacity.value=null!==(r=t.strokeOpacity)&&void 0!==r?r:e.strokeOpacity.value}),[t.strokeOpacity]),P.useEffect((()=>{var r;e.thickness.value=null!==(r=t.thickness)&&void 0!==r?r:e.thickness.value}),[t.thickness]),P.useEffect((()=>{e.colorBackfaces.value=!!t.colorBackfaces}),[t.colorBackfaces]),P.useEffect((()=>{e.dash.value=!!t.dash}),[t.dash]),P.useEffect((()=>{e.dashInvert.value=!!t.dashInvert}),[t.dashInvert]),P.useEffect((()=>{var r;e.dashRepeats.value=null!==(r=t.dashRepeats)&&void 0!==r?r:e.dashRepeats.value}),[t.dashRepeats]),P.useEffect((()=>{var r;e.dashLength.value=null!==(r=t.dashLength)&&void 0!==r?r:e.dashLength.value}),[t.dashLength]),P.useEffect((()=>{e.squeeze.value=!!t.squeeze}),[t.squeeze]),P.useEffect((()=>{var r;e.squeezeMin.value=null!==(r=t.squeezeMin)&&void 0!==r?r:e.squeezeMin.value}),[t.squeezeMin]),P.useEffect((()=>{var r;e.squeezeMax.value=null!==(r=t.squeezeMax)&&void 0!==r?r:e.squeezeMax.value}),[t.squeezeMax]),P.useEffect((()=>{e.stroke.value=t.stroke?new D.Color(t.stroke):e.stroke.value}),[t.stroke]),P.useEffect((()=>{e.fill.value=t.fill?new D.Color(t.fill):e.fill.value}),[t.fill]),P.useEffect((()=>{e.backfaceStroke.value=t.backfaceStroke?new D.Color(t.backfaceStroke):e.backfaceStroke.value}),[t.backfaceStroke])}(n,t),P.useLayoutEffect((()=>{const t=Na(r);if(!t)throw new Error(\"Wireframe: Must be a child of a Mesh, Line or Points object or specify a geometry prop.\");const n=t.clone();return ja(t,e),()=>{t.copy(n),n.dispose()}}),[e]),P.useLayoutEffect((()=>{const e=r.current.parent,t=e.material.clone();return function(e,t){e.onBeforeCompile=e=>{e.uniforms={...e.uniforms,...t},e.vertexShader=e.vertexShader.replace(\"void main() {\",`\\n\\t\\t  ${Ua.vertex}\\n\\t\\t  void main() {\\n\\t\\t\\tinitWireframe();\\n\\t\\t`),e.fragmentShader=e.fragmentShader.replace(\"void main() {\",`\\n\\t\\t  ${Ua.fragment}\\n\\t\\t  void main() {\\n\\t\\t`),e.fragmentShader=e.fragmentShader.replace(\"#include <color_fragment>\",\"\\n\\t\\t  #include <color_fragment>\\n\\t\\t\\t  float edge = getWireframe();\\n\\t\\t  vec4 colorStroke = vec4(stroke, edge);\\n\\t\\t  #ifdef FLIP_SIDED\\n\\t\\t\\tcolorStroke.rgb = backfaceStroke;\\n\\t\\t  #endif\\n\\t\\t  vec4 colorFill = vec4(mix(diffuseColor.rgb, fill, fillMix), mix(diffuseColor.a, fillOpacity, fillMix));\\n\\t\\t  vec4 outColor = mix(colorFill, colorStroke, edge * strokeOpacity);\\n\\n\\t\\t  diffuseColor.rgb = outColor.rgb;\\n\\t\\t  diffuseColor.a *= outColor.a;\\n\\t\\t\")},e.side=D.DoubleSide,e.transparent=!0}(e.material,n),()=>{e.material.dispose(),e.material=t}}),[]),P.createElement(\"object3D\",{ref:r})}const Ha=new D.Matrix4,$a=new D.Ray,qa=new D.Sphere,Xa=new D.Vector3;class Za extends D.Group{constructor(){super(),this.size=0,this.color=new D.Color(\"white\"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){var r,n;const a=this.instance.current;if(!a||!a.geometry)return;const o=a.userData.instances.indexOf(this.instanceKey);if(-1===o||o>a.geometry.drawRange.count)return;const i=null!==(r=null==(n=e.params.Points)?void 0:n.threshold)&&void 0!==r?r:1;if(qa.set(this.getWorldPosition(Xa),i),!1===e.ray.intersectsSphere(qa))return;Ha.copy(a.matrixWorld).invert(),$a.copy(e.ray).applyMatrix4(Ha);const s=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=$a.distanceSqToPoint(this.position);if(c<l){const r=new D.Vector3;$a.closestPointToPoint(this.position,r),r.applyMatrix4(this.matrixWorld);const n=e.ray.origin.distanceTo(r);if(n<e.near||n>e.far)return;t.push({distance:n,distanceToRay:Math.sqrt(c),point:r,index:o,face:null,object:this})}}}let Ya,Qa;const Ka=P.createContext(null),Ja=new D.Matrix4,eo=new D.Vector3,to=P.forwardRef((({children:e,range:t,limit:r=1e3,...n},o)=>{const i=P.useRef(null),[s,l]=P.useState([]),[[c,u,d]]=P.useState((()=>[new Float32Array(3*r),Float32Array.from({length:3*r},(()=>1)),Float32Array.from({length:r},(()=>1))]));P.useEffect((()=>{i.current.geometry.attributes.position.needsUpdate=!0})),a.useFrame((()=>{for(i.current.updateMatrix(),i.current.updateMatrixWorld(),Ja.copy(i.current.matrixWorld).invert(),i.current.geometry.drawRange.count=Math.min(r,void 0!==t?t:r,s.length),Ya=0;Ya<s.length;Ya++)Qa=s[Ya].current,Qa.getWorldPosition(eo).applyMatrix4(Ja),eo.toArray(c,3*Ya),i.current.geometry.attributes.position.needsUpdate=!0,Qa.matrixWorldNeedsUpdate=!0,Qa.color.toArray(u,3*Ya),i.current.geometry.attributes.color.needsUpdate=!0,d.set([Qa.size],Ya),i.current.geometry.attributes.size.needsUpdate=!0}));const m=P.useMemo((()=>({getParent:()=>i,subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return P.createElement(\"points\",C.default({userData:{instances:s},matrixAutoUpdate:!1,ref:k.default([o,i]),raycast:()=>null},n),P.createElement(\"bufferGeometry\",null,P.createElement(\"bufferAttribute\",{attach:\"attributes-position\",count:c.length/3,array:c,itemSize:3,usage:D.DynamicDrawUsage}),P.createElement(\"bufferAttribute\",{attach:\"attributes-color\",count:u.length/3,array:u,itemSize:3,usage:D.DynamicDrawUsage}),P.createElement(\"bufferAttribute\",{attach:\"attributes-size\",count:d.length,array:d,itemSize:1,usage:D.DynamicDrawUsage})),P.createElement(Ka.Provider,{value:m},e))})),ro=P.forwardRef((({children:e,...t},r)=>{P.useMemo((()=>a.extend({PositionPoint:Za})),[]);const n=P.useRef(),{subscribe:o,getParent:i}=P.useContext(Ka);return P.useLayoutEffect((()=>o(n)),[]),P.createElement(\"positionPoint\",C.default({instance:i(),instanceKey:n,ref:k.default([r,n])},t),e)})),no=P.forwardRef((({children:e,positions:t,colors:r,sizes:n,stride:o=3,...i},s)=>{const l=P.useRef(null);return a.useFrame((()=>{const e=l.current.geometry.attributes;e.position.needsUpdate=!0,r&&(e.color.needsUpdate=!0),n&&(e.size.needsUpdate=!0)})),P.createElement(\"points\",C.default({ref:k.default([s,l])},i),P.createElement(\"bufferGeometry\",null,P.createElement(\"bufferAttribute\",{attach:\"attributes-position\",count:t.length/o,array:t,itemSize:o,usage:D.DynamicDrawUsage}),r&&P.createElement(\"bufferAttribute\",{attach:\"attributes-color\",count:r.length/o,array:r,itemSize:3,usage:D.DynamicDrawUsage}),n&&P.createElement(\"bufferAttribute\",{attach:\"attributes-size\",count:n.length/o,array:n,itemSize:1,usage:D.DynamicDrawUsage})),e)})),ao=P.forwardRef(((e,t)=>e.positions instanceof Float32Array?P.createElement(no,C.default({},e,{ref:t})):P.createElement(to,C.default({},e,{ref:t})))),oo=new D.Matrix4,io=new D.Matrix4,so=[],lo=new D.Mesh;class co extends D.Group{constructor(){super(),this.color=new D.Color(\"white\"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){const r=this.instance.current;if(!r)return;if(!r.geometry||!r.material)return;lo.geometry=r.geometry;const n=r.matrixWorld,a=r.userData.instances.indexOf(this.instanceKey);if(!(-1===a||a>r.count)){r.getMatrixAt(a,oo),io.multiplyMatrices(n,oo),lo.matrixWorld=io,r.material instanceof D.Material?lo.material.side=r.material.side:lo.material.side=r.material[0].side,lo.raycast(e,so);for(let e=0,r=so.length;e<r;e++){const r=so[e];r.instanceId=a,r.object=this,t.push(r)}so.length=0}}}const uo=P.createContext(null),mo=new D.Matrix4,fo=new D.Matrix4,po=new D.Matrix4,ho=new D.Vector3,xo=new D.Quaternion,yo=new D.Vector3,vo=P.forwardRef((({context:e,children:t,...r},n)=>{P.useMemo((()=>a.extend({PositionMesh:co})),[]);const o=P.useRef(),{subscribe:i,getParent:s}=P.useContext(e||uo);return P.useLayoutEffect((()=>i(o)),[]),P.createElement(\"positionMesh\",C.default({instance:s(),instanceKey:o,ref:k.default([n,o])},r),t)})),go=P.forwardRef((({children:e,range:t,limit:r=1e3,frames:n=1/0,...o},i)=>{const[{context:s,instance:l}]=P.useState((()=>{const e=P.createContext(null);return{context:e,instance:P.forwardRef(((t,r)=>P.createElement(vo,C.default({context:e},t,{ref:r}))))}})),c=P.useRef(null),[u,d]=P.useState([]),[[m,f]]=P.useState((()=>{const e=new Float32Array(16*r);for(let t=0;t<r;t++)po.identity().toArray(e,16*t);return[e,new Float32Array([...new Array(3*r)].map((()=>1)))]}));P.useEffect((()=>{c.current.instanceMatrix.needsUpdate=!0}));let p=0,h=0;a.useFrame((()=>{if(n===1/0||p<n){c.current.updateMatrix(),c.current.updateMatrixWorld(),mo.copy(c.current.matrixWorld).invert(),h=Math.min(r,void 0!==t?t:r,u.length),c.current.count=h,za(c.current.instanceMatrix,{offset:0,count:16*h}),za(c.current.instanceColor,{offset:0,count:3*h});for(let e=0;e<u.length;e++){const t=u[e].current;t.matrixWorld.decompose(ho,xo,yo),fo.compose(ho,xo,yo).premultiply(mo),fo.toArray(m,16*e),c.current.instanceMatrix.needsUpdate=!0,t.color.toArray(f,3*e),c.current.instanceColor.needsUpdate=!0}p++}}));const x=P.useMemo((()=>({getParent:()=>c,subscribe:e=>(d((t=>[...t,e])),()=>d((t=>t.filter((t=>t.current!==e.current)))))})),[]);return P.createElement(\"instancedMesh\",C.default({userData:{instances:u},matrixAutoUpdate:!1,ref:k.default([i,c]),args:[null,null,0],raycast:()=>null},o),P.createElement(\"instancedBufferAttribute\",{attach:\"instanceMatrix\",count:m.length/16,array:m,itemSize:16,usage:D.DynamicDrawUsage}),P.createElement(\"instancedBufferAttribute\",{attach:\"instanceColor\",count:f.length/3,array:f,itemSize:3,usage:D.DynamicDrawUsage}),\"function\"==typeof e?P.createElement(s.Provider,{value:x},e(l)):P.createElement(uo.Provider,{value:x},e))})),zo=P.forwardRef((function({meshes:e,children:t,...r},n){const a=Array.isArray(e);if(!a)for(const t of Object.keys(e))e[t].isMesh||delete e[t];return P.createElement(\"group\",{ref:n},P.createElement(V.default,{components:(a?e:Object.values(e)).map((({geometry:e,material:t})=>P.createElement(go,C.default({key:e.uuid,geometry:e,material:t},r))))},(r=>a?t(...r):t(Object.keys(e).filter((t=>e[t].isMesh)).reduce(((e,t,n)=>({...e,[t]:r[n]})),{})))))})),wo=P.createContext(null),bo=P.forwardRef(((e,t)=>{P.useMemo((()=>a.extend({SegmentObject:Mo})),[]);const{limit:r=1e3,lineWidth:n=1,children:o,...i}=e,[s,l]=P.useState([]),[c]=P.useState((()=>new d.Line2)),[u]=P.useState((()=>new d.LineMaterial)),[m]=P.useState((()=>new d.LineSegmentsGeometry)),[f]=P.useState((()=>new D.Vector2(512,512))),[p]=P.useState((()=>Array(6*r).fill(0))),[h]=P.useState((()=>Array(6*r).fill(0))),x=P.useMemo((()=>({subscribe:e=>(l((t=>[...t,e])),()=>l((t=>t.filter((t=>t.current!==e.current)))))})),[]);return a.useFrame((()=>{for(let t=0;t<r;t++){var e;const r=null==(e=s[t])?void 0:e.current;r&&(p[6*t+0]=r.start.x,p[6*t+1]=r.start.y,p[6*t+2]=r.start.z,p[6*t+3]=r.end.x,p[6*t+4]=r.end.y,p[6*t+5]=r.end.z,h[6*t+0]=r.color.r,h[6*t+1]=r.color.g,h[6*t+2]=r.color.b,h[6*t+3]=r.color.r,h[6*t+4]=r.color.g,h[6*t+5]=r.color.b)}m.setColors(h),m.setPositions(p),c.computeLineDistances()})),P.createElement(\"primitive\",{object:c,ref:t},P.createElement(\"primitive\",{object:m,attach:\"geometry\"}),P.createElement(\"primitive\",C.default({object:u,attach:\"material\",vertexColors:!0,resolution:f,linewidth:n},i)),P.createElement(wo.Provider,{value:x},o))}));class Mo{constructor(){this.color=new D.Color(\"white\"),this.start=new D.Vector3(0,0,0),this.end=new D.Vector3(0,0,0)}}const Eo=e=>e instanceof D.Vector3?e:new D.Vector3(...\"number\"==typeof e?[e,e,e]:e),So=P.forwardRef((({color:e,start:t,end:r},n)=>{const a=P.useContext(wo);if(!a)throw\"Segment must used inside Segments component.\";const o=P.useRef(null);return P.useLayoutEffect((()=>a.subscribe(o)),[]),P.createElement(\"segmentObject\",{ref:k.default([o,n]),color:e,start:Eo(t),end:Eo(r)})})),To=P.forwardRef((({children:e,hysteresis:t=0,distances:r,...n},o)=>{const i=P.useRef(null);return P.useLayoutEffect((()=>{const{current:e}=i;e.levels.length=0,e.children.forEach(((n,a)=>e.levels.push({object:n,hysteresis:t,distance:r[a]})))})),a.useFrame((e=>{var t;return null==(t=i.current)?void 0:t.update(e.camera)})),P.createElement(\"lOD\",C.default({ref:k.default([i,o])},n),e)}));const Co=new n.Matrix4,Po=new n.Ray,Ro=new n.Sphere,Do=new n.Vector3;const Fo=t.createContext(null);const ko=P.forwardRef((({children:e,compute:t,width:r,height:n,samples:o=8,renderPriority:i=0,eventPriority:s=0,frames:l=1/0,stencilBuffer:c=!1,depthBuffer:u=!0,generateMipmaps:d=!1,...m},f)=>{const{size:p,viewport:h}=a.useThree(),x=nt((r||p.width)*h.dpr,(n||p.height)*h.dpr,{samples:o,stencilBuffer:c,depthBuffer:u,generateMipmaps:d}),[y]=P.useState((()=>new D.Scene)),v=P.useCallback(((e,t,r)=>{var n,a;let o=null==(n=x.texture)?void 0:n.__r3f.parent;for(;o&&!(o instanceof D.Object3D);)o=o.__r3f.parent;if(!o)return!1;r.raycaster.camera||r.events.compute(e,r,null==(a=r.previousRoot)?void 0:a.getState());const[i]=r.raycaster.intersectObject(o);if(!i)return!1;const s=i.uv;if(!s)return!1;t.raycaster.setFromCamera(t.pointer.set(2*s.x-1,2*s.y-1),t.camera)}),[]);return P.useImperativeHandle(f,(()=>x.texture),[x]),P.createElement(P.Fragment,null,a.createPortal(P.createElement(_o,{renderPriority:i,frames:l,fbo:x},e,P.createElement(\"group\",{onPointerOver:()=>null})),y,{events:{compute:t||v,priority:s}}),P.createElement(\"primitive\",C.default({object:x.texture},m)))}));function _o({frames:e,renderPriority:t,children:r,fbo:n}){let o,i=0;return a.useFrame((t=>{(e===1/0||i<e)&&(o=t.gl.autoClear,t.gl.autoClear=!0,t.gl.setRenderTarget(n),t.gl.render(t.scene,t.camera),t.gl.setRenderTarget(null),t.gl.autoClear=o,i++)}),t),P.createElement(P.Fragment,null,r)}const Ao=P.forwardRef((({children:e,compute:t,renderPriority:r=-1,eventPriority:n=0,frames:o=1/0,stencilBuffer:i=!1,depthBuffer:s=!0,generateMipmaps:l=!1,resolution:c=896,near:u=.1,far:d=1e3,flip:m=!1,position:f,rotation:p,scale:h,quaternion:x,matrix:y,matrixAutoUpdate:v,...g},z)=>{const{size:w,viewport:b}=a.useThree(),M=P.useRef(null),E=P.useMemo((()=>{const e=new D.WebGLCubeRenderTarget(Math.max((c||w.width)*b.dpr,(c||w.height)*b.dpr),{stencilBuffer:i,depthBuffer:s,generateMipmaps:l});return e.texture.isRenderTargetTexture=!m,e.texture.flipY=!0,e.texture.type=D.HalfFloatType,e}),[c,m]);P.useEffect((()=>()=>E.dispose()),[E]);const[S]=P.useState((()=>new D.Scene));return P.useImperativeHandle(z,(()=>({scene:S,fbo:E,camera:M.current})),[E]),P.createElement(P.Fragment,null,a.createPortal(P.createElement(Lo,{renderPriority:r,frames:o,camera:M},e,P.createElement(\"group\",{onPointerOver:()=>null})),S,{events:{compute:t,priority:n}}),P.createElement(\"primitive\",C.default({object:E.texture},g)),P.createElement(\"cubeCamera\",{ref:M,args:[u,d,E],position:f,rotation:p,scale:h,quaternion:x,matrix:y,matrixAutoUpdate:v}))}));function Lo({frames:e,renderPriority:t,children:r,camera:n}){let o=0;return a.useFrame((t=>{(e===1/0||o<e)&&(n.current.update(t.gl,t.scene),o++)}),t),P.createElement(P.Fragment,null,r)}const Bo=P.forwardRef((({id:e=1,colorWrite:t=!1,depthWrite:r=!1,...n},a)=>{const o=P.useRef(null),i=P.useMemo((()=>({colorWrite:t,depthWrite:r,stencilWrite:!0,stencilRef:e,stencilFunc:D.AlwaysStencilFunc,stencilFail:D.ReplaceStencilOp,stencilZFail:D.ReplaceStencilOp,stencilZPass:D.ReplaceStencilOp})),[e,t,r]);return P.useLayoutEffect((()=>{Object.assign(o.current.material,i)})),P.useImperativeHandle(a,(()=>o.current),[]),P.createElement(\"mesh\",C.default({ref:o,renderOrder:-e},n))}));function Uo({api:e}){const t=new D.Vector3,r=new D.Quaternion,n=new D.Vector3,o=new D.Euler(0,Math.PI,0);return a.useFrame((a=>{a.camera.matrixWorld.decompose(t,r,n),e.current.camera.position.copy(t),e.current.camera.quaternion.setFromEuler(o).premultiply(r)})),null}const Io=Ee({blur:0,map:null,sdf:null,blend:0,size:0,resolution:new D.Vector2},\"varying vec2 vUv;\\n   void main() {\\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n     vUv = uv;\\n   }\",`uniform sampler2D sdf;\\n   uniform sampler2D map;\\n   uniform float blur;\\n   uniform float size;\\n   uniform float time;\\n   uniform vec2 resolution;\\n   varying vec2 vUv;\\n   #include <packing>\\n   void main() {\\n     vec2 uv = gl_FragCoord.xy / resolution.xy;\\n     vec4 t = texture2D(map, uv);\\n     float k = blur;\\n     float d = texture2D(sdf, vUv).r/size;\\n     float alpha = 1.0 - smoothstep(0.0, 1.0, clamp(d/k + 1.0, 0.0, 1.0));\\n     gl_FragColor = vec4(t.rgb, blur == 0.0 ? t.a : t.a * alpha);\\n     #include <tonemapping_fragment>\\n     #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n   }`),Vo=P.forwardRef((({children:e,events:t,blur:r=0,eventPriority:n=0,renderPriority:o=0,worldUnits:i=!1,resolution:s=512,...l},c)=>{a.extend({PortalMaterialImpl:Io});const u=P.useRef(null),{scene:d,gl:m,size:f,viewport:p,setEvents:h}=a.useThree(),x=nt(s,s),[y,v]=P.useState(0);a.useFrame((()=>{const e=u.current.blend>0?Math.max(1,o):0;y!==e&&v(e)})),P.useEffect((()=>{void 0!==t&&h({enabled:!t})}),[t]);const[g,z]=P.useState(!0),w=wr(z);P.useLayoutEffect((()=>{var e;w.current=null==(e=u.current)?void 0:e.__r3f.parent}),[]),P.useLayoutEffect((()=>{if(w.current&&r&&null===u.current.sdf){const e=new D.Mesh(w.current.geometry,new D.MeshBasicMaterial),t=(new D.Box3).setFromBufferAttribute(e.geometry.attributes.position),r=new D.OrthographicCamera(t.min.x*(1+2/s),t.max.x*(1+2/s),t.max.y*(1+2/s),t.min.y*(1+2/s),.1,1e3);r.position.set(0,0,1),r.lookAt(0,0,0),m.setRenderTarget(x),m.render(e,r);const n=No(s,s,m)(x.texture),a=new Float32Array(s*s);m.readRenderTargetPixels(n,0,0,s,s,a);let o=1/0;for(let e=0;e<a.length;e++)a[e]<o&&(o=a[e]);o=-o,u.current.size=o,u.current.sdf=n.texture,m.setRenderTarget(null)}}),[s,r]),P.useImperativeHandle(c,(()=>u.current));const b=P.useCallback(((e,t,r)=>{var n;if(!w.current)return!1;if(t.pointer.set(e.offsetX/t.size.width*2-1,-e.offsetY/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera),0===(null==(n=u.current)?void 0:n.blend)){const[e]=t.raycaster.intersectObject(w.current);if(!e)return t.raycaster.camera=void 0,!1}}),[]);return P.createElement(\"portalMaterialImpl\",C.default({ref:u,blur:r,blend:0,resolution:[f.width*p.dpr,f.height*p.dpr],attach:\"material\"},l),P.createElement(ko,{attach:\"map\",frames:g?1/0:0,eventPriority:n,renderPriority:o,compute:b},e,P.createElement(Oo,{events:t,rootScene:d,priority:y,material:u,worldUnits:i})))}));function Oo({events:e,rootScene:t,material:r,priority:n,worldUnits:o}){const i=a.useThree((e=>e.scene)),s=a.useThree((e=>e.setEvents)),l=nt(),c=nt();P.useLayoutEffect((()=>{i.matrixAutoUpdate=!1}),[]),P.useEffect((()=>{void 0!==e&&s({enabled:e})}),[e]);const[u,m]=P.useMemo((()=>{const e={value:0};return[new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{a:{value:l.texture},b:{value:c.texture},blend:e},vertexShader:\"\\n          varying vec2 vUv;\\n          void main() {\\n            vUv = uv;\\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n          }\",fragmentShader:`\\n          uniform sampler2D a;\\n          uniform sampler2D b;\\n          uniform float blend;\\n          varying vec2 vUv;\\n          #include <packing>\\n          void main() {\\n            vec4 ta = texture2D(a, vUv);\\n            vec4 tb = texture2D(b, vUv);\\n            gl_FragColor = mix(tb, ta, blend);\\n            #include <tonemapping_fragment>\\n            #include <${Ce>=154?\"colorspace_fragment\":\"encodings_fragment\"}>\\n          }`})),e]}),[]);return a.useFrame((e=>{var a;let s=null==r||null==(a=r.current)?void 0:a.__r3f.parent;if(s){var d,f,p,h;if(o)i.matrixWorld.identity();else n&&1===(null==(d=r.current)?void 0:d.blend)&&s.updateWorldMatrix(!0,!1),i.matrixWorld.copy(s.matrixWorld);if(n)(null==(f=r.current)?void 0:f.blend)>0&&(null==(p=r.current)?void 0:p.blend)<1?(m.value=r.current.blend,e.gl.setRenderTarget(l),e.gl.render(i,e.camera),e.gl.setRenderTarget(c),e.gl.render(t,e.camera),e.gl.setRenderTarget(null),u.render(e.gl)):1===(null==(h=r.current)?void 0:h.blend)&&e.gl.render(i,e.camera)}}),n),P.createElement(P.Fragment,null)}const No=(e,t,r)=>{let n=new D.WebGLRenderTarget(e,t,{minFilter:D.LinearMipmapLinearFilter,magFilter:D.LinearFilter,type:D.FloatType,format:D.RedFormat,generateMipmaps:!0}),a=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter}),o=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter}),i=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter}),s=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter}),l=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter,type:D.FloatType,format:D.RedFormat}),c=new D.WebGLRenderTarget(e,t,{minFilter:D.NearestFilter,magFilter:D.NearestFilter,type:D.FloatType,format:D.RedFormat});const u=new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (round(texture2D(tex, vUv).x)));\\n        }\"})),m=new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        uniform sampler2D tex;\\n        varying vec2 vUv;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = pack2HalfToRGBA(vUv * (1.0 - round(texture2D(tex, vUv).x)));\\n        }\"})),f=new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{tex:{value:null},offset:{value:0},level:{value:0},maxSteps:{value:0}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:`\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform float offset;\\n        uniform float level;\\n        uniform float maxSteps;\\n        #include <packing>\\n        void main() {\\n          float closestDist = 9999999.9;\\n          vec2 closestPos = vec2(0.0);\\n          for (float x = -1.0; x <= 1.0; x += 1.0) {\\n            for (float y = -1.0; y <= 1.0; y += 1.0) {\\n              vec2 voffset = vUv;\\n              voffset += vec2(x, y) * vec2(${1/e}, ${1/t}) * offset;\\n              vec2 pos = unpackRGBATo2Half(texture2D(tex, voffset));\\n              float dist = distance(pos.xy, vUv);\\n              if(pos.x != 0.0 && pos.y != 0.0 && dist < closestDist) {\\n                closestDist = dist;\\n                closestPos = pos;\\n              }\\n            }\\n          }\\n          gl_FragColor = pack2HalfToRGBA(closestPos);\\n        }`})),p=new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{tex:{value:null},size:{value:new D.Vector2(e,t)}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        varying vec2 vUv;\\n        uniform sampler2D tex;\\n        uniform vec2 size;\\n        #include <packing>\\n        void main() {\\n          gl_FragColor = vec4(distance(size * unpackRGBATo2Half(texture2D(tex, vUv)), size * vUv), 0.0, 0.0, 0.0);\\n        }\"})),h=new d.FullScreenQuad(new D.ShaderMaterial({uniforms:{inside:{value:c.texture},outside:{value:l.texture},tex:{value:null}},vertexShader:\"\\n        varying vec2 vUv;\\n        void main() {\\n          vUv = uv;\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\",fragmentShader:\"\\n        varying vec2 vUv;\\n        uniform sampler2D inside;\\n        uniform sampler2D outside;\\n        uniform sampler2D tex;\\n        #include <packing>\\n        void main() {\\n          float i = texture2D(inside, vUv).x;\\n          float o =texture2D(outside, vUv).x;\\n          if (texture2D(tex, vUv).x == 0.0) {\\n            gl_FragColor = vec4(o, 0.0, 0.0, 0.0);\\n          } else {\\n            gl_FragColor = vec4(-i, 0.0, 0.0, 0.0);\\n          }\\n        }\"}));return d=>{let x=n;d.minFilter=D.NearestFilter,d.magFilter=D.NearestFilter,u.material.uniforms.tex.value=d,r.setRenderTarget(a),u.render(r);const y=Math.ceil(Math.log(Math.max(e,t))/Math.log(2));let v=a,g=null;for(let e=0;e<y;e++){const t=Math.pow(2,y-e-1);g=v===a?i:a,f.material.uniforms.level.value=e,f.material.uniforms.maxSteps.value=y,f.material.uniforms.offset.value=t,f.material.uniforms.tex.value=v.texture,r.setRenderTarget(g),f.render(r),v=g}r.setRenderTarget(l),p.material.uniforms.tex.value=g.texture,p.render(r),m.material.uniforms.tex.value=d,r.setRenderTarget(o),m.render(r),v=o;for(let e=0;e<y;e++){const t=Math.pow(2,y-e-1);g=v===o?s:o,f.material.uniforms.level.value=e,f.material.uniforms.maxSteps.value=y,f.material.uniforms.offset.value=t,f.material.uniforms.tex.value=v.texture,r.setRenderTarget(g),f.render(r),v=g}return r.setRenderTarget(c),p.material.uniforms.tex.value=g.texture,p.render(r),r.setRenderTarget(x),h.material.uniforms.tex.value=d,h.render(r),r.setRenderTarget(null),x}},jo=new D.Color;function Wo(e){return\"top\"in e}function Go({canvasSize:e,scene:t,index:r,children:n,frames:o,rect:i,track:s}){const l=a.useThree((e=>e.get)),c=a.useThree((e=>e.camera)),u=a.useThree((e=>e.scene)),d=a.useThree((e=>e.setEvents));let m=0;return a.useFrame((r=>{var a,l;(o===1/0||m<=o)&&(i.current=null==(a=s.current)?void 0:a.getBoundingClientRect(),m++);if(i.current){const{position:{left:a,bottom:o,width:s,height:d},isOffscreen:m}=function(e,t){const{right:r,top:n,left:a,bottom:o,width:i,height:s}=t,l=t.bottom<0||n>e.height||r<0||t.left>e.width;if(Wo(e)){const t=e.top+e.height-o;return{position:{width:i,height:s,left:a-e.left,top:n,bottom:t,right:r},isOffscreen:l}}return{position:{width:i,height:s,top:n,left:a,bottom:e.height-o,right:r},isOffscreen:l}}(e,i.current),f=s/d;(l=c)&&l.isOrthographicCamera?c.left===s/-2&&c.right===s/2&&c.top===d/2&&c.bottom===d/-2||(Object.assign(c,{left:s/-2,right:s/2,top:d/2,bottom:d/-2}),c.updateProjectionMatrix()):c.aspect!==f&&(c.aspect=f,c.updateProjectionMatrix()),r.gl.setViewport(a,o,s,d),r.gl.setScissor(a,o,s,d),r.gl.setScissorTest(!0),m?(r.gl.getClearColor(jo),r.gl.setClearColor(jo,r.gl.getClearAlpha()),r.gl.clear(!0,!0)):r.gl.render(n?u:t,c),r.gl.setScissorTest(!0)}}),r),P.useEffect((()=>{const e=l().events.connected;return d({connected:s.current}),()=>d({connected:e})}),[]),P.useEffect((()=>{Wo(e)||console.warn(\"Detected @react-three/fiber canvas size does not include position information. <View /> may not work as expected. Upgrade to @react-three/fiber ^8.1.0 for support.\\n See https://github.com/pmndrs/drei/issues/944\")}),[]),P.createElement(P.Fragment,null,n)}const Ho=P.createContext(null),$o=new D.Vector3,qo=new D.Vector3,Xo=new D.Vector3(0,1,0),Zo=new D.Matrix4,Yo=({direction:e,axis:t})=>{const{translation:r,translationLimits:n,annotations:o,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:x,userData:y}=P.useContext(Ho),v=a.useThree((e=>e.controls)),g=P.useRef(null),z=P.useRef(null),w=P.useRef(null),b=P.useRef(0),[M,E]=P.useState(!1),S=P.useCallback((n=>{o&&(g.current.innerText=`${r.current[t].toFixed(2)}`,g.current.style.display=\"block\"),n.stopPropagation();const a=(new D.Matrix4).extractRotation(z.current.matrixWorld),i=n.point.clone(),s=(new D.Vector3).setFromMatrixPosition(z.current.matrixWorld),l=e.clone().applyMatrix4(a).normalize();w.current={clickPoint:i,dir:l},b.current=r.current[t],p({component:\"Arrow\",axis:t,origin:s,directions:[l]}),v&&(v.enabled=!1),n.target.setPointerCapture(n.pointerId)}),[o,e,v,p,r,t]),T=P.useCallback((e=>{if(e.stopPropagation(),M||E(!0),w.current){const{clickPoint:a,dir:i}=w.current,[s,l]=(null==n?void 0:n[t])||[void 0,void 0];let c=((e,t,r,n)=>{const a=t.dot(t),o=t.dot(e)-t.dot(r),i=t.dot(n);return 0===i?-o/a:($o.copy(n).multiplyScalar(a/i).sub(t),qo.copy(n).multiplyScalar(o/i).add(r).sub(e),-$o.dot(qo)/$o.dot($o))})(a,i,e.ray.origin,e.ray.direction);void 0!==s&&(c=Math.max(c,s-b.current)),void 0!==l&&(c=Math.min(c,l-b.current)),r.current[t]=b.current+c,o&&(g.current.innerText=`${r.current[t].toFixed(2)}`),Zo.makeTranslation(i.x*c,i.y*c,i.z*c),h(Zo)}}),[o,h,M,r,n,t]),C=P.useCallback((e=>{o&&(g.current.style.display=\"none\"),e.stopPropagation(),w.current=null,x(),v&&(v.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[o,v,x]),R=P.useCallback((e=>{e.stopPropagation(),E(!1)}),[]),{cylinderLength:F,coneWidth:k,coneLength:_,matrixL:A}=P.useMemo((()=>{const t=u?c/l*1.6:l/20,r=u?.2:l/5,n=u?1-r:l-r,a=(new D.Quaternion).setFromUnitVectors(Xo,e.clone().normalize());return{cylinderLength:n,coneWidth:t,coneLength:r,matrixL:(new D.Matrix4).makeRotationFromQuaternion(a)}}),[e,l,c,u]),L=M?m:d[t];return P.createElement(\"group\",{ref:z},P.createElement(\"group\",{matrix:A,matrixAutoUpdate:!1,onPointerDown:S,onPointerMove:T,onPointerUp:C,onPointerOut:R},o&&P.createElement(Y,{position:[0,-_,0]},P.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:i,ref:g})),P.createElement(\"mesh\",{visible:!1,position:[0,(F+_)/2,0],userData:y},P.createElement(\"cylinderGeometry\",{args:[1.4*k,1.4*k,F+_,8,1]})),P.createElement(ue,{transparent:!0,raycast:()=>null,depthTest:s,points:[0,0,0,0,F,0],lineWidth:c,color:L,opacity:f,polygonOffset:!0,renderOrder:1,polygonOffsetFactor:-10,fog:!1}),P.createElement(\"mesh\",{raycast:()=>null,position:[0,F+_/2,0],renderOrder:500},P.createElement(\"coneGeometry\",{args:[k,_,24,1]}),P.createElement(\"meshBasicMaterial\",{transparent:!0,depthTest:s,color:L,opacity:f,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))))},Qo=new D.Ray,Ko=new D.Vector3,Jo=new D.Matrix4,ei=({dir1:e,dir2:t,axis:r})=>{const{translation:n,translationLimits:o,annotations:i,annotationsClass:s,depthTest:l,scale:c,lineWidth:u,fixed:d,axisColors:m,hoveredColor:f,opacity:p,onDragStart:h,onDrag:x,onDragEnd:y,userData:v}=P.useContext(Ho),g=a.useThree((e=>e.controls)),z=P.useRef(null),w=P.useRef(null),b=P.useRef(null),M=P.useRef(0),E=P.useRef(0),[S,T]=P.useState(!1),C=P.useCallback((e=>{i&&(z.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`,z.current.style.display=\"block\"),e.stopPropagation();const t=e.point.clone(),a=(new D.Vector3).setFromMatrixPosition(w.current.matrixWorld),o=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,0).normalize(),s=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,1).normalize(),l=(new D.Vector3).setFromMatrixColumn(w.current.matrixWorld,2).normalize(),c=(new D.Plane).setFromNormalAndCoplanarPoint(l,a);b.current={clickPoint:t,e1:o,e2:s,plane:c},M.current=n.current[(r+1)%3],E.current=n.current[(r+2)%3],h({component:\"Slider\",axis:r,origin:a,directions:[o,s,l]}),g&&(g.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[i,g,h,r]),R=P.useCallback((e=>{if(e.stopPropagation(),S||T(!0),b.current){const{clickPoint:t,e1:a,e2:s,plane:l}=b.current,[c,u]=(null==o?void 0:o[(r+1)%3])||[void 0,void 0],[d,m]=(null==o?void 0:o[(r+2)%3])||[void 0,void 0];Qo.copy(e.ray),Qo.intersectPlane(l,Ko),Qo.direction.negate(),Qo.intersectPlane(l,Ko),Ko.sub(t);let[f,p]=((e,t,r)=>{const n=Math.abs(e.x)>=Math.abs(e.y)&&Math.abs(e.x)>=Math.abs(e.z)?0:Math.abs(e.y)>=Math.abs(e.x)&&Math.abs(e.y)>=Math.abs(e.z)?1:2,a=[0,1,2].sort(((e,r)=>Math.abs(t.getComponent(r))-Math.abs(t.getComponent(e)))),o=n===a[0]?a[1]:a[0],i=e.getComponent(n),s=e.getComponent(o),l=t.getComponent(n),c=t.getComponent(o),u=r.getComponent(n),d=(r.getComponent(o)-u*(s/i))/(c-l*(s/i));return[(u-d*l)/i,d]})(a,s,Ko);void 0!==c&&(f=Math.max(f,c-M.current)),void 0!==u&&(f=Math.min(f,u-M.current)),void 0!==d&&(p=Math.max(p,d-E.current)),void 0!==m&&(p=Math.min(p,m-E.current)),n.current[(r+1)%3]=M.current+f,n.current[(r+2)%3]=E.current+p,i&&(z.current.innerText=`${n.current[(r+1)%3].toFixed(2)}, ${n.current[(r+2)%3].toFixed(2)}`),Jo.makeTranslation(f*a.x+p*s.x,f*a.y+p*s.y,f*a.z+p*s.z),x(Jo)}}),[i,x,S,n,o,r]),F=P.useCallback((e=>{i&&(z.current.style.display=\"none\"),e.stopPropagation(),b.current=null,y(),g&&(g.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[i,g,y]),k=P.useCallback((e=>{e.stopPropagation(),T(!1)}),[]),_=P.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new D.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),A=d?1/7:c/7,L=d?.225:.225*c,B=S?f:m[r],U=P.useMemo((()=>[new D.Vector3(0,0,0),new D.Vector3(0,L,0),new D.Vector3(L,L,0),new D.Vector3(L,0,0),new D.Vector3(0,0,0)]),[L]);return P.createElement(\"group\",{ref:w,matrix:_,matrixAutoUpdate:!1},i&&P.createElement(Y,{position:[0,0,0]},P.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:s,ref:z})),P.createElement(\"group\",{position:[1.7*A,1.7*A,0]},P.createElement(\"mesh\",{visible:!0,onPointerDown:C,onPointerMove:R,onPointerUp:F,onPointerOut:k,scale:L,userData:v},P.createElement(\"planeGeometry\",null),P.createElement(\"meshBasicMaterial\",{transparent:!0,depthTest:l,color:B,polygonOffset:!0,polygonOffsetFactor:-10,side:D.DoubleSide,fog:!1})),P.createElement(ue,{position:[-L/2,-L/2,0],transparent:!0,depthTest:l,points:U,lineWidth:u,color:B,opacity:p,polygonOffset:!0,polygonOffsetFactor:-10,userData:v,fog:!1})))},ti=new D.Vector3,ri=new D.Vector3,ni=e=>180*e/Math.PI,ai=e=>{let t=((e,t)=>{let r=Math.floor(e/t);return r=r<0?r+1:r,e-r*t})(e,2*Math.PI);return Math.abs(t)<1e-6?0:(t<0&&(t+=2*Math.PI),t)},oi=new D.Matrix4,ii=new D.Vector3,si=new D.Ray,li=new D.Vector3,ci=({dir1:e,dir2:t,axis:r})=>{const{rotationLimits:n,annotations:o,annotationsClass:i,depthTest:s,scale:l,lineWidth:c,fixed:u,axisColors:d,hoveredColor:m,opacity:f,onDragStart:p,onDrag:h,onDragEnd:x,userData:y}=P.useContext(Ho),v=a.useThree((e=>e.controls)),g=P.useRef(null),z=P.useRef(null),w=P.useRef(0),b=P.useRef(0),M=P.useRef(null),[E,S]=P.useState(!1),T=P.useCallback((e=>{o&&(g.current.innerText=`${ni(b.current).toFixed(0)}º`,g.current.style.display=\"block\"),e.stopPropagation();const t=e.point.clone(),n=(new D.Vector3).setFromMatrixPosition(z.current.matrixWorld),a=(new D.Vector3).setFromMatrixColumn(z.current.matrixWorld,0).normalize(),i=(new D.Vector3).setFromMatrixColumn(z.current.matrixWorld,1).normalize(),s=(new D.Vector3).setFromMatrixColumn(z.current.matrixWorld,2).normalize(),l=(new D.Plane).setFromNormalAndCoplanarPoint(s,n);M.current={clickPoint:t,origin:n,e1:a,e2:i,normal:s,plane:l},p({component:\"Rotator\",axis:r,origin:n,directions:[a,i,s]}),v&&(v.enabled=!1),e.target.setPointerCapture(e.pointerId)}),[o,v,p,r]),C=P.useCallback((e=>{if(e.stopPropagation(),E||S(!0),M.current){const{clickPoint:t,origin:a,e1:i,e2:s,normal:l,plane:c}=M.current,[u,d]=(null==n?void 0:n[r])||[void 0,void 0];si.copy(e.ray),si.intersectPlane(c,li),si.direction.negate(),si.intersectPlane(c,li);let m=((e,t,r,n,a)=>{ti.copy(e).sub(r),ri.copy(t).sub(r);const o=n.dot(n),i=a.dot(a),s=ti.dot(n)/o,l=ti.dot(a)/i,c=ri.dot(n)/o,u=ri.dot(a)/i,d=Math.atan2(l,s);return Math.atan2(u,c)-d})(t,li,a,i,s),f=ni(m);e.shiftKey&&(f=10*Math.round(f/10),m=(e=>e*Math.PI/180)(f)),void 0!==u&&void 0!==d&&d-u<2*Math.PI?(m=ai(m),m=m>Math.PI?m-2*Math.PI:m,m=O.default(m,u-w.current,d-w.current),b.current=w.current+m):(b.current=ai(w.current+m),b.current=b.current>Math.PI?b.current-2*Math.PI:b.current),o&&(f=ni(b.current),g.current.innerText=`${f.toFixed(0)}º`),oi.makeRotationAxis(l,m),ii.copy(a).applyMatrix4(oi).sub(a).negate(),oi.setPosition(ii),h(oi)}}),[o,h,E,n,r]),R=P.useCallback((e=>{o&&(g.current.style.display=\"none\"),e.stopPropagation(),w.current=b.current,M.current=null,x(),v&&(v.enabled=!0),e.target.releasePointerCapture(e.pointerId)}),[o,v,x]),F=P.useCallback((e=>{e.stopPropagation(),S(!1)}),[]),k=P.useMemo((()=>{const r=e.clone().normalize(),n=t.clone().normalize();return(new D.Matrix4).makeBasis(r,n,r.clone().cross(n))}),[e,t]),_=u?.65:.65*l,A=P.useMemo((()=>{const e=[];for(let t=0;t<=32;t++){const r=t*(Math.PI/2)/32;e.push(new D.Vector3(Math.cos(r)*_,Math.sin(r)*_,0))}return e}),[_]);return P.createElement(\"group\",{ref:z,onPointerDown:T,onPointerMove:C,onPointerUp:R,onPointerOut:F,matrix:k,matrixAutoUpdate:!1},o&&P.createElement(Y,{position:[_,_,0]},P.createElement(\"div\",{style:{display:\"none\",background:\"#151520\",color:\"white\",padding:\"6px 8px\",borderRadius:7,whiteSpace:\"nowrap\"},className:i,ref:g})),P.createElement(ue,{points:A,lineWidth:4*c,visible:!1,userData:y}),P.createElement(ue,{transparent:!0,raycast:()=>null,depthTest:s,points:A,lineWidth:c,color:E?m:d[r],opacity:f,polygonOffset:!0,polygonOffsetFactor:-10,fog:!1}))},ui=new D.Vector3,di=new D.Vector3,mi=new D.Vector3,fi=(e,t,r,n=1)=>{const a=ui.set(e.x/r.width*2-1,-e.y/r.height*2+1,n);return a.unproject(t),a},pi=(e,t,r,n)=>{const a=((e,t,r)=>{const n=r.width/2,a=r.height/2;t.updateMatrixWorld(!1);const o=e.project(t);return o.x=o.x*n+n,o.y=-o.y*a+a,o})(mi.copy(e),r,n);let o=0;for(let i=0;i<2;++i){const s=di.copy(a).setComponent(i,a.getComponent(i)+t),l=fi(s,r,n,s.z);o=Math.max(o,e.distanceTo(l))}return o},hi=new D.Matrix4,xi=new D.Matrix4,yi=new D.Matrix4,vi=new D.Matrix4,gi=new D.Matrix4,zi=new D.Matrix4,wi=new D.Matrix4,bi=new D.Matrix4,Mi=new D.Box3,Ei=new D.Box3,Si=new D.Vector3,Ti=new D.Vector3,Ci=new D.Vector3,Pi=new D.Vector3,Ri=new D.Vector3(1,0,0),Di=new D.Vector3(0,1,0),Fi=new D.Vector3(0,0,1),ki=P.forwardRef((({matrix:e,onDragStart:t,onDrag:r,onDragEnd:n,autoTransform:o=!0,anchor:i,disableAxes:s=!1,disableSliders:l=!1,disableRotations:c=!1,activeAxes:u=[!0,!0,!0],offset:d=[0,0,0],rotation:m=[0,0,0],scale:f=1,lineWidth:p=4,fixed:h=!1,translationLimits:x,rotationLimits:y,depthTest:v=!0,axisColors:g=[\"#ff2060\",\"#20df80\",\"#2080ff\"],hoveredColor:z=\"#ffff40\",annotations:w=!1,annotationsClass:b,opacity:M=1,visible:E=!0,userData:S,children:T,...R},F)=>{const k=a.useThree((e=>e.invalidate)),_=P.useRef(null),A=P.useRef(null),L=P.useRef(null),B=P.useRef(null),U=P.useRef([0,0,0]);P.useLayoutEffect((()=>{i&&(B.current.updateWorldMatrix(!0,!0),vi.copy(B.current.matrixWorld).invert(),Mi.makeEmpty(),B.current.traverse((e=>{e.geometry&&(e.geometry.boundingBox||e.geometry.computeBoundingBox(),zi.copy(e.matrixWorld).premultiply(vi),Ei.copy(e.geometry.boundingBox),Ei.applyMatrix4(zi),Mi.union(Ei))})),Si.copy(Mi.max).add(Mi.min).multiplyScalar(.5),Ti.copy(Mi.max).sub(Mi.min).multiplyScalar(.5),Ci.copy(Ti).multiply(new D.Vector3(...i)).add(Si),Pi.set(...d).add(Ci),L.current.position.copy(Pi),k())}));const I=P.useMemo((()=>({onDragStart:e=>{hi.copy(A.current.matrix),xi.copy(A.current.matrixWorld),t&&t(e),k()},onDrag:e=>{yi.copy(_.current.matrixWorld),vi.copy(yi).invert(),gi.copy(xi).premultiply(e),zi.copy(gi).premultiply(vi),wi.copy(hi).invert(),bi.copy(zi).multiply(wi),o&&A.current.matrix.copy(zi),r&&r(zi,bi,gi,e),k()},onDragEnd:()=>{n&&n(),k()},translation:U,translationLimits:x,rotationLimits:y,axisColors:g,hoveredColor:z,opacity:M,scale:f,lineWidth:p,fixed:h,depthTest:v,userData:S,annotations:w,annotationsClass:b})),[t,r,n,U,x,y,v,f,p,h,...g,z,M,S,o,w,b]),V=new D.Vector3;return a.useFrame((e=>{if(h){const a=pi(L.current.getWorldPosition(V),f,e.camera,e.size);var t,r,n;if(L.current)(null==(t=L.current)?void 0:t.scale.x)===a&&(null==(r=L.current)?void 0:r.scale.y)===a&&(null==(n=L.current)?void 0:n.scale.z)===a||(L.current.scale.setScalar(a),e.invalidate())}})),P.useImperativeHandle(F,(()=>A.current),[]),P.useLayoutEffect((()=>{e&&e instanceof D.Matrix4&&(A.current.matrix=e)}),[e]),P.createElement(Ho.Provider,{value:I},P.createElement(\"group\",{ref:_},P.createElement(\"group\",C.default({ref:A,matrix:e,matrixAutoUpdate:!1},R),P.createElement(\"group\",{visible:E,ref:L,position:d,rotation:m},!s&&u[0]&&P.createElement(Yo,{axis:0,direction:Ri}),!s&&u[1]&&P.createElement(Yo,{axis:1,direction:Di}),!s&&u[2]&&P.createElement(Yo,{axis:2,direction:Fi}),!l&&u[0]&&u[1]&&P.createElement(ei,{axis:2,dir1:Ri,dir2:Di}),!l&&u[0]&&u[2]&&P.createElement(ei,{axis:1,dir1:Fi,dir2:Ri}),!l&&u[2]&&u[1]&&P.createElement(ei,{axis:0,dir1:Di,dir2:Fi}),!c&&u[0]&&u[1]&&P.createElement(ci,{axis:2,dir1:Ri,dir2:Di}),!c&&u[0]&&u[2]&&P.createElement(ci,{axis:1,dir1:Fi,dir2:Ri}),!c&&u[2]&&u[1]&&P.createElement(ci,{axis:0,dir1:Di,dir2:Fi})),P.createElement(\"group\",{ref:B},T))))}));exports.AccumulativeShadows=$n,exports.AdaptiveDpr=function({pixelated:e}){const t=a.useThree((e=>e.gl)),r=a.useThree((e=>e.internal.active)),n=a.useThree((e=>e.performance.current)),o=a.useThree((e=>e.viewport.initialDpr)),i=a.useThree((e=>e.setDpr));return P.useEffect((()=>{const n=t.domElement;return()=>{r&&i(o),e&&n&&(n.style.imageRendering=\"auto\")}}),[]),P.useEffect((()=>{i(n*o),e&&t.domElement&&(t.domElement.style.imageRendering=1===n?\"auto\":\"pixelated\")}),[n]),null},exports.AdaptiveEvents=function(){const e=a.useThree((e=>e.get)),t=a.useThree((e=>e.setEvents)),r=a.useThree((e=>e.performance.current));return P.useEffect((()=>{const r=e().events.enabled;return()=>t({enabled:r})}),[]),P.useEffect((()=>t({enabled:1===r})),[r]),null},exports.ArcballControls=mt,exports.AsciiRenderer=function({renderIndex:e=1,bgColor:t=\"black\",fgColor:r=\"white\",characters:n=\" .:-+*=%@#\",invert:o=!0,color:i=!1,resolution:s=.15}){const{size:l,gl:c,scene:u,camera:m}=a.useThree(),f=P.useMemo((()=>{const e=new d.AsciiEffect(c,n,{invert:o,color:i,resolution:s});return e.domElement.style.position=\"absolute\",e.domElement.style.top=\"0px\",e.domElement.style.left=\"0px\",e.domElement.style.pointerEvents=\"none\",e}),[n,o,i,s]);return P.useLayoutEffect((()=>{f.domElement.style.color=r,f.domElement.style.backgroundColor=t}),[r,t]),P.useEffect((()=>(c.domElement.style.opacity=\"0\",c.domElement.parentNode.appendChild(f.domElement),()=>{c.domElement.style.opacity=\"1\",c.domElement.parentNode.removeChild(f.domElement)})),[f]),P.useEffect((()=>{f.setSize(l.width,l.height)}),[f,l]),a.useFrame((e=>{f.render(u,m)}),e),P.createElement(P.Fragment,null)},exports.BBAnchor=({anchor:e,...t})=>{const r=P.useRef(null),n=P.useRef(null);return P.useEffect((()=>{var e;null!=(e=r.current)&&null!=(e=e.parent)&&e.parent&&(n.current=r.current.parent,r.current.parent.parent.add(r.current))}),[]),a.useFrame((()=>{n.current&&(Tr.setFromObject(n.current),Tr.getSize(Cr),r.current.position.set(n.current.position.x+Cr.x*(Array.isArray(e)?e[0]:e.x)/2,n.current.position.y+Cr.y*(Array.isArray(e)?e[1]:e.y)/2,n.current.position.z+Cr.z*(Array.isArray(e)?e[2]:e.z)/2))})),P.createElement(\"group\",C.default({ref:r},t))},exports.Backdrop=function({children:e,floor:t=.25,segments:r=20,receiveShadow:n,...a}){const o=P.useRef(null);return P.useLayoutEffect((()=>{let e=0;const n=r/r/2,a=o.current.attributes.position;for(let o=0;o<r+1;o++)for(let i=0;i<r+1;i++)a.setXYZ(e++,o/r-n+(0===o?-t:0),i/r-n,Qn(o/r));a.needsUpdate=!0,o.current.computeVertexNormals()}),[r,t]),P.createElement(\"group\",a,P.createElement(\"mesh\",{receiveShadow:n,rotation:[-Math.PI/2,0,Math.PI/2]},P.createElement(\"planeGeometry\",{ref:o,args:[1,1,r,r]}),e))},exports.BakeShadows=function(){const e=a.useThree((e=>e.gl));return t.useEffect((()=>(e.shadowMap.autoUpdate=!1,e.shadowMap.needsUpdate=!0,()=>{e.shadowMap.autoUpdate=e.shadowMap.needsUpdate=!0})),[e.shadowMap]),null},exports.Billboard=le,exports.Bounds=Pn,exports.Box=Kr,exports.Bvh=zr,exports.CameraControls=xt,exports.CameraShake=Dn,exports.Capsule=xn,exports.CatmullRomLine=pe,exports.Caustics=aa,exports.Center=Dr,exports.Circle=Jr,exports.Clone=Oe,exports.Cloud=Da,exports.CloudInstance=Ra,exports.Clouds=Pa,exports.ComputedAttribute=({compute:e,name:t,...r})=>{const[a]=P.useState((()=>new n.BufferAttribute(new Float32Array(0),1))),o=P.useRef(null);return P.useLayoutEffect((()=>{if(o.current){var t;const r=null!==(t=o.current.parent)&&void 0!==t?t:o.current.__r3f.parent,n=e(r);o.current.copy(n)}}),[e]),P.createElement(\"primitive\",C.default({ref:o,object:a,attach:`attributes-${t}`},r))},exports.Cone=en,exports.ContactShadows=Wn,exports.CubeCamera=function({children:e,frames:t=1/0,resolution:r,near:n,far:o,envMap:i,fog:s,...l}){const c=P.useRef(null),{fbo:u,camera:d,update:m}=it({resolution:r,near:n,far:o,envMap:i,fog:s});let f=0;return a.useFrame((()=>{c.current&&(t===1/0||f<t)&&(c.current.visible=!1,m(),c.current.visible=!0,f++)})),P.createElement(\"group\",l,P.createElement(\"primitive\",{object:d}),P.createElement(\"group\",{ref:c},e(u.texture)))},exports.CubicBezierLine=fe,exports.CurveModifier=_r,exports.CycleRaycast=function({onChanged:e,portal:t,preventDefault:r=!0,scroll:n=!0,keyCode:o=9}){const i=P.useRef(0),s=a.useThree((e=>e.setEvents)),l=a.useThree((e=>e.get)),c=a.useThree((e=>e.gl));return P.useEffect((()=>{var a;let u,d=[];const m=l().events.filter,f=null!==(a=null==t?void 0:t.current)&&void 0!==a?a:c.domElement.parentNode,p=()=>f&&e&&e(d,Math.round(i.current)%d.length);s({filter:(e,t)=>{let r=[...e];r.length===d.length&&d.every((e=>r.map((e=>e.object.uuid)).includes(e.object.uuid)))||(i.current=0,d=r,p()),m&&(r=m(r,t));for(let e=0;e<Math.round(i.current)%r.length;e++){const e=r.shift();r=[...r,e]}return r}});const h=e=>{var t,r;i.current=e(i.current),null==(t=l().events.handlers)||t.onPointerCancel(void 0),null==(r=l().events.handlers)||r.onPointerMove(u),p()},x=e=>{(e.keyCode||e.which)===o&&(r&&e.preventDefault(),d.length>1&&h((e=>e+1)))},y=e=>{r&&e.preventDefault();let t=0;e||(e=window.event),e.wheelDelta?t=e.wheelDelta/120:e.detail&&(t=-e.detail/3),d.length>1&&h((e=>Math.abs(e-t)))},v=e=>u=e;return document.addEventListener(\"pointermove\",v,{passive:!0}),n&&document.addEventListener(\"wheel\",y),void 0!==o&&document.addEventListener(\"keydown\",x),()=>{s({filter:m}),void 0!==o&&document.removeEventListener(\"keydown\",x),n&&document.removeEventListener(\"wheel\",y),document.removeEventListener(\"pointermove\",v)}}),[c,l,s,r,n,o]),null},exports.Cylinder=tn,exports.Decal=$e,exports.Detailed=To,exports.DeviceOrientationControls=st,exports.Dodecahedron=fn,exports.Edges=_e,exports.Effects=be,exports.Environment=jn,exports.EnvironmentCube=Vn,exports.EnvironmentMap=In,exports.EnvironmentPortal=On,exports.Example=Fr,exports.Extrude=pn,exports.FaceControls=Dt,exports.FaceLandmarker=function({basePath:e=St.basePath,options:r=St.options,children:n}){const a=JSON.stringify(r),o=f.suspend((async()=>{const{FilesetResolver:t,FaceLandmarker:n}=await Promise.resolve().then((function(){return T(__webpack_require__(/*! @mediapipe/tasks-vision */ \"(ssr)/./node_modules/@mediapipe/tasks-vision/vision_bundle.cjs\"))})),a=await t.forVisionTasks(e);return n.createFromOptions(a,r)}),[e,a]);return t.useEffect((()=>()=>{null==o||o.close(),f.clear([e,a])}),[o,e,a]),P.createElement(Et.Provider,{value:o},n)},exports.FaceLandmarkerDefaults=St,exports.Facemesh=zt,exports.FacemeshDatas=Mt,exports.FacemeshEye=bt,exports.FacemeshEyeDefaults=wt,exports.FirstPersonControls=ht,exports.Fisheye=function({renderPriority:e=1,zoom:t=0,segments:r=64,children:n,resolution:o=896,...i}){const s=P.useRef(null),l=P.useRef(null),{width:c,height:u}=a.useThree((e=>e.size)),[d]=P.useState((()=>new D.OrthographicCamera));P.useLayoutEffect((()=>{d.position.set(0,0,100),d.zoom=100,d.left=c/-2,d.right=c/2,d.top=u/2,d.bottom=u/-2,d.updateProjectionMatrix()}),[c,u]);const m=Math.sqrt(c*c+u*u)/100*(.5+t/2),f=new D.Vector3,p=new D.Sphere(new D.Vector3,m),h=new D.Matrix3,x=P.useCallback(((e,t,r)=>{t.pointer.set(e.offsetX/t.size.width*2-1,-e.offsetY/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,d),t.raycaster.ray.intersectSphere(p,f)&&(f.normalize(),h.getNormalMatrix(l.current.camera.matrixWorld),l.current.camera.getWorldPosition(t.raycaster.ray.origin),t.raycaster.ray.direction.set(0,0,1).reflect(f),t.raycaster.ray.direction.x*=-1,t.raycaster.ray.direction.applyNormalMatrix(h).multiplyScalar(-1))}),[]);return a.useFrame((t=>{e&&t.gl.render(s.current,d)}),e),P.createElement(P.Fragment,null,P.createElement(\"mesh\",C.default({ref:s},i,{scale:m}),P.createElement(\"sphereGeometry\",{args:[1,r,r]}),P.createElement(\"meshBasicMaterial\",null,P.createElement(Ao,{compute:x,attach:\"envMap\",flip:!0,resolution:o,ref:l},n,P.createElement(Uo,{api:l})))))},exports.Float=Fn,exports.FlyControls=lt,exports.GizmoHelper=({alignment:e=\"bottom-right\",margin:t=[80,80],renderPriority:r=1,onUpdate:o,onTarget:i,children:s})=>{const l=a.useThree((e=>e.size)),c=a.useThree((e=>e.camera)),u=a.useThree((e=>e.controls)),d=a.useThree((e=>e.invalidate)),m=P.useRef(null),f=P.useRef(null),p=P.useRef(!1),h=P.useRef(0),x=P.useRef(new n.Vector3(0,0,0)),y=P.useRef(new n.Vector3(0,0,0));P.useEffect((()=>{y.current.copy(c.up)}),[c]);const v=P.useCallback((e=>{p.current=!0,(u||i)&&(x.current=(null==u?void 0:u.target)||(null==i?void 0:i())),h.current=c.position.distanceTo(Xt),$t.copy(c.quaternion),Zt.copy(e).multiplyScalar(h.current).add(Xt),Gt.lookAt(Zt),Gt.up.copy(c.up),qt.copy(Gt.quaternion),d()}),[u,c,i,d]);a.useFrame(((e,t)=>{if(f.current&&m.current){var r;if(p.current)if($t.angleTo(qt)<.01)p.current=!1,\"minPolarAngle\"in u&&c.up.copy(y.current);else{const e=t*Wt;$t.rotateTowards(qt,e),c.position.set(0,0,1).applyQuaternion($t).multiplyScalar(h.current).add(x.current),c.up.set(0,1,0).applyQuaternion($t).normalize(),c.quaternion.copy($t),o?o():u&&u.update(),d()}Ht.copy(c.matrix).invert(),null==(r=m.current)||r.quaternion.setFromRotationMatrix(Ht)}}));const g=P.useMemo((()=>({tweenCamera:v})),[v]),[z,w]=t,b=e.endsWith(\"-center\")?0:e.endsWith(\"-left\")?-l.width/2+z:l.width/2-z,M=e.startsWith(\"center-\")?0:e.startsWith(\"top-\")?l.height/2-w:-l.height/2+w;return P.createElement(Ot,{renderPriority:r},P.createElement(Nt.Provider,{value:g},P.createElement(at,{makeDefault:!0,ref:f,position:[0,0,200]}),P.createElement(\"group\",{ref:m,position:[b,M,0]},s)))},exports.GizmoViewcube=e=>P.createElement(\"group\",{scale:[60,60,60]},P.createElement(sr,e),ar.map(((t,r)=>P.createElement(lr,C.default({key:r,position:t,dimensions:or[r]},e)))),rr.map(((t,r)=>P.createElement(lr,C.default({key:r,position:t,dimensions:nr},e))))),exports.GizmoViewport=({hideNegativeAxes:e,hideAxisHeads:t,disabled:r,font:n=\"18px Inter var, Arial, sans-serif\",axisColors:a=[\"#ff2060\",\"#20df80\",\"#2080ff\"],axisHeadScale:o=1,axisScale:i,labels:s=[\"X\",\"Y\",\"Z\"],labelColor:l=\"#000\",onClick:c,...u})=>{const[d,m,f]=a,{tweenCamera:p}=jt(),h={font:n,disabled:r,labelColor:l,onClick:c,axisHeadScale:o,onPointerDown:r?void 0:e=>{p(e.object.position),e.stopPropagation()}};return P.createElement(\"group\",C.default({scale:40},u),P.createElement(cr,{color:d,rotation:[0,0,0],scale:i}),P.createElement(cr,{color:m,rotation:[0,0,Math.PI/2],scale:i}),P.createElement(cr,{color:f,rotation:[0,-Math.PI/2,0],scale:i}),!t&&P.createElement(P.Fragment,null,P.createElement(ur,C.default({arcStyle:d,position:[1,0,0],label:s[0]},h)),P.createElement(ur,C.default({arcStyle:m,position:[0,1,0],label:s[1]},h)),P.createElement(ur,C.default({arcStyle:f,position:[0,0,1],label:s[2]},h)),!e&&P.createElement(P.Fragment,null,P.createElement(ur,C.default({arcStyle:d,position:[-1,0,0]},h)),P.createElement(ur,C.default({arcStyle:m,position:[0,-1,0]},h)),P.createElement(ur,C.default({arcStyle:f,position:[0,0,-1]},h)))))},exports.Gltf=Ke,exports.GradientTexture=function({stops:e,colors:t,size:r=1024,width:n=16,type:o=Me.Linear,innerCircleRadius:i=0,outerCircleRadius:s=\"auto\",...l}){const c=a.useThree((e=>e.gl)),u=P.useMemo((()=>{const a=document.createElement(\"canvas\"),l=a.getContext(\"2d\");let c;if(a.width=n,a.height=r,o===Me.Linear)c=l.createLinearGradient(0,0,0,r);else{const e=a.width/2,t=a.height/2,r=\"auto\"!==s?Math.abs(Number(s)):Math.sqrt(e**2+t**2);c=l.createRadialGradient(e,t,Math.abs(i),e,t,r)}let u=e.length;for(;u--;)c.addColorStop(e[u],t[u]);return l.save(),l.fillStyle=c,l.fillRect(0,0,n,r),l.restore(),a}),[e]);return P.createElement(\"canvasTexture\",C.default({colorSpace:c.outputColorSpace,args:[u],attach:\"map\"},l))},exports.GradientType=Me,exports.Grid=mr,exports.Html=Y,exports.Hud=Ot,exports.Icosahedron=dn,exports.Image=ke,exports.Instance=vo,exports.Instances=go,exports.IsObject=Se,exports.KeyboardControls=function({map:e,children:t,onChange:r,domElement:n}){const a=e.map((e=>e.name+e.keys)).join(\"-\"),o=P.useMemo((()=>F.default(u.subscribeWithSelector((()=>e.reduce(((e,t)=>({...e,[t.name]:!1})),{}))))),[a]),i=P.useMemo((()=>[o.subscribe,o.getState,o]),[a]),s=o.setState;return P.useEffect((()=>{const t=e.map((({name:e,keys:t,up:n})=>({keys:t,up:n,fn:t=>{s({[e]:t}),r&&r(e,t,i[1]())}}))).reduce(((e,{keys:t,fn:r,up:n=!0})=>(t.forEach((t=>e[t]={fn:r,pressed:!1,up:n})),e)),{}),a=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:a,pressed:o,up:i}=n;n.pressed=!0,!i&&o||a(!0)},o=({key:e,code:r})=>{const n=t[e]||t[r];if(!n)return;const{fn:a,up:o}=n;n.pressed=!1,o&&a(!1)},l=n||window;return l.addEventListener(\"keydown\",a,{passive:!0}),l.addEventListener(\"keyup\",o,{passive:!0}),()=>{l.removeEventListener(\"keydown\",a),l.removeEventListener(\"keyup\",o)}}),[n,a]),P.createElement(ie.Provider,{value:i,children:t})},exports.Lathe=hn,exports.Lightformer=pa,exports.Line=ue,exports.Loader=function({containerStyles:e,innerStyles:t,barStyles:r,dataStyles:n,dataInterpolation:a=J,initialState:o=(e=>e)}){const{active:i,progress:s}=K(),l=P.useRef(0),c=P.useRef(0),u=P.useRef(null),[d,m]=P.useState(o(i));P.useEffect((()=>{let e;return i!==d&&(e=setTimeout((()=>m(i)),300)),()=>clearTimeout(e)}),[d,i]);const f=P.useCallback((()=>{u.current&&(l.current+=(s-l.current)/2,(l.current>.95*s||100===s)&&(l.current=s),u.current.innerText=a(l.current),l.current<s&&(c.current=requestAnimationFrame(f)))}),[a,s]);return P.useEffect((()=>(f(),()=>cancelAnimationFrame(c.current))),[f]),d?P.createElement(\"div\",{style:{...ee.container,opacity:i?1:0,...e}},P.createElement(\"div\",null,P.createElement(\"div\",{style:{...ee.inner,...t}},P.createElement(\"div\",{style:{...ee.bar,transform:`scaleX(${s/100})`,...r}}),P.createElement(\"span\",{ref:u,style:{...ee.data,...n}})))):null},exports.MapControls=ct,exports.MarchingCube=We,exports.MarchingCubes=je,exports.MarchingPlane=Ge,exports.Mask=Bo,exports.Merged=zo,exports.MeshDiscardMaterial=$r,exports.MeshDistortMaterial=Lr,exports.MeshPortalMaterial=Vo,exports.MeshReflectorMaterial=Nr,exports.MeshRefractionMaterial=function({aberrationStrength:e=0,fastChroma:r=!0,envMap:n,...o}){a.extend({MeshRefractionMaterial:jr});const i=t.useRef(),{size:s}=a.useThree(),l=t.useMemo((()=>{var t,a;const o={},i=(s=n)&&s.isCubeTexture;var s;const l=(null!==(t=i?null==(a=n.image[0])?void 0:a.width:n.image.width)&&void 0!==t?t:1024)/4,c=Math.floor(Math.log2(l)),u=Math.pow(2,c),d=3*Math.max(u,112),m=4*u;return i&&(o.ENVMAP_TYPE_CUBEM=\"\"),o.CUBEUV_TEXEL_WIDTH=\"\"+1/d,o.CUBEUV_TEXEL_HEIGHT=\"\"+1/m,o.CUBEUV_MAX_MIP=`${c}.0`,e>0&&(o.CHROMATIC_ABERRATIONS=\"\"),r&&(o.FAST_CHROMA=\"\"),o}),[e,r]);return t.useLayoutEffect((()=>{var e;const t=null==(e=i.current)||null==(e=e.__r3f)||null==(e=e.parent)?void 0:e.geometry;t&&(i.current.bvh=new w.MeshBVHUniformStruct,i.current.bvh.updateFrom(new w.MeshBVH(t.clone().toNonIndexed(),{lazyGeneration:!1,strategy:w.SAH})))}),[]),a.useFrame((({camera:e})=>{i.current.viewMatrixInverse=e.matrixWorld,i.current.projectionMatrixInverse=e.projectionMatrixInverse})),P.createElement(\"meshRefractionMaterial\",C.default({key:JSON.stringify(l),defines:l,ref:i,resolution:[s.width,s.height],aberrationStrength:e,envMap:n},o))},exports.MeshTransmissionMaterial=Hr,exports.MeshWobbleMaterial=Ur,exports.MotionPathControls=It,exports.Octahedron=mn,exports.OrbitControls=ut,exports.OrthographicCamera=at,exports.Outlines=function({color:e=\"black\",opacity:t=1,transparent:r=!1,screenspace:n=!1,toneMapped:o=!0,polygonOffset:i=!1,polygonOffsetFactor:s=0,renderOrder:l=0,thickness:c=.05,angle:u=Math.PI,...m}){const f=P.useRef(),[p]=P.useState((()=>new Ae({side:D.BackSide}))),{gl:h}=a.useThree(),x=h.getDrawingBufferSize(new D.Vector2);P.useMemo((()=>a.extend({OutlinesMaterial:Ae})),[]);const y=P.useRef(0),v=P.useRef();return P.useLayoutEffect((()=>{const e=f.current;if(!e)return;const t=e.parent;if(t&&t.geometry&&(y.current!==u||v.current!==t.geometry)){y.current=u,v.current=t.geometry;let r=e.children[0];r&&(u&&r.geometry.dispose(),e.remove(r)),t.skeleton?(r=new D.SkinnedMesh,r.material=p,r.bind(t.skeleton,t.bindMatrix),e.add(r)):t.isInstancedMesh?(r=new D.InstancedMesh(t.geometry,p,t.count),r.instanceMatrix=t.instanceMatrix,e.add(r)):(r=new D.Mesh,r.material=p,e.add(r)),r.geometry=u?d.toCreasedNormals(t.geometry,u):t.geometry}})),P.useLayoutEffect((()=>{const u=f.current;if(!u)return;const d=u.children[0];d&&(d.renderOrder=l,a.applyProps(d.material,{transparent:r,thickness:c,color:e,opacity:t,size:x,screenspace:n,toneMapped:o,polygonOffset:i,polygonOffsetFactor:s}))})),P.useEffect((()=>()=>{const e=f.current;if(!e)return;const t=e.children[0];t&&(u&&t.geometry.dispose(),e.remove(t))}),[]),P.createElement(\"group\",C.default({ref:f},m))},exports.PerformanceMonitor=function({iterations:e=10,ms:r=250,threshold:n=.75,step:o=.1,factor:i=.5,flipflops:s=1/0,bounds:l=(e=>e>100?[60,100]:[40,60]),onIncline:c,onDecline:u,onChange:d,onFallback:m,children:f}){const p=Math.pow(10,0),[h,x]=t.useState((()=>({fps:0,index:0,factor:i,flipped:0,refreshrate:0,fallback:!1,frames:[],averages:[],subscriptions:new Map,subscribe:e=>{const t=Symbol();return h.subscriptions.set(t,e.current),()=>{h.subscriptions.delete(t)}}})));let y=0;return a.useFrame((()=>{const{frames:t,averages:a}=h;if(!h.fallback&&a.length<e){t.push(performance.now());const i=t[t.length-1]-t[0];if(i>=r){if(h.fps=Math.round(t.length/i*1e3*p)/p,h.refreshrate=Math.max(h.refreshrate,h.fps),a[h.index++%e]=h.fps,a.length===e){const[t,r]=l(h.refreshrate),i=a.filter((e=>e>=r)),f=a.filter((e=>e<t));i.length>e*n&&(h.factor=Math.min(1,h.factor+o),h.flipped++,c&&c(h),h.subscriptions.forEach((e=>e.onIncline&&e.onIncline(h)))),f.length>e*n&&(h.factor=Math.max(0,h.factor-o),h.flipped++,u&&u(h),h.subscriptions.forEach((e=>e.onDecline&&e.onDecline(h)))),y!==h.factor&&(y=h.factor,d&&d(h),h.subscriptions.forEach((e=>e.onChange&&e.onChange(h)))),h.flipped>s&&!h.fallback&&(h.fallback=!0,m&&m(h),h.subscriptions.forEach((e=>e.onFallback&&e.onFallback(h)))),h.averages=[]}h.frames=[]}}})),P.createElement(Fo.Provider,{value:h},f)},exports.PerspectiveCamera=ot,exports.PivotControls=ki,exports.Plane=nn,exports.Point=ro,exports.PointMaterial=Zr,exports.PointMaterialImpl=Xr,exports.PointerLockControls=pt,exports.Points=ao,exports.PointsBuffer=no,exports.Polyhedron=un,exports.PositionPoint=Za,exports.PositionalAudio=he,exports.Preload=function({all:e,scene:t,camera:r}){const o=a.useThree((({gl:e})=>e)),i=a.useThree((({camera:e})=>e)),s=a.useThree((({scene:e})=>e));return P.useLayoutEffect((()=>{const a=[];e&&(t||s).traverse((e=>{!1===e.visible&&(a.push(e),e.visible=!0)})),o.compile(t||s,r||i);const l=new n.WebGLCubeRenderTarget(128);new n.CubeCamera(.01,1e5,l).update(o,t||s),l.dispose(),a.forEach((e=>e.visible=!1))}),[]),null},exports.PresentationControls=function({enabled:e=!0,snap:t,global:r,domElement:o,cursor:i=!0,children:s,speed:u=1,rotation:d=[0,0,0],zoom:m=1,polar:f=[0,Math.PI/2],azimuth:p=[-1/0,1/0],config:h={mass:1,tension:170,friction:26}}){const x=a.useThree((e=>e.events)),y=a.useThree((e=>e.gl)),v=o||x.connected||y.domElement,{size:g}=a.useThree(),z=P.useMemo((()=>[d[0]+f[0],d[0]+f[1]]),[d[0],f[0],f[1]]),w=P.useMemo((()=>[d[1]+p[0],d[1]+p[1]]),[d[1],p[0],p[1]]),b=P.useMemo((()=>[n.MathUtils.clamp(d[0],...z),n.MathUtils.clamp(d[1],...w),d[2]]),[d[0],d[1],d[2],z,w]),[M,E]=l.useSpring((()=>({scale:1,rotation:b,config:h})));P.useEffect((()=>{E.start({scale:1,rotation:b,config:h})}),[b]),P.useEffect((()=>{if(r&&i&&e)return v.style.cursor=\"grab\",y.domElement.style.cursor=\"\",()=>{v.style.cursor=\"default\",y.domElement.style.cursor=\"default\"}}),[r,i,v,e]);const S=c.useGesture({onHover:({last:t})=>{i&&!r&&e&&(v.style.cursor=t?\"auto\":\"grab\")},onDrag:({down:r,delta:[a,o],memo:[s,l]=M.rotation.animation.to||b})=>{if(!e)return[o,a];i&&(v.style.cursor=r?\"grabbing\":\"grab\"),a=n.MathUtils.clamp(l+a/g.width*Math.PI*u,...w),o=n.MathUtils.clamp(s+o/g.height*Math.PI*u,...z);const c=t&&!r&&\"boolean\"!=typeof t?t:h;return E.start({scale:r&&o>z[1]/2?m:1,rotation:t&&!r?b:[o,a,0],config:e=>\"scale\"===e?{...c,friction:3*c.friction}:c}),[o,a]}},{target:r?v:void 0});return P.createElement(l.a.group,C.default({},null==S?void 0:S(),M),s)},exports.QuadraticBezierLine=me,exports.RandomizedLight=qn,exports.Reflector=oa,exports.RenderCubeTexture=Ao,exports.RenderTexture=ko,exports.Resize=bn,exports.Ring=cn,exports.RoundedBox=gn,exports.Sampler=function({children:e,weight:t,transform:r,instances:n,mesh:a,count:o=16,...i}){const s=P.useRef(null),l=P.useRef(null),c=P.useRef(null);return P.useLayoutEffect((()=>{var e,t;l.current=null!==(e=null==n?void 0:n.current)&&void 0!==e?e:s.current.children.find((e=>e.hasOwnProperty(\"instanceMatrix\"))),c.current=null!==(t=null==a?void 0:a.current)&&void 0!==t?t:s.current.children.find((e=>\"Mesh\"===e.type))}),[e,null==a?void 0:a.current,null==n?void 0:n.current]),Ve(c,o,r,t,l),P.createElement(\"group\",C.default({ref:s},i),e)},exports.ScreenQuad=wn,exports.ScreenSpace=ce,exports.Scroll=oe,exports.ScrollControls=function({eps:e=1e-5,enabled:t=!0,infinite:r,horizontal:n,pages:o=1,distance:i=1,damping:l=.25,maxSpeed:c=1/0,style:u={},children:d}){const{get:m,setEvents:f,gl:p,size:h,invalidate:x,events:y}=a.useThree(),[v]=P.useState((()=>document.createElement(\"div\"))),[g]=P.useState((()=>document.createElement(\"div\"))),[z]=P.useState((()=>document.createElement(\"div\"))),w=p.domElement.parentNode,b=P.useRef(0),M=P.useMemo((()=>{const t={el:v,eps:e,fill:g,fixed:z,horizontal:n,damping:l,offset:0,delta:0,scroll:b,pages:o,range(e,t,r=0){const n=e-r,a=n+t+2*r;return this.offset<n?0:this.offset>a?1:(this.offset-n)/(a-n)},curve(e,t,r=0){return Math.sin(this.range(e,t,r)*Math.PI)},visible(e,t,r=0){const n=e-r,a=n+t+2*r;return this.offset>=n&&this.offset<=a}};return t}),[e,l,n,o]);P.useEffect((()=>{v.style.position=\"absolute\",v.style.width=\"100%\",v.style.height=\"100%\",v.style[n?\"overflowX\":\"overflowY\"]=\"auto\",v.style[n?\"overflowY\":\"overflowX\"]=\"hidden\",v.style.top=\"0px\",v.style.left=\"0px\";for(const e in u)v.style[e]=u[e];z.style.position=\"sticky\",z.style.top=\"0px\",z.style.left=\"0px\",z.style.width=\"100%\",z.style.height=\"100%\",z.style.overflow=\"hidden\",v.appendChild(z),g.style.height=n?\"100%\":o*i*100+\"%\",g.style.width=n?o*i*100+\"%\":\"100%\",g.style.pointerEvents=\"none\",v.appendChild(g),w.appendChild(v),v[n?\"scrollLeft\":\"scrollTop\"]=1;const e=y.connected||p.domElement;requestAnimationFrame((()=>null==y.connect?void 0:y.connect(v)));const t=m().events.compute;return f({compute(e,t){const{left:r,top:n}=w.getBoundingClientRect(),a=e.clientX-r,o=e.clientY-n;t.pointer.set(a/t.size.width*2-1,-o/t.size.height*2+1),t.raycaster.setFromCamera(t.pointer,t.camera)}}),()=>{w.removeChild(v),f({compute:t}),null==y.connect||y.connect(e)}}),[o,i,n,v,g,z,w]),P.useEffect((()=>{if(y.connected===v){const e=h[n?\"width\":\"height\"],a=v[n?\"scrollWidth\":\"scrollHeight\"],o=a-e;let i=0,s=!0,l=!0;const c=()=>{if(t&&!l&&(x(),i=v[n?\"scrollLeft\":\"scrollTop\"],b.current=i/o,r)){if(!s)if(i>=o){const e=1-M.offset;v[n?\"scrollLeft\":\"scrollTop\"]=1,b.current=M.offset=-e,s=!0}else if(i<=0){const e=1+M.offset;v[n?\"scrollLeft\":\"scrollTop\"]=a,b.current=M.offset=e,s=!0}s&&setTimeout((()=>s=!1),40)}};v.addEventListener(\"scroll\",c,{passive:!0}),requestAnimationFrame((()=>l=!1));const u=e=>v.scrollLeft+=e.deltaY/2;return n&&v.addEventListener(\"wheel\",u,{passive:!0}),()=>{v.removeEventListener(\"scroll\",c),n&&v.removeEventListener(\"wheel\",u)}}}),[v,y,h,r,M,x,n,t]);let E=0;return a.useFrame(((t,r)=>{E=M.offset,s.easing.damp(M,\"offset\",b.current,l,r,c,void 0,e),s.easing.damp(M,\"delta\",Math.abs(E-M.offset),l,r,c,void 0,e),M.delta>e&&x()})),P.createElement(te.Provider,{value:M},d)},exports.Segment=So,exports.SegmentObject=Mo,exports.Segments=bo,exports.Select=function({box:e,multiple:t,children:r,onChange:n,onChangePointerUp:o,border:i=\"1px solid #55aaff\",backgroundColor:s=\"rgba(75, 160, 255, 0.1)\",filter:l=(e=>e),...c}){const[u,m]=P.useState(!1),{setEvents:f,camera:p,raycaster:h,gl:x,controls:y,size:v,get:g}=a.useThree(),[z,w]=P.useState(!1),[b,M]=P.useReducer(((e,{object:t,shift:r})=>void 0===t?[]:Array.isArray(t)?t:r?e.includes(t)?e.filter((e=>e!==t)):[t,...e]:e[0]===t?[]:[t]),[]);P.useEffect((()=>{u?null==n||n(b):null==o||o(b)}),[b,u]);const E=P.useCallback((e=>{e.stopPropagation(),M({object:l([e.object])[0],shift:t&&e.shiftKey})}),[]),S=P.useCallback((e=>!z&&M({})),[z]),T=P.useRef(null);return P.useEffect((()=>{if(!e||!t)return;const r=new d.SelectionBox(p,T.current),n=document.createElement(\"div\");n.style.pointerEvents=\"none\",n.style.border=i,n.style.backgroundColor=s,n.style.position=\"fixed\";const a=new D.Vector2,o=new D.Vector2,c=new D.Vector2,u=g().events.enabled,h=null==y?void 0:y.enabled;let z=!1;function w(e,t){const{offsetX:r,offsetY:n}=e,{width:a,height:o}=v;t.set(r/a*2-1,-n/o*2+1)}function b(e){e.shiftKey&&(!function(e){var t;y&&(y.enabled=!1),f({enabled:!1}),m(z=!0),null==(t=x.domElement.parentElement)||t.appendChild(n),n.style.left=`${e.clientX}px`,n.style.top=`${e.clientY}px`,n.style.width=\"0px\",n.style.height=\"0px\",a.x=e.clientX,a.y=e.clientY}(e),w(e,r.startPoint))}let E=[];function S(e){if(z){!function(e){c.x=Math.max(a.x,e.clientX),c.y=Math.max(a.y,e.clientY),o.x=Math.min(a.x,e.clientX),o.y=Math.min(a.y,e.clientY),n.style.left=`${o.x}px`,n.style.top=`${o.y}px`,n.style.width=c.x-o.x+\"px\",n.style.height=c.y-o.y+\"px\"}(e),w(e,r.endPoint);const t=r.select().sort((e=>e.uuid)).filter((e=>e.isMesh));_.default(t,E)||(E=t,M({object:l(t)}))}}function C(e){var t;z&&z&&(y&&(y.enabled=h),f({enabled:u}),m(z=!1),null==(t=n.parentElement)||t.removeChild(n))}return document.addEventListener(\"pointerdown\",b,{passive:!0}),document.addEventListener(\"pointermove\",S,{passive:!0,capture:!0}),document.addEventListener(\"pointerup\",C,{passive:!0}),()=>{document.removeEventListener(\"pointerdown\",b),document.removeEventListener(\"pointermove\",S),document.removeEventListener(\"pointerup\",C)}}),[v.width,v.height,h,p,y,x]),P.createElement(\"group\",C.default({ref:T,onClick:E,onPointerOver:()=>w(!0),onPointerOut:()=>w(!1),onPointerMissed:S},c),P.createElement(se.Provider,{value:b},r))},exports.Shadow=Kn,exports.ShadowAlpha=function({opacity:e,alphaMap:t}){const r=P.useRef(null),n=P.useRef(null),o=P.useRef({value:1}),i=P.useRef({value:null}),s=P.useRef({value:!1});return P.useLayoutEffect((()=>{r.current.onBeforeCompile=n.current.onBeforeCompile=e=>{const t=e.fragmentShader.indexOf(\"void main\");let r,n=\"\",a=t;for(;\"\\n\"!==r&&a<t+100;)r=e.fragmentShader.charAt(a),n+=r,a++;n=n.trim(),e.vertexShader=e.vertexShader.replace(\"void main() {\",\"\\n        varying vec2 custom_vUv;\\n\\n        void main() {\\n          custom_vUv = uv;\\n          \\n        \"),e.fragmentShader=e.fragmentShader.replace(n,\"\\n          uniform float uShadowOpacity;\\n          uniform sampler2D uAlphaMap;\\n          uniform bool uHasAlphaMap;\\n\\n          varying vec2 custom_vUv;\\n  \\n          float bayerDither2x2( vec2 v ) {\\n            return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\\n          }\\n    \\n          float bayerDither4x4( vec2 v ) {\\n            vec2 P1 = mod( v, 2.0 );\\n            vec2 P2 = mod( floor( 0.5  * v ), 2.0 );\\n            return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\\n          }\\n  \\n          void main() {\\n            float alpha = \\n              uHasAlphaMap ? \\n                uShadowOpacity * texture2D(uAlphaMap, custom_vUv).x\\n              : uShadowOpacity;\\n\\n            if( ( bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) ) ) / 16.0 >= alpha ) discard;\\n            \\n          \"),e.uniforms.uShadowOpacity=o.current,e.uniforms.uAlphaMap=i.current,e.uniforms.uHasAlphaMap=s.current}}),[]),a.useFrame((()=>{var n;const a=null==(n=r.current.__r3f)?void 0:n.parent;if(a){const r=a.material;r&&(o.current.value=null!=e?e:r.opacity,!1===t?(i.current.value=null,s.current.value=!1):(i.current.value=t||r.alphaMap,s.current.value=!!i.current.value))}})),P.createElement(P.Fragment,null,P.createElement(\"meshDepthMaterial\",{ref:r,attach:\"customDepthMaterial\",depthPacking:D.RGBADepthPacking}),P.createElement(\"meshDistanceMaterial\",{ref:n,attach:\"customDistanceMaterial\"}))},exports.Shape=yn,exports.Sky=xa,exports.SoftShadows=function({focus:e=0,samples:t=10,size:r=25}){const n=a.useThree((e=>e.gl)),o=a.useThree((e=>e.scene)),i=a.useThree((e=>e.camera));return P.useEffect((()=>{const a=D.ShaderChunk.shadowmap_pars_fragment;return D.ShaderChunk.shadowmap_pars_fragment=D.ShaderChunk.shadowmap_pars_fragment.replace(\"#ifdef USE_SHADOWMAP\",\"#ifdef USE_SHADOWMAP\\n\"+(({focus:e=0,size:t=25,samples:r=10}={})=>`\\n#define PENUMBRA_FILTER_SIZE float(${t})\\n#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\\nvec3 randRGB(vec2 uv) {\\n  return vec3(\\n    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\\n    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\\n    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\\n  );\\n}\\n\\nvec3 lowPassRandRGB(vec2 uv) {\\n  // 3x3 convolution (average)\\n  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\\n  vec3 result = vec3(0);\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\\n  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\\n  result *= 0.111111111; // 1.0 / 9.0\\n  return result;\\n}\\nvec3 highPassRandRGB(vec2 uv) {\\n  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\\n  // hp(x) = x - lp(x)\\n  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\\n}\\n\\n\\nvec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\\n  const float goldenAngle = 2.399963f; // radians\\n  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\\n  float theta = float(sampleIndex) * goldenAngle + angle;\\n  float sine = sin(theta);\\n  float cosine = cos(theta);\\n  return vec2(cosine, sine) * r;\\n}\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\nfloat findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float blockerDepthSum = float(${e});\\n  float blockers = 0.0;\\n\\n  int j = 0;\\n  vec2 offset = vec2(0.);\\n  float depth = 0.;\\n\\n  #pragma unroll_loop_start\\n  for(int i = 0; i < ${r}; i ++) {\\n    offset = (vogelDiskSample(j, ${r}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\\n    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\\n    if (depth < compare) {\\n      blockerDepthSum += depth;\\n      blockers++;\\n    }\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n\\n  if (blockers > 0.0) {\\n    return blockerDepthSum / blockers;\\n  }\\n  return -1.0;\\n}\\n\\n        \\nfloat vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\\n  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\\n  float shadow = 0.0f;\\n  int j = 0;\\n  vec2 vogelSample = vec2(0.0);\\n  vec2 offset = vec2(0.0);\\n  #pragma unroll_loop_start\\n  for (int i = 0; i < ${r}; i++) {\\n    vogelSample = vogelDiskSample(j, ${r}, angle) * texelSize;\\n    offset = vogelSample * (1.0 + filterRadius * float(${t}));\\n    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\\n    j++;\\n  }\\n  #pragma unroll_loop_end\\n  return shadow * 1.0 / ${r}.0;\\n}\\n\\nfloat PCSS (sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\\n  if (avgBlockerDepth == -1.0) {\\n    return 1.0;\\n  }\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\\n}`)({size:r,samples:t,focus:e})).replace(\"#if defined( SHADOWMAP_TYPE_PCF )\",\"\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )\"),Yr(n,o,i),()=>{D.ShaderChunk.shadowmap_pars_fragment=a,Yr(n,o,i)}}),[e,r,t]),null},exports.Sparkles=Ba,exports.Sphere=rn,exports.Splat=function({src:e,toneMapped:t=!1,alphaTest:r=0,alphaHash:n=!1,chunkSize:o=25e3,...i}){a.extend({SplatMaterial:Je});const s=P.useRef(null),l=a.useThree((e=>e.gl)),c=a.useThree((e=>e.camera)),u=a.useLoader(tt,e,(e=>{e.gl=l,e.chunkSize=o}));return P.useLayoutEffect((()=>u.connect(s.current)),[e]),a.useFrame((()=>u.update(s.current,c,n))),P.createElement(\"mesh\",C.default({ref:s,frustumCulled:!1},i),P.createElement(\"splatMaterial\",{key:`${e}/${r}/${n}${Je.key}`,transparent:!n,depthTest:!0,alphaTest:n?0:r,centerAndScaleTexture:u.centerAndScaleTexture,covAndColorTexture:u.covAndColorTexture,depthWrite:!!n||r>0,blending:n?D.NormalBlending:D.CustomBlending,blendSrcAlpha:D.OneFactor,alphaHash:!!n,toneMapped:t}))},exports.SpotLight=fa,exports.SpotLightShadow=function(e){return e.shader?P.createElement(da,e):P.createElement(ma,e)},exports.SpriteAnimator=kr,exports.Stage=function({children:e,center:t,adjustCamera:r=!0,intensity:n=.5,shadows:a=\"contact\",environment:o=\"city\",preset:i=\"rembrandt\",...s}){var l,c,u,d,m,f,p,h;const x=\"string\"==typeof i?Zn[i]:i,[{radius:y,height:v},g]=P.useState({radius:0,width:0,height:0,depth:0}),z=null!==(l=null==a?void 0:a.bias)&&void 0!==l?l:-1e-4,w=null!==(c=null==a?void 0:a.normalBias)&&void 0!==c?c:0,b=null!==(u=null==a?void 0:a.size)&&void 0!==u?u:1024,M=null!==(d=null==a?void 0:a.offset)&&void 0!==d?d:0,E=\"contact\"===a||\"contact\"===(null==a?void 0:a.type),S=\"accumulative\"===a||\"accumulative\"===(null==a?void 0:a.type),T={...\"object\"==typeof a?a:{}},R=o?\"string\"==typeof o?{preset:o}:o:null,D=P.useCallback((e=>{const{width:r,height:n,depth:a,boundingSphere:o}=e;g({radius:o.radius,width:r,height:n,depth:a}),null!=t&&t.onCentered&&t.onCentered(e)}),[]);return P.createElement(P.Fragment,null,P.createElement(\"ambientLight\",{intensity:n/3}),P.createElement(\"spotLight\",{penumbra:1,position:[x.main[0]*y,x.main[1]*y,x.main[2]*y],intensity:2*n,castShadow:!!a,\"shadow-bias\":z,\"shadow-normalBias\":w,\"shadow-mapSize\":b}),P.createElement(\"pointLight\",{position:[x.fill[0]*y,x.fill[1]*y,x.fill[2]*y],intensity:n}),P.createElement(Pn,C.default({fit:!!r,clip:!!r,margin:Number(r),observe:!0},s),P.createElement(Yn,{radius:y,adjustCamera:r}),P.createElement(Dr,C.default({},t,{position:[0,M/2,0],onCentered:D}),e)),P.createElement(\"group\",{position:[0,-v/2-M/2,0]},E&&P.createElement(Wn,C.default({scale:4*y,far:y,blur:2},T)),S&&P.createElement($n,C.default({temporal:!0,frames:100,alphaTest:.9,toneMapped:!0,scale:4*y},T),P.createElement(qn,{amount:null!==(m=T.amount)&&void 0!==m?m:8,radius:null!==(f=T.radius)&&void 0!==f?f:y,ambient:null!==(p=T.ambient)&&void 0!==p?p:.5,intensity:null!==(h=T.intensity)&&void 0!==h?h:1,position:[x.main[0]*y,x.main[1]*y,x.main[2]*y],size:4*y,bias:-z,mapSize:b}))),o&&P.createElement(jn,R))},exports.Stars=ga,exports.Stats=function({showPanel:e=0,className:t,parent:r}){const n=function(e,t=[],r){const[n,a]=P.useState();return P.useLayoutEffect((()=>{const t=e();return a(t),yr(r,t),()=>yr(r,null)}),t),n}((()=>new U.default),[]);return P.useEffect((()=>{if(n){const o=r&&r.current||document.body;n.showPanel(e),null==o||o.appendChild(n.dom),t&&n.dom.classList.add(...t.split(\" \").filter((e=>e)));const i=a.addEffect((()=>n.begin())),s=a.addAfterEffect((()=>n.end()));return()=>{null==o||o.removeChild(n.dom),i(),s()}}}),[r,n,t,e]),null},exports.StatsGl=function({className:e,parent:t,...r}){const n=a.useThree((e=>e.gl)),o=P.useMemo((()=>{const e=new I.default({...r});return e.init(n),e}),[n]);return P.useEffect((()=>{if(o){const r=t&&t.current||document.body;null==r||r.appendChild(o.dom),e&&o.container.classList.add(...e.split(\" \").filter((e=>e)));const n=a.addAfterEffect((()=>o.update()));return()=>{null==r||r.removeChild(o.dom),n()}}}),[t,o,e]),null},exports.Svg=qe,exports.Tetrahedron=ln,exports.Text=xe,exports.Text3D=we,exports.Torus=on,exports.TorusKnot=sn,exports.TrackballControls=dt,exports.Trail=Ie,exports.TransformControls=ft,exports.Tube=an,exports.View=({track:e,index:t=1,frames:r=1/0,children:n})=>{var o,i;const s=P.useRef(null),{size:l,scene:c}=a.useThree(),[u]=P.useState((()=>new D.Scene)),d=P.useCallback(((t,r)=>{if(s.current&&e.current&&t.target===e.current){const{width:e,height:n,left:a,top:o}=s.current,i=t.clientX-a,l=t.clientY-o;r.pointer.set(i/e*2-1,-l/n*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)}}),[s,e]),[m,f]=P.useReducer((()=>!0),!1);return P.useEffect((()=>{var t;s.current=null==(t=e.current)?void 0:t.getBoundingClientRect(),f()}),[e]),P.createElement(P.Fragment,null,m&&a.createPortal(P.createElement(Go,{canvasSize:l,frames:r,scene:c,track:e,rect:s,index:t},n,P.createElement(\"group\",{onPointerOver:()=>null})),u,{events:{compute:d,priority:t},size:{width:null==(o=s.current)?void 0:o.width,height:null==(i=s.current)?void 0:i.height}}))},exports.Wireframe=function({geometry:e,...t}){return e?P.createElement(Wa,C.default({geometry:e},t)):P.createElement(Ga,t)},exports.accumulativeContext=Gn,exports.calcPosFromAngles=ha,exports.calculateScaleFactor=pi,exports.isWebGL2Available=()=>{try{var e=document.createElement(\"canvas\");return!(!window.WebGL2RenderingContext||!e.getContext(\"webgl2\"))}catch(e){return!1}},exports.meshBounds=function(e,t){const r=this.geometry,n=this.material,a=this.matrixWorld;void 0!==n&&(null===r.boundingSphere&&r.computeBoundingSphere(),Ro.copy(r.boundingSphere),Ro.applyMatrix4(a),!1!==e.ray.intersectsSphere(Ro)&&(Co.copy(a).invert(),Po.copy(e.ray).applyMatrix4(Co),null!==r.boundingBox&&null===Po.intersectBox(r.boundingBox,Do)||t.push({distance:Do.distanceTo(e.ray.origin),point:Do.clone(),object:this})))},exports.shaderMaterial=Ee,exports.useAnimations=function(e,t){const r=P.useRef(),[o]=P.useState((()=>t?t instanceof n.Object3D?{current:t}:t:r)),[i]=P.useState((()=>new n.AnimationMixer(void 0)));P.useLayoutEffect((()=>{t&&(o.current=t instanceof n.Object3D?t:t.current),i._root=o.current}));const s=P.useRef({}),l=P.useMemo((()=>{const t={};return e.forEach((e=>Object.defineProperty(t,e.name,{enumerable:!0,get(){if(o.current)return s.current[e.name]||(s.current[e.name]=i.clipAction(e,o.current))},configurable:!0}))),{ref:o,clips:e,actions:t,names:e.map((e=>e.name)),mixer:i}}),[e]);return a.useFrame(((e,t)=>i.update(t))),P.useEffect((()=>{const e=o.current;return()=>{s.current={},i.stopAllAction(),Object.values(l.actions).forEach((t=>{e&&i.uncacheAction(t,e)}))}}),[e]),l},exports.useAspect=function(e,t,r=1){const n=a.useThree((e=>e.viewport)),o=t*(n.aspect>e/t?n.width/e:n.height/t);return[e*(n.aspect>e/t?n.width/e:n.height/t)*r,o*r,1]},exports.useBVH=function(e,t){t={strategy:w.SAH,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1,...t},P.useEffect((()=>{if(e.current){e.current.raycast=w.acceleratedRaycast;const r=e.current.geometry;return r.computeBoundsTree=w.computeBoundsTree,r.disposeBoundsTree=w.disposeBoundsTree,r.computeBoundsTree(t),()=>{r.boundsTree&&r.disposeBoundsTree()}}}),[e,JSON.stringify(t)])},exports.useBounds=Rn,exports.useBoxProjectedEnv=function(e=new D.Vector3,t=new D.Vector3){const[r]=P.useState((()=>({position:new D.Vector3,size:new D.Vector3})));a.applyProps(r,{position:e,size:t});const n=P.useRef(null),o=P.useMemo((()=>({ref:n,onBeforeCompile:e=>function(e,t,r){e.defines.BOX_PROJECTED_ENV_MAP=!0,e.uniforms.envMapPosition={value:t},e.uniforms.envMapSize={value:r},e.vertexShader=`\\n  varying vec3 vWorldPosition;\\n  ${e.vertexShader.replace(\"#include <worldpos_vertex>\",br)}`,e.fragmentShader=`\\n    ${Mr}\\n    ${e.fragmentShader.replace(\"#include <envmap_physical_pars_fragment>\",D.ShaderChunk.envmap_physical_pars_fragment).replace(\"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\",`vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n         ${Er}\\n         `).replace(\"reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\",`reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n         ${Sr}\\n        `)}`}(e,r.position,r.size),customProgramCacheKey:()=>JSON.stringify(r.position.toArray())+JSON.stringify(r.size.toArray())})),[...r.position.toArray(),...r.size.toArray()]);return P.useLayoutEffect((()=>{n.current.needsUpdate=!0}),[r]),o},exports.useCamera=function(e,t){const r=a.useThree((e=>e.pointer)),[o]=P.useState((()=>{const o=new n.Raycaster;return t&&a.applyProps(o,t,{}),function(t,a){o.setFromCamera(r,e instanceof n.Camera?e:e.current);const i=this.constructor.prototype.raycast.bind(this);i&&i(o,a)}}));return o},exports.useContextBridge=function(...e){const t=P.useRef([]);return t.current=e.map((e=>P.useContext(e))),P.useMemo((()=>({children:r})=>e.reduceRight(((e,r,n)=>P.createElement(r.Provider,{value:t.current[n],children:e})),r)),[])},exports.useCubeCamera=it,exports.useCubeTexture=fr,exports.useCursor=function(e,t=\"pointer\",r=\"auto\",n=document.body){P.useEffect((()=>{if(e)return n.style.cursor=t,()=>{n.style.cursor=r}}),[e])},exports.useDepthBuffer=function({size:e=256,frames:t=1/0}={}){const r=a.useThree((e=>e.viewport.dpr)),{width:o,height:i}=a.useThree((e=>e.size)),s=e||o*r,l=e||i*r,c=P.useMemo((()=>{const e=new n.DepthTexture(s,l);return e.format=n.DepthFormat,e.type=n.UnsignedShortType,{depthTexture:e}}),[s,l]);let u=0;const d=nt(s,l,c);return a.useFrame((e=>{(t===1/0||u<t)&&(e.gl.setRenderTarget(d),e.gl.render(e.scene,e.camera),e.gl.setRenderTarget(null),u++)})),d.depthTexture},exports.useDetectGPU=e=>f.suspend((()=>z.getGPUTier(e)),[\"useDetectGPU\"]),exports.useEnvironment=Ln,exports.useFBO=nt,exports.useFBX=pr,exports.useFaceControls=Ft,exports.useFaceLandmarker=Tt,exports.useFont=ge,exports.useGLTF=Qe,exports.useGizmoContext=jt,exports.useHelper=vr,exports.useIntersect=wr,exports.useKTX2=xr,exports.useKeyboardControls=function(e){const[t,r,n]=P.useContext(ie);return e?n(e):[t,r]},exports.useMask=function(e,t=!1){return{stencilWrite:!0,stencilRef:e,stencilFunc:t?D.NotEqualStencilFunc:D.EqualStencilFunc,stencilFail:D.KeepStencilOp,stencilZFail:D.KeepStencilOp,stencilZPass:D.KeepStencilOp}},exports.useMatcapTexture=function(e=0,t=1024,r){const n=f.suspend((()=>fetch(\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/matcaps.json\").then((e=>e.json()))),[\"matcapList\"]),a=n[0],o=P.useMemo((()=>Object.keys(n).length),[]),i=`${P.useMemo((()=>\"string\"==typeof e?e:\"number\"==typeof e?n[e]:null),[e])||a}${function(e){switch(e){case 64:return\"-64px\";case 128:return\"-128px\";case 256:return\"-256px\";case 512:return\"-512px\";default:return\"\"}}(t)}.png`,s=`https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d/${t}/${i}`;return[Te(s,r),s,o]},exports.useMotion=Bt,exports.useNormalTexture=function(e=0,t={},r){const{repeat:a=[1,1],anisotropy:o=1,offset:i=[0,0]}=t,s=f.suspend((()=>fetch(\"https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/normals/normals.json\").then((e=>e.json()))),[\"normalsList\"]),l=P.useMemo((()=>Object.keys(s).length),[]),c=s[0],u=`https://rawcdn.githack.com/pmndrs/drei-assets/7a3104997e1576f83472829815b00880d88b32fb/normals/${s[e]||c}`,d=Te(u,r);return P.useLayoutEffect((()=>{d&&(d.wrapS=d.wrapT=n.RepeatWrapping,d.repeat=new n.Vector2(a[0],a[1]),d.offset=new n.Vector2(i[0],i[1]),d.anisotropy=o)}),[d,o,a,i]),[d,u,l]},exports.usePerformanceMonitor=function({onIncline:e,onDecline:r,onChange:n,onFallback:a}){const o=t.useContext(Fo),i=t.useRef({onIncline:e,onDecline:r,onChange:n,onFallback:a});t.useLayoutEffect((()=>{i.current.onIncline=e,i.current.onDecline=r,i.current.onChange=n,i.current.onFallback=a}),[e,r,n,a]),t.useLayoutEffect((()=>o.subscribe(i)),[o])},exports.useProgress=K,exports.useScroll=re,exports.useSelect=function(){return P.useContext(se)},exports.useSurfaceSampler=Ve,exports.useTexture=Te,exports.useTrail=Ue,exports.useTrailTexture=function(e={}){const{size:r,maxAge:n,radius:o,intensity:i,interpolate:s,smoothing:l,minForce:c,blend:u,ease:d}=e,m=t.useMemo((()=>new Rr(e)),[r,n,o,i,s,l,c,u,d]);a.useFrame(((e,t)=>{m.update(t)}));const f=t.useCallback((e=>m.addTouch(e.uv)),[m]);return[m.texture,f]},exports.useVideoTexture=yt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaW5kZXguY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFNBQVMsRUFBQyxDQUFDLE1BQU0sbUJBQU8sQ0FBQyw4RkFBZ0MsSUFBSSxtQkFBTyxDQUFDLHdHQUFPLElBQUksbUJBQU8sQ0FBQyxxRkFBa0IsSUFBSSxtQkFBTyxDQUFDLHlEQUFPLElBQUksbUJBQU8sQ0FBQyxpR0FBb0IsSUFBSSxtQkFBTyxDQUFDLDBEQUFTLElBQUksbUJBQU8sQ0FBQyw2RUFBa0IsSUFBSSxtQkFBTyxDQUFDLDJEQUFPLElBQUksbUJBQU8sQ0FBQyxtSUFBcUIsSUFBSSxtQkFBTyxDQUFDLGlHQUFvQixJQUFJLG1CQUFPLENBQUMsMEVBQW9CLElBQUksbUJBQU8sQ0FBQyxpRUFBYyxJQUFJLG1CQUFPLENBQUMsb0VBQWlCLElBQUksbUJBQU8sQ0FBQyxzRUFBZSxJQUFJLG1CQUFPLENBQUMsOERBQVUsSUFBSSxtQkFBTyxDQUFDLDhEQUFhLElBQUksbUJBQU8sQ0FBQyw4REFBYSxJQUFJLG1CQUFPLENBQUMscUZBQWlCLElBQUksbUJBQU8sQ0FBQyxrRUFBVSxJQUFJLG1CQUFPLENBQUMsNkRBQVUsSUFBSSxtQkFBTyxDQUFDLDBFQUFZLElBQUksbUJBQU8sQ0FBQyw4R0FBZ0IsSUFBSSxtQkFBTyxDQUFDLDhEQUFNLElBQUksbUJBQU8sQ0FBQyx3RUFBZ0IsSUFBSSxtQkFBTyxDQUFDLGdFQUFjLEVBQUUsY0FBYywrQ0FBK0MsV0FBVyxjQUFjLDRCQUE0QiwwQkFBMEIsOENBQThDLGtCQUFrQiwyQ0FBMkMsbUNBQW1DLDZCQUE2QixhQUFhLEdBQUcsZ0NBQWdDLHNHQUFzRyxzREFBc0Qsa0JBQWtCLCtDQUErQyxhQUFhLCtCQUErQix5QkFBeUIsaUNBQWlDLHFCQUFxQixrQkFBa0IsWUFBWSxPQUFPLDhDQUE4QyxXQUFXLDREQUE0RCxNQUFNLGdCQUFnQiwrRkFBK0YsT0FBTyx3QkFBd0IsK1NBQStTLE1BQU0sTUFBTSw2REFBNkQsNlVBQTZVLDRDQUE0QyxhQUFhLHdCQUF3QixxQkFBcUIscUNBQXFDLG1CQUFtQixtSUFBbUksK0JBQStCLGNBQWMsa0NBQWtDLDhEQUE4RCxNQUFNLE9BQU8sb0JBQW9CLGdCQUFnQixFQUFFLEtBQUsseUJBQXlCLG1DQUFtQyxNQUFNLE9BQU8sd0JBQXdCLEtBQUssS0FBSyxLQUFLLE1BQU0scUJBQXFCLEVBQUUsaURBQWlELGtDQUFrQyxpQ0FBaUMsbUJBQW1CLE9BQU8sMkJBQTJCLGlIQUFpSCxFQUFFLHlFQUF5RSw4REFBOEQsTUFBTSxtQ0FBbUMsb0NBQW9DLFFBQVEsd0JBQXdCLFFBQVEsc0VBQXNFLGVBQWUsd0JBQXdCLGVBQWUsd0JBQXdCLHFDQUFxQywwREFBMEQsc0NBQXNDLEdBQUcsR0FBRyxzQkFBc0IsZ0JBQWdCLGNBQWMseURBQXlELHFDQUFxQyxrR0FBa0csc0JBQXNCLDRIQUE0SCw4QkFBOEIsY0FBYyxTQUFTLHNFQUFzRSxtQkFBbUIsTUFBTSwwQkFBMEIsMkRBQTJELGtDQUFrQyxpQ0FBaUMsYUFBYSxzQkFBc0Isb0NBQW9DLFNBQVMsa0JBQWtCLGlCQUFpQixtQkFBbUIsNkVBQTZFLG9EQUFvRCxxQkFBcUIsZ0JBQWdCLHdFQUF3RSxzSkFBc0osMEJBQTBCLGdCQUFnQixLQUFLLHNFQUFzRSxxREFBcUQsMENBQTBDLEVBQUUsYUFBYSxZQUFZLEtBQUssV0FBVyxtQkFBbUIsRUFBRSxLQUFLLDRCQUE0Qix5T0FBeU8sRUFBRSx3REFBd0QsRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxxREFBcUQsS0FBSyxtQ0FBbUMsbURBQW1ELHFDQUFxQyw4SEFBOEgsNkJBQTZCLFNBQVMsZ0JBQWdCLGlDQUFpQyxLQUFLLEtBQUssS0FBSyxjQUFjLEVBQUUsR0FBRyw4QkFBOEIsbUNBQW1DLGNBQWMsOEJBQThCLG9EQUFvRCxNQUFNLHVCQUF1QixHQUFHLDhOQUE4TixLQUFLLHlEQUF5RCwyQkFBMkIsZUFBZSxLQUFLLHNCQUFzQixvREFBb0Qsd0RBQXdELHdDQUF3QyxxQ0FBcUMsR0FBRywwQkFBMEIsNFRBQTRULHlDQUF5QyxtQ0FBbUMseU1BQXlNLCtFQUErRSx5QkFBeUIscUdBQXFHLHFHQUFxRyw2RUFBNkUsMkRBQTJELGlHQUFpRyxtQ0FBbUMsNEdBQTRHLDRHQUE0RywrQ0FBK0MsNERBQTRELGFBQWEsaURBQWlELG9EQUFvRCxXQUFXLFVBQVUsUUFBUSwyQ0FBMkMsSUFBSSxNQUFNLGlDQUFpQyxtQ0FBbUMsK0VBQStFLGdGQUFnRixJQUFJLEdBQUcsUUFBUSxpRUFBaUUsR0FBRywyREFBMkQsRUFBRSxxQ0FBcUMsR0FBRyxVQUFVLEVBQUUsNENBQTRDLHVCQUF1QixpREFBaUQsZ0JBQWdCLGdFQUFnRSxFQUFFLEVBQUUsd0RBQXdELG9CQUFvQixhQUFhLEdBQUcsVUFBVSxXQUFXLHVMQUF1TCxRQUFRLDJEQUEyRCxNQUFNLG9HQUFvRyxPQUFPLG1WQUFtViwwQkFBMEIsY0FBYyx3QkFBd0IseUJBQXlCLFdBQVcsTUFBTSwrQkFBK0IsaUJBQWlCLDZCQUE2Qix3QkFBd0IsdUhBQXVILDRCQUE0QixxQkFBcUIsSUFBSSxzQkFBc0Isd0JBQXdCLE1BQU0sK0JBQStCLGlCQUFpQixzR0FBc0csd0JBQXdCLHlEQUF5RCx1Q0FBdUMsS0FBSyx1Q0FBdUMsUUFBUSw2Q0FBNkMsNEJBQTRCLDhEQUE4RCxpQ0FBaUMsUUFBUSxxQ0FBcUMsUUFBUSxZQUFZLHNCQUFzQixZQUFZLE1BQU0sZ0JBQWdCLG9DQUFvQyxNQUFNLEtBQUssR0FBRywrQkFBK0IsNkJBQTZCLGlDQUFpQyw2REFBNkQsSUFBSSwyREFBMkQscUJBQXFCLFNBQVMsSUFBSSx5QkFBeUIsbUNBQW1DLHlQQUF5UCxrRkFBa0YsbURBQW1ELDZCQUE2QixNQUFNLEtBQUssc0JBQXNCLDJCQUEyQixNQUFNLHVCQUF1QixxQkFBcUIsU0FBUyxJQUFJLDRFQUE0RSxzQ0FBc0MscUJBQXFCLDZCQUE2QixnQkFBZ0IsS0FBSyw4QkFBOEIseUZBQXlGLElBQUksb0pBQW9KLHFFQUFxRSx5QkFBeUIsZ0pBQWdKLEdBQUcsK0JBQStCLHVEQUF1RCxzQkFBc0IsU0FBUyxXQUFXLCtCQUErQix5QkFBeUIsaUNBQWlDLG1FQUFtRSx1RkFBdUYsZUFBZSxpQ0FBaUMsMkJBQTJCLHlDQUF5Qyx3SEFBd0gsTUFBTSwrQ0FBK0MsdURBQXVELElBQUksaVpBQWlaLHdCQUF3Qiw4QkFBOEIsaUJBQWlCLHFGQUFxRixNQUFNLDhDQUE4QyxxQ0FBcUMsOEJBQThCLEtBQUssOEJBQThCLCtDQUErQyxJQUFJLHdCQUF3QixrTUFBa00scURBQXFELGVBQWUscUNBQXFDLGVBQWUsS0FBSyw4QkFBOEIsOEZBQThGLElBQUksd0JBQXdCLGlFQUFpRSx1Q0FBdUMsdUVBQXVFLHlCQUF5QiwyQkFBMkIsNkRBQTZELHdCQUF3QixnQ0FBZ0MsWUFBWSxJQUFJLEtBQUssZ0NBQWdDLG9DQUFvQywrQkFBK0IsU0FBUyxxQ0FBcUMsOEJBQThCLEtBQUssc0JBQXNCLDZDQUE2QyxNQUFNLG1DQUFtQyxTQUFTLGdGQUFnRix5QkFBeUIsa0JBQWtCLCtFQUErRSwrQkFBK0Isa0JBQWtCLHFCQUFxQixzRkFBc0YsbURBQW1ELDhCQUE4QixLQUFLLHNCQUFzQixrSEFBa0gsTUFBTSxNQUFNLHFCQUFxQix3REFBd0QsU0FBUyxtQkFBTyxDQUFDLCtGQUFtQixHQUFHLHdCQUF3QixhQUFhLHlEQUF5RCxXQUFXLFNBQVMsaUNBQWlDLHNEQUFzRCxTQUFTLE9BQU8seUNBQXlDLG9CQUFvQixvREFBb0QsYUFBYSxZQUFZLEdBQUcsaUZBQWlGLDJFQUEyRSxPQUFPLEdBQUcsWUFBWSxxQkFBcUIsMEJBQTBCLHdEQUF3RCxtQkFBbUIsZUFBZSx5QkFBeUIseURBQXlELGdEQUFnRCxnTUFBZ00sTUFBTSx5QkFBeUIsbUNBQW1DLE9BQU8sa0RBQWtELDhJQUE4SSx5REFBeUQsU0FBUyxXQUFXLGlDQUFpQyx3Q0FBd0MsWUFBWSwwQ0FBMEMsK0JBQStCLHdHQUF3Ryx3RkFBd0YsSUFBSSxNQUFNLHlDQUF5QyxPQUFPLEtBQUssc0JBQXNCLHlLQUF5SyxNQUFNLHlCQUF5QixnRkFBZ0YsT0FBTyxvQkFBb0Isd0NBQXdDLG1DQUFtQyxrREFBa0QsdUZBQXVGLEVBQUUscUhBQXFILEdBQUcsa0JBQWtCLFFBQVEsNkZBQTZGLGdDQUFnQyxNQUFNLG1DQUFtQyxLQUFLLFdBQVcsK0NBQStDLGtDQUFrQyxTQUFTLGFBQWEsMkNBQTJDLGlCQUFpQixTQUFTLGlEQUFpRCw2QkFBNkIsNEJBQTRCLDhCQUE4QixTQUFTLEVBQUUsR0FBRywrQ0FBK0MsZ0NBQWdDLE9BQU8sR0FBRyxtQkFBbUIsNkNBQTZDLEdBQUcsRUFBRSxxQkFBcUIsdUNBQXVDLGdCQUFnQixFQUFFLDBCQUEwQixPQUFPLGdDQUFnQywrQkFBK0IsS0FBSyxTQUFTLEVBQUUsS0FBSyxrQ0FBa0MsOERBQThELCtEQUErRCx1Q0FBdUMsMENBQTBDLG1FQUFtRSxpQkFBaUIsc0ZBQXNGLDJCQUEyQixjQUFjLHlCQUF5QixzQkFBc0IsaURBQWlELGdCQUFnQixXQUFXLFFBQVEsNkJBQTZCLFNBQVMsU0FBUyxzR0FBc0csZ0VBQWdFLHlIQUF5SCx1QkFBdUIsaUJBQWlCLHFGQUFxRixlQUFlLEtBQUssNkdBQTZHLHVCQUF1Qiw2QkFBNkIsdUJBQXVCLDBCQUEwQix1QkFBdUIsNEJBQTRCLDBCQUEwQiwrQ0FBK0MsbURBQW1ELGtGQUFrRixLQUFLLDRCQUE0Qix3Q0FBd0MsS0FBSyxpQkFBaUIsNkJBQTZCLG1DQUFtQywyQkFBMkIsMkJBQTJCLG1GQUFtRixzR0FBc0csdUNBQXVDLCtEQUErRCx3RkFBd0YsNkRBQTZELG1EQUFtRCxNQUFNLHdCQUF3Qiw4SEFBOEgsTUFBTSxVQUFVLGlCQUFpQixFQUFFLDZGQUE2RiwyRUFBMkUsZ0pBQWdKLHdDQUF3Qyx3Q0FBd0MscUNBQXFDLGVBQWUsbUNBQW1DLG1HQUFtRyxLQUFLLHNCQUFzQixXQUFXLE1BQU0sY0FBYyxzQ0FBc0MsSUFBSSxnQkFBZ0IsR0FBRyxzQkFBc0IsV0FBVyxvQ0FBb0MsSUFBSSxNQUFNLDhCQUE4QiwrQ0FBK0MsSUFBSSxNQUFNLEdBQUcsbURBQW1ELElBQUksTUFBTSxHQUFHLHVEQUF1RCxzQkFBc0IscUVBQXFFLE1BQU0sdUJBQXVCLCtCQUErQix5QkFBeUIsTUFBTSxzQkFBc0IsbU1BQW1NLHNGQUFzRix1QkFBdUIsNENBQTRDLFFBQVEsR0FBRyxVQUFVLHFGQUFxRiwySEFBMkgsK0JBQStCLHVCQUF1QixrQkFBa0IscVpBQXFaLCtDQUErQyx3RUFBd0UsZ0RBQWdELDZDQUE2QyxvRUFBb0Usb0ZBQW9GLFNBQVMsTUFBTSw0RUFBNEUsd0VBQXdFLDBGQUEwRixtQ0FBbUMsb0NBQW9DLFFBQVEsTUFBTSxzQkFBc0IsMkJBQTJCLGlCQUFpQiwyQ0FBMkMseURBQXlELG1EQUFtRCxPQUFPLEdBQUcsVUFBVSx1REFBdUQsc0RBQXNELGlCQUFpQixNQUFNLDZDQUE2QyxFQUFFLFdBQVcsa0RBQWtELHdCQUF3QixpQ0FBaUMsY0FBYyx5Q0FBeUMsU0FBUyw4Q0FBOEMsd0JBQXdCLGlCQUFpQixrQkFBa0IsTUFBTSwyQ0FBMkMsWUFBWSxZQUFZLElBQUksK0ZBQStGLGtCQUFrQixtQ0FBbUMsS0FBSywrQkFBK0IsTUFBTSxXQUFXLElBQUkscURBQXFELEVBQUUsV0FBVyxFQUFFLHlDQUF5Qyx3R0FBd0csNkNBQTZDLEVBQUUsa0JBQWtCLDBGQUEwRixRQUFRLFNBQVMscUVBQXFFLE1BQU0sZ0NBQWdDLG9GQUFvRixFQUFFLE1BQU0sdUNBQXVDLFVBQVUsMkRBQTJELEdBQUcsS0FBSyxVQUFVLDREQUE0RCwyRUFBMkUsYUFBYSx5QkFBeUIsa0RBQWtELHdCQUF3QixvQ0FBb0MsdUVBQXVFLDRCQUE0Qiw4QkFBOEIsTUFBTSxLQUFLLEdBQUcsMEJBQTBCLDRCQUE0QixvQkFBb0IsU0FBUyxpREFBaUQsK0RBQStELEdBQUcsK0JBQStCLDZCQUE2Qiw0Q0FBNEMscUNBQXFDLHFFQUFxRSxnQ0FBZ0MsWUFBWSxJQUFJLDRDQUE0QywwREFBMEQsNkhBQTZILDRGQUE0RixpQkFBaUIseUJBQXlCLDBGQUEwRixNQUFNLE1BQU0sU0FBUyxxREFBcUQscUJBQXFCLDhCQUE4QixTQUFTLG1CQUFtQix3QkFBd0IscUNBQXFDLFNBQVMscUVBQXFFLElBQUksTUFBTSwwQ0FBMEMsb0JBQW9CLFVBQVUsTUFBTSxnQkFBZ0IsYUFBYSxpV0FBaVcsRUFBRSxxQkFBcUIsMktBQTJLLG1CQUFtQixzQkFBc0IsZ0JBQWdCLEVBQUUsVUFBVSx3RUFBd0UsZ0RBQWdELHFDQUFxQyxNQUFNLE1BQU0saUdBQWlHLG9CQUFvQixtQ0FBbUMsb0JBQW9CLElBQUksV0FBVyxVQUFVLCtDQUErQyxvRkFBb0YsTUFBTSx5R0FBeUcsZ0JBQWdCLE9BQU8sd0JBQXdCLHFCQUFxQiw2RUFBNkUsOEJBQThCLGlDQUFpQyxRQUFRLE1BQU0sc0JBQXNCLHlDQUF5QyxNQUFNLE1BQU0sWUFBWSwwRUFBMEUsdUJBQXVCLDZHQUE2RyxzQ0FBc0MscUJBQXFCLEtBQUssc0JBQXNCLGlEQUFpRCxNQUFNLE1BQU0sWUFBWSxxSUFBcUksd0JBQXdCLHdDQUF3QyxzQ0FBc0MscUJBQXFCLEtBQUssR0FBRyx1QkFBdUIsbUJBQW1CLHdCQUF3Qix5RUFBeUUsaUNBQWlDLDRHQUE0RyxJQUFJLHVCQUF1Qix5Q0FBeUMsdUJBQXVCLCtCQUErQixpRUFBaUUseUdBQXlHLFNBQVMsd0VBQXdFLE1BQU0sZ0JBQWdCLG1CQUFtQixFQUFFLDhCQUE4QixrRUFBa0UsV0FBVyxFQUFFLEtBQUssdUJBQXVCLGtHQUFrRyxvQkFBb0IsRUFBRSwrS0FBK0ssdUJBQXVCLG9FQUFvRSxxSUFBcUksaUNBQWlDLE1BQU0sMkVBQTJFLGFBQWEsdUNBQXVDLDhCQUE4QixzR0FBc0csSUFBSSx5RUFBeUUsT0FBTyxFQUFFLDRDQUE0QyxNQUFNLG9MQUFvTCxXQUFXLG1IQUFtSCxNQUFNLGdDQUFnQyxlQUFlLHNCQUFzQixRQUFRLG1DQUFtQyxNQUFNLG9LQUFvSyxNQUFNLHFDQUFxQyxTQUFTLGlEQUFpRCxnSEFBZ0gsOEpBQThKLHVCQUF1QixtREFBbUQsb0hBQW9ILFNBQVMsS0FBSyxHQUFHLHlFQUF5RSxtQkFBbUIsV0FBVyx5TUFBeU0sMkJBQTJCLDZDQUE2Qyw4SUFBOEksTUFBTSx5QkFBeUIsV0FBVyxNQUFNLE1BQU0sUUFBUSxPQUFPLHFDQUFxQyxNQUFNLElBQUksU0FBUyxHQUFHLEdBQUcsYUFBYSwyR0FBMkcsa0NBQWtDLGlDQUFpQyxzQkFBc0IseUJBQXlCLDhCQUE4Qiw0QkFBNEIsMEJBQTBCLGdDQUFnQyw4Q0FBOEMsZ0RBQWdELHlDQUF5QywyQkFBMkIseUJBQXlCLDhCQUE4Qix3REFBd0QsMENBQTBDLE9BQU8sc0JBQXNCLDhEQUE4RCxxRkFBcUYsK0VBQStFLHNEQUFzRCxpREFBaUQsaURBQWlELHVDQUF1Qyw0SEFBNEgsaURBQWlELGlCQUFpQixTQUFTLDRFQUE0RSxtRkFBbUYsbUZBQW1GLG1GQUFtRixxTkFBcU4sOE5BQThOLG9EQUFvRCx1QkFBdUIsMENBQTBDLDZDQUE2QywwQ0FBMEMsc0NBQXNDLDBDQUEwQyxrREFBa0QsZ0ZBQWdGLHFDQUFxQywrQ0FBK0MsZ0ZBQWdGLG9FQUFvRSwrRkFBK0YsMkNBQTJDLHlQQUF5UCw2QkFBNkIsc0tBQXNLLE9BQU8sOEdBQThHLHdCQUF3QixvQkFBb0IsbURBQW1ELDhCQUE4QixvQ0FBb0MsZ0RBQWdELDhHQUE4RywyREFBMkQsd0ZBQXdGLFFBQVEsT0FBTyxlQUFlLGVBQWUsZ0JBQWdCLDBCQUEwQiwyQ0FBMkMsMENBQTBDLHVCQUF1Qix5Q0FBeUMseUJBQXlCLG9CQUFvQixpQkFBaUIsMkVBQTJFLFFBQVEsWUFBWSxJQUFJLEtBQUssNkRBQTZELHdFQUF3RSw2Q0FBNkMsWUFBWSxJQUFJLGdDQUFnQywrQkFBK0IsWUFBWSxRQUFRLHVCQUF1QiwyQkFBMkIsWUFBWSxJQUFJLHNCQUFzQixTQUFTLDhDQUE4QyxlQUFlLHlCQUF5QixlQUFlLDBCQUEwQixrQkFBa0IsNkNBQTZDLGNBQWMsU0FBUyx3SEFBd0gsOEJBQThCLDJEQUEyRCxxTkFBcU4sc0JBQXNCLFdBQVcsdUpBQXVKLHNCQUFzQiwwREFBMEQseUNBQXlDLG1DQUFtQyw2QkFBNkIsYUFBYSxZQUFZLFdBQVcsUUFBUSxpQ0FBaUMsTUFBTSxLQUFLLE1BQU0sZUFBZSx1QkFBdUIsV0FBVywyQ0FBMkMsbUNBQW1DLHdCQUF3QixzQ0FBc0MsdURBQXVELEVBQUUscUJBQXFCLFVBQVUsWUFBWSwwREFBMEQsZ0NBQWdDLDBCQUEwQixRQUFRLHdDQUF3QywrQkFBK0Isd0NBQXdDLDRDQUE0QyxzQ0FBc0Msb0NBQW9DLHlCQUF5Qix5QkFBeUIsa0VBQWtFLDRDQUE0QyxzQ0FBc0MsMEVBQTBFLEVBQUUsa0JBQWtCLFNBQVMsaUJBQWlCLE1BQU0sVUFBVSwwREFBMEQsd0NBQXdDLDJDQUEyQyx5QkFBeUIsc0JBQXNCLHNEQUFzRCxhQUFhLHFDQUFxQyxJQUFJLCtGQUErRixrRUFBa0UsK0NBQStDLCtCQUErQixxR0FBcUcsY0FBYywyQkFBMkIsc0NBQXNDLDJHQUEyRyxtQkFBbUIsTUFBTSxFQUFFLGlHQUFpRyxxRkFBcUYseUNBQXlDLFdBQVcsaVRBQWlULDJTQUEyUyxtQkFBbUIsMkJBQTJCLDJCQUEyQiw2Q0FBNkMsc0NBQXNDLDZCQUE2QiwrQ0FBK0MsOEdBQThHLDBCQUEwQix5Q0FBeUMsNkVBQTZFLHFvQkFBcW9CLHdCQUF3Qix5Q0FBeUMsSUFBSSxtQkFBbUIsMEJBQTBCLCtHQUErRywrSkFBK0osWUFBWSxJQUFJLEtBQUssd0hBQXdILFdBQVcscUhBQXFILHlEQUF5RCxrQkFBa0IsZ0RBQWdELHVCQUF1QixRQUFRLFlBQVksV0FBVyxpRUFBaUUsZ0NBQWdDLDJKQUEySixZQUFZLFdBQVcsb0NBQW9DLG1DQUFtQyx3RUFBd0UsK0lBQStJLFlBQVksS0FBSyw0QkFBNEIsS0FBSyxJQUFJLEVBQUUsWUFBWSx3R0FBd0csMk5BQTJOLHFEQUFxRCwrSUFBK0ksa0RBQWtELDZNQUE2TSxTQUFTLG1CQUFtQix1S0FBdUssRUFBRSx5QkFBeUIscUJBQXFCLHFDQUFxQyw0RUFBNEUsRUFBRSw2RUFBNkUsTUFBTSwrQkFBK0IsZ0NBQWdDLHFEQUFxRCx5QkFBeUIscUVBQXFFLE1BQU0sc0JBQXNCLE1BQU0sdUJBQXVCLFNBQVMsdUJBQXVCLE9BQU8saURBQWlELHdCQUF3Qiw2Q0FBNkMsaUNBQWlDLG1DQUFtQywyQkFBMkIsTUFBTSxVQUFVLGdCQUFnQixpQkFBaUIsaUJBQWlCLFNBQVMsS0FBSyxXQUFXLGVBQWUsNkJBQTZCLHVCQUF1Qix5TkFBeU4sbUZBQW1GLHVGQUF1RixvQ0FBb0MsTUFBTSxtQkFBbUIsc0JBQXNCLHFFQUFxRSxNQUFNLHNCQUFzQixNQUFNLHVCQUF1QixTQUFTLHVCQUF1QixPQUFPLGlEQUFpRCx3QkFBd0IsOENBQThDLGlDQUFpQyxtQ0FBbUMsR0FBRyxlQUFlLDZCQUE2Qix1QkFBdUIseU5BQXlOLDJCQUEyQixNQUFNLFVBQVUsZ0JBQWdCLGlCQUFpQixpQkFBaUIsU0FBUyxLQUFLLDBGQUEwRixxQkFBcUIsb0NBQW9DLE1BQU0sbUJBQW1CLEdBQUcsYUFBYSxvREFBb0QsR0FBRyxFQUFFLHNCQUFzQixLQUFLLHVCQUF1QixRQUFRLHlCQUF5Qix1Q0FBdUMsd0NBQXdDLE9BQU8sc0JBQXNCLFlBQVksT0FBTyx5REFBeUQsUUFBUSw0QkFBNEIseUZBQXlGLFdBQVcsT0FBTyx5QkFBeUIsK0JBQStCLE1BQU0sdUNBQXVDLGtMQUFrTCx5QkFBeUIsWUFBWSxhQUFhLDJKQUEySiw0RUFBNEUsVUFBVSwyREFBMkQseUJBQXlCLE1BQU0scUJBQXFCLFVBQVUsV0FBVyxTQUFTLFdBQVcsR0FBRyxrREFBa0QsZUFBZSxVQUFVLHNCQUFzQixrQkFBa0IsTUFBTSxNQUFNLDhCQUE4QixnUEFBZ1AsMkNBQTJDLFlBQVksOEJBQThCLFlBQVksYUFBYSx5SUFBeUksMkJBQTJCLE1BQU0scUJBQXFCLFVBQVUsV0FBVyxTQUFTLFdBQVcsR0FBRyxpRkFBaUYsMEJBQTBCLEtBQUssd0JBQXdCLGlCQUFpQixNQUFNLE1BQU0sc0VBQXNFLHVQQUF1UCx5QkFBeUIsYUFBYSxZQUFZLGFBQWEsMkdBQTJHLHFIQUFxSCxtQ0FBbUMsTUFBTSxxQkFBcUIsVUFBVSxXQUFXLFNBQVMsV0FBVyxHQUFHLGdGQUFnRixnQ0FBZ0MsS0FBSyxzQkFBc0Isa0hBQWtILE1BQU0sNFRBQTRULHdCQUF3QixzQkFBc0IsbUVBQW1FLFlBQVksa0NBQWtDLFlBQVksMkJBQTJCLE9BQU8sUUFBUSxPQUFPLFNBQVMscUdBQXFHLG1HQUFtRyxtQ0FBbUMsTUFBTSxxQkFBcUIsVUFBVSxXQUFXLFNBQVMsV0FBVyxHQUFHLGdEQUFnRCwrQkFBK0IsS0FBSyxzQkFBc0IsZ0ZBQWdGLE1BQU0sTUFBTSx5RUFBeUUsc0dBQXNHLHdCQUF3QixzQkFBc0IsMENBQTBDLFlBQVksZ0NBQWdDLFlBQVksNEJBQTRCLDJHQUEyRyx5R0FBeUcsaUNBQWlDLGlCQUFpQix5QkFBeUIsTUFBTSxxQkFBcUIsVUFBVSxXQUFXLFNBQVMsV0FBVyxHQUFHLGdEQUFnRCxlQUFlLEtBQUssc0JBQXNCLGdGQUFnRixNQUFNLCtSQUErUix3QkFBd0Isc0JBQXNCLDBDQUEwQyxZQUFZLGdDQUFnQyxZQUFZLDRCQUE0QiwyR0FBMkcseUdBQXlHLDZCQUE2QixNQUFNLHFCQUFxQixVQUFVLFdBQVcsU0FBUyxXQUFXLEdBQUcsZ0RBQWdELGVBQWUsS0FBSyxzQkFBc0IsMEdBQTBHLE1BQU0sdUhBQXVILGNBQWMsOFVBQThVLGtJQUFrSSxXQUFXLDhCQUE4QixNQUFNLDhCQUE4QixpR0FBaUcsU0FBUywwREFBMEQsK0JBQStCLFlBQVksK0JBQStCLFlBQVksK0JBQStCLFlBQVksK0JBQStCLFlBQVkseUJBQXlCLFlBQVksa0NBQWtDLDRIQUE0SCxrSkFBa0osbUpBQW1KLDJCQUEyQixNQUFNLHFCQUFxQixVQUFVLFdBQVcsU0FBUyxXQUFXLEdBQUcsa0ZBQWtGLGVBQWUsd0NBQXdDLE1BQU0sYUFBYSxzQkFBc0IsdUZBQXVGLE1BQU0sTUFBTSxjQUFjLDhSQUE4Uix5QkFBeUIsTUFBTSxhQUFhLDJCQUEyQixVQUFVLGFBQWEseUNBQXlDLHNHQUFzRyxPQUFPLGtCQUFrQixVQUFVLElBQUksMkJBQTJCLFlBQVksYUFBYSxpR0FBaUcsNkVBQTZFLDZEQUE2RCxxS0FBcUssbUNBQW1DLE1BQU0scUJBQXFCLFVBQVUsV0FBVyxTQUFTLFdBQVcsR0FBRyxnREFBZ0QsZUFBZSxLQUFLLHNCQUFzQixnQ0FBZ0MsTUFBTSw0TkFBNE4seUJBQXlCLE1BQU0scUJBQXFCLFVBQVUsV0FBVyxTQUFTLFdBQVcsR0FBRyw2QkFBNkIsWUFBWSwrQ0FBK0MsZUFBZSxVQUFVLDRCQUE0QixnQkFBZ0IsU0FBUyx1QkFBdUIsd0JBQXdCLDhKQUE4SixtQkFBbUIsUUFBUSxZQUFZLDZCQUE2QixFQUFFLE1BQU0sTUFBTSxnRkFBZ0YsbVRBQW1ULDJCQUEyQix1QkFBdUIsMENBQTBDLGVBQWUsNEJBQTRCLFlBQVksMkJBQTJCLE9BQU8sUUFBUSxPQUFPLFNBQVMsd05BQXdOLCtOQUErTixxQ0FBcUMsTUFBTSxxQkFBcUIsVUFBVSxXQUFXLFNBQVMsV0FBVyxHQUFHLGdEQUFnRCxlQUFlLEtBQUssR0FBRyxpQkFBaUIsTUFBTSxzREFBc0QsRUFBRSxpR0FBaUcsK0RBQStELHVEQUF1RCxrSEFBa0gsMEJBQTBCLDhHQUE4RyxTQUFTLHlCQUF5QiwrQ0FBK0MsV0FBVyw2Q0FBNkMsc0ZBQXNGLHlCQUF5Qix3R0FBd0csR0FBRyx5QkFBeUIsa1FBQWtRLE1BQU0sTUFBTSw0RkFBNEYsa1JBQWtSLGFBQWEsY0FBYyxrQkFBa0IsTUFBTSwyREFBMkQsTUFBTSx5Q0FBeUMsa0JBQWtCLFFBQVEsOENBQThDLGFBQWEsUUFBUSw0WkFBNFosMkJBQTJCLDZIQUE2SCx5Q0FBeUMsa0ZBQWtGLDJDQUEyQyxvQkFBb0IsK0RBQStELG1EQUFtRCxtR0FBbUcsY0FBYyxxQ0FBcUMsbUNBQW1DLHdDQUF3Qyw0QkFBNEIsb0JBQW9CLDJCQUEyQixjQUFjLFFBQVEsa0hBQWtILDhEQUE4RCx5Q0FBeUMseUJBQXlCLGdEQUFnRCxPQUFPLHFDQUFxQyxrSUFBa0ksMERBQTBELE1BQU0sMEJBQTBCLE1BQU0sMEJBQTBCLE1BQU0saUVBQWlFLFNBQVMsc0JBQXNCLHNDQUFzQyxpQ0FBaUMsTUFBTSxnQ0FBZ0MsWUFBWSxxQkFBcUIsMEJBQTBCLHNCQUFzQiwyQkFBMkIsMkJBQTJCLGtCQUFrQixzRUFBc0UsU0FBUyxjQUFjLE9BQU8sa0JBQWtCLHNEQUFzRCxjQUFjLHVDQUF1QyxRQUFRLDJCQUEyQixNQUFNLDRCQUE0QixvQkFBb0Isa0JBQWtCLE1BQU0sZ0dBQWdHLG1IQUFtSCxnSUFBZ0ksc0VBQXNFLE1BQU0sc0hBQXNILGlCQUFpQiw0UEFBNFAsZ0RBQWdELDhCQUE4QixxREFBcUQsVUFBVSxxQ0FBcUMsb0JBQW9CLDZEQUE2RCxNQUFNLGdFQUFnRSxNQUFNLHdEQUF3RCw4Q0FBOEMsTUFBTSxPQUFPLHV2VEFBdXZULFlBQVksMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsOERBQThELEVBQUUsK0VBQStFLEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0VBQStFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUscUVBQXFFLEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsbUZBQW1GLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsa0ZBQWtGLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsaUZBQWlGLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsbUZBQW1GLEVBQUUsK0VBQStFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUseUVBQXlFLEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsMkVBQTJFLEVBQUUsdUVBQXVFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsMkVBQTJFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUseUVBQXlFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0VBQStFLEVBQUUsOERBQThELEVBQUUsZ0ZBQWdGLEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNEVBQTRFLEVBQUUsNEVBQTRFLEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsOERBQThELEVBQUUsOEVBQThFLEVBQUUsNkVBQTZFLEVBQUUseUVBQXlFLEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsOEVBQThFLEVBQUUsNEVBQTRFLEVBQUUsK0VBQStFLEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0VBQStFLEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsd0VBQXdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNEVBQTRFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsMERBQTBELEVBQUUsK0RBQStELEVBQUUsK0VBQStFLEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsa0ZBQWtGLEVBQUUsaUZBQWlGLEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOEVBQThFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsZ0ZBQWdGLEVBQUUsc0VBQXNFLEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsa0ZBQWtGLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsMEVBQTBFLEVBQUUsOERBQThELEVBQUUseUVBQXlFLEVBQUUsMkVBQTJFLEVBQUUsMkVBQTJFLEVBQUUsK0RBQStELEVBQUUsMkVBQTJFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUscUVBQXFFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsK0VBQStFLEVBQUUsK0RBQStELEVBQUUsaUZBQWlGLEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsMkRBQTJELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkVBQTZFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsOEVBQThFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUseUVBQXlFLEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsOEVBQThFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsNEVBQTRFLEVBQUUsNkVBQTZFLEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsMkVBQTJFLEVBQUUsNEVBQTRFLEVBQUUsOEVBQThFLEVBQUUsOEVBQThFLEVBQUUsMkVBQTJFLEVBQUUsNkVBQTZFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkVBQTZFLEVBQUUsOEVBQThFLEVBQUUsK0RBQStELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELEVBQUUsMkVBQTJFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMEVBQTBFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMEVBQTBFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkVBQTZFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNEVBQTRFLEVBQUUsOERBQThELE9BQU8sOElBQThJLCtCQUErQixpQkFBaUIsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsaUVBQWlFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsaUVBQWlFLEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsMkRBQTJELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsaUVBQWlFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsaUVBQWlFLEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsMkRBQTJELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsMERBQTBELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsNkRBQTZELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsNkRBQTZELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsMkRBQTJELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNkRBQTZELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsNkRBQTZELEVBQUUsOERBQThELEVBQUUsK0RBQStELEVBQUUsK0RBQStELEVBQUUsOERBQThELEVBQUUsNERBQTRELEVBQUUsOERBQThELEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLEVBQUUsZ0VBQWdFLEVBQUUsK0RBQStELEVBQUUsaUVBQWlFLEVBQUUsaUVBQWlFLEVBQUUsK0RBQStELEVBQUUsZ0VBQWdFLHFCQUFxQixhQUFhLDBFQUEwRSxFQUFFLHlFQUF5RSxFQUFFLDRFQUE0RSxFQUFFLDRFQUE0RSxFQUFFLGdGQUFnRixFQUFFLGlGQUFpRixFQUFFLDRFQUE0RSxFQUFFLGtGQUFrRixFQUFFLGlGQUFpRixFQUFFLDRFQUE0RSxFQUFFLDhFQUE4RSxFQUFFLGdGQUFnRixFQUFFLGlGQUFpRixFQUFFLDZFQUE2RSxFQUFFLGdGQUFnRixFQUFFLCtFQUErRSxFQUFFLGdGQUFnRixFQUFFLDhFQUE4RSxFQUFFLGdGQUFnRixFQUFFLDhFQUE4RSxFQUFFLDhFQUE4RSxFQUFFLDZFQUE2RSxFQUFFLDhFQUE4RSxFQUFFLDhFQUE4RSxFQUFFLDBFQUEwRSxFQUFFLHdFQUF3RSxFQUFFLDJFQUEyRSxFQUFFLDJFQUEyRSxFQUFFLGdGQUFnRixFQUFFLGlGQUFpRixFQUFFLGlGQUFpRixFQUFFLGtGQUFrRixFQUFFLDhFQUE4RSxFQUFFLDRFQUE0RSxFQUFFLHFGQUFxRixFQUFFLHVGQUF1RixFQUFFLCtFQUErRSxFQUFFLGdGQUFnRixFQUFFLDhFQUE4RSxFQUFFLDZFQUE2RSxFQUFFLCtFQUErRSxFQUFFLCtFQUErRSxFQUFFLGdGQUFnRixFQUFFLGlGQUFpRixFQUFFLGtGQUFrRixFQUFFLG1GQUFtRixFQUFFLG1GQUFtRixFQUFFLG9GQUFvRixFQUFFLG9GQUFvRixFQUFFLG9GQUFvRixFQUFFLCtFQUErRSxFQUFFLGtGQUFrRiwyQkFBMkIsaUNBQWlDLDBRQUEwUSxHQUFHLHNCQUFzQixNQUFNLHFGQUFxRixhQUFhLCtJQUErSSxzRkFBc0YsY0FBYyx3QkFBd0IsaUJBQWlCLDJDQUEyQyxtQkFBbUIsMEJBQTBCLHlCQUF5QiwyQkFBMkIscUJBQXFCLDBPQUEwTyxNQUFNLFFBQVEsbVdBQW1XLGtCQUFrQixrQkFBa0IsTUFBTSxNQUFNLHNDQUFzQyxHQUFHLHlCQUF5QixNQUFNLGFBQWEsWUFBWSxhQUFhLFdBQVcsb1ZBQW9WLHlJQUF5SSxTQUFTLHVGQUF1RixNQUFNLE1BQU0sMENBQTBDLGFBQWEsb0hBQW9ILDZEQUE2RCx5REFBeUQsb0ZBQW9GLDZDQUE2QyxLQUFLLE9BQU8sb0JBQW9CLFFBQVEsR0FBRyxpRkFBaUYsNEVBQTRFLE1BQU0sMEZBQTBGLFlBQVksTUFBTSw0RkFBNEYsWUFBWSx1REFBdUQsWUFBWSw0Q0FBNEMsK0NBQStDLHVDQUF1QyxpQ0FBaUMsTUFBTSxxQkFBcUIsVUFBVSxXQUFXLFNBQVMsV0FBVyxHQUFHLGFBQWEsNkpBQTZKLG9DQUFvQyxRQUFRLGdDQUFnQyxjQUFjLHFCQUFxQixvQ0FBb0MsaUNBQWlDLE1BQU0sSUFBSSxxSkFBcUosdUNBQXVDLGtCQUFrQixJQUFJLDhDQUE4QyxpQ0FBaUMsTUFBTSx1SEFBdUgsZ0JBQWdCLG1CQUFtQixRQUFRLG1DQUFtQyx1QkFBdUIsT0FBTywyREFBMkQsWUFBWSx5QkFBeUIscUJBQXFCLE9BQU8sd0VBQXdFLGNBQWMscUJBQXFCLHVCQUF1QixHQUFHLHNCQUFzQixjQUFjLE1BQU0sY0FBYyxRQUFRLDhDQUE4QyxpQkFBaUIsbUNBQW1DLEVBQUUsU0FBUyxRQUFRLHlCQUF5QixVQUFVLFFBQVEsNkVBQTZFLGNBQWMsa0JBQWtCLDJDQUEyQyxNQUFNLHFEQUFxRCx5Q0FBeUMscUNBQXFDLFNBQVMsMEJBQTBCLGNBQWMsd0JBQXdCLGFBQWEsWUFBWSxFQUFFLE1BQU0sT0FBTyx3RUFBd0UsY0FBYywwRUFBMEUseUJBQXlCLDZEQUE2RCx5RUFBeUUsbURBQW1ELEtBQUsseUJBQXlCLHNJQUFzSSxNQUFNLE1BQU0sU0FBUyw0R0FBNEcsa0VBQWtFLFVBQVUsd0dBQXdHLFVBQVUsd0JBQXdCLE1BQU0sWUFBWSxnRUFBZ0UsWUFBWSxXQUFXLGdCQUFnQixNQUFNLHdFQUF3RSxhQUFhLHFCQUFxQix1RUFBdUUscUNBQXFDLE9BQU8sUUFBUSx5Q0FBeUMsMkJBQTJCLGlKQUFpSiwySUFBMkksb0VBQW9FLDJKQUEySixzQ0FBc0MsTUFBTSxpQ0FBaUMsUUFBUSxpQ0FBaUMsR0FBRyxhQUFhLGtEQUFrRCxFQUFFLE1BQU0sc0JBQXNCLGNBQWMsTUFBTSx3QkFBd0IsOEdBQThHLDhCQUE4Qix1QkFBdUIsRUFBRSxhQUFhLDhCQUE4QixFQUFFLE1BQU0saUJBQWlCLGdEQUFnRCw0R0FBNEcsZ0RBQWdELE1BQU0sUUFBUSxjQUFjLEdBQUcsMkJBQTJCLCtqQkFBK2pCLDZJQUE2SSxJQUFJLGdEQUFnRCx5Q0FBeUMseUJBQXlCLDJCQUEyQixpTkFBaU4saUJBQWlCLDRDQUE0QywrRUFBK0UsRUFBRSw2Q0FBNkMsRUFBRSxRQUFRLE1BQU0sY0FBYyw2QkFBNkIsK0JBQStCLGlCQUFpQiw0QkFBNEIsbUJBQW1CLGlEQUFpRCx5QkFBeUIscUNBQXFDLEVBQUUseURBQXlELDBCQUEwQiw0Q0FBNEMsTUFBTSxrREFBa0QsSUFBSSxNQUFNLGNBQWMsMkJBQTJCLCtCQUErQix3Q0FBd0MsMEJBQTBCLGtCQUFrQiwwQkFBMEIsaUJBQWlCLHlCQUF5QixFQUFFLHNDQUFzQyxzREFBc0QsaUNBQWlDLE9BQU8sSUFBSSxhQUFhLHdDQUF3QyxFQUFFLGdDQUFnQyxXQUFXLHlCQUF5QixrQkFBa0IsZ0NBQWdDLE9BQU8sdUNBQXVDLHNCQUFzQixJQUFJLGFBQWEsbUZBQW1GLEVBQUUsZ0RBQWdELHlDQUF5Qyx1QkFBdUIsMkJBQTJCLGtMQUFrTCwwREFBMEQsMkNBQTJDLG1DQUFtQywwQkFBMEIsK0JBQStCLDBCQUEwQixFQUFFLHNDQUFzQyx1R0FBdUcsR0FBRyxhQUFhLGlQQUFpUCxtQ0FBbUMsaUNBQWlDLDBDQUEwQyxzQ0FBc0MsaUNBQWlDLGdDQUFnQyxnQ0FBZ0MscUJBQXFCLHFDQUFxQyw4REFBOEQsdUVBQXVFLDJCQUEyQiwyRUFBMkUscUVBQXFFLFNBQVMsc0VBQXNFLE9BQU8sd0NBQXdDLGlDQUFpQywwQ0FBMEMsNkJBQTZCLGdDQUFnQyw2QkFBNkIsZ0NBQWdDLGlDQUFpQyxpQ0FBaUMsa0NBQWtDLHFDQUFxQyxvREFBb0QseUNBQXlDLDBEQUEwRCwyREFBMkQsb0NBQW9DLE9BQU8scUJBQXFCLG9EQUFvRCwwREFBMEQseUVBQXlFLHNEQUFzRCxtRkFBbUYsdUVBQXVFLHdFQUF3RSwyQ0FBMkMsNkRBQTZELG1EQUFtRCxRQUFRLDBCQUEwQiwyTkFBMk4sTUFBTSxVQUFVLGdCQUFnQixFQUFFLG1GQUFtRixnQkFBZ0IseUVBQXlFLDZGQUE2RixpR0FBaUcsR0FBRyxTQUFTLHVGQUF1RixJQUFJLDZEQUE2RCx5Q0FBeUMsc0NBQXNDLDhDQUE4QyxrREFBa0Qsd0NBQXdDLE9BQU8sR0FBRyxHQUFHLGVBQWUsT0FBTyxFQUFFLGdFQUFnRSxTQUFTLGVBQWUsa0NBQWtDLGVBQWUsT0FBTyxnS0FBZ0ssaUVBQWlFLG1CQUFtQixHQUFHLFVBQVUsdUZBQXVGLDBDQUEwQyxHQUFHLHFCQUFxQixnREFBZ0QsZ0JBQWdCLDRCQUE0QixzQ0FBc0Msb0JBQW9CLE1BQU0sU0FBUyxpQkFBaUIsaURBQWlELG1CQUFtQixHQUFHLG1EQUFtRCx1QkFBdUIsaURBQWlELHNCQUFzQiw4Q0FBOEMsK0JBQStCLE1BQU0sNEhBQTRILDJEQUEyRCxpQ0FBaUMsTUFBTSxnREFBZ0QsS0FBSyxxQkFBcUIseUJBQXlCLDhJQUE4SSxNQUFNLHNEQUFzRCxxRUFBcUUsTUFBTSxTQUFTLDBFQUEwRSxhQUFhLHdDQUF3Qyx3T0FBd08sUUFBUSxzQ0FBc0Msa0dBQWtHLEtBQUsseUNBQXlDLE1BQU0sT0FBTyxHQUFHLGVBQWUsbUVBQW1FLCtCQUErQixZQUFZLHlCQUF5QixrQkFBa0IsTUFBTSxnRUFBZ0Usa0NBQWtDLDhHQUE4RyxXQUFXLDZCQUE2QixRQUFRLHlKQUF5Six5RUFBeUUsb0ZBQW9GLGdDQUFnQyxnQ0FBZ0MsNkVBQTZFLGlDQUFpQyx1RUFBdUUsd0VBQXdFLG9CQUFvQix1REFBdUQsdURBQXVELHVEQUF1RCwwRUFBMEUsb0VBQW9FLHVDQUF1QyxLQUFLLGlJQUFpSSwrSEFBK0gsWUFBWSxxQ0FBcUMseUNBQXlDLFNBQVMsYUFBYSwwSEFBMEgsR0FBRyxFQUFFLG9MQUFvTCxjQUFjLG1WQUFtVixrQkFBa0IsSUFBSSxVQUFVLHlDQUF5Qyx1REFBdUQsNkRBQTZELGtCQUFrQiwrQkFBK0IsUUFBUSx1SUFBdUksWUFBWSx3Q0FBd0MsTUFBTSxnRkFBZ0YsaUNBQWlDLG1CQUFtQixnREFBZ0QsaUVBQWlFLG1CQUFtQixJQUFJLHFCQUFxQixzQ0FBc0MsR0FBRyxpQkFBaUIsbUNBQW1DLEVBQUUsYUFBYSxTQUFTLHFDQUFxQyxRQUFRLHNLQUFzSyxpSEFBaUgsd0NBQXdDLGVBQWUsc0pBQXNKLGlDQUFpQywrSUFBK0ksSUFBSSx5REFBeUQsK0JBQStCLGlDQUFpQyxxSUFBcUksc0NBQXNDLHlEQUF5RCxpRkFBaUYsd0tBQXdLLEVBQUUsOEdBQThHLE1BQU0sNkJBQTZCLE1BQU0sMEJBQTBCLE1BQU0sTUFBTSxzQkFBc0Isb0VBQW9FLE1BQU0sc0hBQXNILGNBQWMsVUFBVSxrR0FBa0csY0FBYyxxQkFBcUIsZ0NBQWdDLGlCQUFpQixFQUFFLHFCQUFxQixtQ0FBbUMseUNBQXlDLGFBQWEsMENBQTBDLFFBQVEsVUFBVSxzQkFBc0Isb1BBQW9QLE1BQU0sb1RBQW9ULGdCQUFnQixZQUFZLHNEQUFzRCxrQkFBa0IseUJBQXlCLDhFQUE4RSxZQUFZLEdBQUcsNkJBQTZCLGFBQWEsR0FBRyxRQUFRLFdBQVcsNEJBQTRCLGlCQUFpQixZQUFZLGFBQWEsVUFBVSxJQUFJLHdCQUF3QixjQUFjLCtCQUErQixJQUFJLDJCQUEyQixrQkFBa0IseUJBQXlCLDJFQUEyRSxNQUFNLFFBQVEseUNBQXlDLE1BQU0sT0FBTyxnQkFBZ0IsYUFBYSxNQUFNLGlEQUFpRCxzQ0FBc0MsZ0JBQWdCLG9CQUFvQixRQUFRLFlBQVksMkNBQTJDLElBQUksMkJBQTJCLE9BQU8sa0JBQWtCLHlDQUF5QyxnQkFBZ0IsYUFBYSxTQUFTLEdBQUcsS0FBSyw2SkFBNkosTUFBTSxRQUFRLGlDQUFpQyxrQ0FBa0MsMkJBQTJCLFFBQVEsVUFBVSxpQkFBaUIsTUFBTSxZQUFZLFdBQVcsS0FBSyxXQUFXLHlCQUF5Qix3RkFBd0YsZ0VBQWdFLG9DQUFvQyxTQUFTLEdBQUcsU0FBUyxNQUFNLFdBQVcsNENBQTRDLFVBQVUsUUFBUSxxQkFBcUIsTUFBTSxNQUFNLE9BQU8sVUFBVSxZQUFZLFFBQVEsOERBQThELFNBQVMsdUlBQXVJLHNCQUFzQixnRUFBZ0UsMENBQTBDLEVBQUUsZUFBZSxZQUFZLE9BQU8sK0JBQStCLE9BQU8sUUFBUSxhQUFhLFNBQVMsMEJBQTBCLHdIQUF3SCxvQkFBb0IsUUFBUSxpR0FBaUcsZ0RBQWdELE1BQU0sT0FBTyxVQUFVLFlBQVksUUFBUSxnRUFBZ0UscURBQXFELDBDQUEwQyxlQUFlLDBDQUEwQyx1RkFBdUYsVUFBVSxrREFBa0QsSUFBSSxHQUFHLFlBQVksZ0NBQWdDLGlDQUFpQyx1QkFBdUIsNEJBQTRCLE9BQU8sVUFBVSwwQ0FBMEMsTUFBTSxnQ0FBZ0MsY0FBYyw4QkFBOEIsY0FBYyxtQ0FBbUMsK0RBQStELCtCQUErQixjQUFjLGtDQUFrQyxXQUFXLHVDQUF1QyxpRkFBaUYsT0FBTyxzQkFBc0IsbUJBQW1CLE1BQU0sdUVBQXVFLHlCQUF5QiwwREFBMEQseUJBQXlCLE1BQU0sNkNBQTZDLHNDQUFzQyxtQkFBbUIsTUFBTSwwQ0FBMEMsd0ZBQXdGLFNBQVMsR0FBRyxHQUFHLHdDQUF3QyxnQkFBZ0IsRUFBRSx1Q0FBdUMsUUFBUSxnQkFBZ0IsU0FBUyxlQUFlLFNBQVMsbUJBQW1CLHNJQUFzSSw2QkFBNkIsOEJBQThCLCtDQUErQyxxQ0FBcUMsb0JBQW9CLHFDQUFxQyxxQkFBcUIsaUNBQWlDLDJCQUEyQiw0Q0FBNEMscUJBQXFCLG1DQUFtQyxtQ0FBbUMsNkJBQTZCLHlCQUF5QiwyQkFBMkIsYUFBYSx5QkFBeUIseUJBQXlCLG9CQUFvQixvQkFBb0IsaUJBQWlCLFlBQVksc0hBQXNILHdCQUF3Qix1QkFBdUIsaUNBQWlDLHNCQUFzQix3QkFBd0IsdUJBQXVCLHVCQUF1Qix5QkFBeUIsd0JBQXdCLHdCQUF3QiwwQkFBMEIsMEJBQTBCLDJCQUEyQixnQ0FBZ0MsZ0NBQWdDLHdCQUF3Qix3QkFBd0Isd0JBQXdCLHdCQUF3QiwyRUFBMkUsV0FBVyxXQUFXLFdBQVcsV0FBVyxzRUFBc0UsTUFBTSx3RUFBd0UsVUFBVSxlQUFlLGtIQUFrSCx3RUFBd0UsbUZBQW1GLGFBQWEsV0FBVyx3QkFBd0IsWUFBWSxtQkFBbUIsY0FBYywyQkFBMkIsZUFBZSxzQkFBc0IsYUFBYSwwQkFBMEIsY0FBYyxzQkFBc0IseUJBQXlCLGVBQWUsTUFBTSxrQ0FBa0Msc0dBQXNHLGlDQUFpQyxLQUFLLEdBQUcsd0NBQXdDLGdCQUFnQixFQUFFLHVDQUF1QyxRQUFRLGVBQWUsU0FBUyxtQkFBbUIscUdBQXFHLDZCQUE2QixVQUFVLGVBQWUsK0hBQStILGlDQUFpQyxpQ0FBaUMsc0RBQXNELGtEQUFrRCxnQ0FBZ0MsR0FBRyxXQUFXLHdCQUF3QixZQUFZLG1CQUFtQixhQUFhLDBCQUEwQixjQUFjLHNCQUFzQix5QkFBeUIsZUFBZSxNQUFNLGtDQUFrQyxzR0FBc0csaUNBQWlDLEtBQUssR0FBRyxrQ0FBa0MsNkJBQTZCLE9BQU8sVUFBVSwwYUFBMGEsNEhBQTRILHdDQUF3QyxtQ0FBbUMsa0NBQWtDLDBDQUEwQywwQ0FBMEMsbUNBQW1DLDZDQUE2QywyQkFBMkIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLHlCQUF5QixvQ0FBb0MsK0ZBQStGLHNHQUFzRyx3Q0FBd0MsbUVBQW1FLHlHQUF5Ryx1RUFBdUUsdUVBQXVFLHVFQUF1RSx1Q0FBdUMsOEdBQThHLG1EQUFtRCxZQUFZLHVDQUF1QyxxQ0FBcUMsK0JBQStCLDhCQUE4QiwyQkFBMkIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLHlCQUF5Qiw4Q0FBOEMscUJBQXFCLDRFQUE0RSxvREFBb0Qsb0RBQW9ELG9EQUFvRCxvREFBb0Qsd0RBQXdELFdBQVcsbURBQW1ELDBGQUEwRixrQkFBa0IscUdBQXFHLGlCQUFpQix3Q0FBd0MsU0FBUyxhQUFhLGlJQUFpSSxFQUFFLHVFQUF1RSx1R0FBdUcscWdCQUFxZ0IsMkdBQTJHLGtOQUFrTixjQUFjLDJFQUEyRSw0Q0FBNEMsbUNBQW1DLGlCQUFpQixjQUFjLHFCQUFxQixJQUFJLDRHQUE0RywrR0FBK0csd0NBQXdDLGdCQUFnQixFQUFFLHVCQUF1QixXQUFXLHNCQUFzQixXQUFXLGlCQUFpQixXQUFXLHFCQUFxQixXQUFXLHNCQUFzQixXQUFXLGdCQUFnQixTQUFTLGVBQWUsUUFBUSxnQkFBZ0IsUUFBUSxxQkFBcUIsU0FBUywwQkFBMEIsU0FBUywwQkFBMEIsUUFBUSxtQkFBbUIsUUFBUSw2QkFBNkIsVUFBVSxtQkFBbUIsUUFBUSxvQkFBb0IsUUFBUSxtQkFBbUIsbUJBQW1CLE1BQU0sd3RCQUF3dEIsOEJBQThCLFVBQVUsZUFBZSx1SkFBdUosbUZBQW1GLDBEQUEwRCx5Q0FBeUMsbUNBQW1DLDBDQUEwQyxtQ0FBbUMsbUNBQW1DLGtDQUFrQywrQkFBK0IsZ0NBQWdDLCtCQUErQixvQ0FBb0MsMENBQTBDLDBDQUEwQyxvQ0FBb0MsbUNBQW1DLDZDQUE2Qyw4QkFBOEIsWUFBWSxpQkFBaUIscUpBQXFKLHVHQUF1Ryw4Q0FBOEMsc0NBQXNDLHNDQUFzQyx1REFBdUQseURBQXlELDRCQUE0QixtRUFBbUUscUVBQXFFLHFIQUFxSCwrQ0FBK0MsK0RBQStELDREQUE0RCxnRUFBZ0UsOEJBQThCLDZCQUE2QixtREFBbUQsK0JBQStCLGdGQUFnRixrR0FBa0csb0NBQW9DLDJEQUEyRCxrR0FBa0csd0RBQXdELHVEQUF1RCxxRkFBcUYsdUdBQXVHLGdFQUFnRSwyR0FBMkcsK0NBQStDLGlFQUFpRSx5REFBeUQseURBQXlELHlEQUF5RCx3R0FBd0csV0FBVyxlQUFlLDRCQUE0QixnQkFBZ0IsdUJBQXVCLGFBQWEsMEJBQTBCLGNBQWMscUJBQXFCLG9CQUFvQixpQ0FBaUMscUJBQXFCLDRCQUE0QixtQkFBbUIsZ0NBQWdDLG9CQUFvQiwyQkFBMkIsb0JBQW9CLGlDQUFpQyxxQkFBcUIsNEJBQTRCLGNBQWMsMkJBQTJCLGVBQWUsc0JBQXNCLGFBQWEsMEJBQTBCLGNBQWMscUJBQXFCLGNBQWMsMkJBQTJCLGVBQWUsc0JBQXNCLGtCQUFrQixnQ0FBZ0MsbUJBQW1CLDJCQUEyQix3QkFBd0IscUNBQXFDLHlCQUF5QixnQ0FBZ0Msd0JBQXdCLHFDQUFxQyx5QkFBeUIsZ0NBQWdDLGlCQUFpQiw4QkFBOEIsa0JBQWtCLHlCQUF5QiwyQkFBMkIsd0NBQXdDLDRCQUE0QixtQ0FBbUMsaUJBQWlCLDhCQUE4QixrQkFBa0IseUJBQXlCLGtCQUFrQiwrQkFBK0IsbUJBQW1CLDJCQUEyQix5QkFBeUIsb09BQW9PLE1BQU0sVUFBVSw2QkFBNkIsRUFBRSxzQkFBc0IsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsUUFBUSx1aEJBQXVoQixNQUFNLHNFQUFzRSxhQUFhLDRNQUE0TSxna0JBQWdrQiwyQkFBMkIsd1BBQXdQLG1DQUFtQyxTQUFTLHVFQUF1RSxrQ0FBa0Msb0lBQW9JLHVDQUF1QyxtQkFBbUIscUhBQXFILEdBQUcsd1ZBQXdWLEVBQUUsbUNBQW1DLHdCQUF3QixNQUFNLHNFQUFzRSxhQUFhLGFBQWEsOENBQThDLDBPQUEwTywwREFBMEQsMEhBQTBILE9BQU8sVUFBVSx1T0FBdU8scUNBQXFDLG9DQUFvQyx5QkFBeUIscUNBQXFDLG1FQUFtRSxxQ0FBcUMsaURBQWlELHFEQUFxRCwwRkFBMEYsbUVBQW1FLDZHQUE2Ryw4REFBOEQsMEZBQTBGLDZFQUE2RSxxR0FBcUcsc0ZBQXNGLEtBQUssaUVBQWlFLCtCQUErQixnQ0FBZ0MseUJBQXlCLHFDQUFxQyxtRUFBbUUsNkVBQTZFLHdDQUF3QywwQ0FBMEMsTUFBTSxnQkFBZ0IsTUFBTSwwQkFBMEIsb0JBQW9CLHNCQUFzQiw2QkFBNkIsNEJBQTRCLDBCQUEwQiw2QkFBNkIseUNBQXlDLG1DQUFtQyxxQ0FBcUMsdUJBQXVCLGlFQUFpRSxpRUFBaUUsS0FBSywyR0FBMkcsMEJBQTBCLDZCQUE2Qiw4REFBOEQsd0RBQXdELGtFQUFrRSxtRkFBbUYseUJBQXlCLGFBQWEsTUFBTSx3Q0FBd0MsZ0RBQWdELHFDQUFxQyx5QkFBeUIseUJBQXlCLDZHQUE2Ryw4RUFBOEUsOERBQThELHFDQUFxQyxpQ0FBaUMsZ0JBQWdCLFNBQVMseURBQXlELGlEQUFpRCxPQUFPLDRFQUE0RSwwQkFBMEIsS0FBSyxvTUFBb00sK0pBQStKLE9BQU8sb0dBQW9HLDhDQUE4QywwREFBMEQsZ0hBQWdILE9BQU8sK0JBQStCLDZDQUE2QyxnR0FBZ0cscUZBQXFGLDJEQUEyRCw0QkFBNEIsc0NBQXNDLHFFQUFxRSxzQkFBc0IsNEpBQTRKLDBIQUEwSCwrRkFBK0Ysc0tBQXNLLHlKQUF5Six3R0FBd0csMEZBQTBGLDBGQUEwRixpRUFBaUUsK0hBQStILHdGQUF3Rix3Q0FBd0Msc0VBQXNFLG9GQUFvRixvRUFBb0UsMkVBQTJFLHVEQUF1RCxtREFBbUQsTUFBTSxHQUFHLGNBQWMsaUJBQWlCLGlCQUFpQix5Q0FBeUMsV0FBVyxHQUFHLHdDQUF3QyxzQkFBc0IsdUJBQXVCLHFCQUFxQixVQUFVLGVBQWUsUUFBUSxnQkFBZ0IsUUFBUSxrQkFBa0IsV0FBVyxZQUFZLFFBQVEsWUFBWSxRQUFRLGVBQWUsV0FBVyxzQkFBc0IsVUFBVSxtQkFBbUIsMkJBQTJCLGtCQUFrQixTQUFTLE9BQU8sUUFBUSxhQUFhLFFBQVEsa0JBQWtCLFNBQVMscUJBQXFCLFFBQVEsU0FBUyxZQUFZLDBCQUEwQixZQUFZLCtCQUErQixnTEFBZ0wsNENBQTRDLDJCQUEyQixpQ0FBaUMsc0NBQXNDLHlDQUF5QyxpQ0FBaUMsZ0NBQWdDLDhEQUE4RCxpQkFBaUIsK0JBQStCLG9CQUFvQiwrQkFBK0Isb0JBQW9CLCtCQUErQix1QkFBdUIsU0FBUywyQkFBMkIsNkJBQTZCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDRCQUE0Qiw0QkFBNEIsbUJBQW1CLFNBQVMsMEdBQTBHLHlEQUF5RCwrQkFBK0IseURBQXlELCtCQUErQix5REFBeUQsc05BQXNOLGlEQUFpRCw2RUFBNkUsd0VBQXdFLDZGQUE2Riw4RUFBOEUsK0RBQStELHVCQUF1Qiw0RkFBNEYsa0RBQWtELGtDQUFrQyxrREFBa0Qsa0NBQWtDLGtEQUFrRCxrQ0FBa0Msa0RBQWtELHdCQUF3Qiw2REFBNkQsc0JBQXNCLHdCQUF3QixTQUFTLHNDQUFzQyxvQ0FBb0MsZ0NBQWdDLCtDQUErQyw0Q0FBNEMsOENBQThDLG9DQUFvQywwQ0FBMEMsZ0NBQWdDLG9DQUFvQyxxQ0FBcUMsb0JBQW9CLDBCQUEwQiw0QkFBNEIsNEJBQTRCLDRCQUE0QixnQ0FBZ0MsbUNBQW1DLHlDQUF5Qyx5Q0FBeUMsMENBQTBDLGlCQUFpQixpQkFBaUIsaUJBQWlCLG9DQUFvQyxTQUFTLHVDQUF1QyxpS0FBaUssU0FBUyxrVEFBa1Qsb0NBQW9DLDhDQUE4QywwQ0FBMEMsc0ZBQXNGLGtHQUFrRyxtRUFBbUUscURBQXFELHFDQUFxQywwQ0FBMEMsd0NBQXdDLHdKQUF3Siw4SEFBOEgsd0dBQXdHLG9FQUFvRSxvRUFBb0Usb0VBQW9FLHVJQUF1SSxhQUFhLHVGQUF1RixpUUFBaVEsYUFBYSxpSEFBaUgsMkhBQTJILHFLQUFxSyw4R0FBOEcsZ0dBQWdHLGlDQUFpQyw0S0FBNEssbURBQW1ELG1JQUFtSSxnQkFBZ0IsTUFBTSwySkFBMkosNkZBQTZGLDZEQUE2RCxlQUFlLGFBQWEsNGJBQTRiLG1HQUFtRyxpRUFBaUUsaU1BQWlNLDJEQUEyRCxzQ0FBc0Msc0NBQXNDLHdLQUF3SyxzSkFBc0osa0lBQWtJLDhGQUE4RixhQUFhLDZNQUE2TSwyQ0FBMkMseUNBQXlDLDZEQUE2RCx1REFBdUQsNkdBQTZHLG9IQUFvSCw4REFBOEQscURBQXFELG1FQUFtRSx3Q0FBd0MsNERBQTRELHNDQUFzQywrRkFBK0YsNENBQTRDLDhFQUE4RSxpQ0FBaUMsa1BBQWtQLFdBQVcsOEJBQThCLE1BQU0sRUFBRSxJQUFJLE9BQU8sd0xBQXdMLHlUQUF5VCxFQUFFLHVGQUF1RixnVEFBZ1QsRUFBRSx5RUFBeUUsRUFBRSx1RkFBdUYscVRBQXFULEVBQUUsd0VBQXdFLEVBQUUsdUZBQXVGLDRDQUE0Qyw0Q0FBNEMsNENBQTRDLFdBQVcsNEJBQTRCLEVBQUUsR0FBRyxzRkFBc0YsS0FBSyxzRUFBc0UsK0RBQStELEtBQUsseUJBQXlCLHdOQUF3TixNQUFNLFVBQVUsNEJBQTRCLEVBQUUsdUVBQXVFLFVBQVUsdUJBQXVCLDBrQkFBMGtCLHFHQUFxRyxpQkFBaUIsSUFBSSxzR0FBc0csR0FBRyxzQ0FBc0MsdUJBQXVCLG1EQUFtRCxNQUFNLHVEQUF1RCxrQ0FBa0MsZUFBZSxzQ0FBc0MsTUFBTSxXQUFXLGdCQUFnQix1REFBdUQsR0FBRyxnQkFBZ0IsZUFBZSxHQUFHLGlFQUFpRSxHQUFHLEdBQUcsNkNBQTZDLGdDQUFnQyxxQ0FBcUMsbUVBQW1FLHNFQUFzRSwyREFBMkQsbURBQW1ELGNBQWMsK0JBQStCLHdDQUF3QywrQ0FBK0MsSUFBSSxpQ0FBaUMsR0FBRyxHQUFHLG1CQUFtQixnQkFBZ0IsNkZBQTZGLDJDQUEyQyxpQkFBaUIscUJBQXFCLHVCQUF1Qix1QkFBdUIsTUFBTSx1QkFBdUIsd0VBQXdFLHNCQUFzQixxQ0FBcUMsTUFBTSx1QkFBdUIseUJBQXlCLEtBQUssR0FBRywwVUFBMFUsV0FBVyxJQUFJLHVGQUF1RixhQUFhLFdBQVcsb0JBQW9CLFlBQVksVUFBVSw0RUFBNEUsdURBQXVELFdBQVcsaUNBQWlDLCtHQUErRyxJQUFJLHVDQUF1QywyQkFBMkIsNEtBQTRLLHFDQUFxQyxzR0FBc0csNkJBQTZCLCtCQUErQixnRUFBZ0UsMkNBQTJDLE1BQU0sdUNBQXVDLGlCQUFpQixLQUFLLEdBQUcsY0FBYyxtRUFBbUUscUlBQXFJLGlDQUFpQyxnQkFBZ0IsSUFBSSx5QkFBeUIseUNBQXlDLGtDQUFrQyxPQUFPLHNCQUFzQiw2REFBNkQsTUFBTSx5REFBeUQsK0JBQStCLGlDQUFpQyxpREFBaUQsNERBQTRELHNCQUFzQiwwREFBMEQsOEZBQThGLE1BQU0sNkJBQTZCLE1BQU0sMEJBQTBCLE1BQU0sTUFBTSxHQUFHLG1CQUFtQix3RUFBd0UsT0FBTyxFQUFFLCtHQUErRyxhQUFhLDRGQUE0RixFQUFFLHdCQUF3Qiw2QkFBNkIsMERBQTBELFlBQVksa0JBQWtCLHVEQUF1RCxjQUFjLHNFQUFzRSx1RkFBdUYsYUFBYSw4S0FBOEssT0FBTyxrQ0FBa0MsT0FBTyxxQkFBcUIsbUJBQW1CLEtBQUsscUJBQXFCLGtCQUFrQiw4Q0FBOEMsZ0JBQWdCLGdDQUFnQywyREFBMkQsNE9BQTRPLFNBQVMsTUFBTSxvQkFBb0IsNkNBQTZDLDJFQUEyRSx1RUFBdUUsd0dBQXdHLFdBQVcsMkdBQTJHLFNBQVMsY0FBYyxFQUFFLDhJQUE4SSw4RkFBOEYsd0dBQXdHLEtBQUssb0JBQW9CLEVBQUUsOEJBQThCLFNBQVMsRUFBRSxPQUFPLDhCQUE4QixZQUFZLHNmQUFzZiwyRkFBMkYsVUFBVSxnREFBZ0Qsa0hBQWtILFFBQVEsTUFBTSxXQUFXLEtBQUsseUdBQXlHLGVBQWUsd0JBQXdCLE1BQU0sYUFBYSw2Q0FBNkMsa01BQWtNLDJEQUEyRCxtQkFBbUIsMkVBQTJFLE9BQU8sb0JBQW9CLCtCQUErQixrRUFBa0UscUNBQXFDLGdEQUFnRCwrQkFBK0IsK1dBQStXLEtBQUsscUJBQXFCLGtXQUFrVyxLQUFLLDRCQUE0QixNQUFNLDhCQUE4QixRQUFRLEtBQUssY0FBYyx3QkFBd0IseUJBQXlCLHNJQUFzSSxNQUFNLCtPQUErTyx5REFBeUQsc0NBQXNDLDRDQUE0QyxpQkFBaUIseUJBQXlCLE1BQU0sYUFBYSw4QkFBOEIsK0NBQStDLG9DQUFvQyw2QkFBNkIsbUpBQW1KLCtGQUErRixRQUFRLHNCQUFzQix5R0FBeUcsTUFBTSxxREFBcUQsdUJBQXVCLFFBQVEsb0JBQW9CLDJDQUEyQyw0SEFBNEgseUJBQXlCLHFMQUFxTCxzREFBc0QseUNBQXlDLEtBQUssT0FBTyxpVEFBaVQsdUhBQXVILGFBQWEsaUhBQWlILEdBQUcsRUFBRSxNQUFNLGtCQUFrQixNQUFNLG9GQUFvRixhQUFhLGlXQUFpVyxtQ0FBbUMsc0NBQXNDLGNBQWMsdUVBQXVFLDJHQUEyRyxhQUFhLG1EQUFtRCxPQUFPLHlCQUF5Qiw0RUFBNEUsNEhBQTRILGtIQUFrSCxhQUFhLHFDQUFxQyxFQUFFLGlDQUFpQywrQkFBK0IsMEJBQTBCLG9CQUFvQixhQUFhLG9DQUFvQyxFQUFFLHlDQUF5QywrREFBK0QsYUFBYSxvSUFBb0ksRUFBRSw4SEFBOEgsdUNBQXVDLHdDQUF3QyxPQUFPLHdHQUF3RyxRQUFRLHdCQUF3Qiw0Q0FBNEMsa0hBQWtILG1CQUFtQiwyQkFBMkIsbURBQW1ELHdCQUF3QixpQ0FBaUMsWUFBWSxlQUFlLFlBQVkseUJBQXlCLHlCQUF5Qiw0Q0FBNEMsT0FBTyw0S0FBNEssc0VBQXNFLElBQUksTUFBTSw2Q0FBNkMsaUNBQWlDLEdBQUcsZUFBZSx5SEFBeUgseUJBQXlCLHNLQUFzSyxNQUFNLDJGQUEyRiw0REFBNEQscUNBQXFDLG9FQUFvRSx1REFBdUQsOEZBQThGLGtEQUFrRCxZQUFZLHNCQUFzQixzQkFBc0IseURBQXlELHVCQUF1QiwwQkFBMEIsb0dBQW9HLGlFQUFpRSxJQUFJLGtHQUFrRyxrREFBa0QscUJBQXFCLHlRQUF5USxZQUFZLHdCQUF3Qiw2UUFBNlEsa0ZBQWtGLHVCQUF1QixJQUFJLE1BQU0sMEJBQTBCLGtFQUFrRSxzQ0FBc0Msb0RBQW9ELHlDQUF5QyxtQ0FBbUMsR0FBRyxHQUFHLHNDQUFzQywyREFBMkQsbUJBQW1CLGtCQUFrQixzRkFBc0YsZ0JBQWdCLE1BQU0sb0JBQW9CLDJCQUEyQix3QkFBd0IsMkJBQTJCLDZCQUE2Qix5QkFBeUIsa0JBQWtCLHNEQUFzRCxtTEFBbUwseURBQXlELG1EQUFtRCxPQUFPLHNCQUFzQixzS0FBc0ssTUFBTSxVQUFVLHNCQUFzQixFQUFFLDJMQUEyTCx3QkFBd0IsdUJBQXVCLE1BQU0seUJBQXlCLHdIQUF3SCxVQUFVLDJCQUEyQixvQ0FBb0MsZ0JBQWdCLDJCQUEyQixrS0FBa0ssWUFBWSxJQUFJLDBEQUEwRCxpQ0FBaUMsc0JBQXNCLCtCQUErQix3REFBd0QseURBQXlELHNGQUFzRixzREFBc0Qsd0JBQXdCLDhCQUE4QixRQUFRLDZCQUE2Qix5REFBeUQsNkVBQTZFLDZGQUE2RixJQUFJLHNCQUFzQiw2S0FBNkssTUFBTSwrRkFBK0YsTUFBTSx5QkFBeUIsNEJBQTRCLDJLQUEySyxLQUFLLHVFQUF1RSw2RkFBNkYsbUNBQW1DLFNBQVMsUUFBUSxvRUFBb0UsTUFBTSxrQkFBa0IscURBQXFELE1BQU0sK0NBQStDLDRDQUE0QyxNQUFNLGdCQUFnQixTQUFTLDZDQUE2Qyx3RUFBd0UsdUNBQXVDLDRDQUE0QyxNQUFNLEdBQUcsU0FBUyx3QkFBd0IsMkpBQTJKLFNBQVMsMEVBQTBFLCtNQUErTSxPQUFPLDBCQUEwQix3Q0FBd0MsdUJBQXVCLFVBQVUsb0NBQW9DLGlDQUFpQywwQ0FBMEMsaURBQWlELEVBQUUsK0NBQStDLEdBQUcsbUNBQW1DLHFFQUFxRSxrQ0FBa0MsNEZBQTRGLG1GQUFtRixTQUFTLHVHQUF1RyxRQUFRLHdiQUF3YixhQUFhLG1CQUFtQixnQkFBZ0IsaUJBQWlCLHVCQUF1QiwrQkFBK0Isb0JBQW9CLDZCQUE2QixFQUFFLEdBQUcsVUFBVSwyR0FBMkcsU0FBUyxnSEFBZ0gsYUFBYSxjQUFjLGdCQUFnQix1QkFBdUIsaUVBQWlFLGdMQUFnTCwwT0FBME8sVUFBVSxXQUFXLDhCQUE4QixXQUFXLGlDQUFpQyxVQUFVLCtCQUErQixPQUFPLGtDQUFrQyxhQUFhLHdCQUF3QixFQUFFLGFBQWEseUJBQXlCLDRCQUE0QixjQUFjLHdDQUF3Qyx5QkFBeUIsdUZBQXVGLE1BQU0sd0JBQXdCLHlDQUF5Qyx5QkFBeUIsMkdBQTJHLHNJQUFzSSxTQUFTLHlDQUF5Qyw0Q0FBNEMsK0VBQStFLDhEQUE4RCxrQ0FBa0Msc0JBQXNCLElBQUksR0FBRywyQkFBMkIsU0FBUyxxQkFBcUIsK0NBQStDLE9BQU8sR0FBRyxpQ0FBaUMseUdBQXlHLG1FQUFtRSxZQUFZLHFLQUFxSyxNQUFNLEVBQUUsYUFBYSx5SEFBeUgsaUNBQWlDLGtCQUFrQixzRkFBc0YsNkRBQTZELDBDQUEwQyxNQUFNLCtCQUErQix1QkFBdUIsdUNBQXVDLHdDQUF3QyxpQ0FBaUMsaUNBQWlDLGtCQUFrQixrSEFBa0gsMkNBQTJDLHlEQUF5RCxvRUFBb0Usb0VBQW9FLHVEQUF1RCx1REFBdUQsbURBQW1ELE9BQU8sVUFBVSx3VEFBd1QsdUJBQXVCLGlCQUFpQixpQkFBaUIsK0VBQStFLEtBQUssd0NBQXdDLDJDQUEyQywwQkFBMEIsa0NBQWtDLHFDQUFxQyx1QkFBdUIsc0JBQXNCLHVCQUF1Qiw4QkFBOEIsNkJBQTZCLHVCQUF1Qiw0QkFBNEIsc0JBQXNCLCtCQUErQiwrQkFBK0Isb0NBQW9DLG1DQUFtQywwQkFBMEIscUJBQXFCLHFEQUFxRCxrQ0FBa0MsK0RBQStELDZFQUE2RSw0RUFBNEUsc0VBQXNFLG9DQUFvQyx1QkFBdUIsOENBQThDLHVEQUF1RCxLQUFLLHNEQUFzRCxnREFBZ0QsS0FBSyxpSUFBaUkscUJBQXFCLHdCQUF3Qiw4REFBOEQsMkNBQTJDLDBCQUEwQixLQUFLLGlCQUFpQixpR0FBaUcsK0RBQStELDBEQUEwRCxxREFBcUQsc0JBQXNCLGtEQUFrRCxnREFBZ0QsZUFBZSxPQUFPLHNDQUFzQyxtQ0FBbUMscUNBQXFDLG1DQUFtQyxvQ0FBb0MsbUNBQW1DLHFDQUFxQyxtQ0FBbUMsOENBQThDLDhDQUE4Qyw4Q0FBOEMsOENBQThDLDBFQUEwRSwwRUFBMEUsMEVBQTBFLDBFQUEwRSwyREFBMkQsMkRBQTJELDJEQUEyRCwyREFBMkQsNkdBQTZHLGdEQUFnRCxlQUFlLE9BQU8saURBQWlELGlEQUFpRCxpREFBaUQsaURBQWlELG9EQUFvRCxvREFBb0Qsb0RBQW9ELG9EQUFvRCw4Q0FBOEMsOENBQThDLDBGQUEwRiwwRkFBMEYsMEZBQTBGLDBGQUEwRiw2SkFBNkosOEZBQThGLDhGQUE4Riw4RkFBOEYsOEZBQThGLDhDQUE4Qyw4Q0FBOEMsOENBQThDLDhDQUE4QyxrSkFBa0osd0RBQXdELG1IQUFtSCxLQUFLLE9BQU8sbUZBQW1GLEtBQUssa0dBQWtHLG9CQUFvQiwyTEFBMkwsTUFBTSxVQUFVLDhCQUE4QixFQUFFLDJUQUEyVCx3QkFBd0IsbUNBQW1DLEdBQUcsUUFBUSxxS0FBcUssWUFBWSxJQUFJLDRGQUE0Rix3QkFBd0IsbUJBQW1CLFFBQVEsc2ZBQXNmLFlBQVksSUFBSSxvQkFBb0Isb0NBQW9DLG1CQUFtQix1Q0FBdUMsMkxBQTJMLHdHQUF3RyxvREFBb0Qsd0VBQXdFLHNFQUFzRSxtR0FBbUcsa05BQWtOLGdLQUFnSyx5SEFBeUgseTRCQUF5NEIsa0ZBQWtGLE1BQU0sNkJBQTZCLE1BQU0sdUNBQXVDLGlCQUFpQiw2QkFBNkIsNENBQTRDLHFGQUFxRixtS0FBbUssa0VBQWtFLDhCQUE4QixLQUFLLHNCQUFzQixtUEFBbVAsTUFBTSxVQUFVLHlCQUF5QixvQkFBb0IseUhBQXlILE1BQU0sc0JBQXNCLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLFFBQVEsdWhCQUF1aEIscU1BQXFNLHdrQkFBd2tCLDJCQUEyQix3UEFBd1AsZ0NBQWdDLFNBQVMsdUVBQXVFLGtDQUFrQyxvSUFBb0ksdUNBQXVDLG1CQUFtQixxSEFBcUgsR0FBRywrV0FBK1csRUFBRSxxQ0FBcUMsd0JBQXdCLDhCQUE4QixxQkFBcUIsOENBQThDLGtQQUFrUCxxQ0FBcUMscUJBQXFCLHFDQUFxQyxPQUFPLDZFQUE2RSxHQUFHLGtDQUFrQyxjQUFjLE9BQU8sVUFBVSxPQUFPLFdBQVcsVUFBVSxRQUFRLGNBQWMsVUFBVSxhQUFhLFNBQVMsZUFBZSwyQkFBMkIsYUFBYSwyQkFBMkIsYUFBYSxRQUFRLFlBQVksUUFBUSxhQUFhLDBCQUEwQiwyRUFBMkUsK0JBQStCLG1DQUFtQyxvQ0FBb0Msb0NBQW9DLGtHQUFrRyx1RkFBdUYsaUVBQWlFLDJEQUEyRCxvQ0FBb0MsbUdBQW1HLDREQUE0RCxzREFBc0QseURBQXlELCtCQUErQixtQ0FBbUMsb0NBQW9DLG1DQUFtQyxrQ0FBa0Msa0NBQWtDLG1DQUFtQyxrQ0FBa0MsZ0NBQWdDLDBJQUEwSSwyREFBMkQsdUxBQXVMLHdHQUF3Ryw2Q0FBNkMsV0FBVyx5QkFBeUIsa0hBQWtILCtFQUErRSwwREFBMEQsZ0xBQWdMLHlCQUF5QixxREFBcUQsK0VBQStFLGFBQWEsbUVBQW1FLHFFQUFxRSxtREFBbUQsWUFBWSxVQUFVLEdBQUcsNENBQTRDLDZCQUE2QixvQkFBb0IsWUFBWSx5Q0FBeUMsNkJBQTZCLEVBQUUseUNBQXlDLGFBQWEsNkhBQTZILEVBQUUsZ0xBQWdMLHNEQUFzRCxnSUFBZ0ksR0FBRyx3QkFBd0IsZ0RBQWdELDZIQUE2SCxXQUFXLCtEQUErRCxrQ0FBa0MsOEJBQThCLHlTQUF5UyxJQUFJLHVCQUF1Qiw2REFBNkQsd0JBQXdCLG9GQUFvRixrRUFBa0UsNEJBQTRCLHFCQUFxQix1REFBdUQsaUJBQWlCLGlCQUFpQiwwSEFBMEgsR0FBRyxhQUFhLGtHQUFrRyxFQUFFLGtEQUFrRCxjQUFjLG9EQUFvRCwrREFBK0Qsc0JBQXNCLFlBQVksUUFBUSxRQUFRLFNBQVMsRUFBRSxrQkFBa0IsNkJBQTZCLE9BQU8sa0VBQWtFLDhEQUE4RCwyQkFBMkIsdUJBQXVCLHFGQUFxRixhQUFhLCtCQUErQixTQUFTLDZCQUE2QixpQ0FBaUMsNERBQTRELEtBQUssTUFBTSxrRkFBa0YsMkRBQTJELDRCQUE0Qiw0RUFBNEUsa0pBQWtKLE1BQU0sYUFBYSxvRkFBb0YsRUFBRSxrREFBa0QsNkVBQTZFLDRCQUE0Qiw0RUFBNEUsMElBQTBJLE1BQU0seUJBQXlCLHdLQUF3SyxNQUFNLHVCQUF1QixxRkFBcUYsaUJBQWlCLHlDQUF5Qyw4REFBOEQsMkJBQTJCLGlIQUFpSCx3QkFBd0IsdUJBQXVCLEdBQUcsc0JBQXNCLDRHQUE0RyxNQUFNLHVCQUF1QiwrQkFBK0IsaURBQWlELFFBQVEsOENBQThDLDhDQUE4Qyw0REFBNEQsMEZBQTBGLDZCQUE2QixpREFBaUQsY0FBYyw2Q0FBNkMsZUFBZSxzRUFBc0UsT0FBTywyREFBMkQscUNBQXFDLElBQUksR0FBRyxpQ0FBaUMsMENBQTBDLHlEQUF5RCx5QkFBeUIsZ0pBQWdKLE1BQU0sMEZBQTBGLDhDQUE4QyxpT0FBaU8sS0FBSyxHQUFHLGtDQUFrQyxjQUFjLE9BQU8sVUFBVSxNQUFNLFFBQVEsT0FBTyxTQUFTLDBDQUEwQyw2QkFBNkIsNEJBQTRCLHFCQUFxQix5QkFBeUIsa0VBQWtFLG1GQUFtRixzREFBc0QsU0FBUyx5REFBeUQsMkJBQTJCLDRCQUE0QixxQkFBcUIsOEJBQThCLDRCQUE0Qiw4REFBOEQsMkRBQTJELFdBQVcsK0NBQStDLGlFQUFpRSxtREFBbUQsVUFBVSxFQUFFLEdBQUcseUlBQXlJLGtGQUFrRixNQUFNLDJDQUEyQyw4QkFBOEIsU0FBUyw4Q0FBOEMsVUFBVSxZQUFZLFlBQVksSUFBSSx5RkFBeUYsb0VBQW9FLGVBQWUsdUZBQXVGLGtDQUFrQyxpQ0FBaUMsTUFBTSwwRUFBMEUsd0NBQXdDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLG9DQUFvQyxnQ0FBZ0Msa0lBQWtJLEdBQUcsY0FBYyx1REFBdUQseUpBQXlKLGtMQUFrTCxNQUFNLFFBQVEsdUNBQXVDLGNBQWMsUUFBUSx5RkFBeUYseUJBQXlCLHdDQUF3Qyx3Q0FBd0MsNkhBQTZILDhEQUE4RCx3REFBd0QsRUFBRSxnQkFBZ0IsRUFBRSxrRkFBa0YsdUJBQXVCLE9BQU8sVUFBVSxnQkFBZ0IsRUFBRSxvRkFBb0YsU0FBUywrREFBK0QsU0FBUyxzQ0FBc0MsY0FBYyxnRUFBZ0Usb0JBQW9CLG9IQUFvSCxtQkFBbUIscVZBQXFWLCtDQUErQyxtQkFBbUIsc0lBQXNJLCtKQUErSiwyQkFBMkIsb0RBQW9ELCtDQUErQyxvQkFBb0IsdURBQXVELG1CQUFtQiw0Q0FBNEMsaUJBQWlCLEVBQUUsR0FBRyxpSEFBaUgsNERBQTRELE1BQU0saUNBQWlDLFFBQVEsb0NBQW9DLDZDQUE2Qyw2Q0FBNkMsMkRBQTJELG1DQUFtQyxZQUFZLDZDQUE2QyxnRUFBZ0Usb0NBQW9DLDhDQUE4QyxLQUFLLHNCQUFzQiwrTEFBK0wsTUFBTSxhQUFhLDBCQUEwQix1QkFBdUIsd0hBQXdILHdKQUF3SixZQUFZLCtCQUErQixtQkFBbUIsTUFBTSxnQkFBZ0IsMEhBQTBILEVBQUUsOEJBQThCLDhGQUE4Riw4QkFBOEIsRUFBRSxtR0FBbUcsOE9BQThPLEdBQUcsaURBQWlELFVBQVUsMENBQTBDLDZDQUE2QyxzRkFBc0YsTUFBTSxLQUFLLDBFQUEwRSxNQUFNLDJEQUEyRCxNQUFNLGVBQWUsb0JBQW9CLDRCQUE0Qix5QkFBeUIsNkJBQTZCLDhCQUE4Qiw4QkFBOEIsMkJBQTJCLDJCQUEyQiwwQkFBMEIsNkJBQTZCLG1CQUFtQiwrREFBK0QsdUZBQXVGLHVGQUF1Rix1RkFBdUYsdURBQXVELGlFQUFpRSx3Q0FBd0MsK0NBQStDLGlEQUFpRCx1QkFBdUIsMkJBQTJCLE9BQU8sd0JBQXdCLDZCQUE2QixtQkFBbUIsb0VBQW9FLHVEQUF1RCx5REFBeUQsMkRBQTJELG1EQUFtRCxRQUFRLHlLQUF5SyxtQkFBbUIsdUJBQXVCLGVBQWUsa0JBQWtCLHlCQUF5QixvQkFBb0IsV0FBVyxxQ0FBcUMsNEJBQTRCLDRCQUE0QixvQkFBb0IsV0FBVyxxQkFBcUIsNEJBQTRCLDBCQUEwQixTQUFTLFVBQVUsMEJBQTBCLFNBQVMsSUFBSSxPQUFPLHlCQUF5QixxRkFBcUYsTUFBTSx5QkFBeUIsd0JBQXdCLE9BQU8sZ0hBQWdILFNBQVMsMEtBQTBLLHVCQUF1Qiw2RUFBNkUsbUZBQW1GLGdCQUFnQixFQUFFLEdBQUcsa0JBQWtCLEVBQUUsSUFBSSxNQUFNLDJFQUEyRSx3Q0FBd0MscUNBQXFDLG9DQUFvQyxxQ0FBcUMsdUNBQXVDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLHFDQUFxQyxxQ0FBcUMscUNBQXFDLDhDQUE4QywwQ0FBMEMsR0FBRyxHQUFHLFVBQVUsVUFBVSxrUUFBa1EsMENBQTBDLDJDQUEyQyxvQ0FBb0MsOEJBQThCLDBDQUEwQyx3Q0FBd0MsT0FBTyw2SUFBNkksb0NBQW9DLHNDQUFzQyxnQ0FBZ0MsNEJBQTRCLDhCQUE4QixrQ0FBa0MsK0NBQStDLHdCQUF3Qiw0QkFBNEIsZ0NBQWdDLCtCQUErQiwrQ0FBK0MsK0JBQStCLCtCQUErQiw2Q0FBNkMsa0NBQWtDLHdCQUF3QixvRkFBb0YsMkNBQTJDLDBFQUEwRSxPQUFPLDRGQUE0RixxRUFBcUUsT0FBTyxnQ0FBZ0MsK0NBQStDLDRJQUE0SSw2SkFBNkosNkVBQTZFLDhDQUE4QyxTQUFTLHdIQUF3SCwyR0FBMkcsNEZBQTRGLFNBQVMsbURBQW1ELHVLQUF1Syw0QkFBNEIsOENBQThDLFdBQVcsa0ZBQWtGLHFDQUFxQyxjQUFjLHdIQUF3SCwyRUFBMkUsU0FBUyxxSEFBcUgsc0JBQXNCLE9BQU8sUUFBUSxpREFBaUQsc0JBQXNCLDZFQUE2RSxLQUFLLHFDQUFxQywwREFBMEQsNENBQTRDLGtFQUFrRSxpRUFBaUUsd0VBQXdFLGdDQUFnQyxLQUFLLE9BQU8sZUFBZSwyQ0FBMkMsZUFBZSxtQ0FBbUMsZUFBZSwyQ0FBMkMsTUFBTSxlQUFlLHNDQUFzQyxjQUFjLDJFQUEyRSxpQkFBaUIsZUFBZSw4QkFBOEIsS0FBSyxvRkFBb0Ysb0JBQW9CLGlCQUFpQixZQUFZLDhGQUE4Rix5QkFBeUIsMkJBQTJCLHNCQUFzQiw4Q0FBOEMsWUFBWSxJQUFJLEtBQUssY0FBYywyREFBMkQscURBQXFELE1BQU0sZ0NBQWdDLGFBQWEsOEJBQThCLEVBQUUsVUFBVSx5QkFBeUIsRUFBRSw0QkFBNEIsd0JBQXdCLGNBQWMseUdBQXlHLG9CQUFvQixTQUFTLGtCQUFrQixrRUFBa0UsV0FBVyxvREFBb0QsMkZBQTJGLElBQUksWUFBWSxnRUFBZ0UsS0FBSyxhQUFhLG1CQUFtQixFQUFFLG1EQUFtRCxXQUFXLGlDQUFpQyxzQkFBc0IsU0FBUyxtQkFBbUIscUJBQXFCLGtCQUFrQixNQUFNLCtFQUErRSxxQ0FBcUMsTUFBTSxtRUFBbUUsaUNBQWlDLE1BQU0scUZBQXFGLHVDQUF1QyxNQUFNLHlFQUF5RSxtQ0FBbUMsMENBQTBDLHdDQUF3QyxzQkFBc0IsOEJBQThCLGtDQUFrQyxvQ0FBb0MsTUFBTSwrRUFBK0UscUNBQXFDLE1BQU0sNEVBQTRFLG9DQUFvQyw0QkFBNEIsaUNBQWlDLE1BQU0sNEVBQTRFLG9DQUFvQyxNQUFNLDRFQUE0RSxvQ0FBb0MsNkRBQTZELGdDQUFnQyxxREFBcUQsOEJBQThCLDZGQUE2RixzQkFBc0IsOEJBQThCLGNBQWMsaUhBQWlILGtCQUFrQixvQkFBb0IsdUJBQXVCLCtCQUErQiw4Q0FBOEMscUJBQXFCLHNCQUFzQixZQUFZLG1CQUFtQixxREFBcUQsYUFBYSxVQUFVLHFCQUFxQix3QkFBd0IsaUVBQWlFLGFBQWEsWUFBWSxxQkFBcUIsdUpBQXVKLDhDQUE4QyxrRUFBa0UsNkhBQTZILDBFQUEwRSwwQ0FBMEMscUNBQXFDLFNBQVMsc0NBQXNDLG9CQUFvQixtQ0FBbUMsa0NBQWtDLE1BQU0sRUFBRSxxRUFBcUUseUJBQXlCLGNBQWMsbUVBQW1FLGVBQWUsbUJBQW1CLGdCQUFnQixlQUFlLE1BQU0seURBQXlELGFBQWEsUUFBUSw4QkFBOEIsMEJBQTBCLHVEQUF1RCwrQ0FBK0MsZ0ZBQWdGLDhFQUE4RSxnRUFBZ0UsbUdBQW1HLFFBQVEsc0JBQXNCLHlFQUF5RSxtQ0FBbUMsNEJBQTRCLFFBQVEsNEVBQTRFLElBQUksVUFBVSxvRkFBb0Ysb0NBQW9DLE1BQU0sZ0hBQWdILFdBQVcsNkJBQTZCLFNBQVMsYUFBYSxrQkFBa0Isc0RBQXNELG9CQUFvQiwrS0FBK0ssWUFBWSx1VEFBdVQsR0FBRyx5QkFBeUIsaUdBQWlHLE9BQU8sMkNBQTJDLFVBQVUsWUFBWSwyREFBMkQsNkVBQTZFLDBGQUEwRixxQ0FBcUMsdUZBQXVGLHFDQUFxQyxvRkFBb0YsZ0NBQWdDLFFBQVEsS0FBSyxzQkFBc0IsZ0JBQWdCLE1BQU0seUJBQXlCLGlCQUFpQixPQUFPLG9CQUFvQix3QkFBd0Isa0JBQWtCLG1GQUFtRixnREFBZ0QsT0FBTyxzQkFBc0Isd0RBQXdELE1BQU0sdUJBQXVCLHdCQUF3QixzQ0FBc0MsaUZBQWlGLHVDQUF1QyxxQkFBcUIsNkVBQTZFLDBGQUEwRix3Q0FBd0MsdUZBQXVGLHdDQUF3QyxzRkFBc0YsTUFBTSw4RkFBOEYsSUFBSSxNQUFNLGtDQUFrQyxJQUFJLE1BQU0sMkRBQTJELHlCQUF5QixjQUFjLHVEQUF1RCxlQUFlLG1CQUFtQixnQkFBZ0IsZUFBZSxNQUFNLHlEQUF5RCxhQUFhLDhCQUE4QixhQUFhLG1DQUFtQyx1QkFBdUIsdUVBQXVFLHlCQUF5Qix1TEFBdUwsd0JBQXdCLElBQUksS0FBSyxjQUFjLHVDQUF1QyxjQUFjLDJKQUEySiwwQkFBMEIsTUFBTSx5QkFBeUIsZ0JBQWdCLE9BQU8sb0JBQW9CLHdCQUF3QixxQkFBcUIsa0ZBQWtGLGdEQUFnRCxPQUFPLHNCQUFzQixpREFBaUQsTUFBTSxPQUFPLHFCQUFxQixtQkFBbUIsOEJBQThCLE9BQU8sc0VBQXNFLFVBQVUsSUFBSSxNQUFNLE1BQU0sa0VBQWtFLCtCQUErQixZQUFZLElBQUksa0NBQWtDLDZEQUE2RCxHQUFHLGtCQUFrQix3Q0FBd0MsR0FBRyxZQUFZLGlCQUFpQixpQkFBaUIsb0xBQW9MLG9CQUFvQiw4QkFBOEIsbUJBQW1CLEVBQUUsWUFBWSxXQUFXLEtBQUsscUJBQXFCLGdNQUFnTSxLQUFLLEdBQUcseUJBQXlCLGlHQUFpRyxPQUFPLGtEQUFrRCxVQUFVLFlBQVksOEVBQThFLGdEQUFnRCx1RkFBdUYsOENBQThDLG9GQUFvRixtREFBbUQsUUFBUSxvQ0FBb0MsUUFBUSxLQUFLLDhCQUE4Qix5QkFBeUIsSUFBSSx5QkFBeUIsNkRBQTZELGdDQUFnQyxNQUFNLDRCQUE0Qix5Q0FBeUMsc0JBQXNCLGlDQUFpQyxpQ0FBaUMsT0FBTyw0RUFBNEUsY0FBYyxLQUFLLE1BQU0scURBQXFELHlCQUF5QixpQkFBaUIsT0FBTyxNQUFNLDBDQUEwQyxzU0FBc1MsaUZBQWlGLE9BQU8sd0JBQXdCLFlBQVksSUFBSSxLQUFLLE1BQU0sd0NBQXdDLG1PQUFtTywwREFBMEQsZ0NBQWdDLGVBQWUsOEJBQThCLDJCQUEyQix5Q0FBeUMsb0VBQW9FLGtDQUFrQyxRQUFRLEtBQUssR0FBRyxTQUFTLGNBQWMsK0ZBQStGLHVHQUF1RyxzQkFBc0IsTUFBTSx5QkFBeUIsMERBQTBELHVCQUF1QixtRkFBbUYsbURBQW1ELEVBQUUsc0JBQXNCLDJDQUEyQyxNQUFNLHVCQUF1QiwrQkFBK0IsTUFBTSxVQUFVLEdBQUcsNERBQTRELG9DQUFvQyxJQUFJLG1CQUFtQixNQUFNLHFEQUFxRCxvQ0FBb0MscUJBQXFCLE9BQU8sR0FBRyxxRUFBcUUsK0JBQStCLHlCQUF5QixrS0FBa0ssTUFBTSxNQUFNLGtCQUFrQiwyREFBMkQsMERBQTBELCtEQUErRCxRQUFRLGdEQUFnRCxLQUFLLDhCQUE4QixrQkFBa0IsZUFBZSx1RkFBdUYsd0NBQXdDLGVBQWUsYUFBYSxlQUFlLG1FQUFtRSxNQUFNLHVIQUF1SCxnQ0FBZ0MsNEJBQTRCLHVCQUF1QixNQUFNLFFBQVEseUJBQXlCLHlDQUF5QyxpQkFBaUIsTUFBTSxHQUFHLGFBQWEsMkNBQTJDLEVBQUUsVUFBVSx1QkFBdUIsMkpBQTJKLHdDQUF3Qyx5QkFBeUIsNFBBQTRQLE1BQU0sTUFBTSxrQkFBa0IsaURBQWlELHNGQUFzRixnREFBZ0QsRUFBRSw4RkFBOEYsU0FBUyx1Q0FBdUMsdUNBQXVDLHNDQUFzQywrQkFBK0IsMkVBQTJFLG1DQUFtQyw0QkFBNEIsdUJBQXVCLE1BQU0sUUFBUSxzQkFBc0IseUNBQXlDLGlCQUFpQixtQ0FBbUMsMEZBQTBGLEdBQUcsR0FBRyxhQUFhLDhDQUE4QyxFQUFFLFFBQVEsdUJBQXVCLHFEQUFxRCx3Q0FBd0MseUJBQXlCLDRDQUE0QyxNQUFNLDBDQUEwQyxzTEFBc0wsWUFBWSwrQkFBK0Isb0NBQW9DLGlGQUFpRixxQkFBcUIsS0FBSyxHQUFHLGFBQWEsTUFBTSxFQUFFLG9GQUFvRix1QkFBdUIsbUlBQW1JLFFBQVEsYUFBYSxpRUFBaUUsbUJBQW1CLGtCQUFrQiw4RUFBOEUsZ0JBQWdCLE1BQU0seUJBQXlCLDJCQUEyQix3QkFBd0Isd0JBQXdCLHdCQUF3Qiw2QkFBNkIsc0JBQXNCLHlDQUF5QyxpREFBaUQsbUNBQW1DLHNCQUFzQiw0Q0FBNEMsNEVBQTRFLG1FQUFtRSx5REFBeUQsbURBQW1ELE9BQU8sc0JBQXNCLHdHQUF3RyxNQUFNLFVBQVUsc0JBQXNCLEVBQUUsd0JBQXdCLDJDQUEyQyw0Q0FBNEMsaUJBQWlCLDBDQUEwQyxZQUFZLHFCQUFxQixlQUFlLFdBQVcsRUFBRSxPQUFPLGtDQUFrQyx3QkFBd0IsTUFBTSxvREFBb0QsOEJBQThCLHVDQUF1Qyx3T0FBd08seUVBQXlFLHFEQUFxRCxzQ0FBc0MsVUFBVSxZQUFZLFdBQVcscUJBQXFCLHVFQUF1RSxrREFBa0QsaUNBQWlDLE1BQU0sdUJBQXVCLGtLQUFrSyxnREFBZ0QsMkNBQTJDLE1BQU0sdURBQXVELGlGQUFpRix3QkFBd0IsdUVBQXVFLHVCQUF1Qix3REFBd0QsSUFBSSxHQUFHLGFBQWEsd0RBQXdELEVBQUUsOEVBQThFLHdCQUF3QixzQkFBc0Isd0JBQXdCLGVBQWUsVUFBVSxFQUFFLE9BQU8sMkJBQTJCLFNBQVMsU0FBUyxrREFBa0QsVUFBVSxHQUFHLGdCQUFnQixJQUFJLGdCQUFnQixTQUFTLDRDQUE0Qyx5QkFBeUIsdUJBQXVCLHVGQUF1RixhQUFhLGtEQUFrRCxnQ0FBZ0MsZ0NBQWdDLDZCQUE2Qix1REFBdUQsMENBQTBDLDBDQUEwQyxnREFBZ0QsdUVBQXVFLG1EQUFtRCxjQUFjLEVBQUUsTUFBTSxNQUFNLHVCQUF1QixNQUFNLHlEQUF5RCxNQUFNLFlBQVksOEJBQThCLCtHQUErRywyVEFBMlQsc0NBQXNDLG1CQUFtQixtQ0FBbUMscUhBQXFILGlDQUFpQyxvREFBb0QsaUNBQWlDLG9EQUFvRCxpQ0FBaUMsb0RBQW9ELGlDQUFpQyxvREFBb0QsaUNBQWlDLHdGQUF3RixpQ0FBaUMsd0ZBQXdGLEVBQUUsbURBQW1ELFVBQVUsS0FBSyxZQUFZLDBDQUEwQyx1QkFBdUIscUJBQXFCLHFGQUFxRixXQUFXLGtEQUFrRCwyQkFBMkIsbURBQW1ELGlGQUFpRixXQUFXLEVBQUUsZ0RBQWdELFVBQVUsS0FBSyxZQUFZLDBDQUEwQyx1QkFBdUIscUJBQXFCLHFGQUFxRixXQUFXLGtEQUFrRCwyQkFBMkIsbURBQW1ELHVGQUF1RixXQUFXLEVBQUUsZ0RBQWdELFVBQVUsS0FBSyxXQUFXLFNBQVMsUUFBUSxRQUFRLFFBQVEsV0FBVyxTQUFTLDBDQUEwQyx1QkFBdUIscUJBQXFCLHFGQUFxRixXQUFXLDZDQUE2QyxnQ0FBZ0MsK0JBQStCLDhCQUE4QixpQ0FBaUMsbURBQW1ELDBDQUEwQyx3Q0FBd0MsaUNBQWlDLFVBQVUsV0FBVyxtQ0FBbUMsVUFBVSxXQUFXLG1DQUFtQywrQ0FBK0MsSUFBSSxJQUFJLElBQUksV0FBVyxzRUFBc0UsbURBQW1ELHdFQUF3RSxxQ0FBcUMsbUNBQW1DLGlCQUFpQixlQUFlLGFBQWEsdURBQXVELFdBQVcsRUFBRSxnREFBZ0QsVUFBVSxLQUFLLFdBQVcsT0FBTywwQkFBMEIsMENBQTBDLHVCQUF1QixxQkFBcUIscUZBQXFGLFdBQVcsNkNBQTZDLGdDQUFnQyw0QkFBNEIsbURBQW1ELG9IQUFvSCxXQUFXLEVBQUUsZ0RBQWdELFVBQVUsUUFBUSxnQkFBZ0IsVUFBVSxnQkFBZ0IsTUFBTSxZQUFZLDBDQUEwQyx1QkFBdUIscUJBQXFCLHFGQUFxRixXQUFXLDZDQUE2QyxtQ0FBbUMsb0NBQW9DLGdDQUFnQyxtREFBbUQsK0NBQStDLCtDQUErQywrQ0FBK0Msb0RBQW9ELGNBQWMsTUFBTSxxREFBcUQsYUFBYSxXQUFXLEVBQUUsR0FBRyxXQUFXLFFBQVEseUhBQXlILHVEQUF1RCxlQUFlLFlBQVksSUFBSSxLQUFLLDBCQUEwQixtTUFBbU0sOElBQThJLFlBQVksSUFBSSxLQUFLLDBCQUEwQixtTUFBbU0sNEtBQTRLLGdCQUFnQixlQUFlLGdCQUFnQixhQUFhLGdFQUFnRSxFQUFFLHFIQUFxSCxRQUFRLHVCQUF1QixRQUFRLHNGQUFzRixjQUFjLE1BQU0sVUFBVSxpQ0FBaUMsZUFBZSxlQUFlLE1BQU0sK0NBQStDLGlEQUFpRCxVQUFVLHlCQUF5QixPQUFPLFVBQVUsc0RBQXNELGdCQUFnQixPQUFPLFVBQVUsd0RBQXdELGdCQUFnQixvQkFBb0IsNEdBQTRHLHdDQUF3QyxzU0FBc1MsdUJBQXVCLDZCQUE2QixVQUFVLG9CQUFvQixTQUFTLFlBQVksRUFBRSx3QkFBd0IsMk9BQTJPLHlDQUF5QywrR0FBK0csbUJBQW1CLElBQUksTUFBTSwrTEFBK0wsMkpBQTJKLDJCQUEyQix3QkFBd0IsdURBQXVELHdMQUF3TCxXQUFXLG1CQUFtQiwyQkFBMkIsaURBQWlELDREQUE0RCxzQ0FBc0MsMkNBQTJDLE1BQU0sbUJBQW1CLHdEQUF3RCxtQkFBbUIsZ0RBQWdELDhIQUE4SCxvQ0FBb0Msb0lBQW9JLHdCQUF3QixnREFBZ0Qsc0NBQXNDLHlJQUF5SSxnQ0FBZ0MsMEJBQTBCLE9BQU8sb0RBQW9ELGlCQUFpQixnSEFBZ0gsT0FBTyxpR0FBaUcsd0JBQXdCLGdDQUFnQyxNQUFNLDBCQUEwQiwwRkFBMEYsdUJBQXVCLGtCQUFrQix3QkFBd0IsT0FBTyx1R0FBdUcsbUJBQW1CLDJCQUEyQiw2Q0FBNkMscUNBQXFDLDJCQUEyQix1QkFBdUIsNkpBQTZKLDBCQUEwQixzREFBc0QsaUNBQWlDLGdCQUFnQix1Q0FBdUMsNkZBQTZGLEtBQUsscURBQXFELHFCQUFxQixJQUFJLE1BQU0sK0xBQStMLHlLQUF5SywyQkFBMkIsOEJBQThCLElBQUksOEJBQThCLHVEQUF1RCwyV0FBMlcsV0FBVywrQkFBK0IsOERBQThELHNEQUFzRCw0REFBNEQsa0NBQWtDLDJDQUEyQyxNQUFNLCtCQUErQixpSEFBaUgsK0ZBQStGLG9CQUFvQix3WEFBd1gsb0JBQW9CLFVBQVUseVBBQXlQLDhCQUE4QixJQUFJLDhCQUE4QixrRUFBa0Usc0NBQXNDLHlJQUF5SSxnQ0FBZ0MsMEJBQTBCLHdCQUF3QixzREFBc0Qsd0RBQXdELGtMQUFrTCxnQ0FBZ0MsbUNBQW1DLHVCQUF1QixpQkFBaUIsd0JBQXdCLE9BQU8sdUdBQXVHLG1CQUFtQiw0QkFBNEIseUJBQXlCLHlCQUF5QiwyRkFBMkYsNEVBQTRFLHFHQUFxRyx1QkFBdUIsb0pBQW9KLElBQUksOERBQThELGVBQWUsc0JBQXNCLHlCQUF5QixlQUFlLGtEQUFrRCxzRUFBc0UscUJBQXFCLElBQUksTUFBTSw4S0FBOEsseUtBQXlLLDJCQUEyQix5QkFBeUIsd0RBQXdELDJXQUEyVyxXQUFXLGlEQUFpRCxJQUFJLHVEQUF1RCw0REFBNEQsa0NBQWtDLDJDQUEyQyxNQUFNLGlEQUFpRCx3REFBd0QscUZBQXFGLHFCQUFxQixvQ0FBb0Msc0dBQXNHLHlCQUF5QixzQkFBc0Isb1VBQW9VLGFBQWEsbUdBQW1HLG9DQUFvQyw2SkFBNkosZ0NBQWdDLDBCQUEwQix3QkFBd0Isc0RBQXNELHdEQUF3RCx5Q0FBeUMsV0FBVyxZQUFZLE1BQU0sS0FBSyx5QkFBeUIscURBQXFELFNBQVMsT0FBTyxnQ0FBZ0MsZ0dBQWdHLHVCQUF1QixpQkFBaUIsd0JBQXdCLE9BQU8sdUdBQXVHLG1CQUFtQix1QkFBdUIsNkNBQTZDLHNCQUFzQiwwSUFBMEksR0FBRyxxRUFBcUUsb0RBQW9ELHdCQUF3QixnQkFBZ0IsbUJBQW1CLCtCQUErQix3QkFBd0IscUJBQXFCLGtDQUFrQyxrQkFBa0IsUUFBUSxZQUFZLElBQUksS0FBSyx1RUFBdUUsOEJBQThCLFNBQVMsb1VBQW9VLG9iQUFvYixNQUFNLDhIQUE4SCx3QkFBd0Isc0hBQXNILDhLQUE4Syx5TUFBeU0sR0FBRyx5QkFBeUIsZ0JBQWdCLHFFQUFxRSxZQUFZLDJNQUEyTSxnQkFBZ0IsV0FBVyw4S0FBOEssMkRBQTJELHVCQUF1QixNQUFNLDREQUE0RCxVQUFVLGdNQUFnTSx1RUFBdUUsZ0RBQWdELG9DQUFvQyxRQUFRLDBCQUEwQixNQUFNLG9DQUFvQyxtQ0FBbUMsNkJBQTZCLHNDQUFzQywrQkFBK0Isb0JBQW9CLGdDQUFnQyxvQkFBb0IsZ0NBQWdDLG9CQUFvQixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1QixzQ0FBc0MsdUJBQXVCLHNDQUFzQyx1QkFBdUIsc0NBQXNDLHVCQUF1Qiw0QkFBNEIsTUFBTSxPQUFPLEdBQUcsMkJBQTJCLElBQUksbUJBQW1CLFdBQVcsWUFBWSxFQUFFLGlMQUFpTCx5QkFBeUIscUJBQXFCLFdBQVcsK0NBQStDLHdCQUF3QixxRkFBcUYsWUFBWSxDQUFDLHNCQUFzQixZQUFZLHVHQUF1Ryx5QkFBeUIsMkJBQTJCLGFBQWEsVUFBVSxFQUFFLDBCQUEwQixjQUFjLGFBQWEsQ0FBQyx1QkFBdUIsSUFBSSxxQkFBcUIsV0FBVyxzSEFBc0gsRUFBRSxNQUFNLDZCQUE2QixnQ0FBZ0MsK0JBQStCLDhCQUE4QixFQUFFLG1KQUFtSixhQUFhLCtCQUErQixnRUFBZ0UsaUhBQWlILGlGQUFpRiwwQkFBMEIsNEJBQTRCLHlCQUF5QixjQUFjLHNDQUFzQyxDQUFDLGdCQUFnQixHQUFHLGNBQWMsSUFBSSx3Q0FBd0MseUJBQXlCLE1BQU0sdUhBQXVILHVCQUF1Qix3UEFBd1Asc0NBQXNDLE1BQU0sS0FBSyxDQUFDLGdCQUFnQixXQUFXLDBEQUEwRCxFQUFFLHVCQUF1QiwrQkFBK0IsUUFBUSw4Q0FBOEMsWUFBWSxNQUFNLGdCQUFnQixNQUFNLG1EQUFtRCxrREFBa0QsMkRBQTJELGtEQUFrRCxrQ0FBa0MscUJBQXFCLE1BQU0sQ0FBQyxtQkFBbUIsWUFBWSw4QkFBOEIsbUZBQW1GLGtEQUFrRCx1QkFBdUIsQ0FBQyxpQkFBaUIsSUFBSSxjQUFjLElBQUksV0FBVyxJQUFJLFdBQVcsSUFBSSxzQkFBc0IsSUFBSSxtQkFBbUIsSUFBSSxlQUFlLElBQUksc0JBQXNCLElBQUksZ0JBQWdCLElBQUksY0FBYyxJQUFJLGNBQWMsSUFBSSxhQUFhLElBQUksYUFBYSxJQUFJLHFCQUFxQixJQUFJLGNBQWMsSUFBSSx5QkFBeUIsR0FBRyxzQkFBc0IsSUFBSSx5RkFBeUYsK0JBQStCLGNBQWMsTUFBTSxnRkFBZ0YsbUJBQW1CLDhDQUE4QyxvQ0FBb0MsRUFBRSxFQUFFLEtBQUssQ0FBQyxZQUFZLElBQUksc0JBQXNCLElBQUksa0JBQWtCLFdBQVcsc0VBQXNFLEVBQUUsd0JBQXdCLHdCQUF3QixLQUFLLHlDQUF5QyxFQUFFLFFBQVEsd0JBQXdCLCtFQUErRSwwREFBMEQsU0FBUywyQkFBMkIsTUFBTSxnQkFBZ0IsQ0FBQyx1QkFBdUIsSUFBSSxxQkFBcUIsSUFBSSxvQkFBb0IsV0FBVyxpRUFBaUUsRUFBRSxvR0FBb0cseUJBQXlCLE1BQU0sV0FBVyxzSkFBc0osR0FBRyxlQUFlLGFBQWEsMEhBQTBILFlBQVksaUNBQWlDLEtBQUssa0JBQWtCLFdBQVcsVUFBVSxFQUFFLFlBQVksUUFBUSxzSUFBc0ksT0FBTywwRUFBMEUsT0FBTyxzQkFBc0IsUUFBUSxnSEFBZ0gsVUFBVSxrREFBa0QsV0FBVyxrR0FBa0csR0FBRyxTQUFTLGtKQUFrSixzQkFBc0IsQ0FBQyxnQkFBZ0IsSUFBSSxhQUFhLElBQUksZ0JBQWdCLElBQUksaUNBQWlDLElBQUksb0JBQW9CLElBQUksYUFBYSxJQUFJLGVBQWUsSUFBSSxtQkFBbUIsSUFBSSx1QkFBdUIsSUFBSSxzQkFBc0IsSUFBSSx5QkFBeUIsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJLG9CQUFvQixJQUFJLHNCQUFzQixXQUFXLHVEQUF1RCxFQUFFLGlEQUFpRCxNQUFNLG1DQUFtQywwQ0FBMEMsU0FBUyxtQkFBTyxDQUFDLCtGQUF5QixHQUFHLCtCQUErQixnQ0FBZ0MsU0FBUyw2QkFBNkIsa0NBQWtDLHdDQUF3QyxRQUFRLElBQUksQ0FBQyw4QkFBOEIsSUFBSSxnQkFBZ0IsSUFBSSxxQkFBcUIsSUFBSSxtQkFBbUIsSUFBSSwyQkFBMkIsSUFBSSwyQkFBMkIsSUFBSSxlQUFlLFdBQVcsMkVBQTJFLEVBQUUseUNBQXlDLGlCQUFpQix3RUFBd0Usd0JBQXdCLDhHQUE4RyxTQUFTLG1JQUFtSSxnYUFBZ2EsTUFBTSx1QkFBdUIsNEJBQTRCLHVFQUF1RSxNQUFNLElBQUksUUFBUSxvQ0FBb0MsYUFBYSwrREFBK0QscURBQXFELHVCQUF1QixNQUFNLE1BQU0sQ0FBQyxhQUFhLElBQUksbUJBQW1CLElBQUksbUJBQW1CLEdBQUcsZ0dBQWdHLElBQUksMlBBQTJQLGtCQUFrQixxQkFBcUIsT0FBTywyQkFBMkIsa1BBQWtQLGFBQWEsb0JBQW9CLHlCQUF5QixNQUFNLDBGQUEwRixLQUFLLGFBQWEsd01BQXdNLHdGQUF3RixHQUFHLHlCQUF5QixjQUFjLG1LQUFtSywyQkFBMkIsaUJBQWlCLDhCQUE4QixRQUFRLHFCQUFxQix3Q0FBd0MsMkJBQTJCLHVCQUF1QixNQUFNLENBQUMscUJBQXFCLDZCQUE2QixpQkFBaUIsb0VBQW9FLGtDQUFrQyxvREFBb0QsK0JBQStCLFFBQVEscUJBQXFCLEdBQUcsOE5BQThOLElBQUksZ0JBQWdCLGNBQWMsU0FBUyxvRkFBb0YsMkNBQTJDLDBDQUEwQyxTQUFTLHdCQUF3QixpQ0FBaUMsc0JBQXNCLHlDQUF5QyxzQkFBc0IsMENBQTBDLG9FQUFvRSx1Q0FBdUMsbUNBQW1DLHVDQUF1QyxtQ0FBbUMsdUNBQXVDLHVFQUF1RSw2QkFBNkIsbUNBQW1DLDZCQUE2QixtQ0FBbUMsNkJBQTZCLFFBQVEsQ0FBQyxZQUFZLElBQUksdUJBQXVCLFdBQVcsK0dBQStHLEVBQUUsZ0RBQWdELDhEQUE4RCxNQUFNLHdFQUF3RSxLQUFLLHFGQUFxRixnREFBZ0QsZUFBZSxLQUFLLElBQUksMkJBQTJCLGdFQUFnRSxPQUFPLGtEQUFrRCxvREFBb0QsS0FBSyxDQUFDLG9CQUFvQixJQUFJLFlBQVksSUFBSSxZQUFZLEdBQUcsV0FBVyxJQUFJLG1CQUFtQixJQUFJLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxpQkFBaUIsSUFBSSxnQkFBZ0IsSUFBSSx3QkFBd0IsV0FBVyx5Q0FBeUMsRUFBRSx1SEFBdUgsaUJBQWlCLEtBQUssMEVBQTBFLHlCQUF5QixpQkFBaUIsbUJBQW1CLEtBQUssbUJBQW1CLEdBQUcsTUFBTSxvQkFBb0IsZ0JBQWdCLG9CQUFvQix3QkFBd0IscUJBQXFCLFNBQVMsTUFBTSxhQUFhLElBQUksbUJBQW1CLGFBQWEsTUFBTSxvQkFBb0IsR0FBRywwQkFBMEIsS0FBSyxhQUFhLElBQUksbUJBQW1CLGFBQWEsTUFBTSxVQUFVLEdBQUcsc0JBQXNCLGFBQWEsdUNBQXVDLFdBQVcsZ0NBQWdDLFdBQVcsT0FBTyxxRUFBcUUsc0NBQXNDLG1CQUFtQixFQUFFLENBQUMsYUFBYSxJQUFJLG1CQUFtQixJQUFJLFlBQVksSUFBSSxjQUFjLFdBQVcscUdBQXFHLEVBQUUsTUFBTSxvQkFBb0IseUVBQXlFLGtCQUFrQixNQUFNLGlFQUFpRSxTQUFTLDRCQUE0QixxS0FBcUssU0FBUyxpR0FBaUcsT0FBTyxvQ0FBb0MsbURBQW1ELE9BQU8sa0JBQWtCLHdCQUF3QixPQUFPLDhCQUE4QixNQUFNLFNBQVMsMEJBQTBCLGFBQWEsaUJBQWlCLFVBQVUsQ0FBQyxtQkFBbUIsSUFBSSxvQkFBb0IsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsSUFBSSxZQUFZLElBQUksY0FBYyxJQUFJLDJCQUEyQixJQUFJLDJCQUEyQixJQUFJLDBCQUEwQixJQUFJLDZCQUE2QixJQUFJLDhCQUE4QixXQUFXLHFEQUFxRCxFQUFFLFVBQVUsMEJBQTBCLEVBQUUsb0JBQW9CLE9BQU8sZ0NBQWdDLFFBQVEsVUFBVSwwQkFBMEIsTUFBTSxtS0FBbUssZ0hBQWdILEVBQUUsOERBQThELFNBQVMsK0JBQStCLE1BQU0scUZBQXFGLDhHQUE4RyxpQ0FBaUMsSUFBSSxvQkFBb0IsU0FBUyxJQUFJLHNHQUFzRyx1REFBdUQsa0dBQWtHLEtBQUssQ0FBQyxnQ0FBZ0MsSUFBSSwwQkFBMEIsSUFBSSwwQkFBMEIsSUFBSSxrQkFBa0IsSUFBSSxxQkFBcUIsSUFBSSwwQkFBMEIsSUFBSSxnQkFBZ0IsV0FBVyw4S0FBOEssRUFBRSwrQ0FBK0MsZ0JBQWdCLEtBQUssS0FBSyxzREFBc0QseUJBQXlCLG9CQUFvQixPQUFPLGlDQUFpQywrQkFBK0Isa0JBQWtCLGFBQWEsaUJBQWlCLDJEQUEyRCxpQ0FBaUMsb0JBQW9CLDBVQUEwVSwyQkFBMkIsa0JBQWtCLGFBQWEsc0JBQXNCLDZDQUE2QyxvSEFBb0gsR0FBRyx5QkFBeUIsa0JBQWtCLGFBQWEsc0JBQXNCLHlDQUF5Qyx5Q0FBeUMsTUFBTSxLQUFLLENBQUMsMEJBQTBCLFdBQVcsK0tBQStLLEVBQUUsK0NBQStDLHFIQUFxSCxpQkFBaUIsNkNBQTZDLDRCQUE0QixJQUFJLFFBQVEsd0JBQXdCLE1BQU0sb0JBQW9CLEdBQUcsNEJBQTRCLDBCQUEwQiwyQkFBMkIsU0FBUyx1SEFBdUgsdUVBQXVFLG1kQUFtZCxjQUFjLGdDQUFnQyxRQUFRLElBQUksQ0FBQyx5QkFBeUIsSUFBSSxxQkFBcUIsSUFBSSxhQUFhLElBQUksYUFBYSxJQUFJLHFCQUFxQixJQUFJLHlCQUF5QixJQUFJLDJCQUEyQixJQUFJLGNBQWMsSUFBSSxvQkFBb0IsSUFBSSxrQkFBa0IsSUFBSSxxQkFBcUIsSUFBSSx1QkFBdUIsSUFBSSxlQUFlLFdBQVcsdUJBQXVCLEVBQUUsc0JBQXNCLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLFFBQVEsT0FBTywrQkFBK0IsV0FBVyx3QkFBd0IseUNBQXlDLHdCQUF3Qix5Q0FBeUMsb0ZBQW9GLFdBQVcsQ0FBQyw0QkFBNEIsV0FBVyw0SkFBNEosZ0NBQWdDLEVBQUUsMEZBQTBGLE9BQU8sb1FBQW9RLDRCQUE0QixJQUFJLGtCQUFrQixTQUFTLDRCQUE0QixFQUFFLHlCQUF5QiwwRUFBMEUsOERBQThELGFBQWEsc0JBQXNCLFVBQVUsT0FBTyxJQUFJLDJDQUEyQyxVQUFVLHlEQUF5RCxJQUFJLGtCQUFrQix5SUFBeUksdUNBQXVDLGdCQUFnQixzRUFBc0UsMkJBQTJCLEdBQUcsU0FBUyxFQUFFLGtCQUFrQixFQUFFLDZDQUE2QywwQkFBMEIsQ0FBQywyQkFBMkIsSUFBSSx1QkFBdUIsSUFBSSxpQkFBaUIsSUFBSSx5QkFBeUIsSUFBSSxxQkFBcUIsSUFBSSxjQUFjLElBQUksWUFBWSxJQUFJLGtCQUFrQixJQUFJLGVBQWUsV0FBVyxtRUFBbUUsRUFBRSx5REFBeUQsK0JBQStCLFFBQVEsdU9BQXVPLDBHQUEwRyxNQUFNLE9BQU8sQ0FBQyxrQkFBa0IsSUFBSSxtQkFBbUIsSUFBSSxjQUFjLElBQUksc0JBQXNCLFdBQVcsOEdBQThHLFlBQVksRUFBRSxNQUFNLG9EQUFvRCxvT0FBb08sU0FBUyxrR0FBa0csc0JBQXNCLDZEQUE2RCxnQkFBZ0IsMkNBQTJDLGtCQUFrQixzQkFBc0Isd0NBQXdDLFNBQVMsYUFBYSxrQkFBa0Isa01BQWtNLGlDQUFpQywyVEFBMlQsa0NBQWtDLGlFQUFpRSwyQkFBMkIsVUFBVSxhQUFhLE1BQU0sYUFBYSx1REFBdUQsc0dBQXNHLE9BQU8sb0JBQW9CLFVBQVUsaUNBQWlDLHFDQUFxQyxvQkFBb0Isd0VBQXdFLGtCQUFrQixhQUFhLGlFQUFpRSxlQUFlLG1CQUFtQiwyREFBMkQsY0FBYyxtQkFBbUIsMERBQTBELCtCQUErQiwrQkFBK0IsV0FBVyxvQ0FBb0Msb0NBQW9DLHdDQUF3QyxXQUFXLE9BQU8sd0VBQXdFLHFCQUFxQixRQUFRLDJCQUEyQiwwSUFBMEksZ0NBQWdDLFFBQVEsSUFBSSxDQUFDLGVBQWUsSUFBSSxxQkFBcUIsSUFBSSxnQkFBZ0IsSUFBSSxjQUFjLFdBQVcseUpBQXlKLEVBQUUsMkJBQTJCLDhEQUE4RCwyREFBMkQsaUJBQWlCLHVHQUF1RyxrQkFBa0IsOEJBQThCLFNBQVMsMkJBQTJCLHVCQUF1Qiw0Q0FBNEMsRUFBRSxrQ0FBa0MseUJBQXlCLHlCQUF5QixpQkFBaUIsd0VBQXdFLGlHQUFpRyxzR0FBc0csU0FBUyxnQkFBZ0IsTUFBTSxvQkFBb0IsSUFBSSxpQkFBaUIsR0FBRyx3QkFBd0IsY0FBYywwQkFBMEIsTUFBTSxxQkFBcUIsV0FBVyxpRkFBaUYsVUFBVSxtQkFBbUIsVUFBVSx5RUFBeUUsdUJBQXVCLFNBQVMsY0FBYyxNQUFNLGFBQWEsZ0lBQWdJLElBQUksbUJBQW1CLElBQUksMkRBQTJELG9CQUFvQiwyREFBMkQsd0JBQXdCLFlBQVksSUFBSSxjQUFjLE1BQU0sMkJBQTJCLFVBQVUsdURBQXVELGtEQUFrRCxXQUFXLDZDQUE2QyxzQkFBc0IsMkNBQTJDLFdBQVcsT0FBTyx5SUFBeUksaUVBQWlFLGlGQUFpRixpQ0FBaUMsUUFBUSxLQUFLLENBQUMsY0FBYyxJQUFJLG1CQUFtQixXQUFXLHFCQUFxQixFQUFFLG9EQUFvRCxRQUFRLGNBQWMsV0FBVyxjQUFjLFNBQVMsRUFBRSwrQkFBK0Isd0RBQXdELDhDQUE4QyxlQUFlLEtBQUssa0JBQWtCLHVDQUF1QywrREFBK0QscUNBQXFDLHlCQUF5Qiw0QkFBNEIsK0dBQStHLHdDQUF3QyxzQ0FBc0Msc0NBQXNDLGdEQUFnRCx1REFBdUQsYUFBYSxrREFBa0Qsc0NBQXNDLHNEQUFzRCx1RUFBdUUsYUFBYSw2QkFBNkIsaUtBQWlLLHlHQUF5RyxtSUFBbUksdUJBQXVCLE1BQU0sa0RBQWtELE1BQU0sbUJBQW1CLDZKQUE2Six3RUFBd0UsbUVBQW1FLDBDQUEwQyxzQ0FBc0MsR0FBRyxDQUFDLGFBQWEsSUFBSSxXQUFXLElBQUksbUJBQW1CLFdBQVcsaUNBQWlDLEVBQUUscUZBQXFGLHlCQUF5Qiw4Q0FBOEMsOElBQThJLGlDQUFpQyxHQUFHLDJDQUEyQyxFQUFFLHdFQUF3RSwyTkFBMk4sR0FBRyxrQ0FBa0MsMkpBQTJKLHdEQUF3RCx3REFBd0Qsd0RBQXdELHdEQUF3RCx3REFBd0Qsd0RBQXdELHdEQUF3RCx3REFBd0Qsd0RBQXdELDJCQUEyQiw4QkFBOEIsR0FBRyxpQ0FBaUMsbU1BQW1NLEdBQUcsMkVBQTJFLHlDQUF5QyxtRkFBbUYsMkRBQTJELDRCQUE0Qiw4QkFBOEIsa0NBQWtDLEdBQUcsNEVBQTRFLHlFQUF5RSxHQUFHLCtFQUErRSwrREFBK0Qsb0NBQW9DLEVBQUUsRUFBRSx5QkFBeUIsZ0JBQWdCLDJCQUEyQixxQkFBcUIsa0RBQWtELE1BQU0sSUFBSSxPQUFPLHFDQUFxQyxFQUFFLG1EQUFtRCxxRUFBcUUsNEJBQTRCLGlDQUFpQyxtQkFBbUIsT0FBTyxVQUFVLEtBQUssc0RBQXNELHdDQUF3QyxLQUFLLGdCQUFnQixHQUFHLGlIQUFpSCwrREFBK0Qsd0JBQXdCLGNBQWMsaUNBQWlDLDRCQUE0QixpREFBaUQsTUFBTSxJQUFJLE1BQU0seUNBQXlDLEVBQUUscUJBQXFCLDJEQUEyRCxFQUFFLEdBQUcsNEZBQTRGLFVBQVUsS0FBSyx1REFBdUQsRUFBRSxHQUFHLEdBQUcsbURBQW1ELHdCQUF3QixnQ0FBZ0Msb0dBQW9HLHlFQUF5RSxrQ0FBa0MsaUJBQWlCLEtBQUssbUVBQW1FLDhFQUE4RSxHQUFHLElBQUkseUJBQXlCLHNGQUFzRixxREFBcUQsbURBQW1ELGdCQUFnQixDQUFDLGdCQUFnQixJQUFJLGNBQWMsSUFBSSxhQUFhLFdBQVcseUVBQXlFLEVBQUUsVUFBVSxpQkFBaUIsRUFBRSxtR0FBbUcscUJBQXFCLEdBQUcscUlBQXFJLHVCQUF1QixxQ0FBcUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxPQUFPLDBQQUEwUCxHQUFHLENBQUMsaUJBQWlCLElBQUksdUJBQXVCLGFBQWEsNERBQTRELENBQUMsc0JBQXNCLElBQUksYUFBYSxXQUFXLHdIQUF3SCxFQUFFLG9CQUFvQixxQ0FBcUMsa0JBQWtCLGdCQUFnQixrQ0FBa0Msb1ZBQW9WLDJCQUEyQix5QkFBeUIsU0FBUyw2QkFBNkIsTUFBTSwwQ0FBMEMsR0FBRyxHQUFHLHlDQUF5Qyx5Q0FBeUMsTUFBTSx1RUFBdUUsY0FBYywrQkFBK0IsZ0pBQWdKLGdDQUFnQywyREFBMkQsZ0NBQWdDLDZDQUE2Qyx3QkFBd0Isd0JBQXdCLGlDQUFpQyxJQUFJLGdDQUFnQywrQkFBK0Isd0JBQXdCLGtDQUFrQyx1QkFBdUIsc0NBQXNDLDREQUE0RCx3QkFBd0IsK1BBQStQLDhCQUE4QixDQUFDLGFBQWEsSUFBSSxhQUFhLFdBQVcsbUNBQW1DLEVBQUUsMkJBQTJCLHdCQUF3QiwrQkFBK0IsWUFBWSxtQ0FBbUMsT0FBTyx5QkFBeUIseUJBQXlCLE1BQU0sb0NBQW9DLG9HQUFvRyx1RUFBdUUsV0FBVyx3Q0FBd0Msa0JBQWtCLENBQUMsZUFBZSxXQUFXLDBCQUEwQixFQUFFLGdEQUFnRCx1QkFBdUIsS0FBSyxFQUFFLG1CQUFtQixPQUFPLHlCQUF5QixNQUFNLG9DQUFvQywyRkFBMkYsMkNBQTJDLFdBQVcsb0NBQW9DLGdCQUFnQixDQUFDLFdBQVcsSUFBSSxtQkFBbUIsSUFBSSxZQUFZLElBQUksY0FBYyxJQUFJLGFBQWEsSUFBSSxpQkFBaUIsSUFBSSx5QkFBeUIsSUFBSSxhQUFhLElBQUkseUJBQXlCLElBQUksWUFBWSxJQUFJLFlBQVksR0FBRywwQ0FBMEMsSUFBSSxRQUFRLHdCQUF3QixlQUFlLHlFQUF5RSwrQ0FBK0MsTUFBTSw4QkFBOEIsdUNBQXVDLCtFQUErRSx5Q0FBeUMseUJBQXlCLE1BQU0sbUVBQW1FLDZFQUE2RSxxREFBcUQsNEJBQTRCLHVCQUF1QixNQUFNLFFBQVEscUJBQXFCLE9BQU8scUZBQXFGLEdBQUcsQ0FBQyxpQkFBaUIsV0FBVyxnQkFBZ0IsRUFBRSx1Q0FBdUMsV0FBVywyQkFBMkIsQ0FBQywyQkFBMkIsSUFBSSx5QkFBeUIsSUFBSSw0QkFBNEIsSUFBSSx5QkFBeUIsTUFBTSxJQUFJLHVDQUF1QyxpRUFBaUUsU0FBUyxVQUFVLENBQUMsa0JBQWtCLGVBQWUseURBQXlELDJRQUEyUSxrRUFBa0UsSUFBSSxDQUFDLHNCQUFzQixJQUFJLHFCQUFxQixlQUFlLGtFQUFrRSxVQUFVLDBEQUEwRCx3QkFBd0IscUVBQXFFLEdBQUcsbUJBQW1CLG9CQUFvQixXQUFXLHFEQUFxRCxvQkFBb0IscUZBQXFGLGlCQUFpQixLQUFLLDBEQUEwRCxPQUFPLDBEQUEwRCxrQkFBa0IsV0FBVyxZQUFZLHlEQUF5RCx3QkFBd0IsSUFBSSxTQUFTLENBQUMsaUJBQWlCLG1CQUFtQiw0RUFBNEUsc0RBQXNELENBQUMsY0FBYyxlQUFlLEdBQUcsd0ZBQXdGLG1CQUFtQixjQUFjLHVDQUF1QywyQkFBMkIsbUhBQW1ILHNDQUFzQyx5QkFBeUIsQ0FBQyxpQkFBaUIsSUFBSSwwQkFBMEIsMkNBQTJDLDJCQUEyQiwwQ0FBMEMsSUFBSSxnQkFBZ0Isa0JBQWtCLEVBQUUsMENBQTBDLHlDQUF5Qyw4REFBOEQsUUFBUSx3QkFBd0IsUUFBUSxpREFBaUQsTUFBTSx3REFBd0QsNEJBQTRCLEdBQUcsUUFBUSw2TEFBNkwsc0VBQXNFLGFBQWEsR0FBRyx3RkFBd0Ysb0VBQW9FLGFBQWEsR0FBRyxhQUFhLEVBQUUsc0hBQXNILGtEQUFrRCwrQkFBK0IseUJBQXlCLFNBQVMsQ0FBQyxpQkFBaUIsZUFBZSx3REFBd0Qsd0JBQXdCLDZCQUE2QixnQkFBZ0IscURBQXFELHNEQUFzRCxXQUFXLEdBQUcsU0FBUyxDQUFDLHdCQUF3QixnQkFBZ0IscUJBQXFCLDhEQUE4RCxXQUFXLHVEQUF1RCw4QkFBOEIsV0FBVyxDQUFDLHFCQUFxQixJQUFJLHNCQUFzQixJQUFJLGlCQUFpQixrREFBa0Qsa0JBQWtCLGtDQUFrQyxrQkFBa0IsT0FBTyxDQUFDLHNCQUFzQixXQUFXLHdCQUF3QixHQUFHLEVBQUUseUNBQXlDLGlCQUFpQiw2REFBNkQsZ0NBQWdDLDBEQUEwRCxnQkFBZ0IsU0FBUyxRQUFRLGtCQUFrQix1QkFBdUIsdUdBQXVHLGtCQUFrQixDQUFDLG9CQUFvQixzREFBc0Qsc0JBQXNCLElBQUksY0FBYyxJQUFJLGNBQWMsSUFBSSx1QkFBdUIsSUFBSSx5QkFBeUIsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJLHVCQUF1QixJQUFJLGlCQUFpQixJQUFJLG9CQUFvQixJQUFJLGVBQWUsSUFBSSwyQkFBMkIsYUFBYSw4QkFBOEIsb0JBQW9CLENBQUMsZUFBZSxrQkFBa0IsT0FBTywyS0FBMkssQ0FBQyx3QkFBd0Isd0JBQXdCLGdNQUFnTSwwRUFBMEUsRUFBRSxZQUFZLFVBQVUsc0JBQXNCLHdCQUF3Qix3QkFBd0Isd0JBQXdCLGtCQUFrQixJQUFJLGtHQUFrRyxFQUFFLEdBQUcsRUFBRSxFQUFFLG9CQUFvQixDQUFDLGlCQUFpQixJQUFJLHdCQUF3QixrQkFBa0IsSUFBSSxNQUFNLDZDQUE2QyxxU0FBcVMsUUFBUSxZQUFZLCtCQUErQix5SEFBeUgscUJBQXFCLENBQUMsNkJBQTZCLFdBQVcsZ0RBQWdELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFFLHdCQUF3Qix3RkFBd0YseURBQXlELENBQUMsbUJBQW1CLEdBQUcsaUJBQWlCLElBQUksaUJBQWlCLFlBQVksd0JBQXdCLENBQUMseUJBQXlCLElBQUksa0JBQWtCLElBQUksZ0JBQWdCLElBQUksdUJBQXVCLGNBQWMsRUFBRSxNQUFNLHlGQUF5RixvREFBb0Qsb0JBQW9CLFlBQVksR0FBRyxpREFBaUQsb0JBQW9CLENBQUMsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9pbmRleC5janMuanM/Y2ZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgZT1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpLHQ9cmVxdWlyZShcInJlYWN0XCIpLHI9cmVxdWlyZShcInJlYWN0LWRvbS9jbGllbnRcIiksbj1yZXF1aXJlKFwidGhyZWVcIiksYT1yZXF1aXJlKFwiQHJlYWN0LXRocmVlL2ZpYmVyXCIpLG89cmVxdWlyZShcInp1c3RhbmRcIiksaT1yZXF1aXJlKFwicmVhY3QtbWVyZ2UtcmVmc1wiKSxzPXJlcXVpcmUoXCJtYWF0aFwiKSxsPXJlcXVpcmUoXCJAcmVhY3Qtc3ByaW5nL3RocmVlXCIpLGM9cmVxdWlyZShcIkB1c2UtZ2VzdHVyZS9yZWFjdFwiKSx1PXJlcXVpcmUoXCJ6dXN0YW5kL21pZGRsZXdhcmVcIiksZD1yZXF1aXJlKFwidGhyZWUtc3RkbGliXCIpLG09cmVxdWlyZShcInp1c3RhbmQvc2hhbGxvd1wiKSxmPXJlcXVpcmUoXCJzdXNwZW5kLXJlYWN0XCIpLHA9cmVxdWlyZShcIm1lc2hsaW5lXCIpLGg9cmVxdWlyZShcImxvZGFzaC5waWNrXCIpLHg9cmVxdWlyZShcImxvZGFzaC5vbWl0XCIpLHk9cmVxdWlyZShcImNhbWVyYS1jb250cm9sc1wiKSx2PXJlcXVpcmUoXCJzdGF0cy5qc1wiKSxnPXJlcXVpcmUoXCJzdGF0cy1nbFwiKSx6PXJlcXVpcmUoXCJkZXRlY3QtZ3B1XCIpLHc9cmVxdWlyZShcInRocmVlLW1lc2gtYnZoXCIpLGI9cmVxdWlyZShcInV1aWRcIiksTT1yZXF1aXJlKFwicmVhY3QtY29tcG9zZXJcIiksRT1yZXF1aXJlKFwibG9kYXNoLmNsYW1wXCIpO2Z1bmN0aW9uIFMoZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBUKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBlJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbihyKXtpZihcImRlZmF1bHRcIiE9PXIpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLG4uZ2V0P246e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGVbcl19fSl9fSkpLHQuZGVmYXVsdD1lLE9iamVjdC5mcmVlemUodCl9dmFyIEM9UyhlKSxQPVQodCksUj1UKHIpLEQ9VChuKSxGPVMobyksaz1TKGkpLF89UyhtKSxBPVMoaCksTD1TKHgpLEI9Uyh5KSxVPVModiksST1TKGcpLFY9UyhNKSxPPVMoRSk7Y29uc3QgTj1uZXcgbi5WZWN0b3IzLGo9bmV3IG4uVmVjdG9yMyxXPW5ldyBuLlZlY3RvcjM7ZnVuY3Rpb24gRyhlLHQscil7Y29uc3Qgbj1OLnNldEZyb21NYXRyaXhQb3NpdGlvbihlLm1hdHJpeFdvcmxkKTtuLnByb2plY3QodCk7Y29uc3QgYT1yLndpZHRoLzIsbz1yLmhlaWdodC8yO3JldHVybltuLngqYSthLC1uLnkqbytvXX1jb25zdCBIPWU9Pk1hdGguYWJzKGUpPDFlLTEwPzA6ZTtmdW5jdGlvbiAkKGUsdCxyPVwiXCIpe2xldCBuPVwibWF0cml4M2QoXCI7Zm9yKGxldCByPTA7MTYhPT1yO3IrKyluKz1IKHRbcl0qZS5lbGVtZW50c1tyXSkrKDE1IT09cj9cIixcIjpcIilcIik7cmV0dXJuIHIrbn1jb25zdCBxPShYPVsxLC0xLDEsMSwxLC0xLDEsMSwxLC0xLDEsMSwxLC0xLDEsMV0sZT0+JChlLFgpKTt2YXIgWDtjb25zdCBaPShlLHQpPT57cmV0dXJuICQoZSxbMS8ocj10KSwxL3IsMS9yLDEsLTEvciwtMS9yLC0xL3IsLTEsMS9yLDEvciwxL3IsMSwxLDEsMSwxXSxcInRyYW5zbGF0ZSgtNTAlLC01MCUpXCIpO3ZhciByfTtjb25zdCBZPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLGVwczp0PS4wMDEsc3R5bGU6cixjbGFzc05hbWU6byxwcmVwZW5kOmksY2VudGVyOnMsZnVsbHNjcmVlbjpsLHBvcnRhbDpjLGRpc3RhbmNlRmFjdG9yOnUsc3ByaXRlOmQ9ITEsdHJhbnNmb3JtOm09ITEsb2NjbHVkZTpmLG9uT2NjbHVkZTpwLGNhc3RTaGFkb3c6aCxyZWNlaXZlU2hhZG93OngsbWF0ZXJpYWw6eSxnZW9tZXRyeTp2LHpJbmRleFJhbmdlOmc9WzE2Nzc3MjcxLDBdLGNhbGN1bGF0ZVBvc2l0aW9uOno9Ryxhczp3PVwiZGl2XCIsd3JhcHBlckNsYXNzOmIscG9pbnRlckV2ZW50czpNPVwiYXV0b1wiLC4uLkV9LFMpPT57Y29uc3R7Z2w6VCxjYW1lcmE6RCxzY2VuZTpGLHNpemU6ayxyYXljYXN0ZXI6XyxldmVudHM6QSx2aWV3cG9ydDpMfT1hLnVzZVRocmVlKCksW0JdPVAudXNlU3RhdGUoKCgpPT5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHcpKSksVT1QLnVzZVJlZigpLEk9UC51c2VSZWYobnVsbCksVj1QLnVzZVJlZigwKSxPPVAudXNlUmVmKFswLDBdKSwkPVAudXNlUmVmKG51bGwpLFg9UC51c2VSZWYobnVsbCksWT0obnVsbD09Yz92b2lkIDA6Yy5jdXJyZW50KXx8QS5jb25uZWN0ZWR8fFQuZG9tRWxlbWVudC5wYXJlbnROb2RlLFE9UC51c2VSZWYobnVsbCksSz1QLnVzZVJlZighMSksSj1QLnVzZU1lbW8oKCgpPT5mJiZcImJsZW5kaW5nXCIhPT1mfHxBcnJheS5pc0FycmF5KGYpJiZmLmxlbmd0aCYmZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImN1cnJlbnRcImluIGV9KGZbMF0pKSxbZl0pO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IGU9VC5kb21FbGVtZW50O2YmJlwiYmxlbmRpbmdcIj09PWY/KGUuc3R5bGUuekluZGV4PWAke01hdGguZmxvb3IoZ1swXS8yKX1gLGUuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGUuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIik6KGUuc3R5bGUuekluZGV4PW51bGwsZS5zdHlsZS5wb3NpdGlvbj1udWxsLGUuc3R5bGUucG9pbnRlckV2ZW50cz1udWxsKX0pLFtmXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYoSS5jdXJyZW50KXtjb25zdCBlPVUuY3VycmVudD1SLmNyZWF0ZVJvb3QoQik7aWYoRi51cGRhdGVNYXRyaXhXb3JsZCgpLG0pQi5zdHlsZS5jc3NUZXh0PVwicG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3BvaW50ZXItZXZlbnRzOm5vbmU7b3ZlcmZsb3c6aGlkZGVuO1wiO2Vsc2V7Y29uc3QgZT16KEkuY3VycmVudCxELGspO0Iuc3R5bGUuY3NzVGV4dD1gcG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgke2VbMF19cHgsJHtlWzFdfXB4LDApO3RyYW5zZm9ybS1vcmlnaW46MCAwO2B9cmV0dXJuIFkmJihpP1kucHJlcGVuZChCKTpZLmFwcGVuZENoaWxkKEIpKSwoKT0+e1kmJlkucmVtb3ZlQ2hpbGQoQiksZS51bm1vdW50KCl9fX0pLFtZLG1dKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9PntiJiYoQi5jbGFzc05hbWU9Yil9KSxbYl0pO2NvbnN0IGVlPVAudXNlTWVtbygoKCk9Pm0/e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsd2lkdGg6ay53aWR0aCxoZWlnaHQ6ay5oZWlnaHQsdHJhbnNmb3JtU3R5bGU6XCJwcmVzZXJ2ZS0zZFwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9Ontwb3NpdGlvbjpcImFic29sdXRlXCIsdHJhbnNmb3JtOnM/XCJ0cmFuc2xhdGUzZCgtNTAlLC01MCUsMClcIjpcIm5vbmVcIiwuLi5sJiZ7dG9wOi1rLmhlaWdodC8yLGxlZnQ6LWsud2lkdGgvMix3aWR0aDprLndpZHRoLGhlaWdodDprLmhlaWdodH0sLi4ucn0pLFtyLHMsbCxrLG1dKSx0ZT1QLnVzZU1lbW8oKCgpPT4oe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixwb2ludGVyRXZlbnRzOk19KSksW01dKTtQLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt2YXIgdCxuOyhLLmN1cnJlbnQ9ITEsbSk/bnVsbD09KHQ9VS5jdXJyZW50KXx8dC5yZW5kZXIoUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjokLHN0eWxlOmVlfSxQLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOlgsc3R5bGU6dGV9LFAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6UyxjbGFzc05hbWU6byxzdHlsZTpyLGNoaWxkcmVuOmV9KSkpKTpudWxsPT0obj1VLmN1cnJlbnQpfHxuLnJlbmRlcihQLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7cmVmOlMsc3R5bGU6ZWUsY2xhc3NOYW1lOm8sY2hpbGRyZW46ZX0pKX0pKTtjb25zdCByZT1QLnVzZVJlZighMCk7YS51c2VGcmFtZSgoZT0+e2lmKEkuY3VycmVudCl7RC51cGRhdGVNYXRyaXhXb3JsZCgpLEkuY3VycmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSk7Y29uc3QgZT1tP08uY3VycmVudDp6KEkuY3VycmVudCxELGspO2lmKG18fE1hdGguYWJzKFYuY3VycmVudC1ELnpvb20pPnR8fE1hdGguYWJzKE8uY3VycmVudFswXS1lWzBdKT50fHxNYXRoLmFicyhPLmN1cnJlbnRbMV0tZVsxXSk+dCl7Y29uc3QgdD1mdW5jdGlvbihlLHQpe2NvbnN0IHI9Ti5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksbj1qLnNldEZyb21NYXRyaXhQb3NpdGlvbih0Lm1hdHJpeFdvcmxkKSxhPXIuc3ViKG4pLG89dC5nZXRXb3JsZERpcmVjdGlvbihXKTtyZXR1cm4gYS5hbmdsZVRvKG8pPk1hdGguUEkvMn0oSS5jdXJyZW50LEQpO2xldCByPSExO0omJihBcnJheS5pc0FycmF5KGYpP3I9Zi5tYXAoKGU9PmUuY3VycmVudCkpOlwiYmxlbmRpbmdcIiE9PWYmJihyPVtGXSkpO2NvbnN0IGE9cmUuY3VycmVudDtpZihyKXtjb25zdCBlPWZ1bmN0aW9uKGUsdCxyLG4pe2NvbnN0IGE9Ti5zZXRGcm9tTWF0cml4UG9zaXRpb24oZS5tYXRyaXhXb3JsZCksbz1hLmNsb25lKCk7by5wcm9qZWN0KHQpLHIuc2V0RnJvbUNhbWVyYShvLHQpO2NvbnN0IGk9ci5pbnRlcnNlY3RPYmplY3RzKG4sITApO2lmKGkubGVuZ3RoKXtjb25zdCBlPWlbMF0uZGlzdGFuY2U7cmV0dXJuIGEuZGlzdGFuY2VUbyhyLnJheS5vcmlnaW4pPGV9cmV0dXJuITB9KEkuY3VycmVudCxELF8scik7cmUuY3VycmVudD1lJiYhdH1lbHNlIHJlLmN1cnJlbnQ9IXQ7YSE9PXJlLmN1cnJlbnQmJihwP3AoIXJlLmN1cnJlbnQpOkIuc3R5bGUuZGlzcGxheT1yZS5jdXJyZW50P1wiYmxvY2tcIjpcIm5vbmVcIik7Y29uc3Qgbz1NYXRoLmZsb29yKGdbMF0vMiksaT1mP0o/W2dbMF0sb106W28tMSwwXTpnO2lmKEIuc3R5bGUuekluZGV4PWAke2Z1bmN0aW9uKGUsdCxyKXtpZih0IGluc3RhbmNlb2Ygbi5QZXJzcGVjdGl2ZUNhbWVyYXx8dCBpbnN0YW5jZW9mIG4uT3J0aG9ncmFwaGljQ2FtZXJhKXtjb25zdCBuPU4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGUubWF0cml4V29ybGQpLGE9ai5zZXRGcm9tTWF0cml4UG9zaXRpb24odC5tYXRyaXhXb3JsZCksbz1uLmRpc3RhbmNlVG8oYSksaT0oclsxXS1yWzBdKS8odC5mYXItdC5uZWFyKSxzPXJbMV0taSp0LmZhcjtyZXR1cm4gTWF0aC5yb3VuZChpKm8rcyl9fShJLmN1cnJlbnQsRCxpKX1gLG0pe2NvbnN0W2UsdF09W2sud2lkdGgvMixrLmhlaWdodC8yXSxyPUQucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s1XSp0LHtpc09ydGhvZ3JhcGhpY0NhbWVyYTpuLHRvcDphLGxlZnQ6byxib3R0b206aSxyaWdodDpzfT1ELGw9cShELm1hdHJpeFdvcmxkSW52ZXJzZSksYz1uP2BzY2FsZSgke3J9KXRyYW5zbGF0ZSgke0goLShzK28pLzIpfXB4LCR7SCgoYStpKS8yKX1weClgOmB0cmFuc2xhdGVaKCR7cn1weClgO2xldCBtPUkuY3VycmVudC5tYXRyaXhXb3JsZDtkJiYobT1ELm1hdHJpeFdvcmxkSW52ZXJzZS5jbG9uZSgpLnRyYW5zcG9zZSgpLmNvcHlQb3NpdGlvbihtKS5zY2FsZShJLmN1cnJlbnQuc2NhbGUpLG0uZWxlbWVudHNbM109bS5lbGVtZW50c1s3XT1tLmVsZW1lbnRzWzExXT0wLG0uZWxlbWVudHNbMTVdPTEpLEIuc3R5bGUud2lkdGg9ay53aWR0aCtcInB4XCIsQi5zdHlsZS5oZWlnaHQ9ay5oZWlnaHQrXCJweFwiLEIuc3R5bGUucGVyc3BlY3RpdmU9bj9cIlwiOmAke3J9cHhgLCQuY3VycmVudCYmWC5jdXJyZW50JiYoJC5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybT1gJHtjfSR7bH10cmFuc2xhdGUoJHtlfXB4LCR7dH1weClgLFguY3VycmVudC5zdHlsZS50cmFuc2Zvcm09WihtLDEvKCh1fHwxMCkvNDAwKSkpfWVsc2V7Y29uc3QgdD12b2lkIDA9PT11PzE6ZnVuY3Rpb24oZSx0KXtpZih0IGluc3RhbmNlb2Ygbi5PcnRob2dyYXBoaWNDYW1lcmEpcmV0dXJuIHQuem9vbTtpZih0IGluc3RhbmNlb2Ygbi5QZXJzcGVjdGl2ZUNhbWVyYSl7Y29uc3Qgcj1OLnNldEZyb21NYXRyaXhQb3NpdGlvbihlLm1hdHJpeFdvcmxkKSxuPWouc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQubWF0cml4V29ybGQpLGE9dC5mb3YqTWF0aC5QSS8xODAsbz1yLmRpc3RhbmNlVG8obik7cmV0dXJuIDEvKDIqTWF0aC50YW4oYS8yKSpvKX1yZXR1cm4gMX0oSS5jdXJyZW50LEQpKnU7Qi5zdHlsZS50cmFuc2Zvcm09YHRyYW5zbGF0ZTNkKCR7ZVswXX1weCwke2VbMV19cHgsMCkgc2NhbGUoJHt0fSlgfU8uY3VycmVudD1lLFYuY3VycmVudD1ELnpvb219fWlmKCFKJiZRLmN1cnJlbnQmJiFLLmN1cnJlbnQpaWYobSl7aWYoJC5jdXJyZW50KXtjb25zdCBlPSQuY3VycmVudC5jaGlsZHJlblswXTtpZihudWxsIT1lJiZlLmNsaWVudFdpZHRoJiZudWxsIT1lJiZlLmNsaWVudEhlaWdodCl7Y29uc3R7aXNPcnRob2dyYXBoaWNDYW1lcmE6dH09RDtpZih0fHx2KUUuc2NhbGUmJihBcnJheS5pc0FycmF5KEUuc2NhbGUpP0Uuc2NhbGUgaW5zdGFuY2VvZiBuLlZlY3RvcjM/US5jdXJyZW50LnNjYWxlLmNvcHkoRS5zY2FsZS5jbG9uZSgpLmRpdmlkZVNjYWxhcigxKSk6US5jdXJyZW50LnNjYWxlLnNldCgxL0Uuc2NhbGVbMF0sMS9FLnNjYWxlWzFdLDEvRS5zY2FsZVsyXSk6US5jdXJyZW50LnNjYWxlLnNldFNjYWxhcigxL0Uuc2NhbGUpKTtlbHNle2NvbnN0IHQ9KHV8fDEwKS80MDAscj1lLmNsaWVudFdpZHRoKnQsbj1lLmNsaWVudEhlaWdodCp0O1EuY3VycmVudC5zY2FsZS5zZXQocixuLDEpfUsuY3VycmVudD0hMH19fWVsc2V7Y29uc3QgdD1CLmNoaWxkcmVuWzBdO2lmKG51bGwhPXQmJnQuY2xpZW50V2lkdGgmJm51bGwhPXQmJnQuY2xpZW50SGVpZ2h0KXtjb25zdCBlPTEvTC5mYWN0b3Iscj10LmNsaWVudFdpZHRoKmUsbj10LmNsaWVudEhlaWdodCplO1EuY3VycmVudC5zY2FsZS5zZXQocixuLDEpLEsuY3VycmVudD0hMH1RLmN1cnJlbnQubG9va0F0KGUuY2FtZXJhLnBvc2l0aW9uKX19KSk7Y29uc3QgbmU9UC51c2VNZW1vKCgoKT0+KHt2ZXJ0ZXhTaGFkZXI6bT92b2lkIDA6J1xcbiAgICAgICAgICAvKlxcbiAgICAgICAgICAgIFRoaXMgc2hhZGVyIGlzIGZyb20gdGhlIFRIUkVFXFwncyBTcHJpdGVNYXRlcmlhbC5cXG4gICAgICAgICAgICBXZSBuZWVkIHRvIHR1cm4gdGhlIGJhY2tpbmcgcGxhbmUgaW50byBhIFNwcml0ZVxcbiAgICAgICAgICAgIChtYWtlIGl0IGFsd2F5cyBmYWNlIHRoZSBjYW1lcmEpIGlmIFwidHJhbnNmcm9tXCIgXFxuICAgICAgICAgICAgaXMgZmFsc2UuIFxcbiAgICAgICAgICAqL1xcbiAgICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxcblxcbiAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuLCAxLik7XFxuICAgICAgICAgICAgZmxvYXQgcm90YXRpb24gPSAwLjA7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBzb21ld2hhdCBhcmJpdHJhcnksIGJ1dCBpdCBzZWVtcyB0byB3b3JrIHdlbGxcXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRlcml2ZSB0aGlzIGR5bmFtaWNhbGx5IGlmIGl0IGV2ZW4gbWF0dGVyc1xcbiAgICAgICAgICAgIGZsb2F0IHNpemUgPSAwLjAzO1xcblxcbiAgICAgICAgICAgIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcbiAgICAgICAgICAgIHZlYzIgc2NhbGU7XFxuICAgICAgICAgICAgc2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54LCBtb2RlbE1hdHJpeFsgMCBdLnksIG1vZGVsTWF0cml4WyAwIF0ueiApICk7XFxuICAgICAgICAgICAgc2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54LCBtb2RlbE1hdHJpeFsgMSBdLnksIG1vZGVsTWF0cml4WyAxIF0ueiApICk7XFxuXFxuICAgICAgICAgICAgYm9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xcbiAgICAgICAgICAgIGlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56O1xcblxcbiAgICAgICAgICAgIHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGUgKiBzaXplO1xcbiAgICAgICAgICAgIHZlYzIgcm90YXRlZFBvc2l0aW9uO1xcbiAgICAgICAgICAgIHJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG4gICAgICAgICAgICByb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxuICAgICAgICAgICAgbXZQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247XFxuXFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG4gICAgICAgICAgfVxcbiAgICAgICcsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgICAgfVxcbiAgICAgIFwifSkpLFttXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHt9LEUse3JlZjpJfSksZiYmIUomJlAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7Y2FzdFNoYWRvdzpoLHJlY2VpdmVTaGFkb3c6eCxyZWY6UX0sdnx8UC5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLG51bGwpLHl8fFAuY3JlYXRlRWxlbWVudChcInNoYWRlck1hdGVyaWFsXCIse3NpZGU6bi5Eb3VibGVTaWRlLHZlcnRleFNoYWRlcjpuZS52ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXI6bmUuZnJhZ21lbnRTaGFkZXJ9KSkpfSkpO2xldCBRPTA7Y29uc3QgSz1GLmRlZmF1bHQoKGU9PihuLkRlZmF1bHRMb2FkaW5nTWFuYWdlci5vblN0YXJ0PSh0LHIsbik9PntlKHthY3RpdmU6ITAsaXRlbTp0LGxvYWRlZDpyLHRvdGFsOm4scHJvZ3Jlc3M6KHItUSkvKG4tUSkqMTAwfSl9LG4uRGVmYXVsdExvYWRpbmdNYW5hZ2VyLm9uTG9hZD0oKT0+e2Uoe2FjdGl2ZTohMX0pfSxuLkRlZmF1bHRMb2FkaW5nTWFuYWdlci5vbkVycm9yPXQ9PmUoKGU9Pih7ZXJyb3JzOlsuLi5lLmVycm9ycyx0XX0pKSksbi5EZWZhdWx0TG9hZGluZ01hbmFnZXIub25Qcm9ncmVzcz0odCxyLG4pPT57cj09PW4mJihRPW4pLGUoe2FjdGl2ZTohMCxpdGVtOnQsbG9hZGVkOnIsdG90YWw6bixwcm9ncmVzczooci1RKS8obi1RKSoxMDB8fDEwMH0pfSx7ZXJyb3JzOltdLGFjdGl2ZTohMSxwcm9ncmVzczowLGl0ZW06XCJcIixsb2FkZWQ6MCx0b3RhbDowfSkpKSxKPWU9PmBMb2FkaW5nICR7ZS50b0ZpeGVkKDIpfSVgO2NvbnN0IGVlPXtjb250YWluZXI6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6MCxsZWZ0OjAsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwiLGJhY2tncm91bmQ6XCIjMTcxNzE3XCIsZGlzcGxheTpcImZsZXhcIixhbGlnbkl0ZW1zOlwiY2VudGVyXCIsanVzdGlmeUNvbnRlbnQ6XCJjZW50ZXJcIix0cmFuc2l0aW9uOlwib3BhY2l0eSAzMDBtcyBlYXNlXCIsekluZGV4OjFlM30saW5uZXI6e3dpZHRoOjEwMCxoZWlnaHQ6MyxiYWNrZ3JvdW5kOlwiIzI3MjcyN1wiLHRleHRBbGlnbjpcImNlbnRlclwifSxiYXI6e2hlaWdodDozLHdpZHRoOlwiMTAwJVwiLGJhY2tncm91bmQ6XCJ3aGl0ZVwiLHRyYW5zaXRpb246XCJ0cmFuc2Zvcm0gMjAwbXNcIix0cmFuc2Zvcm1PcmlnaW46XCJsZWZ0IGNlbnRlclwifSxkYXRhOntkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCIscG9zaXRpb246XCJyZWxhdGl2ZVwiLGZvbnRWYXJpYW50TnVtZXJpYzpcInRhYnVsYXItbnVtc1wiLG1hcmdpblRvcDpcIjAuOGVtXCIsY29sb3I6XCIjZjBmMGYwXCIsZm9udFNpemU6XCIwLjZlbVwiLGZvbnRGYW1pbHk6Jy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXCJJbnRlclwiLCBcIlNlZ29lIFVJXCIsIFwiSGVsdmV0aWNhIE5ldWVcIiwgSGVsdmV0aWNhLCBBcmlhbCwgUm9ib3RvLCBVYnVudHUsIHNhbnMtc2VyaWYsIFwiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiJyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9fSx0ZT1QLmNyZWF0ZUNvbnRleHQobnVsbCk7ZnVuY3Rpb24gcmUoKXtyZXR1cm4gUC51c2VDb250ZXh0KHRlKX1jb25zdCBuZT1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZX0sdCk9Pntjb25zdCByPVAudXNlUmVmKG51bGwpLG49cmUoKSx7d2lkdGg6byxoZWlnaHQ6aX09YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydCkpO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3IuY3VycmVudC5wb3NpdGlvbi54PW4uaG9yaXpvbnRhbD8tbyoobi5wYWdlcy0xKSpuLm9mZnNldDowLHIuY3VycmVudC5wb3NpdGlvbi55PW4uaG9yaXpvbnRhbD8wOmkqKG4ucGFnZXMtMSkqbi5vZmZzZXR9KSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOmsuZGVmYXVsdChbdCxyXSl9LGUpfSkpLGFlPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHN0eWxlOnQsLi4ucn0sbik9Pntjb25zdCBvPXJlKCksaT1QLnVzZVJlZihudWxsKSx7d2lkdGg6cyxoZWlnaHQ6bH09YS51c2VUaHJlZSgoZT0+ZS5zaXplKSksYz1QLnVzZUNvbnRleHQoYS5jb250ZXh0KSx1PVAudXNlTWVtbygoKCk9PlIuY3JlYXRlUm9vdChvLmZpeGVkKSksW28uZml4ZWRdKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntvLmRlbHRhPm8uZXBzJiYoaS5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybT1gdHJhbnNsYXRlM2QoJHtvLmhvcml6b250YWw/LXMqKG8ucGFnZXMtMSkqby5vZmZzZXQ6MH1weCwke28uaG9yaXpvbnRhbD8wOmwqKG8ucGFnZXMtMSkqLW8ub2Zmc2V0fXB4LDApYCl9KSksdS5yZW5kZXIoUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsQy5kZWZhdWx0KHtyZWY6ay5kZWZhdWx0KFtuLGldKSxzdHlsZTp7Li4udCxwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOjAsbGVmdDowLHdpbGxDaGFuZ2U6XCJ0cmFuc2Zvcm1cIn19LHIpLFAuY3JlYXRlRWxlbWVudCh0ZS5Qcm92aWRlcix7dmFsdWU6b30sUC5jcmVhdGVFbGVtZW50KGEuY29udGV4dC5Qcm92aWRlcix7dmFsdWU6Y30sZSkpKSksbnVsbH0pKSxvZT1QLmZvcndhcmRSZWYoKCh7aHRtbDplLC4uLnR9LHIpPT57Y29uc3Qgbj1lP2FlOm5lO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQobixDLmRlZmF1bHQoe3JlZjpyfSx0KSl9KSk7Y29uc3QgaWU9UC5jcmVhdGVDb250ZXh0KG51bGwpO2NvbnN0IHNlPVAuY3JlYXRlQ29udGV4dChbXSk7Y29uc3QgbGU9UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7Y2hpbGRyZW46ZSxmb2xsb3c6dD0hMCxsb2NrWDpyPSExLGxvY2tZOm89ITEsbG9ja1o6aT0hMSwuLi5zfSxsKXtjb25zdCBjPVAudXNlUmVmKG51bGwpLHU9UC51c2VSZWYobnVsbCksZD1uZXcgbi5RdWF0ZXJuaW9uO3JldHVybiBhLnVzZUZyYW1lKCgoe2NhbWVyYTplfSk9PntpZighdHx8IXUuY3VycmVudClyZXR1cm47Y29uc3Qgbj11LmN1cnJlbnQucm90YXRpb24uY2xvbmUoKTt1LmN1cnJlbnQudXBkYXRlTWF0cml4KCksdS5jdXJyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCExLCExKSx1LmN1cnJlbnQuZ2V0V29ybGRRdWF0ZXJuaW9uKGQpLGUuZ2V0V29ybGRRdWF0ZXJuaW9uKGMuY3VycmVudC5xdWF0ZXJuaW9uKS5wcmVtdWx0aXBseShkLmludmVydCgpKSxyJiYodS5jdXJyZW50LnJvdGF0aW9uLng9bi54KSxvJiYodS5jdXJyZW50LnJvdGF0aW9uLnk9bi55KSxpJiYodS5jdXJyZW50LnJvdGF0aW9uLno9bi56KX0pKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUobCwoKCk9PnUuY3VycmVudCksW10pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6dSxtYXRyaXhBdXRvVXBkYXRlOiExLG1hdHJpeFdvcmxkQXV0b1VwZGF0ZTohMX0scyksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOmN9LGUpKX0pKSxjZT1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxkZXB0aDp0PS0xLC4uLnJ9LG4pPT57Y29uc3Qgbz1QLnVzZVJlZihudWxsKTtyZXR1cm4gYS51c2VGcmFtZSgoKHtjYW1lcmE6ZX0pPT57by5jdXJyZW50LnF1YXRlcm5pb24uY29weShlLnF1YXRlcm5pb24pLG8uY3VycmVudC5wb3NpdGlvbi5jb3B5KGUucG9zaXRpb24pfSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6ay5kZWZhdWx0KFtuLG9dKX0sciksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7XCJwb3NpdGlvbi16XCI6LXR9LGUpKX0pKSx1ZT1QLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtwb2ludHM6ZSxjb2xvcjp0PVwiYmxhY2tcIix2ZXJ0ZXhDb2xvcnM6cixsaW5ld2lkdGg6byxsaW5lV2lkdGg6aSxzZWdtZW50czpzLGRhc2hlZDpsLC4uLmN9LHUpe2NvbnN0IG09YS51c2VUaHJlZSgoZT0+ZS5zaXplKSksZj1QLnVzZU1lbW8oKCgpPT5zP25ldyBkLkxpbmVTZWdtZW50czI6bmV3IGQuTGluZTIpLFtzXSksW3BdPVAudXNlU3RhdGUoKCgpPT5uZXcgZC5MaW5lTWF0ZXJpYWwpKSxoPVAudXNlTWVtbygoKCk9Pntjb25zdCB0PXM/bmV3IGQuTGluZVNlZ21lbnRzR2VvbWV0cnk6bmV3IGQuTGluZUdlb21ldHJ5LGE9ZS5tYXAoKGU9Pntjb25zdCB0PUFycmF5LmlzQXJyYXkoZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBuLlZlY3RvcjM/W2UueCxlLnksZS56XTplIGluc3RhbmNlb2Ygbi5WZWN0b3IyP1tlLngsZS55LDBdOnQmJjM9PT1lLmxlbmd0aD9bZVswXSxlWzFdLGVbMl1dOnQmJjI9PT1lLmxlbmd0aD9bZVswXSxlWzFdLDBdOmV9KSk7aWYodC5zZXRQb3NpdGlvbnMoYS5mbGF0KCkpLHIpe2NvbnN0IGU9ci5tYXAoKGU9PmUgaW5zdGFuY2VvZiBuLkNvbG9yP2UudG9BcnJheSgpOmUpKTt0LnNldENvbG9ycyhlLmZsYXQoKSl9cmV0dXJuIHR9KSxbZSxzLHJdKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Zi5jb21wdXRlTGluZURpc3RhbmNlcygpfSksW2UsZl0pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2w/cC5kZWZpbmVzLlVTRV9EQVNIPVwiXCI6ZGVsZXRlIHAuZGVmaW5lcy5VU0VfREFTSCxwLm5lZWRzVXBkYXRlPSEwfSksW2wscF0pLFAudXNlRWZmZWN0KCgoKT0+KCk9PmguZGlzcG9zZSgpKSxbaF0pLFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLEMuZGVmYXVsdCh7b2JqZWN0OmYscmVmOnV9LGMpLFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtvYmplY3Q6aCxhdHRhY2g6XCJnZW9tZXRyeVwifSksUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtvYmplY3Q6cCxhdHRhY2g6XCJtYXRlcmlhbFwiLGNvbG9yOnQsdmVydGV4Q29sb3JzOkJvb2xlYW4ocikscmVzb2x1dGlvbjpbbS53aWR0aCxtLmhlaWdodF0sbGluZXdpZHRoOm51bGwhPW8/bzppLGRhc2hlZDpsfSxjKSkpfSkpLGRlPW5ldyBuLlZlY3RvcjMsbWU9UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7c3RhcnQ6ZT1bMCwwLDBdLGVuZDp0PVswLDAsMF0sbWlkOnIsc2VnbWVudHM6YT0yMCwuLi5vfSxpKXtjb25zdCBzPVAudXNlUmVmKG51bGwpLFtsXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uUXVhZHJhdGljQmV6aWVyQ3VydmUzKHZvaWQgMCx2b2lkIDAsdm9pZCAwKSkpLGM9UC51c2VDYWxsYmFjaygoKGUsdCxyLGE9MjApPT4oZSBpbnN0YW5jZW9mIG4uVmVjdG9yMz9sLnYwLmNvcHkoZSk6bC52MC5zZXQoLi4uZSksdCBpbnN0YW5jZW9mIG4uVmVjdG9yMz9sLnYyLmNvcHkodCk6bC52Mi5zZXQoLi4udCksciBpbnN0YW5jZW9mIG4uVmVjdG9yMz9sLnYxLmNvcHkocik6QXJyYXkuaXNBcnJheShyKT9sLnYxLnNldCguLi5yKTpsLnYxLmNvcHkobC52MC5jbG9uZSgpLmFkZChsLnYyLmNsb25lKCkuc3ViKGwudjApKS5hZGQoZGUuc2V0KDAsbC52MC55LWwudjIueSwwKSkpLGwuZ2V0UG9pbnRzKGEpKSksW10pO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3MuY3VycmVudC5zZXRQb2ludHM9KGUsdCxyKT0+e2NvbnN0IG49YyhlLHQscik7cy5jdXJyZW50Lmdlb21ldHJ5JiZzLmN1cnJlbnQuZ2VvbWV0cnkuc2V0UG9zaXRpb25zKG4ubWFwKChlPT5lLnRvQXJyYXkoKSkpLmZsYXQoKSl9fSksW10pO2NvbnN0IHU9UC51c2VNZW1vKCgoKT0+YyhlLHQscixhKSksW2UsdCxyLGFdKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KHVlLEMuZGVmYXVsdCh7cmVmOmsuZGVmYXVsdChbcyxpXSkscG9pbnRzOnV9LG8pKX0pKSxmZT1QLmZvcndhcmRSZWYoKGZ1bmN0aW9uKHtzdGFydDplLGVuZDp0LG1pZEE6cixtaWRCOmEsc2VnbWVudHM6bz0yMCwuLi5pfSxzKXtjb25zdCBsPVAudXNlTWVtbygoKCk9Pntjb25zdCBpPWUgaW5zdGFuY2VvZiBuLlZlY3RvcjM/ZTpuZXcgbi5WZWN0b3IzKC4uLmUpLHM9dCBpbnN0YW5jZW9mIG4uVmVjdG9yMz90Om5ldyBuLlZlY3RvcjMoLi4udCksbD1yIGluc3RhbmNlb2Ygbi5WZWN0b3IzP3I6bmV3IG4uVmVjdG9yMyguLi5yKSxjPWEgaW5zdGFuY2VvZiBuLlZlY3RvcjM/YTpuZXcgbi5WZWN0b3IzKC4uLmEpO3JldHVybiBuZXcgbi5DdWJpY0JlemllckN1cnZlMyhpLGwsYyxzKS5nZXRQb2ludHMobyl9KSxbZSx0LHIsYSxvXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudCh1ZSxDLmRlZmF1bHQoe3JlZjpzLHBvaW50czpsfSxpKSl9KSkscGU9UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7cG9pbnRzOmUsY2xvc2VkOnQ9ITEsY3VydmVUeXBlOnI9XCJjZW50cmlwZXRhbFwiLHRlbnNpb246YT0uNSxzZWdtZW50czpvPTIwLHZlcnRleENvbG9yczppLC4uLnN9LGwpe2NvbnN0IGM9UC51c2VNZW1vKCgoKT0+e2NvbnN0IG89ZS5tYXAoKGU9PmUgaW5zdGFuY2VvZiBuLlZlY3RvcjM/ZTpuZXcgbi5WZWN0b3IzKC4uLmUpKSk7cmV0dXJuIG5ldyBuLkNhdG11bGxSb21DdXJ2ZTMobyx0LHIsYSl9KSxbZSx0LHIsYV0pLHU9UC51c2VNZW1vKCgoKT0+Yy5nZXRQb2ludHMobykpLFtjLG9dKSxkPVAudXNlTWVtbygoKCk9PntpZighaXx8aS5sZW5ndGg8MilyZXR1cm47aWYoaS5sZW5ndGg9PT1vKzEpcmV0dXJuIGk7Y29uc3QgZT1pLm1hcCgoZT0+ZSBpbnN0YW5jZW9mIG4uQ29sb3I/ZTpuZXcgbi5Db2xvciguLi5lKSkpO3QmJmUucHVzaChlWzBdLmNsb25lKCkpO2NvbnN0IHI9W2VbMF1dLGE9by8oZS5sZW5ndGgtMSk7Zm9yKGxldCB0PTE7dDxvO3QrKyl7Y29uc3Qgbj10JWEvYSxvPU1hdGguZmxvb3IodC9hKTtyLnB1c2goZVtvXS5jbG9uZSgpLmxlcnAoZVtvKzFdLG4pKX1yZXR1cm4gci5wdXNoKGVbZS5sZW5ndGgtMV0pLHJ9KSxbaSxvXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudCh1ZSxDLmRlZmF1bHQoe3JlZjpsLHBvaW50czp1LHZlcnRleENvbG9yczpkfSxzKSl9KSksaGU9UC5mb3J3YXJkUmVmKCgoe3VybDplLGRpc3RhbmNlOnQ9MSxsb29wOnI9ITAsYXV0b3BsYXk6bywuLi5pfSxzKT0+e2NvbnN0IGw9UC51c2VSZWYoKSxjPWEudXNlVGhyZWUoKCh7Y2FtZXJhOmV9KT0+ZSkpLFt1XT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uQXVkaW9MaXN0ZW5lcikpLGQ9YS51c2VMb2FkZXIobi5BdWRpb0xvYWRlcixlKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1sLmN1cnJlbnQ7ZSYmKGUuc2V0QnVmZmVyKGQpLGUuc2V0UmVmRGlzdGFuY2UodCksZS5zZXRMb29wKHIpLG8mJiFlLmlzUGxheWluZyYmZS5wbGF5KCkpfSksW2QsYyx0LHJdKSxQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWwuY3VycmVudDtyZXR1cm4gYy5hZGQodSksKCk9PntjLnJlbW92ZSh1KSxlJiYoZS5pc1BsYXlpbmcmJmUuc3RvcCgpLGUuc291cmNlJiZlLnNvdXJjZS5fY29ubmVjdGVkJiZlLmRpc2Nvbm5lY3QoKSl9fSksW10pLFAuY3JlYXRlRWxlbWVudChcInBvc2l0aW9uYWxBdWRpb1wiLEMuZGVmYXVsdCh7cmVmOmsuZGVmYXVsdChbbCxzXSksYXJnczpbdV19LGkpKX0pKSx4ZT1QLmZvcndhcmRSZWYoKCh7c2RmR2x5cGhTaXplOmU9NjQsYW5jaG9yWDp0PVwiY2VudGVyXCIsYW5jaG9yWTpyPVwibWlkZGxlXCIsZm9udDpuLGZvbnRTaXplOm89MSxjaGlsZHJlbjppLGNoYXJhY3RlcnM6cyxvblN5bmM6bCwuLi5jfSx1KT0+e2NvbnN0e1RleHQ6ZCxwcmVsb2FkRm9udDptfT1mLnN1c3BlbmQoKGFzeW5jKCk9PlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIFQocmVxdWlyZShcInRyb2lrYS10aHJlZS10ZXh0XCIpKX0pKSksW10pLHA9YS51c2VUaHJlZSgoKHtpbnZhbGlkYXRlOmV9KT0+ZSkpLFtoXT1QLnVzZVN0YXRlKCgoKT0+bmV3IGQpKSxbeCx5XT1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1bXTtsZXQgdD1cIlwiO3JldHVybiBQLkNoaWxkcmVuLmZvckVhY2goaSwocj0+e1wic3RyaW5nXCI9PXR5cGVvZiByfHxcIm51bWJlclwiPT10eXBlb2Ygcj90Kz1yOmUucHVzaChyKX0pKSxbZSx0XX0pLFtpXSk7cmV0dXJuIGYuc3VzcGVuZCgoKCk9Pm5ldyBQcm9taXNlKChlPT5tKHtmb250Om4sY2hhcmFjdGVyczpzfSxlKSkpKSxbXCJ0cm9pa2EtdGV4dFwiLG4sc10pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2guc3luYygoKCk9PntwKCksbCYmbChoKX0pKX0pKSxQLnVzZUVmZmVjdCgoKCk9PigpPT5oLmRpc3Bvc2UoKSksW2hdKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe29iamVjdDpoLHJlZjp1LGZvbnQ6bix0ZXh0OnksYW5jaG9yWDp0LGFuY2hvclk6cixmb250U2l6ZTpvLHNkZkdseXBoU2l6ZTplfSxjKSx4KX0pKTtsZXQgeWU9bnVsbDthc3luYyBmdW5jdGlvbiB2ZShlKXt5ZXx8KHllPW5ldyBkLkZvbnRMb2FkZXIpO2xldCB0PVwic3RyaW5nXCI9PXR5cGVvZiBlP2F3YWl0KGF3YWl0IGZldGNoKGUpKS5qc29uKCk6ZTtyZXR1cm4geWUucGFyc2UodCl9ZnVuY3Rpb24gZ2UoZSl7cmV0dXJuIGYuc3VzcGVuZCh2ZSxbZV0pfWdlLnByZWxvYWQ9ZT0+Zi5wcmVsb2FkKHZlLFtlXSksZ2UuY2xlYXI9ZT0+Zi5jbGVhcihbZV0pO2NvbnN0IHplPVtcInN0cmluZ1wiLFwibnVtYmVyXCJdLHdlPVAuZm9yd2FyZFJlZigoKHtmb250OmUsbGV0dGVyU3BhY2luZzpyPTAsbGluZUhlaWdodDpuPTEsc2l6ZTpvPTEsaGVpZ2h0Omk9LjIsYmV2ZWxUaGlja25lc3M6cz0uMSxiZXZlbFNpemU6bD0uMDEsYmV2ZWxFbmFibGVkOmM9ITEsYmV2ZWxPZmZzZXQ6dT0wLGJldmVsU2VnbWVudHM6bT00LGN1cnZlU2VnbWVudHM6Zj04LHNtb290aDpwLGNoaWxkcmVuOmgsLi4ueH0seSk9PntQLnVzZU1lbW8oKCgpPT5hLmV4dGVuZCh7UmVuYW1lZFRleHRHZW9tZXRyeTpkLlRleHRHZW9tZXRyeX0pKSxbXSk7Y29uc3Qgdj1QLnVzZVJlZihudWxsKSxnPWdlKGUpLHo9dC51c2VNZW1vKCgoKT0+KHtmb250Omcsc2l6ZTpvLGhlaWdodDppLGJldmVsVGhpY2tuZXNzOnMsYmV2ZWxTaXplOmwsYmV2ZWxFbmFibGVkOmMsYmV2ZWxTZWdtZW50czptLGJldmVsT2Zmc2V0OnUsY3VydmVTZWdtZW50czpmLGxldHRlclNwYWNpbmc6cixsaW5lSGVpZ2h0Om59KSksW2csbyxpLHMsbCxjLG0sdSxmLHIsbl0pLFt3LC4uLmJdPXQudXNlTWVtbygoKCk9PihlPT57bGV0IHQ9XCJcIjtjb25zdCByPVtdO3JldHVybiBQLkNoaWxkcmVuLmZvckVhY2goZSwoZT0+e3plLmluY2x1ZGVzKHR5cGVvZiBlKT90Kz1lK1wiXCI6ci5wdXNoKGUpfSkpLFt0LC4uLnJdfSkoaCkpLFtoXSksTT1QLnVzZU1lbW8oKCgpPT5bdyx6XSksW3csel0pO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9PntwJiYodi5jdXJyZW50Lmdlb21ldHJ5PWQubWVyZ2VWZXJ0aWNlcyh2LmN1cnJlbnQuZ2VvbWV0cnkscCksdi5jdXJyZW50Lmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkpfSksW00scF0pLFAudXNlSW1wZXJhdGl2ZUhhbmRsZSh5LCgoKT0+di5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLEMuZGVmYXVsdCh7fSx4LHtyZWY6dn0pLFAuY3JlYXRlRWxlbWVudChcInJlbmFtZWRUZXh0R2VvbWV0cnlcIix7YXJnczpNfSksYil9KSksYmU9UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsbXVsdGlzYW1waW5nOnQ9OCxyZW5kZXJJbmRleDpyPTEsZGlzYWJsZVJlbmRlcjpvLGRpc2FibGVHYW1tYTppLGRpc2FibGVSZW5kZXJQYXNzOnMsZGVwdGhCdWZmZXI6bD0hMCxzdGVuY2lsQnVmZmVyOmM9ITEsYW5pc290cm9weTp1PTEsZW5jb2Rpbmc6bSx0eXBlOmYsLi4ucH0saCk9PntQLnVzZU1lbW8oKCgpPT5hLmV4dGVuZCh7RWZmZWN0Q29tcG9zZXI6ZC5FZmZlY3RDb21wb3NlcixSZW5kZXJQYXNzOmQuUmVuZGVyUGFzcyxTaGFkZXJQYXNzOmQuU2hhZGVyUGFzc30pKSxbXSk7Y29uc3QgeD1QLnVzZVJlZigpLHtzY2VuZTp5LGNhbWVyYTp2LGdsOmcsc2l6ZTp6LHZpZXdwb3J0Ond9PWEudXNlVGhyZWUoKSxbYl09UC51c2VTdGF0ZSgoKCk9Pntjb25zdCBlPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHoud2lkdGgsei5oZWlnaHQse3R5cGU6Znx8bi5IYWxmRmxvYXRUeXBlLGZvcm1hdDpuLlJHQkFGb3JtYXQsZGVwdGhCdWZmZXI6bCxzdGVuY2lsQnVmZmVyOmMsYW5pc290cm9weTp1fSk7cmV0dXJuIGY9PT1uLlVuc2lnbmVkQnl0ZVR5cGUmJm51bGwhPW0mJihcImNvbG9yU3BhY2VcImluIGU/ZS50ZXh0dXJlLmNvbG9yU3BhY2U9bTplLnRleHR1cmUuZW5jb2Rpbmc9bSksZS5zYW1wbGVzPXQsZX0pKTtQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgZSx0O251bGw9PShlPXguY3VycmVudCl8fGUuc2V0U2l6ZSh6LndpZHRoLHouaGVpZ2h0KSxudWxsPT0odD14LmN1cnJlbnQpfHx0LnNldFBpeGVsUmF0aW8ody5kcHIpfSksW2cseix3LmRwcl0pLGEudXNlRnJhbWUoKCgpPT57dmFyIGU7b3x8bnVsbD09KGU9eC5jdXJyZW50KXx8ZS5yZW5kZXIoKX0pLHIpO2NvbnN0IE09W107cmV0dXJuIHN8fE0ucHVzaChQLmNyZWF0ZUVsZW1lbnQoXCJyZW5kZXJQYXNzXCIse2tleTpcInJlbmRlcnBhc3NcIixhdHRhY2g6YHBhc3Nlcy0ke00ubGVuZ3RofWAsYXJnczpbeSx2XX0pKSxpfHxNLnB1c2goUC5jcmVhdGVFbGVtZW50KFwic2hhZGVyUGFzc1wiLHthdHRhY2g6YHBhc3Nlcy0ke00ubGVuZ3RofWAsa2V5OlwiZ2FtbWFwYXNzXCIsYXJnczpbZC5HYW1tYUNvcnJlY3Rpb25TaGFkZXJdfSkpLFAuQ2hpbGRyZW4uZm9yRWFjaChlLChlPT57ZSYmTS5wdXNoKFAuY2xvbmVFbGVtZW50KGUse2tleTpNLmxlbmd0aCxhdHRhY2g6YHBhc3Nlcy0ke00ubGVuZ3RofWB9KSl9KSksUC5jcmVhdGVFbGVtZW50KFwiZWZmZWN0Q29tcG9zZXJcIixDLmRlZmF1bHQoe3JlZjprLmRlZmF1bHQoW2gseF0pLGFyZ3M6W2csYl19LHApLE0pfSkpO2xldCBNZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5MaW5lYXI9XCJsaW5lYXJcIixlLlJhZGlhbD1cInJhZGlhbFwiLGV9KHt9KTtmdW5jdGlvbiBFZShlLHQscixuKXtjb25zdCBhPWNsYXNzIGV4dGVuZHMgRC5TaGFkZXJNYXRlcmlhbHtjb25zdHJ1Y3RvcihhPXt9KXtjb25zdCBvPU9iamVjdC5lbnRyaWVzKGUpO3N1cGVyKHt1bmlmb3JtczpvLnJlZHVjZSgoKGUsW3Qscl0pPT4oey4uLmUsLi4uRC5Vbmlmb3Jtc1V0aWxzLmNsb25lKHtbdF06e3ZhbHVlOnJ9fSl9KSkse30pLHZlcnRleFNoYWRlcjp0LGZyYWdtZW50U2hhZGVyOnJ9KSx0aGlzLmtleT1cIlwiLG8uZm9yRWFjaCgoKFtlXSk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLGUse2dldDooKT0+dGhpcy51bmlmb3Jtc1tlXS52YWx1ZSxzZXQ6dD0+dGhpcy51bmlmb3Jtc1tlXS52YWx1ZT10fSkpKSxPYmplY3QuYXNzaWduKHRoaXMsYSksbiYmbih0aGlzKX19O3JldHVybiBhLmtleT1ELk1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKSxhfWNvbnN0IFNlPWU9PmU9PT1PYmplY3QoZSkmJiFBcnJheS5pc0FycmF5KGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlO2Z1bmN0aW9uIFRlKGUscil7Y29uc3Qgbz1hLnVzZVRocmVlKChlPT5lLmdsKSksaT1hLnVzZUxvYWRlcihuLlRleHR1cmVMb2FkZXIsU2UoZSk/T2JqZWN0LnZhbHVlcyhlKTplKTtpZih0LnVzZUxheW91dEVmZmVjdCgoKCk9PntudWxsPT1yfHxyKGkpfSksW3JdKSx0LnVzZUVmZmVjdCgoKCk9PntpZihcImluaXRUZXh0dXJlXCJpbiBvKXsoQXJyYXkuaXNBcnJheShpKT9pOltpXSkuZm9yRWFjaChvLmluaXRUZXh0dXJlKX19KSxbbyxpXSksU2UoZSkpe2NvbnN0IHQ9e307bGV0IHI9MDtmb3IoY29uc3QgbiBpbiBlKXRbbl09aVtyKytdO3JldHVybiB0fXJldHVybiBpfVRlLnByZWxvYWQ9ZT0+YS51c2VMb2FkZXIucHJlbG9hZChuLlRleHR1cmVMb2FkZXIsZSksVGUuY2xlYXI9ZT0+YS51c2VMb2FkZXIuY2xlYXIobi5UZXh0dXJlTG9hZGVyLGUpO2NvbnN0IENlPSgoKT0+cGFyc2VJbnQobi5SRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csXCJcIikpKSgpLFBlPUVlKHtjb2xvcjpuZXcgRC5Db2xvcihcIndoaXRlXCIpLHNjYWxlOm5ldyBELlZlY3RvcjIoMSwxKSxpbWFnZUJvdW5kczpuZXcgRC5WZWN0b3IyKDEsMSksbWFwOm51bGwsem9vbToxLGdyYXlzY2FsZTowLG9wYWNpdHk6MX0sXCJcXG4gIHZhcnlpbmcgdmVjMiB2VXY7XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuKTtcXG4gICAgdlV2ID0gdXY7XFxuICB9XFxuXCIsYFxcbiAgLy8gbW9zdGx5IGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vc3RhdGljby9kZjY0YzVkMTY3MzYyZWNmN2IzNGZjYTBiMTQ1OWE0NFxcbiAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gIHVuaWZvcm0gdmVjMiBzY2FsZTtcXG4gIHVuaWZvcm0gdmVjMiBpbWFnZUJvdW5kcztcXG4gIHVuaWZvcm0gdmVjMyBjb2xvcjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4gIHVuaWZvcm0gZmxvYXQgem9vbTtcXG4gIHVuaWZvcm0gZmxvYXQgZ3JheXNjYWxlO1xcbiAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiAgY29uc3QgdmVjMyBsdW1hID0gdmVjMyguMjk5LCAwLjU4NywgMC4xMTQpO1xcbiAgdmVjNCB0b0dyYXlzY2FsZSh2ZWM0IGNvbG9yLCBmbG9hdCBpbnRlbnNpdHkpIHtcXG4gICAgcmV0dXJuIHZlYzQobWl4KGNvbG9yLnJnYiwgdmVjMyhkb3QoY29sb3IucmdiLCBsdW1hKSksIGludGVuc2l0eSksIGNvbG9yLmEpO1xcbiAgfVxcbiAgdmVjMiBhc3BlY3QodmVjMiBzaXplKSB7XFxuICAgIHJldHVybiBzaXplIC8gbWluKHNpemUueCwgc2l6ZS55KTtcXG4gIH1cXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBzID0gYXNwZWN0KHNjYWxlKTtcXG4gICAgdmVjMiBpID0gYXNwZWN0KGltYWdlQm91bmRzKTtcXG4gICAgZmxvYXQgcnMgPSBzLnggLyBzLnk7XFxuICAgIGZsb2F0IHJpID0gaS54IC8gaS55O1xcbiAgICB2ZWMyIG5ldyA9IHJzIDwgcmkgPyB2ZWMyKGkueCAqIHMueSAvIGkueSwgcy55KSA6IHZlYzIocy54LCBpLnkgKiBzLnggLyBpLngpO1xcbiAgICB2ZWMyIG9mZnNldCA9IChycyA8IHJpID8gdmVjMigobmV3LnggLSBzLngpIC8gMi4wLCAwLjApIDogdmVjMigwLjAsIChuZXcueSAtIHMueSkgLyAyLjApKSAvIG5ldztcXG4gICAgdmVjMiB1diA9IHZVdiAqIHMgLyBuZXcgKyBvZmZzZXQ7XFxuICAgIHZlYzIgelV2ID0gKHV2IC0gdmVjMigwLjUsIDAuNSkpIC8gem9vbSArIHZlYzIoMC41LCAwLjUpO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0b0dyYXlzY2FsZSh0ZXh0dXJlMkQobWFwLCB6VXYpICogdmVjNChjb2xvciwgb3BhY2l0eSksIGdyYXlzY2FsZSk7XFxuICAgIFxcbiAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICNpbmNsdWRlIDwke0NlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICB9XFxuYCksUmU9UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsY29sb3I6dCxzZWdtZW50czpyPTEsc2NhbGU6bj0xLHpvb206bz0xLGdyYXlzY2FsZTppPTAsb3BhY2l0eTpzPTEsdGV4dHVyZTpsLHRvbmVNYXBwZWQ6Yyx0cmFuc3BhcmVudDp1LHNpZGU6ZCwuLi5tfSxmKT0+e2EuZXh0ZW5kKHtJbWFnZU1hdGVyaWFsOlBlfSk7Y29uc3QgcD1QLnVzZVJlZihudWxsKSxoPUFycmF5LmlzQXJyYXkobik/W25bMF0sblsxXV06W24sbl0seD1bbC5pbWFnZS53aWR0aCxsLmltYWdlLmhlaWdodF07cmV0dXJuIFAudXNlSW1wZXJhdGl2ZUhhbmRsZShmLCgoKT0+cC5jdXJyZW50KSxbXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57cC5jdXJyZW50Lmdlb21ldHJ5LnBhcmFtZXRlcnMmJnAuY3VycmVudC5tYXRlcmlhbC5zY2FsZS5zZXQoaFswXSpwLmN1cnJlbnQuZ2VvbWV0cnkucGFyYW1ldGVycy53aWR0aCxoWzFdKnAuY3VycmVudC5nZW9tZXRyeS5wYXJhbWV0ZXJzLmhlaWdodCl9KSxbXSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLEMuZGVmYXVsdCh7cmVmOnAsc2NhbGU6QXJyYXkuaXNBcnJheShuKT9bLi4ubiwxXTpufSxtKSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6WzEsMSxyLHJdfSksUC5jcmVhdGVFbGVtZW50KFwiaW1hZ2VNYXRlcmlhbFwiLHtjb2xvcjp0LG1hcDpsLHpvb206byxncmF5c2NhbGU6aSxvcGFjaXR5OnMsc2NhbGU6aCxpbWFnZUJvdW5kczp4LHRvbmVNYXBwZWQ6Yyx0cmFuc3BhcmVudDp1LHNpZGU6ZH0pLGUpfSkpLERlPVAuZm9yd2FyZFJlZigoKHt1cmw6ZSwuLi50fSxyKT0+e2NvbnN0IG49VGUoZSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChSZSxDLmRlZmF1bHQoe30sdCx7dGV4dHVyZTpuLHJlZjpyfSkpfSkpLEZlPVAuZm9yd2FyZFJlZigoKHt1cmw6ZSwuLi50fSxyKT0+UC5jcmVhdGVFbGVtZW50KFJlLEMuZGVmYXVsdCh7fSx0LHtyZWY6cn0pKSkpLGtlPVAuZm9yd2FyZFJlZigoKGUsdCk9PntpZihlLnVybClyZXR1cm4gUC5jcmVhdGVFbGVtZW50KERlLEMuZGVmYXVsdCh7fSxlLHtyZWY6dH0pKTtpZihlLnRleHR1cmUpcmV0dXJuIFAuY3JlYXRlRWxlbWVudChGZSxDLmRlZmF1bHQoe30sZSx7cmVmOnR9KSk7dGhyb3cgbmV3IEVycm9yKFwiPEltYWdlIC8+IHJlcXVpcmVzIGEgdXJsIG9yIHRleHR1cmVcIil9KSksX2U9UC5mb3J3YXJkUmVmKCgoe3VzZXJEYXRhOmUsY2hpbGRyZW46dCxnZW9tZXRyeTpyLHRocmVzaG9sZDpuPTE1LGNvbG9yOmE9XCJibGFja1wiLC4uLm99LGkpPT57Y29uc3Qgcz1QLnVzZVJlZihudWxsKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT1zLmN1cnJlbnQucGFyZW50O2lmKGUpe2NvbnN0IHQ9cnx8ZS5nZW9tZXRyeTt0PT09cy5jdXJyZW50LnVzZXJEYXRhLmN1cnJlbnRHZW9tJiZuPT09cy5jdXJyZW50LnVzZXJEYXRhLmN1cnJlbnRUaHJlc2hvbGR8fChzLmN1cnJlbnQudXNlckRhdGEuY3VycmVudEdlb209dCxzLmN1cnJlbnQudXNlckRhdGEuY3VycmVudFRocmVzaG9sZD1uLHMuY3VycmVudC5nZW9tZXRyeT1uZXcgRC5FZGdlc0dlb21ldHJ5KHQsbikpfX0pKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUoaSwoKCk9PnMuY3VycmVudCkpLFAuY3JlYXRlRWxlbWVudChcImxpbmVTZWdtZW50c1wiLEMuZGVmYXVsdCh7cmVmOnMscmF5Y2FzdDooKT0+bnVsbH0sbyksdHx8UC5jcmVhdGVFbGVtZW50KFwibGluZUJhc2ljTWF0ZXJpYWxcIix7Y29sb3I6YX0pKX0pKSxBZT1FZSh7c2NyZWVuc3BhY2U6ITEsY29sb3I6bmV3IEQuQ29sb3IoXCJibGFja1wiKSxvcGFjaXR5OjEsdGhpY2tuZXNzOi4wNSxzaXplOm5ldyBELlZlY3RvcjJ9LFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4gICAjaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuICAgI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiAgIHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xcbiAgIHVuaWZvcm0gZmxvYXQgc2NyZWVuc3BhY2U7XFxuICAgdW5pZm9ybSB2ZWMyIHNpemU7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgI2lmIGRlZmluZWQgKFVTRV9TS0lOTklORylcXG5cXHQgICAgICNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuICAgICAgICNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG4gICAgICAgI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiAgICAgI2VuZGlmXFxuICAgICAjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCAgICNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0ICAgI2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG4gICAgICNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG4gICAgIHZlYzQgdE5vcm1hbCA9IHZlYzQobm9ybWFsLCAwLjApO1xcbiAgICAgdmVjNCB0UG9zaXRpb24gPSB2ZWM0KHRyYW5zZm9ybWVkLCAxLjApO1xcbiAgICAgI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgIHROb3JtYWwgPSBpbnN0YW5jZU1hdHJpeCAqIHROb3JtYWw7XFxuICAgICAgIHRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogdFBvc2l0aW9uO1xcbiAgICAgI2VuZGlmXFxuICAgICBpZiAoc2NyZWVuc3BhY2UgPT0gMC4wKSB7XFxuICAgICAgIHZlYzMgbmV3UG9zaXRpb24gPSB0UG9zaXRpb24ueHl6ICsgdE5vcm1hbC54eXogKiB0aGlja25lc3M7XFxuICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQobmV3UG9zaXRpb24sIDEuMCk7IFxcbiAgICAgfSBlbHNlIHtcXG4gICAgICAgdmVjNCBjbGlwUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdFBvc2l0aW9uO1xcbiAgICAgICB2ZWM0IGNsaXBOb3JtYWwgPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdE5vcm1hbDtcXG4gICAgICAgdmVjMiBvZmZzZXQgPSBub3JtYWxpemUoY2xpcE5vcm1hbC54eSkgKiB0aGlja25lc3MgLyBzaXplICogY2xpcFBvc2l0aW9uLncgKiAyLjA7XFxuICAgICAgIGNsaXBQb3NpdGlvbi54eSArPSBvZmZzZXQ7XFxuICAgICAgIGdsX1Bvc2l0aW9uID0gY2xpcFBvc2l0aW9uO1xcbiAgICAgfVxcbiAgIH1cIixgdW5pZm9ybSB2ZWMzIGNvbG9yO1xcbiAgIHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4gICB2b2lkIG1haW4oKXtcXG4gICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIG9wYWNpdHkpO1xcbiAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgI2luY2x1ZGUgPCR7Q2U+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICB9YCk7Y29uc3QgTGU9e3dpZHRoOi4yLGxlbmd0aDoxLGRlY2F5OjEsbG9jYWw6ITEsc3RyaWRlOjAsaW50ZXJ2YWw6MX0sQmU9KGUsdD0xKT0+KGUuc2V0KGUuc3ViYXJyYXkodCkpLGUuZmlsbCgtMS8wLC10KSxlKTtmdW5jdGlvbiBVZShlLHQpe2NvbnN0e2xlbmd0aDpyLGxvY2FsOm8sZGVjYXk6aSxpbnRlcnZhbDpzLHN0cmlkZTpsfT17Li4uTGUsLi4udH0sYz1QLnVzZVJlZigpLFt1XT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2UmJihjLmN1cnJlbnQ9RmxvYXQzMkFycmF5LmZyb20oe2xlbmd0aDoxMCpyKjN9LCgodCxyKT0+ZS5wb3NpdGlvbi5nZXRDb21wb25lbnQociUzKSkpKX0pLFtyLGVdKTtjb25zdCBkPVAudXNlUmVmKG5ldyBuLlZlY3RvcjMpLG09UC51c2VSZWYoMCk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57aWYoZSYmYy5jdXJyZW50KXtpZigwPT09bS5jdXJyZW50KXtsZXQgdDtvP3Q9ZS5wb3NpdGlvbjooZS5nZXRXb3JsZFBvc2l0aW9uKHUpLHQ9dSk7Y29uc3Qgcj0xKmk7Zm9yKGxldCBlPTA7ZTxyO2UrKyl0LmRpc3RhbmNlVG8oZC5jdXJyZW50KTxsfHwoQmUoYy5jdXJyZW50LDMpLGMuY3VycmVudC5zZXQodC50b0FycmF5KCksYy5jdXJyZW50Lmxlbmd0aC0zKSk7ZC5jdXJyZW50LmNvcHkodCl9bS5jdXJyZW50KyssbS5jdXJyZW50PW0uY3VycmVudCVzfX0pKSxjfWNvbnN0IEllPVAuZm9yd2FyZFJlZigoKGUsdCk9Pntjb25zdHtjaGlsZHJlbjpyfT1lLHt3aWR0aDpvLGxlbmd0aDppLGRlY2F5OnMsbG9jYWw6bCxzdHJpZGU6YyxpbnRlcnZhbDp1fT17Li4uTGUsLi4uZX0se2NvbG9yOmQ9XCJob3RwaW5rXCIsYXR0ZW51YXRpb246bSx0YXJnZXQ6Zn09ZSxoPWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLHg9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLHk9UC51c2VSZWYobnVsbCksW3YsZ109UC51c2VTdGF0ZShudWxsKSx6PVVlKHYse2xlbmd0aDppLGRlY2F5OnMsbG9jYWw6bCxzdHJpZGU6YyxpbnRlcnZhbDp1fSk7UC51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT0obnVsbD09Zj92b2lkIDA6Zi5jdXJyZW50KXx8eS5jdXJyZW50LmNoaWxkcmVuLmZpbmQoKGU9PmUgaW5zdGFuY2VvZiBuLk9iamVjdDNEKSk7ZSYmZyhlKX0pLFt6LGZdKTtjb25zdCB3PVAudXNlTWVtbygoKCk9Pm5ldyBwLk1lc2hMaW5lR2VvbWV0cnkpLFtdKSxiPVAudXNlTWVtbygoKCk9Pnt2YXIgZTtjb25zdCB0PW5ldyBwLk1lc2hMaW5lTWF0ZXJpYWwoe2xpbmVXaWR0aDouMSpvLGNvbG9yOmQsc2l6ZUF0dGVudWF0aW9uOjEscmVzb2x1dGlvbjpuZXcgbi5WZWN0b3IyKGgud2lkdGgsaC5oZWlnaHQpfSk7bGV0IGE7aWYocilpZihBcnJheS5pc0FycmF5KHIpKWE9ci5maW5kKChlPT57Y29uc3QgdD1lO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0LnR5cGUmJlwibWVzaExpbmVNYXRlcmlhbFwiPT09dC50eXBlfSkpO2Vsc2V7Y29uc3QgZT1yO1wic3RyaW5nXCI9PXR5cGVvZiBlLnR5cGUmJlwibWVzaExpbmVNYXRlcmlhbFwiPT09ZS50eXBlJiYoYT1lKX1yZXR1cm5cIm9iamVjdFwiPT10eXBlb2YobnVsbD09KGU9YSk/dm9pZCAwOmUucHJvcHMpJiZ0LnNldFZhbHVlcyhhLnByb3BzKSx0fSksW28sZCxoLHJdKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57Yi51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLnNldChoLndpZHRoLGguaGVpZ2h0KX0pLFtoXSksYS51c2VGcmFtZSgoKCk9Pnt6LmN1cnJlbnQmJncuc2V0UG9pbnRzKHouY3VycmVudCxtKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLG51bGwsYS5jcmVhdGVQb3J0YWwoUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6dCxnZW9tZXRyeTp3LG1hdGVyaWFsOmJ9KSx4KSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6eX0scikpfSkpO2Z1bmN0aW9uIFZlKGUsdD0xNixyLGEsbyl7Y29uc3RbaSxzXT1QLnVzZVN0YXRlKCgoKT0+e2NvbnN0IGU9QXJyYXkuZnJvbSh7bGVuZ3RoOnR9LCgoKT0+WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdKSkuZmxhdCgpO3JldHVybiBuZXcgbi5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoRmxvYXQzMkFycmF5LmZyb20oZSksMTYpfSkpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZih2b2lkIDA9PT1lLmN1cnJlbnQpcmV0dXJuO2NvbnN0IGw9bmV3IGQuTWVzaFN1cmZhY2VTYW1wbGVyKGUuY3VycmVudCk7YSYmbC5zZXRXZWlnaHRBdHRyaWJ1dGUoYSksbC5idWlsZCgpO2NvbnN0IGM9bmV3IG4uVmVjdG9yMyx1PW5ldyBuLlZlY3RvcjMsbT1uZXcgbi5Db2xvcixmPW5ldyBuLk9iamVjdDNEO2UuY3VycmVudC51cGRhdGVNYXRyaXhXb3JsZCghMCk7Zm9yKGxldCBuPTA7bjx0O24rKylsLnNhbXBsZShjLHUsbSksXCJmdW5jdGlvblwiPT10eXBlb2Ygcj9yKHtkdW1teTpmLHNhbXBsZWRNZXNoOmUuY3VycmVudCxwb3NpdGlvbjpjLG5vcm1hbDp1LGNvbG9yOm19LG4pOmYucG9zaXRpb24uY29weShjKSxmLnVwZGF0ZU1hdHJpeCgpLG51bGwhPW8mJm8uY3VycmVudCYmby5jdXJyZW50LnNldE1hdHJpeEF0KG4sZi5tYXRyaXgpLGYubWF0cml4LnRvQXJyYXkoaS5hcnJheSwxNipuKTtudWxsIT1vJiZvLmN1cnJlbnQmJihvLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGU9ITApLGkubmVlZHNVcGRhdGU9ITAscyhpLmNsb25lKCkpfSksW2UsbyxhLHQscl0pLGl9Y29uc3QgT2U9UC5mb3J3YXJkUmVmKCgoe2lzQ2hpbGQ6ZT0hMSxvYmplY3Q6dCxjaGlsZHJlbjpyLGRlZXA6bixjYXN0U2hhZG93OmEscmVjZWl2ZVNoYWRvdzpvLGluamVjdDppLGtleXM6cywuLi5sfSxjKT0+e3ZhciB1O2NvbnN0IG09e2tleXM6cyxkZWVwOm4saW5qZWN0OmksY2FzdFNoYWRvdzphLHJlY2VpdmVTaGFkb3c6b307aWYodD1QLnVzZU1lbW8oKCgpPT57aWYoITE9PT1lJiYhQXJyYXkuaXNBcnJheSh0KSl7bGV0IGU9ITE7aWYodC50cmF2ZXJzZSgodD0+e3QuaXNTa2lubmVkTWVzaCYmKGU9ITApfSkpLGUpcmV0dXJuIGQuU2tlbGV0b25VdGlscy5jbG9uZSh0KX1yZXR1cm4gdH0pLFt0LGVdKSxBcnJheS5pc0FycmF5KHQpKXJldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLEMuZGVmYXVsdCh7fSxsLHtyZWY6Y30pLHQubWFwKChlPT5QLmNyZWF0ZUVsZW1lbnQoT2UsQy5kZWZhdWx0KHtrZXk6ZS51dWlkLG9iamVjdDplfSxtKSkpKSxyKTtjb25zdHtjaGlsZHJlbjpmLC4uLnB9PWZ1bmN0aW9uKGUse2tleXM6dD1bXCJuZWFyXCIsXCJmYXJcIixcImNvbG9yXCIsXCJkaXN0YW5jZVwiLFwiZGVjYXlcIixcInBlbnVtYnJhXCIsXCJhbmdsZVwiLFwiaW50ZW5zaXR5XCIsXCJza2VsZXRvblwiLFwidmlzaWJsZVwiLFwiY2FzdFNoYWRvd1wiLFwicmVjZWl2ZVNoYWRvd1wiLFwibW9ycGhUYXJnZXREaWN0aW9uYXJ5XCIsXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIixcIm5hbWVcIixcImdlb21ldHJ5XCIsXCJtYXRlcmlhbFwiLFwicG9zaXRpb25cIixcInJvdGF0aW9uXCIsXCJzY2FsZVwiLFwidXBcIixcInVzZXJEYXRhXCIsXCJiaW5kTW9kZVwiLFwiYmluZE1hdHJpeFwiLFwiYmluZE1hdHJpeEludmVyc2VcIixcInNrZWxldG9uXCJdLGRlZXA6cixpbmplY3Q6bixjYXN0U2hhZG93OmEscmVjZWl2ZVNoYWRvdzpvfSl7bGV0IGk9QS5kZWZhdWx0KGUsdCk7cmV0dXJuIHImJihpLmdlb21ldHJ5JiZcIm1hdGVyaWFsc09ubHlcIiE9PXImJihpLmdlb21ldHJ5PWkuZ2VvbWV0cnkuY2xvbmUoKSksaS5tYXRlcmlhbCYmXCJnZW9tZXRyaWVzT25seVwiIT09ciYmKGkubWF0ZXJpYWw9aS5tYXRlcmlhbC5jbG9uZSgpKSksbiYmKGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj97Li4uaSxjaGlsZHJlbjpuKGUpfTpQLmlzVmFsaWRFbGVtZW50KG4pP3suLi5pLGNoaWxkcmVuOm59OnsuLi5pLC4uLm59KSxlIGluc3RhbmNlb2YgRC5NZXNoJiYoYSYmKGkuY2FzdFNoYWRvdz0hMCksbyYmKGkucmVjZWl2ZVNoYWRvdz0hMCkpLGl9KHQsbSksaD10LnR5cGVbMF0udG9Mb3dlckNhc2UoKSt0LnR5cGUuc2xpY2UoMSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChoLEMuZGVmYXVsdCh7fSxwLGwse3JlZjpjfSksKG51bGw9PSh1PXQpP3ZvaWQgMDp1LmNoaWxkcmVuKS5tYXAoKGU9PlwiQm9uZVwiPT09ZS50eXBlP1AuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLEMuZGVmYXVsdCh7a2V5OmUudXVpZCxvYmplY3Q6ZX0sbSkpOlAuY3JlYXRlRWxlbWVudChPZSxDLmRlZmF1bHQoe2tleTplLnV1aWQsb2JqZWN0OmV9LG0se2lzQ2hpbGQ6ITB9KSkpKSxyLGYpfSkpLE5lPVAuY3JlYXRlQ29udGV4dChudWxsKSxqZT1QLmZvcndhcmRSZWYoKCh7cmVzb2x1dGlvbjplPTI4LG1heFBvbHlDb3VudDp0PTFlNCxlbmFibGVVdnM6cj0hMSxlbmFibGVDb2xvcnM6bj0hMSxjaGlsZHJlbjpvLC4uLml9LHMpPT57Y29uc3QgbD1QLnVzZVJlZihudWxsKSxjPVAudXNlTWVtbygoKCk9Pm5ldyBkLk1hcmNoaW5nQ3ViZXMoZSxudWxsLHIsbix0KSksW2UsdCxyLG5dKSx1PVAudXNlTWVtbygoKCk9Pih7Z2V0UGFyZW50OigpPT5sfSkpLFtdKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9PntjLnVwZGF0ZSgpLGMucmVzZXQoKX0pLC0xKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLEMuZGVmYXVsdCh7b2JqZWN0OmMscmVmOmsuZGVmYXVsdChbbCxzXSl9LGkpLFAuY3JlYXRlRWxlbWVudChOZS5Qcm92aWRlcix7dmFsdWU6dX0sbykpKX0pKSxXZT1QLmZvcndhcmRSZWYoKCh7c3RyZW5ndGg6ZT0uNSxzdWJ0cmFjdDp0PTEyLGNvbG9yOnIsLi4ubn0sbyk9Pntjb25zdHtnZXRQYXJlbnQ6aX09UC51c2VDb250ZXh0KE5lKSxzPVAudXNlTWVtbygoKCk9PmkoKSksW2ldKSxsPVAudXNlUmVmKCksYz1uZXcgRC5WZWN0b3IzO3JldHVybiBhLnVzZUZyYW1lKChuPT57cy5jdXJyZW50JiZsLmN1cnJlbnQmJihsLmN1cnJlbnQuZ2V0V29ybGRQb3NpdGlvbihjKSxzLmN1cnJlbnQuYWRkQmFsbCguNSsuNSpjLngsLjUrLjUqYy55LC41Ky41KmMueixlLHQscikpfSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6ay5kZWZhdWx0KFtvLGxdKX0sbikpfSkpLEdlPVAuZm9yd2FyZFJlZigoKHtwbGFuZVR5cGU6ZT1cInhcIixzdHJlbmd0aDp0PS41LHN1YnRyYWN0OnI9MTIsLi4ubn0sbyk9Pntjb25zdHtnZXRQYXJlbnQ6aX09UC51c2VDb250ZXh0KE5lKSxzPVAudXNlTWVtbygoKCk9PmkoKSksW2ldKSxsPVAudXNlUmVmKCksYz1QLnVzZU1lbW8oKCgpPT5cInhcIj09PWU/XCJhZGRQbGFuZVhcIjpcInlcIj09PWU/XCJhZGRQbGFuZVlcIjpcImFkZFBsYW5lWlwiKSxbZV0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3MuY3VycmVudCYmbC5jdXJyZW50JiZzLmN1cnJlbnRbY10odCxyKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLEMuZGVmYXVsdCh7cmVmOmsuZGVmYXVsdChbbyxsXSl9LG4pKX0pKTtmdW5jdGlvbiBIZShlPVswLDAsMF0pe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKX0oZSk/ZTplIGluc3RhbmNlb2YgRC5WZWN0b3IzfHxlIGluc3RhbmNlb2YgRC5FdWxlcj9bZS54LGUueSxlLnpdOltlLGUsZV19Y29uc3QgJGU9UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7ZGVidWc6ZSxkZXB0aFRlc3Q6dD0hMSxwb2x5Z29uT2Zmc2V0RmFjdG9yOnI9LTEwLG1hcDpuLG1lc2g6byxjaGlsZHJlbjppLHBvc2l0aW9uOnMscm90YXRpb246bCxzY2FsZTpjLC4uLnV9LG0pe2NvbnN0IGY9UC51c2VSZWYobnVsbCk7UC51c2VJbXBlcmF0aXZlSGFuZGxlKG0sKCgpPT5mLmN1cnJlbnQpKTtjb25zdCBwPVAudXNlUmVmKG51bGwpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCBlPShudWxsPT1vP3ZvaWQgMDpvLmN1cnJlbnQpfHxmLmN1cnJlbnQucGFyZW50LHQ9Zi5jdXJyZW50O2lmKCEoZSBpbnN0YW5jZW9mIEQuTWVzaCkpdGhyb3cgbmV3IEVycm9yKCdEZWNhbCBtdXN0IGhhdmUgYSBNZXNoIGFzIHBhcmVudCBvciBzcGVjaWZ5IGl0cyBcIm1lc2hcIiBwcm9wJyk7Y29uc3Qgcj17cG9zaXRpb246bmV3IEQuVmVjdG9yMyxyb3RhdGlvbjpuZXcgRC5FdWxlcixzY2FsZTpuZXcgRC5WZWN0b3IzKDEsMSwxKX07aWYoZSl7YS5hcHBseVByb3BzKHIse3Bvc2l0aW9uOnMsc2NhbGU6Y30pO2NvbnN0IG49ZS5tYXRyaXhXb3JsZC5jbG9uZSgpO2lmKGUubWF0cml4V29ybGQuaWRlbnRpdHkoKSxsJiZcIm51bWJlclwiIT10eXBlb2YgbClhLmFwcGx5UHJvcHMocix7cm90YXRpb246bH0pO2Vsc2V7Y29uc3QgdD1uZXcgRC5PYmplY3QzRDt0LnBvc2l0aW9uLmNvcHkoci5wb3NpdGlvbiksdC5sb29rQXQoZS5wb3NpdGlvbiksXCJudW1iZXJcIj09dHlwZW9mIGwmJnQucm90YXRlWihsKSxhLmFwcGx5UHJvcHMocix7cm90YXRpb246dC5yb3RhdGlvbn0pfXJldHVybiB0Lmdlb21ldHJ5PW5ldyBkLkRlY2FsR2VvbWV0cnkoZSxyLnBvc2l0aW9uLHIucm90YXRpb24sci5zY2FsZSkscC5jdXJyZW50JiYoYS5hcHBseVByb3BzKHAuY3VycmVudCxyKSxwLmN1cnJlbnQudHJhdmVyc2UoKGU9PmUucmF5Y2FzdD0oKT0+bnVsbCkpKSxlLm1hdHJpeFdvcmxkPW4sKCk9Pnt0Lmdlb21ldHJ5LmRpc3Bvc2UoKX19fSksW28sLi4uSGUocyksLi4uSGUoYyksLi4uSGUobCldKSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZWY6ZixcIm1hdGVyaWFsLXRyYW5zcGFyZW50XCI6ITAsXCJtYXRlcmlhbC1wb2x5Z29uT2Zmc2V0XCI6ITAsXCJtYXRlcmlhbC1wb2x5Z29uT2Zmc2V0RmFjdG9yXCI6cixcIm1hdGVyaWFsLWRlcHRoVGVzdFwiOnQsXCJtYXRlcmlhbC1tYXBcIjpufSx1KSxpLGUmJlAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOnB9LFAuY3JlYXRlRWxlbWVudChcImJveEdlb21ldHJ5XCIsbnVsbCksUC5jcmVhdGVFbGVtZW50KFwibWVzaE5vcm1hbE1hdGVyaWFsXCIse3dpcmVmcmFtZTohMH0pLFAuY3JlYXRlRWxlbWVudChcImF4ZXNIZWxwZXJcIixudWxsKSkpfSkpLHFlPXQuZm9yd2FyZFJlZigoZnVuY3Rpb24oe3NyYzplLHNraXBGaWxsOnIsc2tpcFN0cm9rZXM6byxmaWxsTWF0ZXJpYWw6aSxzdHJva2VNYXRlcmlhbDpzLGZpbGxNZXNoUHJvcHM6bCxzdHJva2VNZXNoUHJvcHM6YywuLi51fSxtKXtjb25zdCBmPWEudXNlTG9hZGVyKGQuU1ZHTG9hZGVyLGUuc3RhcnRzV2l0aChcIjxzdmdcIik/YGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7ZX1gOmUpLHA9dC51c2VNZW1vKCgoKT0+bz9bXTpmLnBhdGhzLm1hcCgoZT0+e3ZhciB0O3JldHVybiB2b2lkIDA9PT0obnVsbD09KHQ9ZS51c2VyRGF0YSk/dm9pZCAwOnQuc3R5bGUuc3Ryb2tlKXx8XCJub25lXCI9PT1lLnVzZXJEYXRhLnN0eWxlLnN0cm9rZT9udWxsOmUuc3ViUGF0aHMubWFwKCh0PT5kLlNWR0xvYWRlci5wb2ludHNUb1N0cm9rZSh0LmdldFBvaW50cygpLGUudXNlckRhdGEuc3R5bGUpKSl9KSkpLFtmLG9dKTtyZXR1cm4gdC51c2VFZmZlY3QoKCgpPT4oKT0+cC5mb3JFYWNoKChlPT5lJiZlLm1hcCgoZT0+ZS5kaXNwb3NlKCkpKSkpKSxbcF0pLFAuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsQy5kZWZhdWx0KHtyZWY6bX0sdSksUC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIix7c2NhbGU6WzEsLTEsMV19LGYucGF0aHMubWFwKCgoZSxhKT0+e3ZhciB1LG07cmV0dXJuIFAuY3JlYXRlRWxlbWVudCh0LkZyYWdtZW50LHtrZXk6YX0sIXImJnZvaWQgMCE9PShudWxsPT0odT1lLnVzZXJEYXRhKT92b2lkIDA6dS5zdHlsZS5maWxsKSYmXCJub25lXCIhPT1lLnVzZXJEYXRhLnN0eWxlLmZpbGwmJmQuU1ZHTG9hZGVyLmNyZWF0ZVNoYXBlcyhlKS5tYXAoKCh0LHIpPT5QLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtrZXk6cn0sbCksUC5jcmVhdGVFbGVtZW50KFwic2hhcGVHZW9tZXRyeVwiLHthcmdzOlt0XX0pLFAuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIsQy5kZWZhdWx0KHtjb2xvcjplLnVzZXJEYXRhLnN0eWxlLmZpbGwsb3BhY2l0eTplLnVzZXJEYXRhLnN0eWxlLmZpbGxPcGFjaXR5LHRyYW5zcGFyZW50OiEwLHNpZGU6bi5Eb3VibGVTaWRlLGRlcHRoV3JpdGU6ITF9LGkpKSkpKSwhbyYmdm9pZCAwIT09KG51bGw9PShtPWUudXNlckRhdGEpP3ZvaWQgMDptLnN0eWxlLnN0cm9rZSkmJlwibm9uZVwiIT09ZS51c2VyRGF0YS5zdHlsZS5zdHJva2UmJmUuc3ViUGF0aHMubWFwKCgodCxyKT0+UC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLEMuZGVmYXVsdCh7a2V5OnIsZ2VvbWV0cnk6cFthXVtyXX0sYyksUC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIixDLmRlZmF1bHQoe2NvbG9yOmUudXNlckRhdGEuc3R5bGUuc3Ryb2tlLG9wYWNpdHk6ZS51c2VyRGF0YS5zdHlsZS5zdHJva2VPcGFjaXR5LHRyYW5zcGFyZW50OiEwLHNpZGU6bi5Eb3VibGVTaWRlLGRlcHRoV3JpdGU6ITF9LHMpKSkpKSl9KSkpKX0pKTtsZXQgWGU9bnVsbCxaZT1cImh0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2RyYWNvL3ZlcnNpb25lZC9kZWNvZGVycy8xLjUuNS9cIjtmdW5jdGlvbiBZZShlLHQscil7cmV0dXJuIG49PntyJiZyKG4pLGUmJihYZXx8KFhlPW5ldyBkLkRSQUNPTG9hZGVyKSxYZS5zZXREZWNvZGVyUGF0aChcInN0cmluZ1wiPT10eXBlb2YgZT9lOlplKSxuLnNldERSQUNPTG9hZGVyKFhlKSksdCYmbi5zZXRNZXNob3B0RGVjb2RlcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLk1lc2hvcHREZWNvZGVyP2QuTWVzaG9wdERlY29kZXIoKTpkLk1lc2hvcHREZWNvZGVyKX19ZnVuY3Rpb24gUWUoZSx0PSEwLHI9ITAsbil7cmV0dXJuIGEudXNlTG9hZGVyKGQuR0xURkxvYWRlcixlLFllKHQscixuKSl9UWUucHJlbG9hZD0oZSx0PSEwLHI9ITAsbik9PmEudXNlTG9hZGVyLnByZWxvYWQoZC5HTFRGTG9hZGVyLGUsWWUodCxyLG4pKSxRZS5jbGVhcj1lPT5hLnVzZUxvYWRlci5jbGVhcihkLkdMVEZMb2FkZXIsZSksUWUuc2V0RGVjb2RlclBhdGg9ZT0+e1plPWV9O2NvbnN0IEtlPVAuZm9yd2FyZFJlZigoKHtzcmM6ZSwuLi50fSxyKT0+e2NvbnN0e3NjZW5lOm59PVFlKGUpO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoT2UsQy5kZWZhdWx0KHtyZWY6cn0sdCx7b2JqZWN0Om59KSl9KSk7Y29uc3QgSmU9RWUoe2FscGhhVGVzdDowLHZpZXdwb3J0Om5ldyBELlZlY3RvcjIoMTk4MCwxMDgwKSxmb2NhbDoxZTMsY2VudGVyQW5kU2NhbGVUZXh0dXJlOm51bGwsY292QW5kQ29sb3JUZXh0dXJlOm51bGx9LFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkQ7XFxuICAgIHByZWNpc2lvbiBoaWdocCB1c2FtcGxlcjJEO1xcbiAgICBvdXQgdmVjNCB2Q29sb3I7XFxuICAgIG91dCB2ZWMzIHZQb3NpdGlvbjtcXG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuICAgIHVuaWZvcm0gdmVjMiB2aWV3cG9ydDtcXG4gICAgdW5pZm9ybSBmbG9hdCBmb2NhbDtcXG4gICAgYXR0cmlidXRlIHVpbnQgc3BsYXRJbmRleDtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2VudGVyQW5kU2NhbGVUZXh0dXJlO1xcbiAgICB1bmlmb3JtIHVzYW1wbGVyMkQgY292QW5kQ29sb3JUZXh0dXJlOyAgICBcXG5cXG4gICAgdmVjMiB1bnBhY2tJbnQxNihpbiB1aW50IHZhbHVlKSB7XFxuICAgICAgaW50IHYgPSBpbnQodmFsdWUpO1xcbiAgICAgIGludCB2MCA9IHYgPj4gMTY7XFxuICAgICAgaW50IHYxID0gKHYgJiAweEZGRkYpO1xcbiAgICAgIGlmKCh2ICYgMHg4MDAwKSAhPSAwKVxcbiAgICAgICAgdjEgfD0gMHhGRkZGMDAwMDtcXG4gICAgICByZXR1cm4gdmVjMihmbG9hdCh2MSksIGZsb2F0KHYwKSk7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluICgpIHtcXG4gICAgICBpdmVjMiB0ZXhTaXplID0gdGV4dHVyZVNpemUoY2VudGVyQW5kU2NhbGVUZXh0dXJlLCAwKTtcXG4gICAgICBpdmVjMiB0ZXhQb3MgPSBpdmVjMihzcGxhdEluZGV4JXVpbnQodGV4U2l6ZS54KSwgc3BsYXRJbmRleC91aW50KHRleFNpemUueCkpO1xcbiAgICAgIHZlYzQgY2VudGVyQW5kU2NhbGVEYXRhID0gdGV4ZWxGZXRjaChjZW50ZXJBbmRTY2FsZVRleHR1cmUsIHRleFBvcywgMCk7XFxuICAgICAgdmVjNCBjZW50ZXIgPSB2ZWM0KGNlbnRlckFuZFNjYWxlRGF0YS54eXosIDEpO1xcbiAgICAgIHZlYzQgY2Ftc3BhY2UgPSBtb2RlbFZpZXdNYXRyaXggKiBjZW50ZXI7XFxuICAgICAgdmVjNCBwb3MyZCA9IHByb2plY3Rpb25NYXRyaXggKiBjYW1zcGFjZTtcXG5cXG4gICAgICBmbG9hdCBib3VuZHMgPSAxLjIgKiBwb3MyZC53O1xcbiAgICAgIGlmIChwb3MyZC56IDwgLXBvczJkLncgfHwgcG9zMmQueCA8IC1ib3VuZHMgfHwgcG9zMmQueCA+IGJvdW5kc1xcbiAgICAgICAgfHwgcG9zMmQueSA8IC1ib3VuZHMgfHwgcG9zMmQueSA+IGJvdW5kcykge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDAuMCwgMC4wLCAyLjAsIDEuMCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHV2ZWM0IGNvdkFuZENvbG9yRGF0YSA9IHRleGVsRmV0Y2goY292QW5kQ29sb3JUZXh0dXJlLCB0ZXhQb3MsIDApO1xcbiAgICAgIHZlYzIgY292M0RfTTExX00xMiA9IHVucGFja0ludDE2KGNvdkFuZENvbG9yRGF0YS54KSAqIGNlbnRlckFuZFNjYWxlRGF0YS53O1xcbiAgICAgIHZlYzIgY292M0RfTTEzX00yMiA9IHVucGFja0ludDE2KGNvdkFuZENvbG9yRGF0YS55KSAqIGNlbnRlckFuZFNjYWxlRGF0YS53O1xcbiAgICAgIHZlYzIgY292M0RfTTIzX00zMyA9IHVucGFja0ludDE2KGNvdkFuZENvbG9yRGF0YS56KSAqIGNlbnRlckFuZFNjYWxlRGF0YS53O1xcbiAgICAgIG1hdDMgVnJrID0gbWF0MyhcXG4gICAgICAgIGNvdjNEX00xMV9NMTIueCwgY292M0RfTTExX00xMi55LCBjb3YzRF9NMTNfTTIyLngsXFxuICAgICAgICBjb3YzRF9NMTFfTTEyLnksIGNvdjNEX00xM19NMjIueSwgY292M0RfTTIzX00zMy54LFxcbiAgICAgICAgY292M0RfTTEzX00yMi54LCBjb3YzRF9NMjNfTTMzLngsIGNvdjNEX00yM19NMzMueVxcbiAgICAgICk7XFxuXFxuICAgICAgbWF0MyBKID0gbWF0MyhcXG4gICAgICAgIGZvY2FsIC8gY2Ftc3BhY2UueiwgMC4sIC0oZm9jYWwgKiBjYW1zcGFjZS54KSAvIChjYW1zcGFjZS56ICogY2Ftc3BhY2UueiksXFxuICAgICAgICAwLiwgZm9jYWwgLyBjYW1zcGFjZS56LCAtKGZvY2FsICogY2Ftc3BhY2UueSkgLyAoY2Ftc3BhY2UueiAqIGNhbXNwYWNlLnopLFxcbiAgICAgICAgMC4sIDAuLCAwLlxcbiAgICAgICk7XFxuXFxuICAgICAgbWF0MyBXID0gdHJhbnNwb3NlKG1hdDMobW9kZWxWaWV3TWF0cml4KSk7XFxuICAgICAgbWF0MyBUID0gVyAqIEo7XFxuICAgICAgbWF0MyBjb3YgPSB0cmFuc3Bvc2UoVCkgKiBWcmsgKiBUO1xcbiAgICAgIHZlYzIgdkNlbnRlciA9IHZlYzIocG9zMmQpIC8gcG9zMmQudztcXG4gICAgICBmbG9hdCBkaWFnb25hbDEgPSBjb3ZbMF1bMF0gKyAwLjM7XFxuICAgICAgZmxvYXQgb2ZmRGlhZ29uYWwgPSBjb3ZbMF1bMV07XFxuICAgICAgZmxvYXQgZGlhZ29uYWwyID0gY292WzFdWzFdICsgMC4zO1xcbiAgICAgIGZsb2F0IG1pZCA9IDAuNSAqIChkaWFnb25hbDEgKyBkaWFnb25hbDIpO1xcbiAgICAgIGZsb2F0IHJhZGl1cyA9IGxlbmd0aCh2ZWMyKChkaWFnb25hbDEgLSBkaWFnb25hbDIpIC8gMi4wLCBvZmZEaWFnb25hbCkpO1xcbiAgICAgIGZsb2F0IGxhbWJkYTEgPSBtaWQgKyByYWRpdXM7XFxuICAgICAgZmxvYXQgbGFtYmRhMiA9IG1heChtaWQgLSByYWRpdXMsIDAuMSk7XFxuICAgICAgdmVjMiBkaWFnb25hbFZlY3RvciA9IG5vcm1hbGl6ZSh2ZWMyKG9mZkRpYWdvbmFsLCBsYW1iZGExIC0gZGlhZ29uYWwxKSk7XFxuICAgICAgdmVjMiB2MSA9IG1pbihzcXJ0KDIuMCAqIGxhbWJkYTEpLCAxMDI0LjApICogZGlhZ29uYWxWZWN0b3I7XFxuICAgICAgdmVjMiB2MiA9IG1pbihzcXJ0KDIuMCAqIGxhbWJkYTIpLCAxMDI0LjApICogdmVjMihkaWFnb25hbFZlY3Rvci55LCAtZGlhZ29uYWxWZWN0b3IueCk7XFxuICAgICAgdWludCBjb2xvclVpbnQgPSBjb3ZBbmRDb2xvckRhdGEudztcXG4gICAgICB2Q29sb3IgPSB2ZWM0KFxcbiAgICAgICAgZmxvYXQoY29sb3JVaW50ICYgdWludCgweEZGKSkgLyAyNTUuMCxcXG4gICAgICAgIGZsb2F0KChjb2xvclVpbnQgPj4gdWludCg4KSkgJiB1aW50KDB4RkYpKSAvIDI1NS4wLFxcbiAgICAgICAgZmxvYXQoKGNvbG9yVWludCA+PiB1aW50KDE2KSkgJiB1aW50KDB4RkYpKSAvIDI1NS4wLFxcbiAgICAgICAgZmxvYXQoY29sb3JVaW50ID4+IHVpbnQoMjQpKSAvIDI1NS4wXFxuICAgICAgKTtcXG4gICAgICB2UG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICAgICB2Q2VudGVyIFxcbiAgICAgICAgICArIHBvc2l0aW9uLnggKiB2MiAvIHZpZXdwb3J0ICogMi4wIFxcbiAgICAgICAgICArIHBvc2l0aW9uLnkgKiB2MSAvIHZpZXdwb3J0ICogMi4wLCBwb3MyZC56IC8gcG9zMmQudywgMS4wKTtcXG4gICAgfVxcbiAgICBcIixgXFxuICAgICNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4gICAgI2luY2x1ZGUgPGFscGhhaGFzaF9wYXJzX2ZyYWdtZW50PlxcbiAgICBpbiB2ZWM0IHZDb2xvcjtcXG4gICAgaW4gdmVjMyB2UG9zaXRpb247XFxuICAgIHZvaWQgbWFpbiAoKSB7XFxuICAgICAgZmxvYXQgQSA9IC1kb3QodlBvc2l0aW9uLnh5LCB2UG9zaXRpb24ueHkpO1xcbiAgICAgIGlmIChBIDwgLTQuMCkgZGlzY2FyZDtcXG4gICAgICBmbG9hdCBCID0gZXhwKEEpICogdkNvbG9yLmE7XFxuICAgICAgdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KHZDb2xvci5yZ2IsIEIpO1xcbiAgICAgICNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuICAgICAgI2luY2x1ZGUgPGFscGhhaGFzaF9mcmFnbWVudD5cXG4gICAgICBnbF9GcmFnQ29sb3IgPSBkaWZmdXNlQ29sb3I7XFxuICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICNpbmNsdWRlIDwke3BhcnNlSW50KEQuUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLFwiXCIpKT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICB9XFxuICBgKTtmdW5jdGlvbiBldChlKXtsZXQgdD1udWxsLHI9MDtlLm9ubWVzc2FnZT1uPT57aWYoXCJwdXNoXCI9PW4uZGF0YS5tZXRob2QpezA9PT1yJiYodD1uZXcgRmxvYXQzMkFycmF5KG4uZGF0YS5sZW5ndGgpKTtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkobi5kYXRhLm1hdHJpY2VzKTt0LnNldChlLHIpLHIrPWUubGVuZ3RofWVsc2UgaWYoXCJzb3J0XCI9PW4uZGF0YS5tZXRob2QmJm51bGwhPT10KXtjb25zdCByPWZ1bmN0aW9uKGUscj0hMSl7Y29uc3Qgbj10Lmxlbmd0aC8xNjtsZXQgYT0tMS8wLG89MS8wO2NvbnN0IGk9bmV3IEZsb2F0MzJBcnJheShuKSxzPW5ldyBJbnQzMkFycmF5KGkuYnVmZmVyKSxsPW5ldyBJbnQzMkFycmF5KG4pO2xldCBjPTA7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj1lWzBdKnRbMTYqcysxMl0rZVsxXSp0WzE2KnMrMTNdK2VbMl0qdFsxNipzKzE0XStlWzNdOyhyfHxuPDAmJnRbMTYqcysxNV0+LTFlLTQqbikmJihpW2NdPW4sbFtjXT1zLGMrKyxuPmEmJihhPW4pLG48byYmKG89bikpfWNvbnN0IHU9NjU1MzUvKGEtbyksZD1uZXcgVWludDMyQXJyYXkoNjU1MzYpO2ZvcihsZXQgZT0wO2U8YztlKyspc1tlXT0oaVtlXS1vKSp1fDAsZFtzW2VdXSsrO2NvbnN0IG09bmV3IFVpbnQzMkFycmF5KDY1NTM2KTtmb3IobGV0IGU9MTtlPDY1NTM2O2UrKyltW2VdPW1bZS0xXStkW2UtMV07Y29uc3QgZj1uZXcgVWludDMyQXJyYXkoYyk7Zm9yKGxldCBlPTA7ZTxjO2UrKylmW21bc1tlXV0rK109bFtlXTtyZXR1cm4gZn0obmV3IEZsb2F0MzJBcnJheShuLmRhdGEudmlldyksbi5kYXRhLmhhc2hlZCk7ZS5wb3N0TWVzc2FnZSh7aW5kaWNlczpyLGtleTpuLmRhdGEua2V5fSxbci5idWZmZXJdKX19fWNsYXNzIHR0IGV4dGVuZHMgRC5Mb2FkZXJ7Y29uc3RydWN0b3IoLi4uZSl7c3VwZXIoLi4uZSksdGhpcy5nbD1udWxsLHRoaXMuY2h1bmtTaXplPTI1ZTN9bG9hZChlLHQscixuKXtjb25zdCBhPXtnbDp0aGlzLmdsLHVybDp0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTChlKSx3b3JrZXI6bmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcIihcIixldC50b1N0cmluZygpLFwiKShzZWxmKVwiXSx7dHlwZTpcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn0pKSksbWFuYWdlcjp0aGlzLm1hbmFnZXIsdXBkYXRlOihlLHQscik9PmZ1bmN0aW9uKGUsdCxyLG4pe2lmKGUudXBkYXRlTWF0cml4V29ybGQoKSx0LmdsLmdldEN1cnJlbnRWaWV3cG9ydChyLnZpZXdwb3J0KSxyLm1hdGVyaWFsLnZpZXdwb3J0Lng9ci52aWV3cG9ydC56LHIubWF0ZXJpYWwudmlld3BvcnQueT1yLnZpZXdwb3J0Lncsci5tYXRlcmlhbC5mb2NhbD1yLnZpZXdwb3J0LncvMipNYXRoLmFicyhlLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbNV0pLHIucmVhZHkpe2lmKG4mJnIuc29ydGVkKXJldHVybjtyLnJlYWR5PSExO2NvbnN0IGU9bmV3IEZsb2F0MzJBcnJheShbci5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbMl0sLXIubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWzZdLHIubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWzEwXSxyLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sxNF1dKTt0Lndvcmtlci5wb3N0TWVzc2FnZSh7bWV0aG9kOlwic29ydFwiLHNyYzp0LnVybCxrZXk6ci51dWlkLHZpZXc6ZS5idWZmZXIsaGFzaGVkOm59LFtlLmJ1ZmZlcl0pLG4mJnQubG9hZGVkJiYoci5zb3J0ZWQ9ITApfX0odCxhLGUsciksY29ubmVjdDplPT5mdW5jdGlvbihlLHQpe2UubG9hZGluZ3x8YXN5bmMgZnVuY3Rpb24oZSl7ZS5sb2FkaW5nPSEwO2xldCB0PTAscj0wO2NvbnN0IG49W107bGV0IGE9MDtjb25zdCBvPTAhPT1lLnRvdGFsRG93bmxvYWRCeXRlcztmb3IoOzspdHJ5e2NvbnN0e3ZhbHVlOmksZG9uZTpzfT1hd2FpdCBlLnN0cmVhbS5yZWFkKCk7aWYocylicmVhaztpZih0Kz1pLmxlbmd0aCxudWxsIT1lLnRvdGFsRG93bmxvYWRCeXRlcyl7Y29uc3Qgcj10L2UudG90YWxEb3dubG9hZEJ5dGVzKjEwMDtpZihlLm9uUHJvZ3Jlc3MmJnItYT4xKXtjb25zdCBuPW5ldyBQcm9ncmVzc0V2ZW50KFwicHJvZ3Jlc3NcIix7bGVuZ3RoQ29tcHV0YWJsZTpvLGxvYWRlZDp0LHRvdGFsOmUudG90YWxEb3dubG9hZEJ5dGVzfSk7ZS5vblByb2dyZXNzKG4pLGE9cn19bi5wdXNoKGkpO2NvbnN0IGw9dC1yO2lmKG51bGwhPWUudG90YWxEb3dubG9hZEJ5dGVzJiZsPmUucm93TGVuZ3RoKmUuY2h1bmtTaXplKXtsZXQgdD1NYXRoLmZsb29yKGwvZS5yb3dMZW5ndGgpO2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkobCk7bGV0IGk9MDtmb3IoY29uc3QgZSBvZiBuKWEuc2V0KGUsaSksaSs9ZS5sZW5ndGg7aWYobi5sZW5ndGg9MCxsPnQqZS5yb3dMZW5ndGgpe2NvbnN0IHI9bmV3IFVpbnQ4QXJyYXkobC10KmUucm93TGVuZ3RoKTtyLnNldChhLnN1YmFycmF5KGwtci5sZW5ndGgsbCksMCksbi5wdXNoKHIpfWNvbnN0IHM9bmV3IFVpbnQ4QXJyYXkodCplLnJvd0xlbmd0aCk7cy5zZXQoYS5zdWJhcnJheSgwLHMuYnl0ZUxlbmd0aCksMCk7Y29uc3QgYz1ydChlLHMuYnVmZmVyLHQpO2lmKGUud29ya2VyLnBvc3RNZXNzYWdlKHttZXRob2Q6XCJwdXNoXCIsc3JjOmUudXJsLGxlbmd0aDoxNiplLm51bVZlcnRpY2VzLG1hdHJpY2VzOmMuYnVmZmVyfSxbYy5idWZmZXJdKSxyKz10KmUucm93TGVuZ3RoLGUub25Qcm9ncmVzcyl7Y29uc3QgdD1uZXcgUHJvZ3Jlc3NFdmVudChcInByb2dyZXNzXCIse2xlbmd0aENvbXB1dGFibGU6byxsb2FkZWQ6ZS50b3RhbERvd25sb2FkQnl0ZXMsdG90YWw6ZS50b3RhbERvd25sb2FkQnl0ZXN9KTtlLm9uUHJvZ3Jlc3ModCl9fX1jYXRjaChlKXtjb25zb2xlLmVycm9yKGUpO2JyZWFrfWlmKHQtcj4wKXtsZXQgdD1uZXcgVWludDhBcnJheShuLnJlZHVjZSgoKGUsdCk9PmUrdC5sZW5ndGgpLDApKSxyPTA7Zm9yKGNvbnN0IGUgb2Ygbil0LnNldChlLHIpLHIrPWUubGVuZ3RoO2xldCBhPU1hdGguZmxvb3IodC5ieXRlTGVuZ3RoL2Uucm93TGVuZ3RoKTtjb25zdCBvPXJ0KGUsdC5idWZmZXIsYSk7ZS53b3JrZXIucG9zdE1lc3NhZ2Uoe21ldGhvZDpcInB1c2hcIixzcmM6ZS51cmwsbGVuZ3RoOjE2KmEsbWF0cmljZXM6by5idWZmZXJ9LFtvLmJ1ZmZlcl0pfWUubG9hZGVkPSEwLGUubWFuYWdlci5pdGVtRW5kKGUudXJsKX0oZSk7dC5yZWFkeT0hMSx0LnBtPW5ldyBELk1hdHJpeDQsdC52bTE9bmV3IEQuTWF0cml4NCx0LnZtMj1uZXcgRC5NYXRyaXg0LHQudmlld3BvcnQ9bmV3IEQuVmVjdG9yNDtsZXQgcj1uZXcgVWludDMyQXJyYXkoZS5idWZmZXJUZXh0dXJlV2lkdGgqZS5idWZmZXJUZXh0dXJlSGVpZ2h0KTtjb25zdCBuPW5ldyBELkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShyLDEsITEpO24uc2V0VXNhZ2UoRC5EeW5hbWljRHJhd1VzYWdlKTtjb25zdCBhPXQuZ2VvbWV0cnk9bmV3IEQuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksbz1uZXcgRmxvYXQzMkFycmF5KDE4KSxpPW5ldyBELkJ1ZmZlckF0dHJpYnV0ZShvLDMpO2Z1bmN0aW9uIHMoZSl7aWYodCYmZS5kYXRhLmtleT09PXQudXVpZCl7bGV0IHI9bmV3IFVpbnQzMkFycmF5KGUuZGF0YS5pbmRpY2VzKTthLmF0dHJpYnV0ZXMuc3BsYXRJbmRleC5zZXQociksYS5hdHRyaWJ1dGVzLnNwbGF0SW5kZXgubmVlZHNVcGRhdGU9ITAsYS5pbnN0YW5jZUNvdW50PXIubGVuZ3RoLHQucmVhZHk9ITB9fWFzeW5jIGZ1bmN0aW9uIGwoKXtmb3IoOzspe2NvbnN0IHQ9ZS5nbC5wcm9wZXJ0aWVzLmdldChlLmNlbnRlckFuZFNjYWxlVGV4dHVyZSkscj1lLmdsLnByb3BlcnRpZXMuZ2V0KGUuY292QW5kQ29sb3JUZXh0dXJlKTtpZihudWxsIT10JiZ0Ll9fd2ViZ2xUZXh0dXJlJiZudWxsIT1yJiZyLl9fd2ViZ2xUZXh0dXJlJiZlLmxvYWRlZFZlcnRleENvdW50PjApYnJlYWs7YXdhaXQgbmV3IFByb21pc2UoKGU9PnNldFRpbWVvdXQoZSwxMCkpKX10LnJlYWR5PSEwfXJldHVybiBhLnNldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIsaSksaS5zZXRYWVooMiwtMiwyLDApLGkuc2V0WFlaKDEsMiwyLDApLGkuc2V0WFlaKDAsLTIsLTIsMCksaS5zZXRYWVooNSwtMiwtMiwwKSxpLnNldFhZWig0LDIsMiwwKSxpLnNldFhZWigzLDIsLTIsMCksaS5uZWVkc1VwZGF0ZT0hMCxhLnNldEF0dHJpYnV0ZShcInNwbGF0SW5kZXhcIixuKSxhLmluc3RhbmNlQ291bnQ9MSxlLndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHMpLGwoKSwoKT0+ZS53b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixzKX0oYSxlKSxsb2FkaW5nOiExLGxvYWRlZDohMSxsb2FkZWRWZXJ0ZXhDb3VudDowLGNodW5rU2l6ZTp0aGlzLmNodW5rU2l6ZSx0b3RhbERvd25sb2FkQnl0ZXM6MCxudW1WZXJ0aWNlczowLHJvd0xlbmd0aDozMixtYXhWZXJ0ZXhlczowLGJ1ZmZlclRleHR1cmVXaWR0aDowLGJ1ZmZlclRleHR1cmVIZWlnaHQ6MCxzdHJlYW06bnVsbCxjZW50ZXJBbmRTY2FsZURhdGE6bnVsbCxjb3ZBbmRDb2xvckRhdGE6bnVsbCxjb3ZBbmRDb2xvclRleHR1cmU6bnVsbCxjZW50ZXJBbmRTY2FsZVRleHR1cmU6bnVsbCxvblByb2dyZXNzOnJ9Oyhhc3luYyBmdW5jdGlvbihlKXtlLm1hbmFnZXIuaXRlbVN0YXJ0KGUudXJsKTtjb25zdCB0PWF3YWl0IGZldGNoKGUudXJsKTtpZihudWxsPT09dC5ib2R5KXRocm93XCJGYWlsZWQgdG8gZmV0Y2ggZmlsZVwiO2xldCByPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKTtjb25zdCBuPXI/cGFyc2VJbnQocik6dm9pZCAwO2lmKG51bGw9PW4pdGhyb3dcIkZhaWxlZCB0byBnZXQgY29udGVudCBsZW5ndGhcIjtlLnN0cmVhbT10LmJvZHkuZ2V0UmVhZGVyKCksZS50b3RhbERvd25sb2FkQnl0ZXM9bixlLm51bVZlcnRpY2VzPU1hdGguZmxvb3IoZS50b3RhbERvd25sb2FkQnl0ZXMvZS5yb3dMZW5ndGgpO2NvbnN0IGE9ZS5nbC5nZXRDb250ZXh0KCk7bGV0IG89YS5nZXRQYXJhbWV0ZXIoYS5NQVhfVEVYVFVSRV9TSVpFKTtlLm1heFZlcnRleGVzPW8qbyxlLm51bVZlcnRpY2VzPmUubWF4VmVydGV4ZXMmJihlLm51bVZlcnRpY2VzPWUubWF4VmVydGV4ZXMpO3JldHVybiBlLmJ1ZmZlclRleHR1cmVXaWR0aD1vLGUuYnVmZmVyVGV4dHVyZUhlaWdodD1NYXRoLmZsb29yKChlLm51bVZlcnRpY2VzLTEpL28pKzEsZS5jZW50ZXJBbmRTY2FsZURhdGE9bmV3IEZsb2F0MzJBcnJheShlLmJ1ZmZlclRleHR1cmVXaWR0aCplLmJ1ZmZlclRleHR1cmVIZWlnaHQqNCksZS5jb3ZBbmRDb2xvckRhdGE9bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyVGV4dHVyZVdpZHRoKmUuYnVmZmVyVGV4dHVyZUhlaWdodCo0KSxlLmNlbnRlckFuZFNjYWxlVGV4dHVyZT1uZXcgRC5EYXRhVGV4dHVyZShlLmNlbnRlckFuZFNjYWxlRGF0YSxlLmJ1ZmZlclRleHR1cmVXaWR0aCxlLmJ1ZmZlclRleHR1cmVIZWlnaHQsRC5SR0JBRm9ybWF0LEQuRmxvYXRUeXBlKSxlLmNlbnRlckFuZFNjYWxlVGV4dHVyZS5uZWVkc1VwZGF0ZT0hMCxlLmNvdkFuZENvbG9yVGV4dHVyZT1uZXcgRC5EYXRhVGV4dHVyZShlLmNvdkFuZENvbG9yRGF0YSxlLmJ1ZmZlclRleHR1cmVXaWR0aCxlLmJ1ZmZlclRleHR1cmVIZWlnaHQsRC5SR0JBSW50ZWdlckZvcm1hdCxELlVuc2lnbmVkSW50VHlwZSksZS5jb3ZBbmRDb2xvclRleHR1cmUuaW50ZXJuYWxGb3JtYXQ9XCJSR0JBMzJVSVwiLGUuY292QW5kQ29sb3JUZXh0dXJlLm5lZWRzVXBkYXRlPSEwLGV9KShhKS50aGVuKHQpLmNhdGNoKChlPT57bnVsbD09bnx8bihlKSxhLm1hbmFnZXIuaXRlbUVycm9yKGEudXJsKX0pKX19ZnVuY3Rpb24gcnQoZSx0LHIpe2NvbnN0IG49ZS5nbC5nZXRDb250ZXh0KCk7aWYoZS5sb2FkZWRWZXJ0ZXhDb3VudCtyPmUubWF4VmVydGV4ZXMmJihyPWUubWF4VmVydGV4ZXMtZS5sb2FkZWRWZXJ0ZXhDb3VudCkscjw9MCl0aHJvd1wiRmFpbGVkIHRvIHBhcnNlIGZpbGVcIjtjb25zdCBhPW5ldyBVaW50OEFycmF5KHQpLG89bmV3IEZsb2F0MzJBcnJheSh0KSxpPW5ldyBGbG9hdDMyQXJyYXkoMTYqcikscz1uZXcgVWludDhBcnJheShlLmNvdkFuZENvbG9yRGF0YS5idWZmZXIpLGw9bmV3IEludDE2QXJyYXkoZS5jb3ZBbmRDb2xvckRhdGEuYnVmZmVyKTtmb3IobGV0IHQ9MDt0PHI7dCsrKXtjb25zdCByPW5ldyBELlF1YXRlcm5pb24oLShhWzMyKnQrMjgrMV0tMTI4KS8xMjgsKGFbMzIqdCsyOCsyXS0xMjgpLzEyOCwoYVszMip0KzI4KzNdLTEyOCkvMTI4LC0oYVszMip0KzI4KzBdLTEyOCkvMTI4KTtyLmludmVydCgpO2NvbnN0IG49bmV3IEQuVmVjdG9yMyhvWzgqdCswXSxvWzgqdCsxXSwtb1s4KnQrMl0pLGM9bmV3IEQuVmVjdG9yMyhvWzgqdCszKzBdLG9bOCp0KzMrMV0sb1s4KnQrMysyXSksdT1uZXcgRC5NYXRyaXg0O3UubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ociksdS50cmFuc3Bvc2UoKSx1LnNjYWxlKGMpO2NvbnN0IGQ9dS5jbG9uZSgpO3UudHJhbnNwb3NlKCksdS5wcmVtdWx0aXBseShkKSx1LnNldFBvc2l0aW9uKG4pO2NvbnN0IG09WzAsMSwyLDUsNiwxMF07bGV0IGY9MDtmb3IobGV0IGU9MDtlPG0ubGVuZ3RoO2UrKylNYXRoLmFicyh1LmVsZW1lbnRzW21bZV1dKT5mJiYoZj1NYXRoLmFicyh1LmVsZW1lbnRzW21bZV1dKSk7bGV0IHA9NCplLmxvYWRlZFZlcnRleENvdW50KzQqdDtlLmNlbnRlckFuZFNjYWxlRGF0YVtwKzBdPW4ueCxlLmNlbnRlckFuZFNjYWxlRGF0YVtwKzFdPS1uLnksZS5jZW50ZXJBbmRTY2FsZURhdGFbcCsyXT1uLnosZS5jZW50ZXJBbmRTY2FsZURhdGFbcCszXT1mLzMyNzY3LHA9OCplLmxvYWRlZFZlcnRleENvdW50KzQqdCoyO2ZvcihsZXQgZT0wO2U8bS5sZW5ndGg7ZSsrKWxbcCtlXT0zMjc2Nyp1LmVsZW1lbnRzW21bZV1dL2Y7cD0xNiplLmxvYWRlZFZlcnRleENvdW50KzQqKDQqdCszKTtjb25zdCBoPW5ldyBELkNvbG9yKGFbMzIqdCsyNCswXS8yNTUsYVszMip0KzI0KzFdLzI1NSxhWzMyKnQrMjQrMl0vMjU1KTtoLmNvbnZlcnRTUkdCVG9MaW5lYXIoKSxzW3ArMF09MjU1KmgucixzW3ArMV09MjU1KmguZyxzW3ArMl09MjU1KmguYixzW3ArM109YVszMip0KzI0KzNdLHUuZWxlbWVudHNbMTVdPU1hdGgubWF4KGMueCxjLnksYy56KSphWzMyKnQrMjQrM10vMjU1O2ZvcihsZXQgZT0wO2U8MTY7ZSsrKWlbMTYqdCtlXT11LmVsZW1lbnRzW2VdfWZvcig7cj4wOyl7bGV0IHQ9MCxhPTA7Y29uc3Qgbz1lLmxvYWRlZFZlcnRleENvdW50JWUuYnVmZmVyVGV4dHVyZVdpZHRoLGk9TWF0aC5mbG9vcihlLmxvYWRlZFZlcnRleENvdW50L2UuYnVmZmVyVGV4dHVyZVdpZHRoKTtlLmxvYWRlZFZlcnRleENvdW50JWUuYnVmZmVyVGV4dHVyZVdpZHRoIT0wPyh0PU1hdGgubWluKGUuYnVmZmVyVGV4dHVyZVdpZHRoLG8rciktbyxhPTEpOk1hdGguZmxvb3Ioci9lLmJ1ZmZlclRleHR1cmVXaWR0aCk+MD8odD1lLmJ1ZmZlclRleHR1cmVXaWR0aCxhPU1hdGguZmxvb3Ioci9lLmJ1ZmZlclRleHR1cmVXaWR0aCkpOih0PXIlZS5idWZmZXJUZXh0dXJlV2lkdGgsYT0xKTtjb25zdCBzPWUuZ2wucHJvcGVydGllcy5nZXQoZS5jZW50ZXJBbmRTY2FsZVRleHR1cmUpO24uYmluZFRleHR1cmUobi5URVhUVVJFXzJELHMuX193ZWJnbFRleHR1cmUpLG4udGV4U3ViSW1hZ2UyRChuLlRFWFRVUkVfMkQsMCxvLGksdCxhLG4uUkdCQSxuLkZMT0FULGUuY2VudGVyQW5kU2NhbGVEYXRhLDQqZS5sb2FkZWRWZXJ0ZXhDb3VudCk7Y29uc3QgbD1lLmdsLnByb3BlcnRpZXMuZ2V0KGUuY292QW5kQ29sb3JUZXh0dXJlKTtuLmJpbmRUZXh0dXJlKG4uVEVYVFVSRV8yRCxsLl9fd2ViZ2xUZXh0dXJlKSxuLnRleFN1YkltYWdlMkQobi5URVhUVVJFXzJELDAsbyxpLHQsYSxuLlJHQkFfSU5URUdFUixuLlVOU0lHTkVEX0lOVCxlLmNvdkFuZENvbG9yRGF0YSw0KmUubG9hZGVkVmVydGV4Q291bnQpLGUuZ2wucmVzZXRTdGF0ZSgpLGUubG9hZGVkVmVydGV4Q291bnQrPXQqYSxyLT10KmF9cmV0dXJuIGl9ZnVuY3Rpb24gbnQoZSx0LHIpe2NvbnN0IG49YS51c2VUaHJlZSgoZT0+ZS5zaXplKSksbz1hLnVzZVRocmVlKChlPT5lLnZpZXdwb3J0KSksaT1cIm51bWJlclwiPT10eXBlb2YgZT9lOm4ud2lkdGgqby5kcHIscz1cIm51bWJlclwiPT10eXBlb2YgdD90Om4uaGVpZ2h0Km8uZHByLGw9KFwibnVtYmVyXCI9PXR5cGVvZiBlP3I6ZSl8fHt9LHtzYW1wbGVzOmM9MCxkZXB0aDp1LC4uLmR9PWwsbT1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1uZXcgRC5XZWJHTFJlbmRlclRhcmdldChpLHMse21pbkZpbHRlcjpELkxpbmVhckZpbHRlcixtYWdGaWx0ZXI6RC5MaW5lYXJGaWx0ZXIsdHlwZTpELkhhbGZGbG9hdFR5cGUsLi4uZH0pO3JldHVybiB1JiYoZS5kZXB0aFRleHR1cmU9bmV3IEQuRGVwdGhUZXh0dXJlKGkscyxELkZsb2F0VHlwZSkpLGUuc2FtcGxlcz1jLGV9KSxbXSk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e20uc2V0U2l6ZShpLHMpLGMmJihtLnNhbXBsZXM9Yyl9KSxbYyxtLGksc10pLFAudXNlRWZmZWN0KCgoKT0+KCk9Pm0uZGlzcG9zZSgpKSxbXSksbX1jb25zdCBhdD1QLmZvcndhcmRSZWYoKCh7ZW52TWFwOmUscmVzb2x1dGlvbjp0PTI1NixmcmFtZXM6cj0xLzAsY2hpbGRyZW46bixtYWtlRGVmYXVsdDpvLC4uLml9LHMpPT57Y29uc3QgbD1hLnVzZVRocmVlKCgoe3NldDplfSk9PmUpKSxjPWEudXNlVGhyZWUoKCh7Y2FtZXJhOmV9KT0+ZSkpLHU9YS51c2VUaHJlZSgoKHtzaXplOmV9KT0+ZSkpLGQ9UC51c2VSZWYobnVsbCksbT1QLnVzZVJlZihudWxsKSxmPW50KHQpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2kubWFudWFsfHxkLmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfSksW3UsaV0pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2QuY3VycmVudC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9KSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYobyl7Y29uc3QgZT1jO3JldHVybiBsKCgoKT0+KHtjYW1lcmE6ZC5jdXJyZW50fSkpKSwoKT0+bCgoKCk9Pih7Y2FtZXJhOmV9KSkpfX0pLFtkLG8sbF0pO2xldCBwPTAsaD1udWxsO2NvbnN0IHg9XCJmdW5jdGlvblwiPT10eXBlb2YgbjtyZXR1cm4gYS51c2VGcmFtZSgodD0+e3gmJihyPT09MS8wfHxwPHIpJiYobS5jdXJyZW50LnZpc2libGU9ITEsdC5nbC5zZXRSZW5kZXJUYXJnZXQoZiksaD10LnNjZW5lLmJhY2tncm91bmQsZSYmKHQuc2NlbmUuYmFja2dyb3VuZD1lKSx0LmdsLnJlbmRlcih0LnNjZW5lLGQuY3VycmVudCksdC5zY2VuZS5iYWNrZ3JvdW5kPWgsdC5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksbS5jdXJyZW50LnZpc2libGU9ITAscCsrKX0pKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLEMuZGVmYXVsdCh7bGVmdDp1LndpZHRoLy0yLHJpZ2h0OnUud2lkdGgvMix0b3A6dS5oZWlnaHQvMixib3R0b206dS5oZWlnaHQvLTIscmVmOmsuZGVmYXVsdChbZCxzXSl9LGkpLCF4JiZuKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6bX0seCYmbihmLnRleHR1cmUpKSl9KSksb3Q9UC5mb3J3YXJkUmVmKCgoe2Vudk1hcDplLHJlc29sdXRpb246dD0yNTYsZnJhbWVzOnI9MS8wLG1ha2VEZWZhdWx0Om4sY2hpbGRyZW46bywuLi5pfSxzKT0+e2NvbnN0IGw9YS51c2VUaHJlZSgoKHtzZXQ6ZX0pPT5lKSksYz1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSx1PWEudXNlVGhyZWUoKCh7c2l6ZTplfSk9PmUpKSxkPVAudXNlUmVmKG51bGwpLG09UC51c2VSZWYobnVsbCksZj1udCh0KTtQLnVzZUxheW91dEVmZmVjdCgoKCk9PntpLm1hbnVhbHx8KGQuY3VycmVudC5hc3BlY3Q9dS53aWR0aC91LmhlaWdodCl9KSxbdSxpXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57ZC5jdXJyZW50LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX0pKTtsZXQgcD0wLGg9bnVsbDtjb25zdCB4PVwiZnVuY3Rpb25cIj09dHlwZW9mIG87cmV0dXJuIGEudXNlRnJhbWUoKHQ9Pnt4JiYocj09PTEvMHx8cDxyKSYmKG0uY3VycmVudC52aXNpYmxlPSExLHQuZ2wuc2V0UmVuZGVyVGFyZ2V0KGYpLGg9dC5zY2VuZS5iYWNrZ3JvdW5kLGUmJih0LnNjZW5lLmJhY2tncm91bmQ9ZSksdC5nbC5yZW5kZXIodC5zY2VuZSxkLmN1cnJlbnQpLHQuc2NlbmUuYmFja2dyb3VuZD1oLHQuZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLG0uY3VycmVudC52aXNpYmxlPSEwLHArKyl9KSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYobil7Y29uc3QgZT1jO3JldHVybiBsKCgoKT0+KHtjYW1lcmE6ZC5jdXJyZW50fSkpKSwoKT0+bCgoKCk9Pih7Y2FtZXJhOmV9KSkpfX0pLFtkLG4sbF0pLFAuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsUC5jcmVhdGVFbGVtZW50KFwicGVyc3BlY3RpdmVDYW1lcmFcIixDLmRlZmF1bHQoe3JlZjprLmRlZmF1bHQoW2Qsc10pfSxpKSwheCYmbyksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOm19LHgmJm8oZi50ZXh0dXJlKSkpfSkpO2Z1bmN0aW9uIGl0KHtyZXNvbHV0aW9uOmU9MjU2LG5lYXI6cj0uMSxmYXI6bz0xZTMsZW52TWFwOmksZm9nOnN9PXt9KXtjb25zdCBsPWEudXNlVGhyZWUoKCh7Z2w6ZX0pPT5lKSksYz1hLnVzZVRocmVlKCgoe3NjZW5lOmV9KT0+ZSkpLHU9dC51c2VNZW1vKCgoKT0+e2NvbnN0IHQ9bmV3IG4uV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KGUpO3JldHVybiB0LnRleHR1cmUudHlwZT1uLkhhbGZGbG9hdFR5cGUsdH0pLFtlXSk7dC51c2VFZmZlY3QoKCgpPT4oKT0+e3UuZGlzcG9zZSgpfSksW3VdKTtjb25zdCBkPXQudXNlTWVtbygoKCk9Pm5ldyBELkN1YmVDYW1lcmEocixvLHUpKSxbcixvLHVdKTtsZXQgbSxmO2NvbnN0IHA9UC51c2VDYWxsYmFjaygoKCk9PnttPWMuZm9nLGY9Yy5iYWNrZ3JvdW5kLGMuYmFja2dyb3VuZD1pfHxmLGMuZm9nPXN8fG0sZC51cGRhdGUobCxjKSxjLmZvZz1tLGMuYmFja2dyb3VuZD1mfSksW2wsYyxkXSk7cmV0dXJue2Zibzp1LGNhbWVyYTpkLHVwZGF0ZTpwfX1jb25zdCBzdD1QLmZvcndhcmRSZWYoKChlLHQpPT57Y29uc3R7Y2FtZXJhOnIsb25DaGFuZ2U6bixtYWtlRGVmYXVsdDpvLC4uLml9PWUscz1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLGw9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksYz1hLnVzZVRocmVlKChlPT5lLmdldCkpLHU9YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSxtPXJ8fHMsZj1QLnVzZU1lbW8oKCgpPT5uZXcgZC5EZXZpY2VPcmllbnRhdGlvbkNvbnRyb2xzKG0pKSxbbV0pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWU9PntsKCksbiYmbihlKX07cmV0dXJuIG51bGw9PWZ8fG51bGw9PWYuYWRkRXZlbnRMaXN0ZW5lcnx8Zi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksKCk9Pm51bGw9PWZ8fG51bGw9PWYucmVtb3ZlRXZlbnRMaXN0ZW5lcj92b2lkIDA6Zi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSl9KSxbbixmLGxdKSxhLnVzZUZyYW1lKCgoKT0+bnVsbD09Zj92b2lkIDA6Zi51cGRhdGUoKSksLTEpLFAudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZjtyZXR1cm4gbnVsbD09ZXx8ZS5jb25uZWN0KCksKCk9Pm51bGw9PWU/dm9pZCAwOmUuZGlzcG9zZSgpfSksW2ZdKSxQLnVzZUVmZmVjdCgoKCk9PntpZihvKXtjb25zdCBlPWMoKS5jb250cm9scztyZXR1cm4gdSh7Y29udHJvbHM6Zn0pLCgpPT51KHtjb250cm9sczplfSl9fSksW28sZl0pLGY/UC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtyZWY6dCxvYmplY3Q6Zn0saSkpOm51bGx9KSksbHQ9UC5mb3J3YXJkUmVmKCgoe2RvbUVsZW1lbnQ6ZSwuLi50fSxyKT0+e2NvbnN0e29uQ2hhbmdlOm4sbWFrZURlZmF1bHQ6bywuLi5pfT10LHM9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksbD1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLGM9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHU9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSxtPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksZj1hLnVzZVRocmVlKChlPT5lLnNldCkpLHA9ZXx8dS5jb25uZWN0ZWR8fGMuZG9tRWxlbWVudCxoPVAudXNlTWVtbygoKCk9Pm5ldyBkLkZseUNvbnRyb2xzKGwpKSxbbF0pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PihoLmNvbm5lY3QocCksKCk9PntoLmRpc3Bvc2UoKX0pKSxbcCxoLHNdKSxQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWU9PntzKCksbiYmbihlKX07cmV0dXJuIG51bGw9PWguYWRkRXZlbnRMaXN0ZW5lcnx8aC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksKCk9Pm51bGw9PWgucmVtb3ZlRXZlbnRMaXN0ZW5lcj92b2lkIDA6aC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSl9KSxbbixzXSksUC51c2VFZmZlY3QoKCgpPT57aWYobyl7Y29uc3QgZT1tKCkuY29udHJvbHM7cmV0dXJuIGYoe2NvbnRyb2xzOmh9KSwoKT0+Zih7Y29udHJvbHM6ZX0pfX0pLFtvLGhdKSxhLnVzZUZyYW1lKCgoZSx0KT0+aC51cGRhdGUodCkpKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjpyLG9iamVjdDpoLGFyZ3M6W2wscF19LGkpKX0pKSxjdD1QLmZvcndhcmRSZWYoKChlPXtlbmFibGVEYW1waW5nOiEwfSx0KT0+e2NvbnN0e2RvbUVsZW1lbnQ6cixjYW1lcmE6bixtYWtlRGVmYXVsdDpvLG9uQ2hhbmdlOmksb25TdGFydDpzLG9uRW5kOmwsLi4uY309ZSx1PWEudXNlVGhyZWUoKGU9PmUuaW52YWxpZGF0ZSkpLG09YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxmPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxwPWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSksaD1hLnVzZVRocmVlKChlPT5lLnNldCkpLHg9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSx5PXJ8fHAuY29ubmVjdGVkfHxmLmRvbUVsZW1lbnQsdj1ufHxtLGc9UC51c2VNZW1vKCgoKT0+bmV3IGQuTWFwQ29udHJvbHModikpLFt2XSk7cmV0dXJuIFAudXNlRWZmZWN0KCgoKT0+e2cuY29ubmVjdCh5KTtjb25zdCBlPWU9Pnt1KCksaSYmaShlKX07cmV0dXJuIGcuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLHMmJmcuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIscyksbCYmZy5hZGRFdmVudExpc3RlbmVyKFwiZW5kXCIsbCksKCk9PntnLmRpc3Bvc2UoKSxnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSxzJiZnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLHMpLGwmJmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZFwiLGwpfX0pLFtpLHMsbCxnLHUseV0pLFAudXNlRWZmZWN0KCgoKT0+e2lmKG8pe2NvbnN0IGU9eCgpLmNvbnRyb2xzO3JldHVybiBoKHtjb250cm9sczpnfSksKCk9Pmgoe2NvbnRyb2xzOmV9KX19KSxbbyxnXSksYS51c2VGcmFtZSgoKCk9PmcudXBkYXRlKCkpLC0xKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjp0LG9iamVjdDpnLGVuYWJsZURhbXBpbmc6ITB9LGMpKX0pKSx1dD1QLmZvcndhcmRSZWYoKCh7bWFrZURlZmF1bHQ6ZSxjYW1lcmE6dCxyZWdyZXNzOnIsZG9tRWxlbWVudDpuLGVuYWJsZURhbXBpbmc6bz0hMCxrZXlFdmVudHM6aT0hMSxvbkNoYW5nZTpzLG9uU3RhcnQ6bCxvbkVuZDpjLC4uLnV9LG0pPT57Y29uc3QgZj1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSxwPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksaD1hLnVzZVRocmVlKChlPT5lLmdsKSkseD1hLnVzZVRocmVlKChlPT5lLmV2ZW50cykpLHk9YS51c2VUaHJlZSgoZT0+ZS5zZXRFdmVudHMpKSx2PWEudXNlVGhyZWUoKGU9PmUuc2V0KSksZz1hLnVzZVRocmVlKChlPT5lLmdldCkpLHo9YS51c2VUaHJlZSgoZT0+ZS5wZXJmb3JtYW5jZSkpLHc9dHx8cCxiPW58fHguY29ubmVjdGVkfHxoLmRvbUVsZW1lbnQsTT1QLnVzZU1lbW8oKCgpPT5uZXcgZC5PcmJpdENvbnRyb2xzKHcpKSxbd10pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e00uZW5hYmxlZCYmTS51cGRhdGUoKX0pLC0xKSxQLnVzZUVmZmVjdCgoKCk9PihpJiZNLmNvbm5lY3QoITA9PT1pP2I6aSksTS5jb25uZWN0KGIpLCgpPT57TS5kaXNwb3NlKCl9KSksW2ksYixyLE0sZl0pLFAudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e2YoKSxyJiZ6LnJlZ3Jlc3MoKSxzJiZzKGUpfSx0PWU9PntsJiZsKGUpfSxuPWU9PntjJiZjKGUpfTtyZXR1cm4gTS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksTS5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRcIix0KSxNLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRcIixuKSwoKT0+e00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIsdCksTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kXCIsbiksTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSl9fSksW3MsbCxjLE0sZix5XSksUC51c2VFZmZlY3QoKCgpPT57aWYoZSl7Y29uc3QgZT1nKCkuY29udHJvbHM7cmV0dXJuIHYoe2NvbnRyb2xzOk19KSwoKT0+dih7Y29udHJvbHM6ZX0pfX0pLFtlLE1dKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjptLG9iamVjdDpNLGVuYWJsZURhbXBpbmc6b30sdSkpfSkpLGR0PVAuZm9yd2FyZFJlZigoKHttYWtlRGVmYXVsdDplLGNhbWVyYTp0LGRvbUVsZW1lbnQ6cixyZWdyZXNzOm4sb25DaGFuZ2U6byxvblN0YXJ0Omksb25FbmQ6cywuLi5sfSxjKT0+e2NvbnN0e2ludmFsaWRhdGU6dSxjYW1lcmE6bSxnbDpmLGV2ZW50czpwLHNldDpoLGdldDp4LHBlcmZvcm1hbmNlOnksdmlld3BvcnQ6dn09YS51c2VUaHJlZSgpLGc9dHx8bSx6PXJ8fHAuY29ubmVjdGVkfHxmLmRvbUVsZW1lbnQsdz1QLnVzZU1lbW8oKCgpPT5uZXcgZC5UcmFja2JhbGxDb250cm9scyhnKSksW2ddKTtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pnt3LmVuYWJsZWQmJncudXBkYXRlKCl9KSwtMSksUC51c2VFZmZlY3QoKCgpPT4ody5jb25uZWN0KHopLCgpPT57dy5kaXNwb3NlKCl9KSksW3osbix3LHVdKSxQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPWU9Pnt1KCksbiYmeS5yZWdyZXNzKCksbyYmbyhlKX07cmV0dXJuIHcuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLGkmJncuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIsaSkscyYmdy5hZGRFdmVudExpc3RlbmVyKFwiZW5kXCIscyksKCk9PntpJiZ3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLGkpLHMmJncucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZFwiLHMpLHcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpfX0pLFtvLGkscyx3LHVdKSxQLnVzZUVmZmVjdCgoKCk9Pnt3LmhhbmRsZVJlc2l6ZSgpfSksW3ZdKSxQLnVzZUVmZmVjdCgoKCk9PntpZihlKXtjb25zdCBlPXgoKS5jb250cm9scztyZXR1cm4gaCh7Y29udHJvbHM6d30pLCgpPT5oKHtjb250cm9sczplfSl9fSksW2Usd10pLFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLEMuZGVmYXVsdCh7cmVmOmMsb2JqZWN0Ond9LGwpKX0pKSxtdD10LmZvcndhcmRSZWYoKCh7Y2FtZXJhOmUsbWFrZURlZmF1bHQ6cixyZWdyZXNzOm4sZG9tRWxlbWVudDpvLG9uQ2hhbmdlOmksb25TdGFydDpzLG9uRW5kOmwsLi4uY30sdSk9Pntjb25zdCBtPWEudXNlVGhyZWUoKGU9PmUuaW52YWxpZGF0ZSkpLGY9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxwPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxoPWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSkseD1hLnVzZVRocmVlKChlPT5lLnNldCkpLHk9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSx2PWEudXNlVGhyZWUoKGU9PmUucGVyZm9ybWFuY2UpKSxnPWV8fGYsej1vfHxoLmNvbm5lY3RlZHx8cC5kb21FbGVtZW50LHc9dC51c2VNZW1vKCgoKT0+bmV3IGQuQXJjYmFsbENvbnRyb2xzKGcpKSxbZ10pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3cuZW5hYmxlZCYmdy51cGRhdGUoKX0pLC0xKSx0LnVzZUVmZmVjdCgoKCk9Pih3LmNvbm5lY3QoeiksKCk9Pnt3LmRpc3Bvc2UoKX0pKSxbeixuLHcsbV0pLHQudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e20oKSxuJiZ2LnJlZ3Jlc3MoKSxpJiZpKGUpfTtyZXR1cm4gdy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSkscyYmdy5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRcIixzKSxsJiZ3LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRcIixsKSwoKT0+e3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLHMmJncucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YXJ0XCIscyksbCYmdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kXCIsbCl9fSksW2kscyxsXSksdC51c2VFZmZlY3QoKCgpPT57aWYocil7Y29uc3QgZT15KCkuY29udHJvbHM7cmV0dXJuIHgoe2NvbnRyb2xzOnd9KSwoKT0+eCh7Y29udHJvbHM6ZX0pfX0pLFtyLHddKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjp1LG9iamVjdDp3fSxjKSl9KSksZnQ9UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsZG9tRWxlbWVudDp0LG9uQ2hhbmdlOnIsb25Nb3VzZURvd246bixvbk1vdXNlVXA6byxvbk9iamVjdENoYW5nZTppLG9iamVjdDpzLG1ha2VEZWZhdWx0OmwsLi4uY30sdSk9Pntjb25zdCBtPVtcImVuYWJsZWRcIixcImF4aXNcIixcIm1vZGVcIixcInRyYW5zbGF0aW9uU25hcFwiLFwicm90YXRpb25TbmFwXCIsXCJzY2FsZVNuYXBcIixcInNwYWNlXCIsXCJzaXplXCIsXCJzaG93WFwiLFwic2hvd1lcIixcInNob3daXCJdLHtjYW1lcmE6ZiwuLi5wfT1jLGg9QS5kZWZhdWx0KHAsbSkseD1MLmRlZmF1bHQocCxtKSx5PWEudXNlVGhyZWUoKGU9PmUuY29udHJvbHMpKSx2PWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxnPWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSksej1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHc9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksYj1hLnVzZVRocmVlKChlPT5lLmdldCkpLE09YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSxFPWZ8fHosUz10fHxnLmNvbm5lY3RlZHx8di5kb21FbGVtZW50LFQ9UC51c2VNZW1vKCgoKT0+bmV3IGQuVHJhbnNmb3JtQ29udHJvbHMoRSxTKSksW0UsU10pLFI9UC51c2VSZWYoKTtQLnVzZUxheW91dEVmZmVjdCgoKCk9PihzP1QuYXR0YWNoKHMgaW5zdGFuY2VvZiBELk9iamVjdDNEP3M6cy5jdXJyZW50KTpSLmN1cnJlbnQgaW5zdGFuY2VvZiBELk9iamVjdDNEJiZULmF0dGFjaChSLmN1cnJlbnQpLCgpPT57VC5kZXRhY2goKX0pKSxbcyxlLFRdKSxQLnVzZUVmZmVjdCgoKCk9PntpZih5KXtjb25zdCBlPWU9PnkuZW5hYmxlZD0hZS52YWx1ZTtyZXR1cm4gVC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2dpbmctY2hhbmdlZFwiLGUpLCgpPT5ULnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkcmFnZ2luZy1jaGFuZ2VkXCIsZSl9fSksW1QseV0pO2NvbnN0IEY9UC51c2VSZWYoKSxrPVAudXNlUmVmKCksXz1QLnVzZVJlZigpLEI9UC51c2VSZWYoKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Ri5jdXJyZW50PXJ9KSxbcl0pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2suY3VycmVudD1ufSksW25dKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9PntfLmN1cnJlbnQ9b30pLFtvXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Qi5jdXJyZW50PWl9KSxbaV0pLFAudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e3coKSxudWxsPT1GLmN1cnJlbnR8fEYuY3VycmVudChlKX0sdD1lPT5udWxsPT1rLmN1cnJlbnQ/dm9pZCAwOmsuY3VycmVudChlKSxyPWU9Pm51bGw9PV8uY3VycmVudD92b2lkIDA6Xy5jdXJyZW50KGUpLG49ZT0+bnVsbD09Qi5jdXJyZW50P3ZvaWQgMDpCLmN1cnJlbnQoZSk7cmV0dXJuIFQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLFQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlRG93blwiLHQpLFQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlVXBcIixyKSxULmFkZEV2ZW50TGlzdGVuZXIoXCJvYmplY3RDaGFuZ2VcIixuKSwoKT0+e1QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpLFQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlRG93blwiLHQpLFQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlVXBcIixyKSxULnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvYmplY3RDaGFuZ2VcIixuKX19KSxbdyxUXSksUC51c2VFZmZlY3QoKCgpPT57aWYobCl7Y29uc3QgZT1iKCkuY29udHJvbHM7cmV0dXJuIE0oe2NvbnRyb2xzOlR9KSwoKT0+TSh7Y29udHJvbHM6ZX0pfX0pLFtsLFRdKSxUP1AuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtyZWY6dSxvYmplY3Q6VH0saCkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6Un0seCksZSkpOm51bGx9KSkscHQ9UC5mb3J3YXJkUmVmKCgoe2RvbUVsZW1lbnQ6ZSxzZWxlY3Rvcjp0LG9uQ2hhbmdlOnIsb25Mb2NrOm4sb25VbmxvY2s6byxlbmFibGVkOmk9ITAsbWFrZURlZmF1bHQ6cywuLi5sfSxjKT0+e2NvbnN0e2NhbWVyYTp1LC4uLm19PWwsZj1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpLHA9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGg9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSx4PWEudXNlVGhyZWUoKGU9PmUuaW52YWxpZGF0ZSkpLHk9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSx2PWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksZz1hLnVzZVRocmVlKChlPT5lLnNldCkpLHo9dXx8aCx3PWV8fHkuY29ubmVjdGVkfHxwLmRvbUVsZW1lbnQsYj1QLnVzZU1lbW8oKCgpPT5uZXcgZC5Qb2ludGVyTG9ja0NvbnRyb2xzKHopKSxbel0pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PntpZihpKXtiLmNvbm5lY3Qodyk7Y29uc3QgZT12KCkuZXZlbnRzLmNvbXB1dGU7cmV0dXJuIGYoe2NvbXB1dGUoZSx0KXtjb25zdCByPXQuc2l6ZS53aWR0aC8yLG49dC5zaXplLmhlaWdodC8yO3QucG9pbnRlci5zZXQoci90LnNpemUud2lkdGgqMi0xLC1uL3Quc2l6ZS5oZWlnaHQqMisxKSx0LnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHQucG9pbnRlcix0LmNhbWVyYSl9fSksKCk9PntiLmRpc2Nvbm5lY3QoKSxmKHtjb21wdXRlOmV9KX19fSksW2ksYl0pLFAudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e3goKSxyJiZyKGUpfTtiLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSxuJiZiLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2NrXCIsbiksbyYmYi5hZGRFdmVudExpc3RlbmVyKFwidW5sb2NrXCIsbyk7Y29uc3QgYT0oKT0+Yi5sb2NrKCksaT10P0FycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KSk6W2RvY3VtZW50XTtyZXR1cm4gaS5mb3JFYWNoKChlPT5lJiZlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGEpKSksKCk9PntiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKSxuJiZiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2NrXCIsbiksbyYmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwidW5sb2NrXCIsbyksaS5mb3JFYWNoKChlPT5lP2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsYSk6dm9pZCAwKSl9fSksW3IsbixvLHQsYix4XSksUC51c2VFZmZlY3QoKCgpPT57aWYocyl7Y29uc3QgZT12KCkuY29udHJvbHM7cmV0dXJuIGcoe2NvbnRyb2xzOmJ9KSwoKT0+Zyh7Y29udHJvbHM6ZX0pfX0pLFtzLGJdKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjpjLG9iamVjdDpifSxtKSl9KSksaHQ9UC5mb3J3YXJkUmVmKCgoe2RvbUVsZW1lbnQ6ZSxtYWtlRGVmYXVsdDp0LC4uLnJ9LG4pPT57Y29uc3Qgbz1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLGk9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHM9YS51c2VUaHJlZSgoZT0+ZS5ldmVudHMpKSxsPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksYz1hLnVzZVRocmVlKChlPT5lLnNldCkpLHU9ZXx8cy5jb25uZWN0ZWR8fGkuZG9tRWxlbWVudCxbbV09UC51c2VTdGF0ZSgoKCk9Pm5ldyBkLkZpcnN0UGVyc29uQ29udHJvbHMobyx1KSkpO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PntpZih0KXtjb25zdCBlPWwoKS5jb250cm9scztyZXR1cm4gYyh7Y29udHJvbHM6bX0pLCgpPT5jKHtjb250cm9sczplfSl9fSksW3QsbV0pLGEudXNlRnJhbWUoKChlLHQpPT57bS51cGRhdGUodCl9KSwtMSksbT9QLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjpuLG9iamVjdDptfSxyKSk6bnVsbH0pKSx4dD10LmZvcndhcmRSZWYoKChlLHIpPT57dC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9e0JveDM6bi5Cb3gzLE1hdGhVdGlsczp7Y2xhbXA6bi5NYXRoVXRpbHMuY2xhbXB9LE1hdHJpeDQ6bi5NYXRyaXg0LFF1YXRlcm5pb246bi5RdWF0ZXJuaW9uLFJheWNhc3RlcjpuLlJheWNhc3RlcixTcGhlcmU6bi5TcGhlcmUsU3BoZXJpY2FsOm4uU3BoZXJpY2FsLFZlY3RvcjI6bi5WZWN0b3IyLFZlY3RvcjM6bi5WZWN0b3IzLFZlY3RvcjQ6bi5WZWN0b3I0fTtCLmRlZmF1bHQuaW5zdGFsbCh7VEhSRUU6ZX0pLGEuZXh0ZW5kKHtDYW1lcmFDb250cm9sc0ltcGw6Qi5kZWZhdWx0fSl9KSxbXSk7Y29uc3R7Y2FtZXJhOm8sZG9tRWxlbWVudDppLG1ha2VEZWZhdWx0OnMsb25TdGFydDpsLG9uRW5kOmMsb25DaGFuZ2U6dSxyZWdyZXNzOmQsLi4ubX09ZSxmPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSkscD1hLnVzZVRocmVlKChlPT5lLmdsKSksaD1hLnVzZVRocmVlKChlPT5lLmludmFsaWRhdGUpKSx4PWEudXNlVGhyZWUoKGU9PmUuZXZlbnRzKSkseT1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpLHY9YS51c2VUaHJlZSgoZT0+ZS5zZXQpKSxnPWEudXNlVGhyZWUoKGU9PmUuZ2V0KSksej1hLnVzZVRocmVlKChlPT5lLnBlcmZvcm1hbmNlKSksdz1vfHxmLGI9aXx8eC5jb25uZWN0ZWR8fHAuZG9tRWxlbWVudCxNPXQudXNlTWVtbygoKCk9Pm5ldyBCLmRlZmF1bHQodykpLFt3XSk7cmV0dXJuIGEudXNlRnJhbWUoKChlLHQpPT57TS5lbmFibGVkJiZNLnVwZGF0ZSh0KX0pLC0xKSx0LnVzZUVmZmVjdCgoKCk9PihNLmNvbm5lY3QoYiksKCk9PntNLmRpc2Nvbm5lY3QoKX0pKSxbYixNXSksdC51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1lPT57aCgpLGQmJnoucmVncmVzcygpLHUmJnUoZSl9LHQ9ZT0+e2wmJmwoZSl9LHI9ZT0+e2MmJmMoZSl9O3JldHVybiBNLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIixlKSxNLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250cm9sc3RhcnRcIix0KSxNLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250cm9sZW5kXCIsciksTS5hZGRFdmVudExpc3RlbmVyKFwiY29udHJvbFwiLGUpLE0uYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25zdGFydFwiLGUpLE0uYWRkRXZlbnRMaXN0ZW5lcihcIndha2VcIixlKSwoKT0+e00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiLGUpLE0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRyb2xzdGFydFwiLHQpLE0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRyb2xlbmRcIixyKSxNLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250cm9sXCIsZSksTS5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbnN0YXJ0XCIsZSksTS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FrZVwiLGUpfX0pLFtNLGwsYyxoLHksZCx1XSksdC51c2VFZmZlY3QoKCgpPT57aWYocyl7Y29uc3QgZT1nKCkuY29udHJvbHM7cmV0dXJuIHYoe2NvbnRyb2xzOk19KSwoKT0+dih7Y29udHJvbHM6ZX0pfX0pLFtzLE1dKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjpyLG9iamVjdDpNfSxtKSl9KSk7ZnVuY3Rpb24geXQoZSxyKXtjb25zdHt1bnN1c3BlbmQ6bixzdGFydDpvLGNyb3NzT3JpZ2luOmksbXV0ZWQ6cyxsb29wOmwsLi4uY309e3Vuc3VzcGVuZDpcImxvYWRlZG1ldGFkYXRhXCIsY3Jvc3NPcmlnaW46XCJBbm9ueW1vdXNcIixtdXRlZDohMCxsb29wOiEwLHN0YXJ0OiEwLHBsYXlzSW5saW5lOiEwLC4uLnJ9LHU9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGQ9Zi5zdXNwZW5kKCgoKT0+bmV3IFByb21pc2UoKCh0LHIpPT57Y29uc3QgYT1PYmplY3QuYXNzaWduKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKSx7c3JjOlwic3RyaW5nXCI9PXR5cGVvZiBlJiZlfHx2b2lkIDAsc3JjT2JqZWN0OmUgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbSYmZXx8dm9pZCAwLGNyb3NzT3JpZ2luOmksbG9vcDpsLG11dGVkOnMsLi4uY30pLG89bmV3IEQuVmlkZW9UZXh0dXJlKGEpO1wiY29sb3JTcGFjZVwiaW4gbz9vLmNvbG9yU3BhY2U9dS5vdXRwdXRDb2xvclNwYWNlOm8uZW5jb2Rpbmc9dS5vdXRwdXRFbmNvZGluZyxhLmFkZEV2ZW50TGlzdGVuZXIobiwoKCk9PnQobykpKX0pKSksW2VdKTtyZXR1cm4gdC51c2VFZmZlY3QoKCgpPT57aWYobylyZXR1cm4gZC5pbWFnZS5wbGF5KCksKCk9PmQuaW1hZ2UucGF1c2UoKX0pLFtkLG9dKSxkfWNvbnN0IHZ0PW5ldyBELlZlY3RvcjMoMCwwLC0xKSxndD1mdW5jdGlvbigpe2NvbnN0IGU9bmV3IEQuVmVjdG9yMyx0PW5ldyBELlZlY3RvcjMscj1uZXcgRC5WZWN0b3IzLG49bmV3IEQuVmVjdG9yMyxhPW5ldyBELlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKG8saSxzLGwpe3JldHVybiBlLmNvcHkobyksdC5jb3B5KGkpLHIuY29weShzKSxuLmNvcHkodCkuc3ViKGUpLGEuY29weShyKS5zdWIoZSksbC5jcm9zc1ZlY3RvcnMoYSxuKS5ub3JtYWxpemUoKX19KCk7Y29uc3QgenQ9UC5mb3J3YXJkUmVmKCgoe3BvaW50czplPU10LlNBTVBMRV9GQUNFTEFORE1BUktFUl9SRVNVTFQuZmFjZUxhbmRtYXJrc1swXSxmYWNlOnQsZmFjaWFsVHJhbnNmb3JtYXRpb25NYXRyaXg6cixmYWNlQmxlbmRzaGFwZXM6bixvZmZzZXQ6byxvZmZzZXRTY2FsYXI6aT04MCx3aWR0aDpzLGhlaWdodDpsLGRlcHRoOmM9MSx2ZXJ0aWNhbFRyaTp1PVsxNTksMzg2LDE1Ml0sb3JpZ2luOmQsZXllczptPSEwLGV5ZXNBc09yaWdpbjpmPSExLGRlYnVnOnA9ITEsY2hpbGRyZW46aCwuLi54fSx5KT0+e3ZhciB2O3QmJihlPXQua2V5cG9pbnRzLGNvbnNvbGUud2FybihcIkZhY2VtZXNoIGBmYWNlYCBwcm9wIGlzIGRlcHJlY2F0ZWQ6IHVzZSBgcG9pbnRzYCBpbnN0ZWFkXCIpKTtjb25zdCBnPVAudXNlUmVmKG51bGwpLHo9UC51c2VSZWYobnVsbCksdz1QLnVzZVJlZihudWxsKSxiPVAudXNlUmVmKG51bGwpLE09UC51c2VSZWYobnVsbCksRT1QLnVzZVJlZihudWxsKSxTPVAudXNlUmVmKG51bGwpLFtUXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuVmVjdG9yMykpLFtDXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuT2JqZWN0M0QpKSxbUl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELlF1YXRlcm5pb24pKSxbRl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSx7aW52YWxpZGF0ZTprfT1hLnVzZVRocmVlKCk7UC51c2VFZmZlY3QoKCgpPT57dmFyIGU7bnVsbD09KGU9TS5jdXJyZW50KXx8ZS5nZW9tZXRyeS5zZXRJbmRleChNdC5UUklBTkdVTEFUSU9OKX0pLFtdKTtjb25zdFtfXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuVmVjdG9yMykpO1AudXNlRWZmZWN0KCgoKT0+e3ZhciB0LGE7Y29uc3QgaD1udWxsPT0odD1NLmN1cnJlbnQpP3ZvaWQgMDp0Lmdlb21ldHJ5O2lmKCFoKXJldHVybjt2YXIgeCx5OyhoLnNldEZyb21Qb2ludHMoZSksaC5zZXREcmF3UmFuZ2UoMCxNdC5UUklBTkdVTEFUSU9OLmxlbmd0aCkscik/KEMubWF0cml4LmZyb21BcnJheShyLmRhdGEpLEMubWF0cml4LmRlY29tcG9zZShDLnBvc2l0aW9uLEMucXVhdGVybmlvbixDLnNjYWxlKSxDLnJvdGF0aW9uLnkqPS0xLEMucm90YXRpb24ueio9LTEsUi5zZXRGcm9tRXVsZXIoQy5yb3RhdGlvbiksbz8oQy5wb3NpdGlvbi55Kj0tMSxDLnBvc2l0aW9uLnoqPS0xLG51bGw9PSh4PWcuY3VycmVudCl8fHgucG9zaXRpb24uY29weShDLnBvc2l0aW9uLmRpdmlkZVNjYWxhcihpKSkpOm51bGw9PSh5PWcuY3VycmVudCl8fHkucG9zaXRpb24uc2V0KDAsMCwwKSk6KGd0KGVbdVswXV0sZVt1WzFdXSxlW3VbMl1dLFQpLFIuc2V0RnJvbVVuaXRWZWN0b3JzKHZ0LFQpKTtjb25zdCB2PVIuY2xvbmUoKS5pbnZlcnQoKTtpZihoLmNvbXB1dGVCb3VuZGluZ0JveCgpLHAmJmsoKSxoLmNlbnRlcigpLGguYXBwbHlRdWF0ZXJuaW9uKHYpLG51bGw9PShhPWIuY3VycmVudCl8fGEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihSKSxtKWlmKG4pe2lmKEUuY3VycmVudCYmUy5jdXJyZW50JiZ3LmN1cnJlbnQpaWYoZil7Y29uc3QgZT1FLmN1cnJlbnQuX2NvbXB1dGVTcGhlcmUoaCksdD1TLmN1cnJlbnQuX2NvbXB1dGVTcGhlcmUoaCkscj1mdW5jdGlvbihlLHQpe3JldHVybiBlLmNsb25lKCkuYWRkKHQpLm11bHRpcGx5U2NhbGFyKC41KX0oZS5jZW50ZXIsdC5jZW50ZXIpO2Q9ci5uZWdhdGUoKSxFLmN1cnJlbnQuX3VwZGF0ZShoLG4sZSksUy5jdXJyZW50Ll91cGRhdGUoaCxuLHQpfWVsc2UgRS5jdXJyZW50Ll91cGRhdGUoaCxuKSxTLmN1cnJlbnQuX3VwZGF0ZShoLG4pfWVsc2UgY29uc29sZS53YXJuKFwiRmFjZW1lc2ggYGV5ZXNgIG9wdGlvbiBvbmx5IHdvcmtzIGlmIGBmYWNlQmxlbmRzaGFwZXNgIGlzIHByb3ZpZGVkOiBza2lwcGluZy5cIik7aWYody5jdXJyZW50KXtpZih2b2lkIDAhPT1kKWlmKFwibnVtYmVyXCI9PXR5cGVvZiBkKXtjb25zdCBlPWguZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik7Ri5zZXQoLWUuZ2V0WChkKSwtZS5nZXRZKGQpLC1lLmdldFooZCkpfWVsc2UgZC5pc1ZlY3RvcjMmJkYuY29weShkKTtlbHNlIEYuc2V0U2NhbGFyKDApO3cuY3VycmVudC5wb3NpdGlvbi5jb3B5KEYpfWlmKHouY3VycmVudCl7bGV0IGU9MTsoc3x8bHx8YykmJihoLmJvdW5kaW5nQm94LmdldFNpemUoXykscyYmKGU9cy9fLngpLGwmJihlPWwvXy55KSxjJiYoZT1jL18ueikpLHouY3VycmVudC5zY2FsZS5zZXRTY2FsYXIoMSE9PWU/ZToxKX1oLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCksaC5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlPSEwfSksW2UscixuLEMsbyxpLHMsbCxjLHUsZCxtLHAsayxULFIsXyxGXSk7Y29uc3QgQT1QLnVzZU1lbW8oKCgpPT4oe291dGVyUmVmOmIsbWVzaFJlZjpNLGV5ZVJpZ2h0UmVmOkUsZXllTGVmdFJlZjpTfSkpLFtdKTtQLnVzZUltcGVyYXRpdmVIYW5kbGUoeSwoKCk9PkEpLFtBXSk7Y29uc3RbTF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSxCPW51bGw9PSh2PU0uY3VycmVudCk/dm9pZCAwOnYuZ2VvbWV0cnkuYm91bmRpbmdCb3gsVT0obnVsbD09Qj92b2lkIDA6Qi5nZXRTaXplKEwpLnopfHwxO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHgsUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOmd9LFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpifSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6en0scD9QLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcImF4ZXNIZWxwZXJcIix7YXJnczpbVV19KSxQLmNyZWF0ZUVsZW1lbnQodWUse3BvaW50czpbWzAsMCwwXSxbMCwwLC1VXV0sY29sb3I6NjU1MzV9KSk6bnVsbCxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6d30sbSYmbiYmUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7bmFtZTpcImV5ZXNcIn0sUC5jcmVhdGVFbGVtZW50KGJ0LHtzaWRlOlwibGVmdFwiLHJlZjpFLGRlYnVnOnB9KSxQLmNyZWF0ZUVsZW1lbnQoYnQse3NpZGU6XCJyaWdodFwiLHJlZjpTLGRlYnVnOnB9KSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6TSxuYW1lOlwiZmFjZVwifSxoLHA/UC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxCJiZQLmNyZWF0ZUVsZW1lbnQoXCJib3gzSGVscGVyXCIse2FyZ3M6W0JdfSkpOm51bGwpKSkpKSl9KSksd3Q9e2NvbnRvdXJMYW5kbWFya3M6e3JpZ2h0OlszMywxMzMsMTU5LDE0NSwxNTNdLGxlZnQ6WzI2MywzNjIsMzg2LDM3NCwzODBdfSxibGVuZHNoYXBlczp7cmlnaHQ6WzE0LDE2LDE4LDEyXSxsZWZ0OlsxMywxNSwxNywxMV19LGNvbG9yOntyaWdodDpcInJlZFwiLGxlZnQ6XCIjMDBmZjAwXCJ9LGZvdjp7aG9yaXpvbnRhbDoxMDAsdmVydGljYWw6OTB9fSxidD1QLmZvcndhcmRSZWYoKCh7c2lkZTplLGRlYnVnOnQ9ITB9LHIpPT57Y29uc3Qgbj1QLnVzZVJlZihudWxsKSxhPVAudXNlUmVmKG51bGwpLFtvXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuU3BoZXJlKSksaT1QLnVzZUNhbGxiYWNrKCh0PT57Y29uc3Qgcj10LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpLG49d3QuY29udG91ckxhbmRtYXJrc1tlXS5tYXAoKGU9Pm5ldyBELlZlY3RvcjMoci5nZXRYKGUpLHIuZ2V0WShlKSxyLmdldFooZSkpKSk7cmV0dXJuIG8uY2VudGVyLnNldCgwLDAsMCksbi5mb3JFYWNoKChlPT5vLmNlbnRlci5hZGQoZSkpKSxvLmNlbnRlci5kaXZpZGVTY2FsYXIobi5sZW5ndGgpLG8ucmFkaXVzPW5bMF0uc3ViKG5bMV0pLmxlbmd0aCgpLzIsb30pLFtvLGVdKSxbc109UC51c2VTdGF0ZSgoKCk9Pm5ldyBELkV1bGVyKSksbD1QLnVzZUNhbGxiYWNrKCgodCxyLG8pPT57dmFyIGw7bi5jdXJyZW50JiYobnVsbCE9PShsPW8pJiZ2b2lkIDAhPT1sfHwobz1pKHQpKSxuLmN1cnJlbnQucG9zaXRpb24uY29weShvLmNlbnRlciksbi5jdXJyZW50LnNjYWxlLnNldFNjYWxhcihvLnJhZGl1cykpO2lmKHImJmEuY3VycmVudCl7Y29uc3QgdD13dC5ibGVuZHNoYXBlc1tlXSxuPXIuY2F0ZWdvcmllc1t0WzBdXS5zY29yZSxvPXIuY2F0ZWdvcmllc1t0WzFdXS5zY29yZSxpPXIuY2F0ZWdvcmllc1t0WzJdXS5zY29yZSxsPXIuY2F0ZWdvcmllc1t0WzNdXS5zY29yZSxjPS41Kih3dC5mb3YuaG9yaXpvbnRhbCpELk1hdGhVdGlscy5ERUcyUkFEKSoobC1pKSx1PS41Kih3dC5mb3YudmVydGljYWwqRC5NYXRoVXRpbHMuREVHMlJBRCkqKG4tbykqKFwibGVmdFwiPT09ZT8xOi0xKTtzLnNldChjLHUsMCksYS5jdXJyZW50LnNldFJvdGF0aW9uRnJvbUV1bGVyKHMpfX0pLFtpLGUsc10pLGM9UC51c2VNZW1vKCgoKT0+KHtleWVNZXNoUmVmOm4saXJpc0RpclJlZjphLF9jb21wdXRlU3BoZXJlOmksX3VwZGF0ZTpsfSkpLFtpLGxdKTtQLnVzZUltcGVyYXRpdmVIYW5kbGUociwoKCk9PmMpLFtjXSk7Y29uc3QgdT13dC5jb2xvcltlXTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixudWxsLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpufSx0JiZQLmNyZWF0ZUVsZW1lbnQoXCJheGVzSGVscGVyXCIsbnVsbCksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOmF9LFAuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsdCYmUC5jcmVhdGVFbGVtZW50KHVlLHtwb2ludHM6W1swLDAsMF0sWzAsMCwtMl1dLGxpbmVXaWR0aDoxLGNvbG9yOnV9KSkpKSl9KSksTXQ9e1RSSUFOR1VMQVRJT046WzEyNywzNCwxMzksMTEsMCwzNywyMzIsMjMxLDEyMCw3MiwzNywzOSwxMjgsMTIxLDQ3LDIzMiwxMjEsMTI4LDEwNCw2OSw2NywxNzUsMTcxLDE0OCwxNTcsMTU0LDE1NSwxMTgsNTAsMTAxLDczLDM5LDQwLDksMTUxLDEwOCw0OCwxMTUsMTMxLDE5NCwyMDQsMjExLDc0LDQwLDE4NSw4MCw0MiwxODMsNDAsOTIsMTg2LDIzMCwyMjksMTE4LDIwMiwyMTIsMjE0LDgzLDE4LDE3LDc2LDYxLDE0NiwxNjAsMjksMzAsNTYsMTU3LDE3MywxMDYsMjA0LDE5NCwxMzUsMjE0LDE5MiwyMDMsMTY1LDk4LDIxLDcxLDY4LDUxLDQ1LDQsMTQ0LDI0LDIzLDc3LDE0Niw5MSwyMDUsNTAsMTg3LDIwMSwyMDAsMTgsOTEsMTA2LDE4Miw5MCw5MSwxODEsODUsODQsMTcsMjA2LDIwMywzNiwxNDgsMTcxLDE0MCw5Miw0MCwzOSwxOTMsMTg5LDI0NCwxNTksMTU4LDI4LDI0NywyNDYsMTYxLDIzNiwzLDE5Niw1NCw2OCwxMDQsMTkzLDE2OCw4LDExNywyMjgsMzEsMTg5LDE5Myw1NSw5OCw5Nyw5OSwxMjYsNDcsMTAwLDE2Niw3OSwyMTgsMTU1LDE1NCwyNiwyMDksNDksMTMxLDEzNSwxMzYsMTUwLDQ3LDEyNiwyMTcsMjIzLDUyLDUzLDQ1LDUxLDEzNCwyMTEsMTcwLDE0MCw2Nyw2OSwxMDgsNDMsMTA2LDkxLDIzMCwxMTksMTIwLDIyNiwxMzAsMjQ3LDYzLDUzLDUyLDIzOCwyMCwyNDIsNDYsNzAsMTU2LDc4LDYyLDk2LDQ2LDUzLDYzLDE0MywzNCwyMjcsMTczLDE1NSwxMzMsMTIzLDExNywxMTEsNDQsMTI1LDE5LDIzNiwxMzQsNTEsMjE2LDIwNiwyMDUsMTU0LDE1MywyMiwzOSwzNywxNjcsMjAwLDIwMSwyMDgsMzYsMTQyLDEwMCw1NywyMTIsMjAyLDIwLDYwLDk5LDI4LDE1OCwxNTcsMzUsMjI2LDExMywxNjAsMTU5LDI3LDIwNCwyMDIsMjEwLDExMywyMjUsNDYsNDMsMjAyLDIwNCw2Miw3Niw3NywxMzcsMTIzLDExNiw0MSwzOCw3MiwyMDMsMTI5LDE0Miw2NCw5OCwyNDAsNDksMTAyLDY0LDQxLDczLDc0LDIxMiwyMTYsMjA3LDQyLDc0LDE4NCwxNjksMTcwLDIxMSwxNzAsMTQ5LDE3NiwxMDUsNjYsNjksMTIyLDYsMTY4LDEyMywxNDcsMTg3LDk2LDc3LDkwLDY1LDU1LDEwNyw4OSw5MCwxODAsMTAxLDEwMCwxMjAsNjMsMTA1LDEwNCw5MywxMzcsMjI3LDE1LDg2LDg1LDEyOSwxMDIsNDksMTQsODcsODYsNTUsOCw5LDEwMCw0NywxMjEsMTQ1LDIzLDIyLDg4LDg5LDE3OSw2LDEyMiwxOTYsODgsOTUsOTYsMTM4LDE3MiwxMzYsMjE1LDU4LDE3MiwxMTUsNDgsMjE5LDQyLDgwLDgxLDE5NSwzLDUxLDQzLDE0Niw2MSwxNzEsMTc1LDE5OSw4MSw4MiwzOCw1Myw0NiwyMjUsMTQ0LDE2MywxMTAsMjQ2LDMzLDcsNTIsNjUsNjYsMjI5LDIyOCwxMTcsMzQsMTI3LDIzNCwxMDcsMTA4LDY5LDEwOSwxMDgsMTUxLDQ4LDY0LDIzNSw2Miw3OCwxOTEsMTI5LDIwOSwxMjYsMTExLDM1LDE0MywxNjMsMTYxLDI0NiwxMTcsMTIzLDUwLDIyMiw2NSw1MiwxOSwxMjUsMTQxLDIyMSw1NSw2NSwzLDE5NSwxOTcsMjUsNywzMywyMjAsMjM3LDQ0LDcwLDcxLDEzOSwxMjIsMTkzLDI0NSwyNDcsMTMwLDMzLDcxLDIxLDE2MiwxNTMsMTU4LDE1OSwxNzAsMTY5LDE1MCwxODgsMTc0LDE5NiwyMTYsMTg2LDkyLDE0NCwxNjAsMTYxLDIsOTcsMTY3LDE0MSwxMjUsMjQxLDE2NCwxNjcsMzcsNzIsMzgsMTIsMTQ1LDE1OSwxNjAsMzgsODIsMTMsNjMsNjgsNzEsMjI2LDM1LDExMSwxNTgsMTUzLDE1NCwxMDEsNTAsMjA1LDIwNiw5MiwxNjUsMjA5LDE5OCwyMTcsMTY1LDE2Nyw5NywyMjAsMTE1LDIxOCwxMzMsMTEyLDI0MywyMzksMjM4LDI0MSwyMTQsMTM1LDE2OSwxOTAsMTczLDEzMywxNzEsMjA4LDMyLDEyNSw0NCwyMzcsODYsODcsMTc4LDg1LDg2LDE3OSw4NCw4NSwxODAsODMsODQsMTgxLDIwMSw4MywxODIsMTM3LDkzLDEzMiw3Niw2MiwxODMsNjEsNzYsMTg0LDU3LDYxLDE4NSwyMTIsNTcsMTg2LDIxNCwyMDcsMTg3LDM0LDE0MywxNTYsNzksMjM5LDIzNywxMjMsMTM3LDE3Nyw0NCwxLDQsMjAxLDE5NCwzMiw2NCwxMDIsMTI5LDIxMywyMTUsMTM4LDU5LDE2NiwyMTksMjQyLDk5LDk3LDIsOTQsMTQxLDc1LDU5LDIzNSwyNCwxMTAsMjI4LDI1LDEzMCwyMjYsMjMsMjQsMjI5LDIyLDIzLDIzMCwyNiwyMiwyMzEsMTEyLDI2LDIzMiwxODksMTkwLDI0MywyMjEsNTYsMTkwLDI4LDU2LDIyMSwyNywyOCwyMjIsMjksMjcsMjIzLDMwLDI5LDIyNCwyNDcsMzAsMjI1LDIzOCw3OSwyMCwxNjYsNTksNzUsNjAsNzUsMjQwLDE0NywxNzcsMjE1LDIwLDc5LDE2NiwxODcsMTQ3LDIxMywxMTIsMjMzLDI0NCwyMzMsMTI4LDI0NSwxMjgsMTE0LDE4OCwxMTQsMjE3LDE3NCwxMzEsMTE1LDIyMCwyMTcsMTk4LDIzNiwxOTgsMTMxLDEzNCwxNzcsMTMyLDU4LDE0MywzNSwxMjQsMTEwLDE2Myw3LDIyOCwxMTAsMjUsMzU2LDM4OSwzNjgsMTEsMzAyLDI2Nyw0NTIsMzUwLDM0OSwzMDIsMzAzLDI2OSwzNTcsMzQzLDI3Nyw0NTIsNDUzLDM1NywzMzMsMzMyLDI5NywxNzUsMTUyLDM3NywzODQsMzk4LDM4MiwzNDcsMzQ4LDMzMCwzMDMsMzA0LDI3MCw5LDMzNiwzMzcsMjc4LDI3OSwzNjAsNDE4LDI2Miw0MzEsMzA0LDQwOCw0MDksMzEwLDQxNSw0MDcsMjcwLDQwOSw0MTAsNDUwLDM0OCwzNDcsNDIyLDQzMCw0MzQsMzEzLDMxNCwxNywzMDYsMzA3LDM3NSwzODcsMzg4LDI2MCwyODYsNDE0LDM5OCwzMzUsNDA2LDQxOCwzNjQsMzY3LDQxNiw0MjMsMzU4LDMyNywyNTEsMjg0LDI5OCwyODEsNSw0LDM3MywzNzQsMjUzLDMwNywzMjAsMzIxLDQyNSw0MjcsNDExLDQyMSwzMTMsMTgsMzIxLDQwNSw0MDYsMzIwLDQwNCw0MDUsMzE1LDE2LDE3LDQyNiw0MjUsMjY2LDM3Nyw0MDAsMzY5LDMyMiwzOTEsMjY5LDQxNyw0NjUsNDY0LDM4NiwyNTcsMjU4LDQ2NiwyNjAsMzg4LDQ1NiwzOTksNDE5LDI4NCwzMzIsMzMzLDQxNywyODUsOCwzNDYsMzQwLDI2MSw0MTMsNDQxLDI4NSwzMjcsNDYwLDMyOCwzNTUsMzcxLDMyOSwzOTIsNDM5LDQzOCwzODIsMzQxLDI1Niw0MjksNDIwLDM2MCwzNjQsMzk0LDM3OSwyNzcsMzQzLDQzNyw0NDMsNDQ0LDI4MywyNzUsNDQwLDM2Myw0MzEsMjYyLDM2OSwyOTcsMzM4LDMzNywyNzMsMzc1LDMyMSw0NTAsNDUxLDM0OSw0NDYsMzQyLDQ2NywyOTMsMzM0LDI4Miw0NTgsNDYxLDQ2MiwyNzYsMzUzLDM4MywzMDgsMzI0LDMyNSwyNzYsMzAwLDI5MywzNzIsMzQ1LDQ0NywzODIsMzk4LDM2MiwzNTIsMzQ1LDM0MCwyNzQsMSwxOSw0NTYsMjQ4LDI4MSw0MzYsNDI3LDQyNSwzODEsMjU2LDI1MiwyNjksMzkxLDM5MywyMDAsMTk5LDQyOCwyNjYsMzMwLDMyOSwyODcsMjczLDQyMiwyNTAsNDYyLDMyOCwyNTgsMjg2LDM4NCwyNjUsMzUzLDM0MiwzODcsMjU5LDI1Nyw0MjQsNDMxLDQzMCwzNDIsMzUzLDI3NiwyNzMsMzM1LDQyNCwyOTIsMzI1LDMwNywzNjYsNDQ3LDM0NSwyNzEsMzAzLDMwMiw0MjMsMjY2LDM3MSwyOTQsNDU1LDQ2MCwyNzksMjc4LDI5NCwyNzEsMjcyLDMwNCw0MzIsNDM0LDQyNywyNzIsNDA3LDQwOCwzOTQsNDMwLDQzMSwzOTUsMzY5LDQwMCwzMzQsMzMzLDI5OSwzNTEsNDE3LDE2OCwzNTIsMjgwLDQxMSwzMjUsMzE5LDMyMCwyOTUsMjk2LDMzNiwzMTksNDAzLDQwNCwzMzAsMzQ4LDM0OSwyOTMsMjk4LDMzMywzMjMsNDU0LDQ0NywxNSwxNiwzMTUsMzU4LDQyOSwyNzksMTQsMTUsMzE2LDI4NSwzMzYsOSwzMjksMzQ5LDM1MCwzNzQsMzgwLDI1MiwzMTgsNDAyLDQwMyw2LDE5Nyw0MTksMzE4LDMxOSwzMjUsMzY3LDM2NCwzNjUsNDM1LDM2NywzOTcsMzQ0LDQzOCw0MzksMjcyLDI3MSwzMTEsMTk1LDUsMjgxLDI3MywyODcsMjkxLDM5Niw0MjgsMTk5LDMxMSwyNzEsMjY4LDI4Myw0NDQsNDQ1LDM3MywyNTQsMzM5LDI2Myw0NjYsMjQ5LDI4MiwzMzQsMjk2LDQ0OSwzNDcsMzQ2LDI2NCw0NDcsNDU0LDMzNiwyOTYsMjk5LDMzOCwxMCwxNTEsMjc4LDQzOSw0NTUsMjkyLDQwNyw0MTUsMzU4LDM3MSwzNTUsMzQwLDM0NSwzNzIsMzkwLDI0OSw0NjYsMzQ2LDM0NywyODAsNDQyLDQ0MywyODIsMTksOTQsMzcwLDQ0MSw0NDIsMjk1LDI0OCw0MTksMTk3LDI2MywyNTUsMzU5LDQ0MCwyNzUsMjc0LDMwMCwzODMsMzY4LDM1MSw0MTIsNDY1LDI2Myw0NjcsNDY2LDMwMSwzNjgsMzg5LDM4MCwzNzQsMzg2LDM5NSwzNzgsMzc5LDQxMiwzNTEsNDE5LDQzNiw0MjYsMzIyLDM3MywzOTAsMzg4LDIsMTY0LDM5MywzNzAsNDYyLDQ2MSwxNjQsMCwyNjcsMzAyLDExLDEyLDM3NCwzNzMsMzg3LDI2OCwxMiwxMywyOTMsMzAwLDMwMSw0NDYsMjYxLDM0MCwzODUsMzg0LDM4MSwzMzAsMjY2LDQyNSw0MjYsNDIzLDM5MSw0MjksMzU1LDQzNywzOTEsMzI3LDMyNiw0NDAsNDU3LDQzOCwzNDEsMzgyLDM2Miw0NTksNDU3LDQ2MSw0MzQsNDMwLDM5NCw0MTQsNDYzLDM2MiwzOTYsMzY5LDI2MiwzNTQsNDYxLDQ1NywzMTYsNDAzLDQwMiwzMTUsNDA0LDQwMywzMTQsNDA1LDQwNCwzMTMsNDA2LDQwNSw0MjEsNDE4LDQwNiwzNjYsNDAxLDM2MSwzMDYsNDA4LDQwNywyOTEsNDA5LDQwOCwyODcsNDEwLDQwOSw0MzIsNDM2LDQxMCw0MzQsNDE2LDQxMSwyNjQsMzY4LDM4MywzMDksNDM4LDQ1NywzNTIsMzc2LDQwMSwyNzQsMjc1LDQsNDIxLDQyOCwyNjIsMjk0LDMyNywzNTgsNDMzLDQxNiwzNjcsMjg5LDQ1NSw0MzksNDYyLDM3MCwzMjYsMiwzMjYsMzcwLDMwNSw0NjAsNDU1LDI1NCw0NDksNDQ4LDI1NSwyNjEsNDQ2LDI1Myw0NTAsNDQ5LDI1Miw0NTEsNDUwLDI1Niw0NTIsNDUxLDM0MSw0NTMsNDUyLDQxMyw0NjQsNDYzLDQ0MSw0MTMsNDE0LDI1OCw0NDIsNDQxLDI1Nyw0NDMsNDQyLDI1OSw0NDQsNDQzLDI2MCw0NDUsNDQ0LDQ2NywzNDIsNDQ1LDQ1OSw0NTgsMjUwLDI4OSwzOTIsMjkwLDI5MCwzMjgsNDYwLDM3Niw0MzMsNDM1LDI1MCwyOTAsMzkyLDQxMSw0MTYsNDMzLDM0MSw0NjMsNDY0LDQ1Myw0NjQsNDY1LDM1Nyw0NjUsNDEyLDM0Myw0MTIsMzk5LDM2MCwzNjMsNDQwLDQzNywzOTksNDU2LDQyMCw0NTYsMzYzLDQwMSw0MzUsMjg4LDM3MiwzODMsMzUzLDMzOSwyNTUsMjQ5LDQ0OCwyNjEsMjU1LDEzMywyNDMsMTkwLDEzMywxNTUsMTEyLDMzLDI0NiwyNDcsMzMsMTMwLDI1LDM5OCwzODQsMjg2LDM2MiwzOTgsNDE0LDM2Miw0NjMsMzQxLDI2MywzNTksNDY3LDI2MywyNDksMjU1LDQ2Niw0NjcsMjYwLDc1LDYwLDE2NiwyMzgsMjM5LDc5LDE2MiwxMjcsMTM5LDcyLDExLDM3LDEyMSwyMzIsMTIwLDczLDcyLDM5LDExNCwxMjgsNDcsMjMzLDIzMiwxMjgsMTAzLDEwNCw2NywxNTIsMTc1LDE0OCwxNzMsMTU3LDE1NSwxMTksMTE4LDEwMSw3NCw3Myw0MCwxMDcsOSwxMDgsNDksNDgsMTMxLDMyLDE5NCwyMTEsMTg0LDc0LDE4NSwxOTEsODAsMTgzLDE4NSw0MCwxODYsMTE5LDIzMCwxMTgsMjEwLDIwMiwyMTQsODQsODMsMTcsNzcsNzYsMTQ2LDE2MSwxNjAsMzAsMTkwLDU2LDE3MywxODIsMTA2LDE5NCwxMzgsMTM1LDE5MiwxMjksMjAzLDk4LDU0LDIxLDY4LDUsNTEsNCwxNDUsMTQ0LDIzLDkwLDc3LDkxLDIwNywyMDUsMTg3LDgzLDIwMSwxOCwxODEsOTEsMTgyLDE4MCw5MCwxODEsMTYsODUsMTcsMjA1LDIwNiwzNiwxNzYsMTQ4LDE0MCwxNjUsOTIsMzksMjQ1LDE5MywyNDQsMjcsMTU5LDI4LDMwLDI0NywxNjEsMTc0LDIzNiwxOTYsMTAzLDU0LDEwNCw1NSwxOTMsOCwxMTEsMTE3LDMxLDIyMSwxODksNTUsMjQwLDk4LDk5LDE0MiwxMjYsMTAwLDIxOSwxNjYsMjE4LDExMiwxNTUsMjYsMTk4LDIwOSwxMzEsMTY5LDEzNSwxNTAsMTE0LDQ3LDIxNywyMjQsMjIzLDUzLDIyMCw0NSwxMzQsMzIsMjExLDE0MCwxMDksNjcsMTA4LDE0Niw0Myw5MSwyMzEsMjMwLDEyMCwxMTMsMjI2LDI0NywxMDUsNjMsNTIsMjQxLDIzOCwyNDIsMTI0LDQ2LDE1Niw5NSw3OCw5Niw3MCw0Niw2MywxMTYsMTQzLDIyNywxMTYsMTIzLDExMSwxLDQ0LDE5LDMsMjM2LDUxLDIwNywyMTYsMjA1LDI2LDE1NCwyMiwxNjUsMzksMTY3LDE5OSwyMDAsMjA4LDEwMSwzNiwxMDAsNDMsNTcsMjAyLDI0MiwyMCw5OSw1NiwyOCwxNTcsMTI0LDM1LDExMywyOSwxNjAsMjcsMjExLDIwNCwyMTAsMTI0LDExMyw0NiwxMDYsNDMsMjA0LDk2LDYyLDc3LDIyNywxMzcsMTE2LDczLDQxLDcyLDM2LDIwMywxNDIsMjM1LDY0LDI0MCw0OCw0OSw2NCw0Miw0MSw3NCwyMTQsMjEyLDIwNywxODMsNDIsMTg0LDIxMCwxNjksMjExLDE0MCwxNzAsMTc2LDEwNCwxMDUsNjksMTkzLDEyMiwxNjgsNTAsMTIzLDE4Nyw4OSw5Niw5MCw2Niw2NSwxMDcsMTc5LDg5LDE4MCwxMTksMTAxLDEyMCw2OCw2MywxMDQsMjM0LDkzLDIyNywxNiwxNSw4NSwyMDksMTI5LDQ5LDE1LDE0LDg2LDEwNyw1NSw5LDEyMCwxMDAsMTIxLDE1MywxNDUsMjIsMTc4LDg4LDE3OSwxOTcsNiwxOTYsODksODgsOTYsMTM1LDEzOCwxMzYsMTM4LDIxNSwxNzIsMjE4LDExNSwyMTksNDEsNDIsODEsNSwxOTUsNTEsNTcsNDMsNjEsMjA4LDE3MSwxOTksNDEsODEsMzgsMjI0LDUzLDIyNSwyNCwxNDQsMTEwLDEwNSw1Miw2NiwxMTgsMjI5LDExNywyMjcsMzQsMjM0LDY2LDEwNyw2OSwxMCwxMDksMTUxLDIxOSw0OCwyMzUsMTgzLDYyLDE5MSwxNDIsMTI5LDEyNiwxMTYsMTExLDE0Myw3LDE2MywyNDYsMTE4LDExNyw1MCwyMjMsMjIyLDUyLDk0LDE5LDE0MSwyMjIsMjIxLDY1LDE5NiwzLDE5Nyw0NSwyMjAsNDQsMTU2LDcwLDEzOSwxODgsMTIyLDI0NSwxMzksNzEsMTYyLDE0NSwxNTMsMTU5LDE0OSwxNzAsMTUwLDEyMiwxODgsMTk2LDIwNiwyMTYsOTIsMTYzLDE0NCwxNjEsMTY0LDIsMTY3LDI0MiwxNDEsMjQxLDAsMTY0LDM3LDExLDcyLDEyLDE0NCwxNDUsMTYwLDEyLDM4LDEzLDcwLDYzLDcxLDMxLDIyNiwxMTEsMTU3LDE1OCwxNTQsMzYsMTAxLDIwNSwyMDMsMjA2LDE2NSwxMjYsMjA5LDIxNyw5OCwxNjUsOTcsMjM3LDIyMCwyMTgsMjM3LDIzOSwyNDEsMjEwLDIxNCwxNjksMTQwLDE3MSwzMiwyNDEsMTI1LDIzNywxNzksODYsMTc4LDE4MCw4NSwxNzksMTgxLDg0LDE4MCwxODIsODMsMTgxLDE5NCwyMDEsMTgyLDE3NywxMzcsMTMyLDE4NCw3NiwxODMsMTg1LDYxLDE4NCwxODYsNTcsMTg1LDIxNiwyMTIsMTg2LDE5MiwyMTQsMTg3LDEzOSwzNCwxNTYsMjE4LDc5LDIzNywxNDcsMTIzLDE3Nyw0NSw0NCw0LDIwOCwyMDEsMzIsOTgsNjQsMTI5LDE5MiwyMTMsMTM4LDIzNSw1OSwyMTksMTQxLDI0Miw5Nyw5NywyLDE0MSwyNDAsNzUsMjM1LDIyOSwyNCwyMjgsMzEsMjUsMjI2LDIzMCwyMywyMjksMjMxLDIyLDIzMCwyMzIsMjYsMjMxLDIzMywxMTIsMjMyLDI0NCwxODksMjQzLDE4OSwyMjEsMTkwLDIyMiwyOCwyMjEsMjIzLDI3LDIyMiwyMjQsMjksMjIzLDIyNSwzMCwyMjQsMTEzLDI0NywyMjUsOTksNjAsMjQwLDIxMywxNDcsMjE1LDYwLDIwLDE2NiwxOTIsMTg3LDIxMywyNDMsMTEyLDI0NCwyNDQsMjMzLDI0NSwyNDUsMTI4LDE4OCwxODgsMTE0LDE3NCwxMzQsMTMxLDIyMCwxNzQsMjE3LDIzNiwyMzYsMTk4LDEzNCwyMTUsMTc3LDU4LDE1NiwxNDMsMTI0LDI1LDExMCw3LDMxLDIyOCwyNSwyNjQsMzU2LDM2OCwwLDExLDI2Nyw0NTEsNDUyLDM0OSwyNjcsMzAyLDI2OSwzNTAsMzU3LDI3NywzNTAsNDUyLDM1NywyOTksMzMzLDI5NywzOTYsMTc1LDM3NywzODEsMzg0LDM4MiwyODAsMzQ3LDMzMCwyNjksMzAzLDI3MCwxNTEsOSwzMzcsMzQ0LDI3OCwzNjAsNDI0LDQxOCw0MzEsMjcwLDMwNCw0MDksMjcyLDMxMCw0MDcsMzIyLDI3MCw0MTAsNDQ5LDQ1MCwzNDcsNDMyLDQyMiw0MzQsMTgsMzEzLDE3LDI5MSwzMDYsMzc1LDI1OSwzODcsMjYwLDQyNCwzMzUsNDE4LDQzNCwzNjQsNDE2LDM5MSw0MjMsMzI3LDMwMSwyNTEsMjk4LDI3NSwyODEsNCwyNTQsMzczLDI1MywzNzUsMzA3LDMyMSwyODAsNDI1LDQxMSwyMDAsNDIxLDE4LDMzNSwzMjEsNDA2LDMyMSwzMjAsNDA1LDMxNCwzMTUsMTcsNDIzLDQyNiwyNjYsMzk2LDM3NywzNjksMjcwLDMyMiwyNjksNDEzLDQxNyw0NjQsMzg1LDM4NiwyNTgsMjQ4LDQ1Niw0MTksMjk4LDI4NCwzMzMsMTY4LDQxNyw4LDQ0OCwzNDYsMjYxLDQxNyw0MTMsMjg1LDMyNiwzMjcsMzI4LDI3NywzNTUsMzI5LDMwOSwzOTIsNDM4LDM4MSwzODIsMjU2LDI3OSw0MjksMzYwLDM2NSwzNjQsMzc5LDM1NSwyNzcsNDM3LDI4Miw0NDMsMjgzLDI4MSwyNzUsMzYzLDM5NSw0MzEsMzY5LDI5OSwyOTcsMzM3LDMzNSwyNzMsMzIxLDM0OCw0NTAsMzQ5LDM1OSw0NDYsNDY3LDI4MywyOTMsMjgyLDI1MCw0NTgsNDYyLDMwMCwyNzYsMzgzLDI5MiwzMDgsMzI1LDI4MywyNzYsMjkzLDI2NCwzNzIsNDQ3LDM0NiwzNTIsMzQwLDM1NCwyNzQsMTksMzYzLDQ1NiwyODEsNDI2LDQzNiw0MjUsMzgwLDM4MSwyNTIsMjY3LDI2OSwzOTMsNDIxLDIwMCw0MjgsMzcxLDI2NiwzMjksNDMyLDI4Nyw0MjIsMjkwLDI1MCwzMjgsMzg1LDI1OCwzODQsNDQ2LDI2NSwzNDIsMzg2LDM4NywyNTcsNDIyLDQyNCw0MzAsNDQ1LDM0MiwyNzYsNDIyLDI3Myw0MjQsMzA2LDI5MiwzMDcsMzUyLDM2NiwzNDUsMjY4LDI3MSwzMDIsMzU4LDQyMywzNzEsMzI3LDI5NCw0NjAsMzMxLDI3OSwyOTQsMzAzLDI3MSwzMDQsNDM2LDQzMiw0MjcsMzA0LDI3Miw0MDgsMzk1LDM5NCw0MzEsMzc4LDM5NSw0MDAsMjk2LDMzNCwyOTksNiwzNTEsMTY4LDM3NiwzNTIsNDExLDMwNywzMjUsMzIwLDI4NSwyOTUsMzM2LDMyMCwzMTksNDA0LDMyOSwzMzAsMzQ5LDMzNCwyOTMsMzMzLDM2NiwzMjMsNDQ3LDMxNiwxNSwzMTUsMzMxLDM1OCwyNzksMzE3LDE0LDMxNiw4LDI4NSw5LDI3NywzMjksMzUwLDI1MywzNzQsMjUyLDMxOSwzMTgsNDAzLDM1MSw2LDQxOSwzMjQsMzE4LDMyNSwzOTcsMzY3LDM2NSwyODgsNDM1LDM5NywyNzgsMzQ0LDQzOSwzMTAsMjcyLDMxMSwyNDgsMTk1LDI4MSwzNzUsMjczLDI5MSwxNzUsMzk2LDE5OSwzMTIsMzExLDI2OCwyNzYsMjgzLDQ0NSwzOTAsMzczLDMzOSwyOTUsMjgyLDI5Niw0NDgsNDQ5LDM0NiwzNTYsMjY0LDQ1NCwzMzcsMzM2LDI5OSwzMzcsMzM4LDE1MSwyOTQsMjc4LDQ1NSwzMDgsMjkyLDQxNSw0MjksMzU4LDM1NSwyNjUsMzQwLDM3MiwzODgsMzkwLDQ2NiwzNTIsMzQ2LDI4MCwyOTUsNDQyLDI4MiwzNTQsMTksMzcwLDI4NSw0NDEsMjk1LDE5NSwyNDgsMTk3LDQ1Nyw0NDAsMjc0LDMwMSwzMDAsMzY4LDQxNywzNTEsNDY1LDI1MSwzMDEsMzg5LDM4NSwzODAsMzg2LDM5NCwzOTUsMzc5LDM5OSw0MTIsNDE5LDQxMCw0MzYsMzIyLDM4NywzNzMsMzg4LDMyNiwyLDM5MywzNTQsMzcwLDQ2MSwzOTMsMTY0LDI2NywyNjgsMzAyLDEyLDM4NiwzNzQsMzg3LDMxMiwyNjgsMTMsMjk4LDI5MywzMDEsMjY1LDQ0NiwzNDAsMzgwLDM4NSwzODEsMjgwLDMzMCw0MjUsMzIyLDQyNiwzOTEsNDIwLDQyOSw0MzcsMzkzLDM5MSwzMjYsMzQ0LDQ0MCw0MzgsNDU4LDQ1OSw0NjEsMzY0LDQzNCwzOTQsNDI4LDM5NiwyNjIsMjc0LDM1NCw0NTcsMzE3LDMxNiw0MDIsMzE2LDMxNSw0MDMsMzE1LDMxNCw0MDQsMzE0LDMxMyw0MDUsMzEzLDQyMSw0MDYsMzIzLDM2NiwzNjEsMjkyLDMwNiw0MDcsMzA2LDI5MSw0MDgsMjkxLDI4Nyw0MDksMjg3LDQzMiw0MTAsNDI3LDQzNCw0MTEsMzcyLDI2NCwzODMsNDU5LDMwOSw0NTcsMzY2LDM1Miw0MDEsMSwyNzQsNCw0MTgsNDIxLDI2MiwzMzEsMjk0LDM1OCw0MzUsNDMzLDM2NywzOTIsMjg5LDQzOSwzMjgsNDYyLDMyNiw5NCwyLDM3MCwyODksMzA1LDQ1NSwzMzksMjU0LDQ0OCwzNTksMjU1LDQ0NiwyNTQsMjUzLDQ0OSwyNTMsMjUyLDQ1MCwyNTIsMjU2LDQ1MSwyNTYsMzQxLDQ1Miw0MTQsNDEzLDQ2MywyODYsNDQxLDQxNCwyODYsMjU4LDQ0MSwyNTgsMjU3LDQ0MiwyNTcsMjU5LDQ0MywyNTksMjYwLDQ0NCwyNjAsNDY3LDQ0NSwzMDksNDU5LDI1MCwzMDUsMjg5LDI5MCwzMDUsMjkwLDQ2MCw0MDEsMzc2LDQzNSwzMDksMjUwLDM5MiwzNzYsNDExLDQzMyw0NTMsMzQxLDQ2NCwzNTcsNDUzLDQ2NSwzNDMsMzU3LDQxMiw0MzcsMzQzLDM5OSwzNDQsMzYwLDQ0MCw0MjAsNDM3LDQ1NiwzNjAsNDIwLDM2MywzNjEsNDAxLDI4OCwyNjUsMzcyLDM1MywzOTAsMzM5LDI0OSwzMzksNDQ4LDI1NV0sU0FNUExFX0ZBQ0U6e2tleXBvaW50czpbe3g6MzU2LjI4MDQ0MTI4NDE3OTcseToyOTUuMTk2MDU2MzY1OTY2OCx6Oi0yMy43ODY0NDk0MzIzNzMwNDcsbmFtZTpcImxpcHNcIn0se3g6MzU0Ljg4NTk0MDU1MTc1NzgseToyNjQuNjk1MjA1Njg4NDc2NTYsejotMzYuNzE4NDM1Mjg3NDc1NTg2fSx7eDozNTUuMjE4MDg2MjQyNjc1OCx5OjI3NS4zMzYwMzY2ODIxMjg5LHo6LTIxLjE4MzcxMjQ4MjQ1MjM5M30se3g6MzQ3LjM0OTg1MzUxNTYyNSx5OjI0Mi40NDAwMjM0MjIyNDEyLHo6LTI1LjA5MzY1NTU4NjI0MjY3Nn0se3g6MzU0LjQwMTM1OTU1ODEwNTQ3LHk6MjU2LjY3OTMzNDY0MDUwMjkzLHo6LTM4LjIzNTcyNjM1NjUwNjM1fSx7eDozNTMuNzY4OTk3MTkyMzgyOCx5OjI0Ny41NDg4NjYyNzE5NzI2Nix6Oi0zNC41NDc1NDM1MjU2OTU4fSx7eDozNTIuMTI4ODI5OTU2MDU0Nyx5OjIyNy4zNDMxMjA1NzQ5NTExNyx6Oi0xMy4wOTUzODYwMjgyODk3OTV9LHt4OjMwMy41MDEzMTk4ODUyNTM5LHk6MjM0LjY3MDAyODY4NjUyMzQ0LHo6MTIuNTAwMTQxODU5MDU0NTY1LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozNTEuMDkzNzg4MTQ2OTcyNjYseToyMTEuODc1NDcyMDY4Nzg2NjIsejotNi40MTM0NzE2OTg3NjA5ODZ9LHt4OjM1MC43MTE1OTM2Mjc5Mjk3LHk6MjAyLjEyNTE2MzA3ODMwODEsejotNi40MTM0NzE2OTg3NjA5ODZ9LHt4OjM0OC4zMzY2Nzc1NTEyNjk1Myx5OjE2OC43NzQxNzU2NDM5MjA5LHo6Ni40ODM1MDAwMDM4MTQ2OTcsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM1Ni40ODA2MzY1OTY2Nzk3LHk6Mjk5LjI5OTUzNTc1MTM0MjgsejotMjMuMTQ0NTE5MzI5MDcxMDQ1fSx7eDozNTYuNTUxMTcwMzQ5MTIxMSx5OjMwMi42NjE0NjY1OTg1MTA3NCx6Oi0yMS4wMjAzMTIzMDkyNjUxMzd9LHt4OjM1Ni42MjM5NTQ3NzI5NDkyLHk6MzA0LjE1MzYzMzExNzY3NTgsejotMTguMTM3NDU5NzU0OTQzODQ4LG5hbWU6XCJsaXBzXCJ9LHt4OjM1Ni41ODA3MzQyNTI5Mjk3LHk6MzA1LjE4NDA1OTE0MzA2NjQsejotMTguNzY3NzE5MjY4Nzk4ODI4LG5hbWU6XCJsaXBzXCJ9LHt4OjM1Ni44MjQxNTAwODU0NDkyLHk6MzA4LjI1NzExMjUwMzA1MTc2LHo6LTIwLjE2ODI5NDkwNjYxNjIxfSx7eDozNTcuMTEzMDM3MTA5Mzc1LHk6MzEyLjI2Mjc3MzUxMzc5Mzk1LHo6LTIyLjEwNTc1ODE5MDE1NTAzfSx7eDozNTcuMzQ5NjI0NjMzNzg5MDYseTozMTcuMTEyMzIxODUzNjM3Nyx6Oi0yMS44MzczMTU1NTkzODcyMDcsbmFtZTpcImxpcHNcIn0se3g6MzU3LjY2NTg2MzAzNzEwOTQseTozMjUuNTEwMzY4MzQ3MTY3OTcsejotMTYuMjcwMDI0Nzc2NDU4NzR9LHt4OjM1NS4wMjAxNDE2MDE1NjI1LHk6MjY5LjM2Mjc5Mjk2ODc1LHo6LTMzLjczMDU0MDI3NTU3MzczfSx7eDozNDguNTIzNzUwMzA1MTc1OCx5OjI3MC4zMzQxMTAyNjAwMDk3Nyx6Oi0yNC45MzAyNTMwMjg4Njk2M30se3g6Mjc5Ljk3MzMxNjE5MjYyNjk1LHk6MjEzLjI0MTc2Nzg4MzMwMDc4LHo6NDcuNzU5NjQyNjAxMDEzMTg0LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMjIuNjY1MjkwODMyNTE5NTMseToyMzguNTAyNzI2NTU0ODcwNix6OjUuNTM1MTkzMDg1NjcwNDcxfSx7eDozMTYuMDk4MzY1NzgzNjkxNCx5OjIzOS45NDQ4OTY2OTc5OTgwNSx6OjUuNzc3Mzc2Mjk0MTM2MDQ3fSx7eDozMDkuOTQzMTYxMDEwNzQyMix5OjI0MC4yNDUxODk2NjY3NDgwNSx6OjcuNTEwNTg5MzYxMTkwNzk2fSx7eDozMDEuMzE5OTQyNDc0MzY1MjMseToyMzcuODYxMzg1MzQ1NDU4OTgsejoxMy4xMTg3MjgzOTkyNzY3MzN9LHt4OjMyOC4xNDI2NjIwNDgzMzk4NCx5OjIzNS44MDQ5Njc4ODAyNDkwMix6OjYuNjQ2OTAwMTc3MDAxOTUzfSx7eDozMTMuNzMyNjQzMTI3NDQxNCx5OjIyMi4xMTE2MTEzNjYyNzE5Nyx6OjMuOTg4NzIzNzU0ODgyODEyNX0se3g6MzIwLjQ1MTk2NTMzMjAzMTI1LHk6MjIxLjg3NzI5MzU4NjczMDk2LHo6NC42MDE0NzYxOTI0NzQzNjV9LHt4OjMwNy4zNTY3OTYyNjQ2NDg0NCx5OjIyMy42Mzc5Mzg0OTk0NTA2OCx6OjUuOTMyMDIzNTI1MjM4MDM3fSx7eDozMDMuMDAzMTIwNDIyMzYzMyx5OjIyNi4zNzQzNzgyMDQzNDU3LHo6OC40NzkzMjEwMDI5NjAyMDV9LHt4OjI5Ni44MDAyMzE5MzM1OTM3NSx5OjI0Mi45NDI5OTEyNTY3MTM4Nyx6OjE1LjkzMTU1MjY0ODU0NDMxMn0se3g6MzMyLjIzNTI5ODE1NjczODMseTozNDAuNzczNDEwNzk3MTE5MTQsejotMTAuMTY1ODQ4NzMxOTk0NjI5fSx7eDozMDEuMzg1ODc5NTE2NjAxNTYseToyMzMuNDY0NDc5NDQ2NDExMTMsejoxNC43NjQ0MDU0ODg5Njc4OTYsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjI3OS4wMTQ3MDE4NDMyNjE3LHk6MjQ0LjM3MTU1NzIzNTcxNzc3LHo6NDUuNzc1NDk0NTc1NTAwNDl9LHt4OjI4OS42MDU0ODQwMDg3ODkwNix5OjIzOS4xODA3NDYwNzg0OTEyLHo6MjMuMTkxMjA0MDcxMDQ0OTIyfSx7eDozMjAuMzIyNTcwODAwNzgxMjUseToyNjcuMTI5Mjc4MTgyOTgzNCx6Oi00Ljk1NDUzNzc0OTI5MDQ2Nn0se3g6MzQ3LjY0NTgzNTg3NjQ2NDg0LHk6Mjk0LjQ5NTUwNjI4NjYyMTEsejotMjMuMDYyODIwNDM0NTcwMzEyLG5hbWU6XCJsaXBzXCJ9LHt4OjM0OS4yODEzODczMjkxMDE1Nix5OjMwMy4xMDk1ODg2MjMwNDY5LHo6LTIwLjIzODMyMzIxMTY2OTkyMn0se3g6MzM4Ljk0NTMxMjUseToyOTguMTkxODYyMTA2MzIzMjQsejotMTkuNDU2MzM2NDk4MjYwNDk4LG5hbWU6XCJsaXBzXCJ9LHt4OjMzMy4zNjc4ODE3NzQ5MDIzNCx5OjMwMi42NzA2NzkwOTI0MDcyLHo6LTE0Ljc3NjA3NzI3MDUwNzgxMixuYW1lOlwibGlwc1wifSx7eDozNDIuODkxODgzODUwMDk3NjYseTozMDQuMzU2MTM2MzIyMDIxNSx6Oi0xNy43NTIzMDE2OTI5NjI2NDZ9LHt4OjMzNy43Mzc1MDMwNTE3NTc4LHk6MzA2LjAwOTgzNjE5Njg5OTQsejotMTMuNDEwNTE1Nzg1MjE3Mjg1fSx7eDozMjUuNjE1OTIxMDIwNTA3OCx5OjMxNi4yMjk5NTM3NjU4NjkxNCx6Oi02LjY4MTkxNDkyNTU3NTI1Nn0se3g6MzQ5LjAxMDQ2NzUyOTI5NjkseToyNjQuOTgxODUxNTc3NzU4OCx6Oi0zNi4yNzQ5MTk1MDk4ODc2OTV9LHt4OjM0Ny43MTM4OTAwNzU2ODM2LHk6MjU3LjU2NjQ4MDYzNjU5NjcsejotMzcuNjc1NDk1MTQ3NzA1MDh9LHt4OjI5MS43OTM1NzUyODY4NjUyMyx5OjIxOC44ODE3MTY3MjgyMTA0NSx6OjExLjU3ODA5NDk1OTI1OTAzMyxuYW1lOlwicmlnaHRFeWVicm93XCJ9LHt4OjMzMi4yNjg5NDM3ODY2MjExLHk6MjQ3LjU2OTQ2NTYzNzIwNzAzLHo6LTMuMzczMDUzOTY3OTUyNzI4M30se3g6MzMyLjAwNzQ0NjI4OTA2MjUseToyNjcuMTIwMTIyOTA5NTQ1OSx6Oi0xOS45Njk4NzkzODg4MDkyMDR9LHt4OjMzMS4yNzk1MjU3NTY4MzU5NCx5OjI2My42OTY3NjU4OTk2NTgyLHo6LTE3LjQ3MjE4NjA4ODU2MjAxfSx7eDozMDEuMDQzNzM5MzE4ODQ3NjYseToyNjkuNTY1NTI1MDU0OTMxNjQsejozLjYxODE1NDgyMzc4MDA2fSx7eDozNDcuNDg2MzgxNTMwNzYxNyx5OjI0OS4wNzA2NDQzNzg2NjIxLHo6LTMyLjYzMzQyMTQyMTA1MTAyNX0se3g6MzA3LjI2MTE4MDg3NzY4NTU1LHk6MjA4LjI2NDY4OTQ0NTQ5NTYsejoxLjE1OTEyMjY2MDc1NjExMTEsbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDoyOTcuOTE5MTk3MDgyNTE5NTMseToyMTIuMjI2MDQ3NTE1ODY5MTQsejo1LjkxNDUxNjQ0ODk3NDYwOSxuYW1lOlwicmlnaHRFeWVicm93XCJ9LHt4OjI4NS4xNjUxMzgyNDQ2Mjg5LHk6MTk3Ljk4NDUwNDY5OTcwNzAzLHo6MzYuMzkxNjM3MzI1Mjg2ODY1LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMzcuMDQwOTc3NDc4MDI3MzQseToyMTEuMjUyMjk4MzU1MTAyNTQsejotNC41NDg5NTQ2NjU2NjA4NTh9LHt4OjMyNi41OTEyNjI4MTczODI4LHk6MjIzLjE2Njk4NTUxMTc3OTc5LHo6Ni42NzAyNDM3NDAwODE3ODd9LHt4OjMyMC4wNTY2NDgyNTQzOTQ1Myx5OjMwOS41ODM0MjU1MjE4NTA2LHo6LTQuMDU1ODM1MDA4NjIxMjE2fSx7eDoyODkuNjg2NjIyNjE5NjI4OSx5OjMxNC42MTczOTU0MDEwMDEsejo1My44NzU0ODkyMzQ5MjQzMTYsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMzNy40MjU2ODk2OTcyNjU2LHk6MjcwLjg3NTUzMDI0MjkxOTksejotMTcuNjcwNjAxNjA2MzY5MDJ9LHt4OjM0My42OTkyMjYzNzkzOTQ1Myx5OjI3My4wMDAwNDAwNTQzMjEzLHo6LTE4Ljc1NjA0ODY3OTM1MTgwN30se3g6MzI3LjQyNDI0MDExMjMwNDcseTozMDkuMjIzOTk1MjA4NzQwMjMsejotNC43MDM2MDEwMDI2OTMxNzYsbmFtZTpcImxpcHNcIn0se3g6MzMwLjM3MjIwMDAxMjIwNzAzLHk6MzA4LjMzMjMwMDE4NjE1NzIsejotNi40NDI2NDk5NjA1MTc4ODN9LHt4OjI5My44NzAyNzc0MDQ3ODUxNix5OjIwNy43OTYxODI2MzI0NDYzLHo6OS44MjE1Mzk1MjEyMTczNDYsbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMzIuMTE0MzcyMjUzNDE3OTcseToyNzEuMjI4MTIyNzExMTgxNjQsejotMTYuNjQzNTEyMjQ4OTkyOTJ9LHt4OjMyMC4xMTk3ODE0OTQxNDA2LHk6MjA3LjQwMzY2NDU4ODkyODIyLHo6LTIuNDgxNjQ1NjQzNzExMDksbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMTguNTk1NzUyNzE2MDY0NDUseToyMDEuMDc0NDM4MDk1MDkyNzcsejotMy4xMTA0NDYwMzU4NjE5NjksbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMTAuNzIzMDM3NzE5NzI2NTYseToxNzUuNzUwNzUxNDk1MzYxMzMsejoxMy4zMjg4MTU2OTg2MjM2NTcsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjI4OS42NzU3ODg4NzkzOTQ1Myx5OjIwMi4yOTgzNTUxMDI1MzkwNix6OjIxLjM3MDQ1NjIxODcxOTQ4Mn0se3g6MzE1LjMwODc5OTc0MzY1MjM0LHk6MTg3LjM1MjYwMDA5NzY1NjI1LHo6NS4wMzA0MDI1NDExNjA1ODM1fSx7eDoyODcuODkzNjc2NzU3ODEyNSx5OjIxNi41NDc5MzczOTMxODg0OCx6OjE3LjgxMDY1ODIxNjQ3NjQ0LG5hbWU6XCJyaWdodEV5ZWJyb3dcIn0se3g6MjgzLjkzOTE4OTkxMDg4ODcseToyMTUuMDExNDI1MDE4MzEwNTUsejozMi4wNDk4NDkwMzMzNTU3MX0se3g6MzQ4LjM1MzMwOTYzMTM0NzY2LHk6Mjk5LjQxNTU3ODg0MjE2MzEsejotMjIuNDc5MjQ1NjYyNjg5MjF9LHt4OjM0MS4xNzkwNDY2MzA4NTk0LHk6MzAxLjgyMjE4NTUxNjM1NzQsejotMTguOTc3ODA1Mzc2MDUyODU2fSx7eDozMzUuNjk3MTM1OTI1MjkyOTcseTozMDQuNDI2Njg5MTQ3OTQ5Mix6Oi0xNC42ODI3MDY1OTQ0NjcxNjN9LHt4OjMzOS40NjE1MTczMzM5ODQ0LHk6MjcyLjM2NTQzNjU1Mzk1NTEsejotMTYuMzg2NzQwMjA3NjcyMTJ9LHt4OjMyOC45OTYwMDk4MjY2NjAxNix5OjMwOC44NjY4NTM3MTM5ODkyNix6Oi01LjYxNjg5Mzc2ODMxMDU0N30se3g6MzMyLjAwMzEzNTY4MTE1MjM0LHk6MzA5LjE4NzU3NDM4NjU5NjcsejotMTAuMzM1MDg0MTk5OTA1Mzk2fSx7eDozMzEuMDA2ODEzMDQ5MzE2NCx5OjMwNy45Mjc0MzY4Mjg2MTMzLHo6LTYuNjgxOTE0OTI1NTc1MjU2LG5hbWU6XCJsaXBzXCJ9LHt4OjM0MS4xMzc5MjQxOTQzMzU5NCx5OjI2Ni40ODc2OTM3ODY2MjExLHo6LTI2LjU2NDI1OTUyOTExMzc3fSx7eDozMzkuMDI5NTAyODY4NjUyMzQseTozMDUuNjY2MzcwMzkxODQ1Nyx6Oi0xMi4zMzY3NDE2ODU4NjczMSxuYW1lOlwibGlwc1wifSx7eDozNDQuMjI5MzU0ODU4Mzk4NDQseTozMDQuOTQ1Mjc4MTY3NzI0Nix6Oi0xNS4xNjEyMzUzMzI0ODkwMTQsbmFtZTpcImxpcHNcIn0se3g6MzUwLjE4NDQwMjQ2NTgyMDMseTozMDQuMzc0MzAzODE3NzQ5LHo6LTE3LjUzMDU0MzgwNDE2ODcsbmFtZTpcImxpcHNcIn0se3g6MzQ4LjUyNjMwNjE1MjM0Mzc1LHk6MzI1Ljk1NjIzMDE2MzU3NDIsejotMTYuMTY0OTgyMzE4ODc4MTc0fSx7eDozNDguNjU4MTgwMjM2ODE2NCx5OjMxNy4xNjI0MTgzNjU0Nzg1LHo6LTIxLjUxMDUxMjgyODgyNjkwNCxuYW1lOlwibGlwc1wifSx7eDozNDguOTc2NjMxMTY0NTUwOCx5OjMxMi4xOTIzMDY1MTg1NTQ3LHo6LTIxLjcwODkyOTUzODcyNjgwN30se3g6MzQ5LjI0Mjc0NDQ0NTgwMDgseTozMDguMDY2MDgyMDAwNzMyNCx6Oi0xOS42NDMwNzkwNDI0MzQ2OTJ9LHt4OjM0OS42NzQ5MTE0OTkwMjM0NCx5OjMwNS40Mjc0NzQ5NzU1ODU5NCx6Oi0xOC4xNjA4MDMzMTgwMjM2OCxuYW1lOlwibGlwc1wifSx7eDozMzcuOTU1ODk0NDcwMjE0ODQseTozMDYuNjUzNTk0OTcwNzAzMSx6Oi0xMi44MDM1OTg2NDIzNDkyNDMsbmFtZTpcImxpcHNcIn0se3g6MzM3LjA2ODc4NjYyMTA5Mzc1LHk6MzA3LjYzMTY5Mjg4NjM1MjU0LHo6LTE0LjI3NDIwMzc3NzMxMzIzMn0se3g6MzM1Ljc3NDQ5Nzk4NTgzOTg0LHk6MzA5Ljg0NDk1MTYyOTYzODcsejotMTUuNjk4MTI0MTcwMzAzMzQ1fSx7eDozMzQuNjA5OTA5MDU3NjE3Mix5OjMxMi43OTk3MDE2OTA2NzM4LHo6LTE0Ljc2NDQwNTQ4ODk2Nzg5NixuYW1lOlwibGlwc1wifSx7eDozMjcuMjMzMDg1NjMyMzI0Mix5OjI5My44MDg2NjA1MDcyMDIxNSx6Oi0xMS44NjQwNDcwNTA0NzYwNzR9LHt4OjI4MC45NzY3OTEzODE4MzU5NCx5OjI3OS43OTkyODk3MDMzNjkxNCx6OjY4LjkwODM0MzMxNTEyNDUxLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNTUuMTM4NDM1MzYzNzY5NTMseToyNzEuNzg3NTY3MTM4NjcxOSx6Oi0yNS4zNTA0Mjc2Mjc1NjM0Nzd9LHt4OjMzNC43MjM1ODcwMzYxMzI4LHk6MzA3LjQ2NTYzOTExNDM3OTksejotOS4zMDIxNTg5NTE3NTkzMzgsbmFtZTpcImxpcHNcIn0se3g6MzMzLjUyOTM5NjA1NzEyODkseTozMDcuODk3ODI1MjQxMDg4ODcsejotMTAuMjAwODYyODg0NTIxNDg0fSx7eDozNDYuMjk2ODgyNjI5Mzk0NTMseToyNzYuNDI1NjI4NjYyMTA5NCx6Oi0xOS43NDgxMjI2OTIxMDgxNTR9LHt4OjMzNS4xNjI0Njc5NTY1NDI5Nyx5OjI3Ni4yMjA5Nzk2OTA1NTE3Nix6Oi0xMi4zMTMzOTgxMjI3ODc0NzZ9LHt4OjM0NS4wOTEzMjM4NTI1MzkwNix5OjI3NC43MDgyOTk2MzY4NDA4LHo6LTE5LjMwNDYwNTcyMjQyNzM2OH0se3g6MzI1LjQyNjc4ODMzMDA3ODEseToyNTIuOTUxMzA3Mjk2NzUyOTMsejotMS42NjYxMDE5NjIzMjc5NTcyfSx7eDozMTUuMzQ3ODQzMTcwMTY2LHk6MjU5LjA1MjAwOTU4MjUxOTUzLHo6LS4yNTYwNDI4MTU3NDQ4NzY4Nn0se3g6MzMwLjQ0OTMzMzE5MDkxNzk3LHk6MjY3Ljc1NzAxNTIyODI3MTUsejotMTQuMDE3NDMyOTI4MDg1MzI3fSx7eDoyOTQuOTY3Njg5NTE0MTYwMTYseToxODUuMjYwMDE5MzAyMzY4MTYsejoyMy45MDMxNjQ4NjM1ODY0MjYsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjI5OS42MzUzMTQ5NDE0MDYyNSx5OjE5Mi43OTEzNzYxMTM4OTE2LHo6MTIuNjQwMTk4NDY5MTYxOTg3fSx7eDozMDQuNTQ1MjExNzkxOTkyMix5OjIwMi40MTQyODM3NTI0NDE0LHo6My4yNDQ2Njc2NDkyNjkxMDQsbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMzEuNjkxNTUxMjA4NDk2MSx5OjMyMC4wNDY3ODcyNjE5NjI5LHo6LTEwLjYzMjcwNTY4ODQ3NjU2Mn0se3g6MzM0LjU5MTE0MDc0NzA3MDMseToyMDEuMjc1NjY4MTQ0MjI2MDcsejotNi4xMzMzNTYwOTQzNjAzNTIsbmFtZTpcInJpZ2h0RXllYnJvd1wifSx7eDozMzEuNDgxNTkwMjcwOTk2MSx5OjE4NS40NDE4MDg3MDA1NjE1Mix6Oi42NjI3MjA1MDE0MjI4ODIxfSx7eDozMjguMDU4MTY2NTAzOTA2MjUseToxNzAuODM4NTQ2NzUyOTI5Nyx6OjcuMzU4ODYwMzczNDk3MDA5LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMDQuNDk3NjQyNTE3MDg5ODQseToyMzkuNzYyOTc4NTUzNzcxOTcsejoxMC4zODc2MDU0Mjg2OTU2Nzl9LHt4OjI5MC42MzgyMTc5MjYwMjU0LHk6MjQ4Ljg1MjU3NzIwOTQ3MjY2LHo6MTkuMDM2MTY0MjgzNzUyNDR9LHt4OjMzMS41NjgyNjAxOTI4NzExLHk6MjMzLjIwNzI3MzQ4MzI3NjM3LHo6Ny44MzczOTAzMDM2MTE3NTV9LHt4OjI5NS41MTE1NTA5MDMzMjAzLHk6MjI4Ljk4MzQ0NTE2NzU0MTUsejoxNC40MTQyNjE1Nzk1MTM1NX0se3g6MzM2Ljk0MzMyMTIyODAyNzM0LHk6MjQxLjgyNTkzMzQ1NjQyMDksejotNS4yNzg0MjEwNDQzNDk2N30se3g6MzM2LjI3OTIyMDU4MTA1NDcseToyNjIuNzA0OTkyMjk0MzExNSx6Oi0yNi4xMjA3NDM3NTE1MjU4OH0se3g6Mjg0LjQxMDI0NzgwMjczNDQseToyNTUuMzI2MjcxMDU3MTI4OSx6OjI1LjQ2NzE0MDY3NDU5MTA2NH0se3g6Mjk1LjE0MjA1OTMyNjE3MTkseToyNTMuMDI2NTUyMjAwMzE3MzgsejoxMi40MzAxMTIzNjE5MDc5NTl9LHt4OjMwMy41MTk2MTEzNTg2NDI2LHk6MjU0LjIwNzAzODg3OTM5NDUzLHo6Ni4xMzkxOTEzODkwODM4NjJ9LHt4OjMxNS43MzQ1MDA4ODUwMDk3Nyx5OjI1MS42NDc5OTY5MDI0NjU4Mix6OjMuMzc4ODg5ODU4NzIyNjg2OH0se3g6MzI0LjY5NjYxNzEyNjQ2NDg0LHk6MjQ3LjU2NDk0NTIyMDk0NzI3LHo6Mi4zMzI4MzQ0NTIzOTA2NzA4fSx7eDozMzEuNTc5NzA0Mjg0NjY3OTcseToyNDMuMDIyNDEzMjUzNzg0MTgsejoxLjE0MjM0NDg0NzMyMTUxMDN9LHt4OjM0NS42MjEwNzA4NjE4MTY0LHk6MjI5Ljk5NzY2MzQ5NzkyNDgsejotMTAuODI1Mjg1OTExNTYwMDU5fSx7eDoyODYuMjY2NDQxMzQ1MjE0ODQseToyNzAuMzc5OTE1MjM3NDI2NzYsejoyMS43MDg5Mjk1Mzg3MjY4MDd9LHt4OjI5MC4yNTI1NTIwMzI0NzA3LHk6MjI4LjQ5MjEzNjAwMTU4NjksejoxNy43MTcyODc1NDA0MzU3OX0se3g6MzUxLjY1MzY3MTI2NDY0ODQ0LHk6MjY5LjM0MDA3NjQ0NjUzMzIsejotMzMuNDUwNDI0NjcxMTczMDk2fSx7eDozMzMuMTM3ODkzNjc2NzU3OCx5OjI1My44ODM4ODYzMzcyODAyNyx6Oi03LjIzMDQ3Mzc1Njc5MDE2MX0se3g6Mjc3LjgzMTg5NzczNTU5NTcseToyNDYuOTUzMzE1NzM0ODYzMjgsejo2OC4yMDgwNTU0OTYyMTU4MixuYW1lOlwiZmFjZU92YWxcIn0se3g6MzM2LjY2ODA5MDgyMDMxMjUseToyMzguMTAwMDM3NTc0NzY4MDcsejouNzY4ODU3ODk2MzI3OTcyNH0se3g6MzI5Ljk1ODAwMDE4MzEwNTQ3LHk6MjY5LjE4MzIzNTE2ODQ1NzAzLHo6LTcuMjA3MTMwNzg5NzU2Nzc1fSx7eDoyOTkuMTc0OTE5MTI4NDE3OTcseToyMzQuMTMzMjQzNTYwNzkxMDIsejoxNS45NTQ4OTUwMTk1MzEyNX0se3g6MzM1LjYxNzI5NDMxMTUyMzQ0LHk6MjU4LjcxNzUyNzM4OTUyNjM3LHo6LTIzLjAxNjEzMzMwODQxMDY0NX0se3g6Mjg0LjEwNzkzMzA0NDQzMzYseToyOTcuMDM0MzQ5NDQxNTI4Myx6OjYzLjI1OTM0ODg2OTMyMzczLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMzEuNDQ1NDI2OTQwOTE3OTcseToyMzAuNjg5MjQ0MjcwMzI0Nyx6OjkuOTI2NTgyNTc0ODQ0MzYsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjM0MS40MTUzNjcxMjY0NjQ4NCx5OjI1My4wMTI2NDc2Mjg3ODQxOCx6Oi0yOS4wMzg2MTA0NTgzNzQwMjN9LHt4OjMwMy41NDcyODY5ODczMDQ3LHk6MzI3LjU4OTY3Mzk5NTk3MTcsejoxNi43MjUyMTIzMzU1ODY1NDh9LHt4OjMwNC43NzU2NTc2NTM4MDg2LHk6MzM3LjQzODk0NTc3MDI2MzcsejoyNy4zODEyNjI3NzkyMzU4NCxuYW1lOlwiZmFjZU92YWxcIn0se3g6MjgwLjgwNTAxNTU2Mzk2NDg0LHk6Mjc1LjMyMDUwMTMyNzUxNDY1LHo6NDUuMDc1MjA2NzU2NTkxOH0se3g6Mjk1LjQzNTgyOTE2MjU5NzY2LHk6MzE4LjQ1MDE2NDc5NDkyMTksejoyNi4yNjA4MDAzNjE2MzMzfSx7eDoyODEuNDMwMzIwNzM5NzQ2MSx5OjIyOC43MzU1NjYxMzkyMjEyLHo6NDAuOTQzNTA4MTQ4MTkzMzZ9LHt4OjMzMS4yNTQ5NTkxMDY0NDUzLHk6MzQ5LjQyMTY1Mzc0NzU1ODYsejotNy4zNzYzNjc0NDk3NjA0Mzd9LHt4OjM1Mi40MjQ3NzQxNjk5MjE5LHk6MjcxLjczMzAwNzQzMTAzMDMsejotMjQuOTUzNTk2NTkxOTQ5NDYzfSx7eDozMjcuNTY3MjkxMjU5NzY1Nix5OjI2MC40MTkwMDYzNDc2NTYyNSx6Oi01LjQ1NjQxMDY0NjQzODU5OX0se3g6Mjg0LjU0MzI0NzIyMjkwMDQseToyNDEuNzY0NzkzMzk1OTk2MSx6OjI5LjY2ODg2OTk3MjIyOTAwNH0se3g6MzEwLHk6MjM1LjY2MTc0NTA3MTQxMTEzLHo6OC41MDI2NjM5Njk5OTM1OTEsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMxNS43MDcxMTEzNTg2NDI2LHk6MjM1Ljc1NzI2MDMyMjU3MDgsejo2LjkzODY4NzU2Mjk0MjUwNSxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzMwLjQxMDg4MTA0MjQ4MDQ3LHk6MzExLjA0MTQzMTQyNzAwMTk1LHo6LTkuMzI1NTAyNTE0ODM5MTcyLG5hbWU6XCJsaXBzXCJ9LHt4OjI4OC41Mzc3NTAyNDQxNDA2LHk6Mjg1LjMxOTgzMzc1NTQ5MzE2LHo6MjEuODM3MzE1NTU5Mzg3MjA3fSx7eDozNDQuNTUwMzk5NzgwMjczNDQseTozNTkuNDMwMDg0MjI4NTE1Nix6Oi02LjcwNTI1Nzg5MjYwODY0MyxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzIzLjQxODgwNzk4MzM5ODQ0LHk6MzUxLjY3MzYyMjEzMTM0NzY2LHo6Ny44MDIzNzU1NTUwMzg0NTIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMxNC42NDA4ODQzOTk0MTQwNix5OjM0Ni4xMTg5NDYwNzU0Mzk0NSx6OjE2LjM2MzM5NzgzNjY4NTE4LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNDkuNDk0NTUyNjEyMzA0Nyx5OjE4NC44NDM0ODI5NzExOTE0LHo6LS4yMTg0NzUyNzQ3NDE2NDk2M30se3g6MzU5LjI0Njk0MDYxMjc5Mjk3LHk6MzU5LjgzNDg5MDM2NTYwMDYsejotOC40MDM0NTYyMTEwOTAwODgsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjMyMS4yNjE4MjU1NjE1MjM0NCx5OjIzNC42NDQ5MjMyMTAxNDQwNCx6OjYuOTA5NTA4NzA1MTM5MTYsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMyNi4zMTgzNTkzNzUseToyMzIuOTAyNTAzMDEzNjEwODQsejo4LjAyOTk2OTMzNDYwMjM1NixuYW1lOlwicmlnaHRFeWVcIn0se3g6MzI5LjYyMTE2MjQxNDU1MDgseToyMzEuNjE5NTc3NDA3ODM2OSx6OjkuNzIyMzMxNzYyMzEzODQzLG5hbWU6XCJyaWdodEV5ZVwifSx7eDoyODUuOTM5ODA3ODkxODQ1Nyx5OjIyOC4yMzUxMzAzMTAwNTg2LHo6MjQuNjUwMTM5ODA4NjU0Nzg1fSx7eDozMjUuNzkyODg0ODI2NjYwMTYseToyMjcuODgwMDc3MzYyMDYwNTUsejo3LjQ2OTczODcyMTg0NzUzNCxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzIwLjE2OTk0NDc2MzE4MzYseToyMjcuNTkzNDg4NjkzMjM3Myx6OjYuMTY4MzcwODQyOTMzNjU1LG5hbWU6XCJyaWdodEV5ZVwifSx7eDozMTQuODU0MDg3ODI5NTg5ODQseToyMjcuODUyODI2MTE4NDY5MjQsejo2LjI2NzU3ODAwNTc5MDcxMDQsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMwOS4zMDg0OTA3NTMxNzM4LHk6MjI5LjE1MTY4NzYyMjA3MDMsejo3LjcwMzE2ODM5MjE4MTM5NjUsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjMwNS41NjIxMzM3ODkwNjI1LHk6MjMwLjkyMzY2MjE4NTY2ODk1LHo6OS43MjIzMzE3NjIzMTM4NDMsbmFtZTpcInJpZ2h0RXllXCJ9LHt4OjI3Ny44NjgxOTQ1ODAwNzgxLHk6MjI4LjUzNTQyMzI3ODgwODYsejo1OS43MTEyMjc0MTY5OTIxOSxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzA2LjE0NDQ2NjQwMDE0NjUseToyMzUuMTk1NDY5ODU2MjYyMix6OjEwLjYwMzUyODAyMjc2NjExMyxuYW1lOlwicmlnaHRFeWVcIn0se3g6MzU1LjQ0Nzg0NTQ1ODk4NDQseToyODEuOTYyMTA4NjEyMDYwNTUsejotMjAuNTY1MTIzNTU4MDQ0NDM0fSx7eDozMzMuMDI2NjE4OTU3NTE5NTMseToyODguMDEwNTQwMDA4NTQ0OSx6Oi0xNC43MjkzOTEzMzY0NDEwNH0se3g6MzM3LjE1NzI4NzU5NzY1NjI1LHk6MjY5LjIwNTk1MTY5MDY3MzgsejotMTkuODQxNDk0NTYwMjQxN30se3g6MzQ1Ljk4OTgzNzY0NjQ4NDQseToyODMuNTQ1MzEyODgxNDY5Nyx6Oi0yMC40ODM0MjQ2NjM1NDM3fSx7eDozNTEuNDg5NjM5MjgyMjI2NTYseToyMTkuOTg5MTYxNDkxMzk0MDQsejotNy4wMzc4OTQ3MjU3OTk1NjA1fSx7eDozMTIuMzk1NzQ0MzIzNzMwNDcseTozMzYuNTA2MjgwODk5MDQ3ODUsejo4LjY3MTkwMDAzMzk1MDgwNn0se3g6MzIxLjMyMTUyNTU3MzczMDQ3LHk6MzQzLjE3NTUyNTY2NTI4MzIsejouOTA2NzI3MTY0OTgzNzQ5NH0se3g6MzQzLjc4Mzc5ODIxNzc3MzQ0LHk6MzUzLjI5NzU5NTk3Nzc4MzIsejotMTQuMzU1OTA1MDU1OTk5NzU2fSx7eDoyOTYuODc5MTM4OTQ2NTMzMix5OjMyNy45MTQ5NzIzMDUyOTc4NSx6OjQxLjAxMzUzNjQ1MzI0NzA3LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozMjkuNjkzOTQ2ODM4Mzc4OSx5OjIyOS4yNzg5NzQ1MzMwODEwNSx6OjguOTM0NTA4NTYyMDg4MDEzLG5hbWU6XCJyaWdodEV5ZVwifSx7eDozNDEuNjkwNTIxMjQwMjM0NCx5OjI0MS40MDczNjU3OTg5NTAyLHo6LTE0LjU4OTMzMzUzNDI0MDcyM30se3g6MzU5LjAzMDc5OTg2NTcyMjY2LHk6MzUzLjQ4ODU5Nzg2OTg3MzA1LHo6LTE1LjgwMzE2NjYyNzg4MzkxMX0se3g6MzMzLjE4NjE4Nzc0NDE0MDYseTozNTYuNDMyMTMyNzIwOTQ3MjcsejotMS4wMjM0NDE3NzY2MzMyNjI2LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDoyODMuOTc0ODM4MjU2ODM1OTQseToyOTEuNDMxODY1NjkyMTM4Nyx6OjQxLjk0NzI1NTEzNDU4MjUyfSx7eDozNDMuMzM3NzA3NTE5NTMxMjUseTozMDUuODMwMTM1MzQ1NDU5LHo6LTE1Ljc1NjQ4MDY5MzgxNzEzOSxuYW1lOlwibGlwc1wifSx7eDozNDIuNDAyODM5NjYwNjQ0NTMseTozMDcuNzQ1Mzg5OTM4MzU0NSx6Oi0xNy40MDIxNTc3ODM1MDgzfSx7eDozNDEuNTM2MjE2NzM1ODM5ODQseTozMTEuMDU5NTcwMzEyNSx6Oi0xOS4wNDc4MzQ4NzMxOTk0NjN9LHt4OjM0MC45MTA3MjA4MjUxOTUzLHk6MzE1LjQ4Mzc3MDM3MDQ4MzQsejotMTguNTU3NjMzMTYxNTQ0OCxuYW1lOlwibGlwc1wifSx7eDozMzkuMTQ3ODcyOTI0ODA0Nyx5OjMyMy40MjIzMzY1NzgzNjkxNCx6Oi0xNC4zNjc1NzY4Mzc1Mzk2NzN9LHt4OjMzMy4zMjAxNTk5MTIxMDk0LHk6MzA3LjQ0MDYzMzc3MzgwMzcsejotOS42MTcyODg3MDg2ODY4Mjl9LHt4OjMzMS4yNDExMTE3NTUzNzExLHk6MzA2Ljk4MTE4MjA5ODM4ODcsejotOS42Njk4MDk5Mzc0NzcxMTJ9LHt4OjMyOS4yMzI1NTkyMDQxMDE1Nix5OjMwNi4wNTA4MzQ2NTU3NjE3LHo6LTkuNTgyMjczOTYwMTEzNTI1LG5hbWU6XCJsaXBzXCJ9LHt4OjMyMi40NTg2NDg2ODE2NDA2LHk6MzAxLjMzMzIzNjY5NDMzNTk0LHo6LTcuNzIwNjc1NDY4NDQ0ODI0fSx7eDoyOTcuMTcxMjExMjQyNjc1OCx5OjI4Ni45NTUyODAzMDM5NTUxLHo6OC4yNDAwNTU0NDE4NTYzODR9LHt4OjM0MS4zMDYwNzYwNDk4MDQ3LHk6MjM1LjQ0MzIyMDEzODU0OTgsejotNy41MDQ3NTM0NzA0MjA4Mzd9LHt4OjMzNi45MzE4Mzg5ODkyNTc4LHk6MjI0LjM0NTE5NzY3NzYxMjMsejo1LjgyOTg5ODExODk3Mjc3OH0se3g6MzMyLjY1MzIzNjM4OTE2MDE2LHk6MjI2LjcwNDAzOTU3MzY2OTQzLHo6OC4xMDU4MzQxMjY0NzI0NzN9LHt4OjMzNC42NzM1NzYzNTQ5ODA0Nyx5OjMwNi40Mzk3NjIxMTU0Nzg1LHo6LTguOTgxMTkzOTAwMTA4MzM3LG5hbWU6XCJsaXBzXCJ9LHt4OjI5Ny40NjAxOTM2MzQwMzMyLHk6MzA2LjI5MjEwNDcyMTA2OTM0LHo6MTUuNDc2MzY1MDg5NDE2NTA0fSx7eDozNDIuOTExOTExMDEwNzQyMix5OjIyMi4zNzA3NzcxMzAxMjY5NSx6Oi0yLjc1NDQ2NjIzNTYzNzY2NX0se3g6MzM1LjQ2Mjk4OTgwNzEyODkseTozMzIuMjAyNTAxMjk2OTk3MDcsejotMTEuODIzMTk2NDExMTMyODEyfSx7eDozNTMuMjQxMjMzODI1NjgzNix5OjI0MC41NjMzOTI2MzkxNjAxNix6Oi0yNy4xNDc4MzE5MTY4MDkwODJ9LHt4OjM0Ni4zMDgwNTk2OTIzODI4LHk6MjM2LjQxNDQ2NTkwNDIzNTg0LHo6LTE4LjQ1MjU4OTUxMTg3MTMzOH0se3g6MzUyLjY0NzUxNDM0MzI2MTcseToyMzQuMTQyMDU1NTExNDc0Nix6Oi0xOS43NDgxMjI2OTIxMDgxNTR9LHt4OjMzNy4zMjA5NzYyNTczMjQyLHk6MjUzLjM5OTM3MjEwMDgzMDA4LHo6LTE2LjAyNDkyNDUxNjY3Nzg1Nn0se3g6MzU4LjYxMjIxMzEzNDc2NTYseTozNDQuOTA4NjE4OTI3MDAxOTUsejotMTguNTkyNjQ3MzE0MDcxNjU1fSx7eDozNTguMTExNzI0ODUzNTE1Nix5OjMzNC42NDk5MDYxNTg0NDcyNyx6Oi0xNy40OTU1Mjg0NTk1NDg5NX0se3g6MzQ2LjQ0NTA0NTQ3MTE5MTQseTozMzUuMDMyMTEwMjE0MjMzNCx6Oi0xNi4zMjgzODI0OTIwNjU0M30se3g6MzE5LjE3NjQwNjg2MDM1MTU2LHk6MzIwLjI4MzM5Mzg1OTg2MzMsejotMy4yNzY3NjQ0NTI0NTc0Mjh9LHt4OjMyNS4yNTQwNTg4Mzc4OTA2LHk6Mjc2LjIzNjk3MjgwODgzNzksejotNi40NjAxNTcwMzY3ODEzMTF9LHt4OjMyNi43MjE0NTg0MzUwNTg2LHk6MzI3LjM5Mzk1MTQxNjAxNTYsejotNy40MTcyMTc0OTMwNTcyNTF9LHt4OjMxMC43MTkwMTMyMTQxMTEzLHk6Mjc3LjIyNjUxNDgxNjI4NDIsejotMy41NDUyMDgyNzUzMTgxNDU4fSx7eDozMTkuNzgzNTU0MDc3MTQ4NDQseToyODQuODIzODE4MjA2Nzg3MSx6Oi02LjQ1NDMyMTE0NjAxMTM1MjV9LHt4OjMwNS43NzM5ODMwMDE3MDkseToyOTAuODM1ODAwMTcwODk4NDQsejouMDY5MDcxMzgwNDIxNTE5Mjh9LHt4OjM0NC40MDAxNzcwMDE5NTMxLHk6MzQ0Ljg1NDA4NzgyOTU4OTg0LHo6LTE2Ljk0Njk3MDIyNDM4MDQ5M30se3g6MzMzLjE4Nzk0MjUwNDg4MjgseToyNTguNzQyNTYxMzQwMzMyMDMsejotMTEuOTA0ODk2NDk3NzI2NDR9LHt4OjMxMy44MDU5ODA2ODIzNzMwNSx5OjMyNy4wODkxOTUyNTE0NjQ4NCx6OjIuMjI3NzkxMjQ5NzUyMDQ0N30se3g6MzIyLjk2Mzc5MDg5MzU1NDcseTozMzQuNjgxOTQ5NjE1NDc4NSx6Oi0zLjM2NDMwMDQyOTgyMTAxNDR9LHt4OjMxMy40MDU1NTE5MTA0MDA0LHk6MzExLjIxNjY2OTA4MjY0MTYsejotMS4xMTc1NDI5ODIxMDE0NDA0fSx7eDoyOTEuMDg2NTc4MzY5MTQwNix5OjI5OC4yODMxMDAxMjgxNzM4LHo6MjIuNDY3NTc1MDczMjQyMTg4fSx7eDozMDUuNjU4MDkyNDk4Nzc5Myx5OjMxMy4zNzA3OTA0ODE1Njc0LHo6NS41NjE0NTM3MDAwNjU2MTN9LHt4OjI4OC4yMzc2MDk4NjMyODEyNSx5OjMwNS45OTQxODY0MDEzNjcyLHo6MzYuNzY1MTIyNDEzNjM1MjU0fSx7eDozMTUuMTA2OTI1OTY0MzU1NDcseToyOTYuMjY5OTEyNzE5NzI2NTYsejotNC42MDQzOTM4Mzk4MzYxMjF9LHt4OjMzNy41MDUxODc5ODgyODEyNSx5OjI0Ny41OTQ0NDIzNjc1NTM3LHo6LTEwLjU5NzY5MTUzNTk0OTcwN30se3g6MzM4Ljg0NTA2MjI1NTg1OTQseToyNjUuNDc3NzgxMjk1Nzc2MzcsejotMjcuNzc4MDkxNDMwNjY0MDYyfSx7eDozMzQuMjUyNTQ4MjE3NzczNDQseToyNjkuMDY3MTkyMDc3NjM2Nyx6Oi0yMC45Mzg2MTEwMzA1Nzg2MTN9LHt4OjM0MS42NDUxMjYzNDI3NzM0NCx5OjI1OS42Mzg3MTk1NTg3MTU4LHo6LTMyLjE4OTkwNTY0MzQ2MzEzNX0se3g6MzMxLjQ0MDgxMTE1NzIyNjU2LHk6MjE5LjA5NzYwOTUxOTk1ODUsejo0LjIwNzU2MzY5ODI5MTc3OX0se3g6MzIwLjU2MzM5MjYzOTE2MDE2LHk6MjE2LjQ5NjU4MjAzMTI1LHo6Mi45MzA5OTczMTIwNjg5Mzl9LHt4OjMxMS4yMTkxMjAwMjU2MzQ3Nyx5OjIxNi41Nzg1MzYwMzM2MzAzNyx6OjIuOTY3NDcwNTg2Mjk5ODk2Mn0se3g6MzAzLjQ2MjU2MjU2MTAzNTE2LHk6MjE4LjU0NjE0NzM0NjQ5NjU4LHo6NS4zNTcyMDM0ODM1ODE1NDN9LHt4OjI5Ny45OTk5OTIzNzA2MDU0Nyx5OjIyMi41MDUyMDIyOTMzOTYsejo5LjMyNTUwMjUxNDgzOTE3Mn0se3g6Mjk0LjkzODM5MjYzOTE2MDE2LHk6MjM2LjM5NjU0MTU5NTQ1ODk4LHo6MTguNTM0Mjg5NTk4NDY0OTY2fSx7eDoyNzguODc0ODkzMTg4NDc2NTYseToyNTkuNzA5NTU4NDg2OTM4NSx6OjQ1LjY4MjEyMDMyMzE4MTE1fSx7eDozMDAuMzc4MjY1MzgwODU5NCx5OjI0NS4zODU5MzI5MjIzNjMyOCx6OjEyLjI3ODM4Mjc3ODE2NzcyNX0se3g6MzA3LjA2MzQ4NDE5MTg5NDUzLHk6MjQ2LjM2ODU3OTg2NDUwMTk1LHo6OC4xNjQxOTEyNDYwMzI3MTV9LHt4OjMxNS41MjI5MTg3MDExNzE5LHk6MjQ1LjM5NDk3Mzc1NDg4Mjgsejo1LjUwMzA5NzE3NjU1MTgxOX0se3g6MzIzLjcxMzk1MTExMDgzOTg0LHk6MjQyLjc1MTc4OTA5MzAxNzU4LHo6NC42MzM1NzIzOTk2MTYyNDE1fSx7eDozMzAuMjc4NTg3MzQxMzA4Nix5OjIzOS4zNDY1ODUyNzM3NDI2OCx6OjQuOTM3MDMwNjczMDI3MDM5fSx7eDozMzQuNjk4MjE5Mjk5MzE2NCx5OjIzNi4wNDYwMzc2NzM5NTAyLHo6NC44MjMyMzM3ODMyNDUwODd9LHt4OjI3OS4zNDEyMjA4NTU3MTI5LHk6MjYzLjUxOTYxMTM1ODY0MjYsejo3MC45MTU4MzcyODc5MDI4MyxuYW1lOlwiZmFjZU92YWxcIn0se3g6MzM0LjY1OTcyOTAwMzkwNjI1LHk6MjcxLjY2NDg1Nzg2NDM3OTksejotMTcuNzc1NjQ0MDYzOTQ5NTg1fSx7eDozNDIuMDU2NzcwMzI0NzA3MDMseToyNDYuOTk4NDYyNjc3MDAxOTUsejotMjAuODQ1MjM5MTYyNDQ1MDd9LHt4OjM0NC4wMzU3OTcxMTkxNDA2LHk6MjY0LjU3MDE1MDM3NTM2NjIsejotMzIuOTM2ODgwNTg4NTMxNDk0fSx7eDozNDguMjU1MzEwMDU4NTkzNzUseToyNjguNjY0NTAzMDk3NTM0Mix6Oi0zMC42OTU5NjA1MjE2OTc5OTh9LHt4OjM0NC4xMjIyNzYzMDYxNTIzNCx5OjI2Ni4zNDIxMjQ5Mzg5NjQ4NCx6Oi0yOS44MDg5MjY1ODIzMzY0MjZ9LHt4OjMzNy4xMjMxODQyMDQxMDE1Nix5OjI3NC4yNTU2ODU4MDYyNzQ0LHo6LTE1Ljc2ODE1MjQ3NTM1NzA1Nn0se3g6MzQ5LjQ5MDQ3MDg4NjIzMDQ3LHk6MjY5LjA3MTY4Mzg4MzY2Nyx6Oi0zMi41MTY3MDgzNzQwMjM0NH0se3g6MzUwLjE2ODMwNDQ0MzM1OTQseToyNzEuNDY5MTM1Mjg0NDIzOCx6Oi0yNC45MzAyNTMwMjg4Njk2M30se3g6MzMzLjk2MzQ3MDQ1ODk4NDQseToyMzAuNTY2MzkxOTQ0ODg1MjUsejo4Ljg5OTQ5MzgxMzUxNDcxfSx7eDozMzguMjE0Nzk3OTczNjMyOCx5OjIzMS40ODA3ODkxODQ1NzAzLHo6NC42NzE1MDQ3OTU1NTEzfSx7eDozNDAuNDcxMjY3NzAwMTk1Myx5OjIzMS43NDQ2MzI3MjA5NDcyNyx6Oi0uMzQ5OTYxNjY4MjUyOTQ0OTV9LHt4OjMwMy4yODk3NTY3NzQ5MDIzNCx5OjIzMi4yNDk4MDM1NDMwOTA4Mix6OjExLjkxNjU2ODI3OTI2NjM1NyxuYW1lOlwicmlnaHRFeWVcIn0se3g6Mjk5LjQ2NDkxMjQxNDU1MDgseToyMjkuNTM4NDI2Mzk5MjMwOTYsejoxMi4zMjUwNjk5MDQzMjczOTN9LHt4OjM1OS4wOTYxODM3NzY4NTU0Nyx5OjI0MS43NzM0OTA5MDU3NjE3Mix6Oi0yNC42NTAxMzk4MDg2NTQ3ODV9LHt4OjM5OS40NjIxNjU4MzI1MTk1Myx5OjIyOS44OTUwMzg2MDQ3MzYzMyx6OjE1LjkxOTg4MDg2NzAwNDM5NSxuYW1lOlwibGVmdEV5ZVwifSx7eDozNjEuMzg5MTk4MzAzMjIyNjYseToyNjkuNjEyOTg5NDI1NjU5Mix6Oi0yNC41MTAwODA4MTQzNjE1NzJ9LHt4OjQxNi45OTczMzczNDEzMDg2LHk6MjA2LjA4OTU1MzgzMzAwNzgsejo1My4yNjg1NzU2NjgzMzQ5NixuYW1lOlwiZmFjZU92YWxcIn0se3g6MzgxLjMyMTc5MjYwMjUzOTA2LHk6MjM1LjU0NzY0NzQ3NjE5NjMsejo3LjYyMTQ2ODMwNTU4Nzc2ODZ9LHt4OjM4Ny44MDY4NTQyNDgwNDY5LHk6MjM2LjI1OTU4NDQyNjg3OTg4LHo6OC4zNDUwOTkwOTE1Mjk4NDZ9LHt4OjM5My45NTc1MTk1MzEyNSx5OjIzNS44NjYwMzY0MTUxMDAxLHo6MTAuNDc1MTQyMDAyMTA1NzEzfSx7eDo0MDEuODQ2MDA4MzAwNzgxMjUseToyMzIuNzcwMTk1MDA3MzI0MjIsejoxNi43NjAyMjY0ODgxMTM0MDN9LHt4OjM3NS43MDU2ODA4NDcxNjc5Nyx5OjIzMy40ODQ1NjM4Mjc1MTQ2NSx6OjguMjM0MjIwMTQ3MTMyODc0fSx7eDozODguMTc3NTI4MzgxMzQ3NjYseToyMTguOTQ3MTc2OTMzMjg4NTcsejo2LjgxMDMwMDk0NjIzNTY1N30se3g6MzgxLjY0OTI4NDM2Mjc5Mjk3LHk6MjE5LjI2NTY2NjAwNzk5NTYsejo2LjcxMTA5Mzc4MzM3ODYwMX0se3g6Mzk0LjQ3NjA1MTMzMDU2NjQseToyMTkuNjY4MjExOTM2OTUwNjgsejo5LjE3Mzc3MzUyNzE0NTM4Nn0se3g6Mzk4Ljg4NDM1MzYzNzY5NTMseToyMjEuODgzNzAyMjc4MTM3Mix6OjEyLjAzMzI4MjUxODM4Njg0fSx7eDo0MDYuNTQ1NDg2NDUwMTk1Myx5OjIzNy4xMjE1Njc3MjYxMzUyNSx6OjE5LjcxMzEwODUzOTU4MTN9LHt4OjM4My44NzQ0NzM1NzE3NzczNCx5OjMzNy42OTMyOTA3MTA0NDkyLHo6LTguNjMxMDQ5OTkwNjUzOTkyfSx7eDo0MDEuMjY4MjM0MjUyOTI5Nyx5OjIyOC41OTE2NTY2ODQ4NzU1LHo6MTguMzU5MjE3NjQzNzM3NzkzLG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjQyMi4wNDQ5NDQ3NjMxODM2LHk6MjM2LjczOTM0OTM2NTIzNDM4LHo6NTEuMTY3NzEyMjExNjA4ODl9LHt4OjQxMi42OTE1MzU5NDk3MDcwMyx5OjIzMi44MDE5ODA5NzIyOTAwNCx6OjI3LjUyMTMxOTM4OTM0MzI2fSx7eDozODcuMzQ5Nzc3MjIxNjc5Nyx5OjI2My4yOTgzOTcwNjQyMDksejotMi44NjA5Njg0MTA5Njg3ODA1fSx7eDozNjQuNTEyNDA1Mzk1NTA3OCx5OjI5My4zOTIyMTAwMDY3MTM4Nyx6Oi0yMi4zOTc1NDY3NjgxODg0NzcsbmFtZTpcImxpcHNcIn0se3g6MzYzLjYyOTg3NTE4MzEwNTQ3LHk6MzAyLjEyOTE0NDY2ODU3OTEsejotMTkuNjQzMDc5MDQyNDM0NjkyfSx7eDozNzMuMjMzNDUxODQzMjYxNyx5OjI5NS44NjQ3MDYwMzk0Mjg3LHo6LTE4LjEyNTc4OTE2NTQ5NjgyNixuYW1lOlwibGlwc1wifSx7eDozNzguODMzNjU2MzExMDM1MTYseToyOTkuNTE3Nzc0NTgxOTA5Mix6Oi0xMy4xNTM3NDM3NDM4OTY0ODQsbmFtZTpcImxpcHNcIn0se3g6MzY5LjkxNDc3OTY2MzA4NTk0LHk6MzAyLjU3MDQwMDIzODAzNzEsejotMTYuNjU1MTgyODM4NDM5OTR9LHt4OjM3NC45MTY3MjUxNTg2OTE0LHk6MzAzLjU0MTY2MDMwODgzNzksejotMTEuOTYzMjUzMDIxMjQwMjM0fSx7eDozODcuNTg4ODgyNDQ2Mjg5MDYseTozMTIuMjcxNjk5OTA1Mzk1NSx6Oi00LjY4MDI1ODYzMTcwNjIzOH0se3g6MzYwLjY2MzUyODQ0MjM4MjgseToyNjQuMzE5ODY4MDg3NzY4NTUsejotMzUuOTQ4MTE2Nzc5MzI3Mzl9LHt4OjM2MS4wNDU2NDY2Njc0ODA0Nyx5OjI1Ni44MjI1ODYwNTk1NzAzLHo6LTM3LjI3ODY2NDExMjA5MTA2NH0se3g6NDA4LjM4NTU0MzgyMzI0MjIseToyMTMuNTIwODg5MjgyMjI2NTYsejoxNS43NTY0ODA2OTM4MTcxMzksbmFtZTpcImxlZnRFeWVicm93XCJ9LHt4OjM3My4yOTQ2MDE0NDA0Mjk3LHk6MjQ1LjM4MTAxMTk2Mjg5MDYyLHo6LTEuOTMxNjI3ODM5ODAzNjk1N30se3g6Mzc2LjgzODYwNzc4ODA4NTk0LHk6MjY0LjM3MjExMDM2NjgyMTMsejotMTguNTEwOTQ3MjI3NDc4MDI3fSx7eDozNzYuOTU0NjEyNzMxOTMzNix5OjI2MS4wMDEwNTI4NTY0NDUzLHo6LTE1Ljk4OTkwOTE3MjA1ODEwNX0se3g6NDA2LjE0OTgyNjA0OTgwNDcseToyNjMuNTAzMDE3NDI1NTM3MSx6OjcuMDcyOTA4ODc4MzI2NDE2fSx7eDozNjAuMDcyMDU5NjMxMzQ3NjYseToyNDguMzYzMTcwNjIzNzc5Myx6Oi0zMi4xNjY1NjQ0NjQ1NjkwOX0se3g6MzkzLjExMTE5MDc5NTg5ODQ0LHk6MjA1LjEwNDczMjUxMzQyNzczLHo6My43Nzg2MzczNDk2MDU1NjAzLG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDo0MDIuMTI3OTE0NDI4NzEwOTQseToyMDcuODkwMDA5ODgwMDY1OTIsejo5LjM4Mzg1OTYzNDM5OTQxNCxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6NDEwLjg2OTMzMTM1OTg2MzMseToxOTEuNjE4MjI3OTU4Njc5Mix6OjQxLjI3MDMwODQ5NDU2Nzg3LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNjQuOTUwOTgxMTQwMTM2Nyx5OjIxMC40MDQ4MzQ3NDczMTQ0NSx6Oi0zLjc1ODIxMjYyNTk4MDM3N30se3g6Mzc1Ljk0NDQ0Mjc0OTAyMzQ0LHk6MjIxLjEzMzE4NDQzMjk4MzQsejo4LjM2ODQ0MjA1ODU2MzIzMn0se3g6MzkyLjE5MDQ3NTQ2Mzg2NzIseTozMDUuMDM2MDI5ODE1NjczOCx6Oi0xLjc1MjE3OTExNjAxMDY2Nn0se3g6NDE5LjUwMjI1ODMwMDc4MTI1LHk6MzA3LjI1NTkyNjEzMjIwMjE1LHo6NTguOTY0MjUyNDcxOTIzODMsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM3Mi4wMDI3MTYwNjQ0NTMxLHk6MjY4LjcyMTI2NTc5Mjg0NjcsejotMTYuNjMxODQwNDY3NDUzMDAzfSx7eDozNjYuMTYxNDIyNzI5NDkyMix5OjI3MS42MjM3NDQ5NjQ1OTk2LHo6LTE4LjIxOTE1OTg0MTUzNzQ3Nn0se3g6Mzg1LjAwOTM4NDE1NTI3MzQ0LHk6MzA1LjM4NjMzMzQ2NTU3NjIsejotMi41Njc3MjI3OTczOTM3OTl9LHt4OjM4MS45OTc3MTg4MTEwMzUxNix5OjMwNC45NzIzNzIwNTUwNTM3LHo6LTQuNTc1MjE1MjgwMDU2fSx7eDo0MDUuMDc4MTI1LHk6MjAzLjIxMjE2NTgzMjUxOTUzLHo6MTMuNzEzOTczNzYwNjA0ODU4LG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDozNzcuMTMyMDcyNDQ4NzMwNDcseToyNjguNDcxMDEyMTE1NDc4NSx6Oi0xNS4yNjYyNzg5ODIxNjI0NzZ9LHt4OjM4MC45NzEzMzYzNjQ3NDYxLHk6MjA1LjM2OTgwNjI4OTY3Mjg1LHo6LS43MjUwODk5MDc2NDYxNzkyLG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDozODEuNzc4ODMxNDgxOTMzNix5OjE5OC45MjY4Mzk4Mjg0OTEyLHo6LTEuMTg0NjUzODYzMzEwODE0LG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDozODUuNTIwNDc3Mjk0OTIxOSx5OjE3Mi4xNDg0Mzc1LHo6MTYuMDQ4MjY4MDc5NzU3NjksbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjQwNy45NDE4OTQ1MzEyNSx5OjE5Ni43NjIzNjE1MjY0ODkyNix6OjI1LjcyMzkxNTEwMDA5NzY1Nn0se3g6MzgzLjAzODkwMjI4MjcxNDg0LHk6MTg0LjUxNTc1Mjc5MjM1ODQsejo3LjM5Mzg3NDUyNjAyMzg2NX0se3g6NDExLjYxNzgxMzExMDM1MTU2LHk6MjEwLjc5MjQxNzUyNjI0NTEyLHo6MjIuMzE1ODQ1NDg5NTAxOTUzLG5hbWU6XCJsZWZ0RXllYnJvd1wifSx7eDo0MTQuMzA4NzAwNTYxNTIzNDQseToyMDguNDY0MzAzMDE2NjYyNix6OjM3LjAyMTg5NDQ1NDk1NjA1NX0se3g6MzY0LjI4NzIyMzgxNTkxNzk3LHk6Mjk4LjM1Nzc3MjgyNzE0ODQ0LHo6LTIxLjg2MDY1NjczODI4MTI1fSx7eDozNzEuMzY4MjU1NjE1MjM0NCx5OjI5OS43ODg0ODQ1NzMzNjQyNix6Oi0xNy44MzQwMDE3Nzk1NTYyNzR9LHt4OjM3Ni44ODIwMTkwNDI5Njg3NSx5OjMwMS42Njk2MDcxNjI0NzU2LHo6LTEzLjE1Mzc0Mzc0Mzg5NjQ4NH0se3g6MzcwLjIxOTM4MzIzOTc0NjEseToyNzAuNDkwOTUxNTM4MDg1OTQsejotMTUuNTY5NzM2OTU3NTUwMDQ5fSx7eDozODMuNTA4MTEwMDQ2Mzg2Nyx5OjMwNS4yNzI2MzY0MTM1NzQyLHo6LTMuNjczNTk0Mjk1OTc4NTQ2fSx7eDozODAuNzM3NjA5ODYzMjgxMjUseTozMDUuOTY4Njk0Njg2ODg5NjUsejotOC42NjAyMjgyNTI0MTA4ODl9LHt4OjM4MS4yMzM0NDQyMTM4NjcyLHk6MzA0LjYzNTc0NDA5NDg0ODYzLHo6LTQuODIwMzE2MTM1ODgzMzMxLG5hbWU6XCJsaXBzXCJ9LHt4OjM2OC4xNjk4OTg5ODY4MTY0LHk6MjY0Ljg4ODQ5NjM5ODkyNTgsejotMjUuNjUzODg2Nzk1MDQzOTQ1fSx7eDozNzMuNTA4NzIwMzk3OTQ5Mix5OjMwMy40MjMzODU2MjAxMTcyLHo6LTEwLjk1OTUwNzIyNjk0Mzk3LG5hbWU6XCJsaXBzXCJ9LHt4OjM2OC40NTQ0MzcyNTU4NTk0LHk6MzAzLjI5NjAxMjg3ODQxNzk3LHo6LTE0LjE2OTE2MTMxOTczMjY2NixuYW1lOlwibGlwc1wifSx7eDozNjIuNzY1NTQxMDc2NjYwMTYseTozMDMuNTczNTYwNzE0NzIxNyx6Oi0xNi45MTE5NTYwNzE4NTM2MzgsbmFtZTpcImxpcHNcIn0se3g6MzY2LjYwOTgwMjI0NjA5Mzc1LHk6MzI0Ljg4NzA2NTg4NzQ1MTIsejotMTUuNjE2NDIyODkxNjE2ODIxfSx7eDozNjUuNzA2NzEwODE1NDI5Nyx5OjMxNS45NTY3ODMyOTQ2Nzc3Myx6Oi0yMC45MDM1OTY4NzgwNTE3NTgsbmFtZTpcImxpcHNcIn0se3g6MzY1LjAwODM5MjMzMzk4NDQseTozMTEuMjIzMjIwODI1MTk1Myx6Oi0yMS4wNjY5OTk0MzU0MjQ4MDV9LHt4OjM2NC4xNTA4MTAyNDE2OTkyLHk6MzA3LjA1ODM0Mzg4NzMyOTEsejotMTguOTA3Nzc3MDcwOTk5MTQ2fSx7eDozNjMuMzc1MTI5Njk5NzA3MDMseTozMDQuNTcyMTQzNTU0Njg3NSx6Oi0xNy40MjU1MDAxNTQ0OTUyNCxuYW1lOlwibGlwc1wifSx7eDozNzQuNTgwMDc4MTI1LHk6MzA0LjMwNTk1Mzk3OTQ5MjIsejotMTEuNDAzMDIzMDA0NTMxODYsbmFtZTpcImxpcHNcIn0se3g6Mzc1LjU1MzYyNzAxNDE2MDE2LHk6MzA1LjA5OTgwMjAxNzIxMTksejotMTIuODYxOTU3NTUwMDQ4ODI4fSx7eDozNzcuMjQzNzI4NjM3Njk1Myx5OjMwNy4xNjc0MzQ2OTIzODI4LHo6LTE0LjIxNTg0NzI1Mzc5OTQzOH0se3g6Mzc4LjY4NTg3NDkzODk2NDg0LHk6MzA5LjkwMTU3MTI3MzgwMzcsejotMTMuMjIzNzcyMDQ4OTUwMTk1LG5hbWU6XCJsaXBzXCJ9LHt4OjM4My44OTkyNjkxMDQwMDM5LHk6MjkwLjI5NjI5NzA3MzM2NDI2LHo6LTkuOTczMjY5MTA0OTU3NTh9LHt4OjQyMy4zODcxODQxNDMwNjY0LHk6MjcxLjkxNjg4NTM3NTk3NjU2LHo6NzQuMzcwNTg5MjU2Mjg2NjIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM3Ny42ODA0MzUxODA2NjQwNix5OjMwNC42MjIwOTcwMTUzODA4Nix6Oi03LjYwMzk2MTIyOTMyNDM0MSxuYW1lOlwibGlwc1wifSx7eDozNzkuMDA0Mjg3NzE5NzI2NTYseTozMDQuOTMxNDU5NDI2ODc5OSx6Oi04LjU3ODUyODE2NTgxNzI2fSx7eDozNjQuMDAyNzk5OTg3NzkyOTcseToyNzUuMjgxMzkxMTQzNzk4OCx6Oi0xOS4yNTc5MjA5ODA0NTM0OX0se3g6Mzc0LjY4MjMxMjAxMTcxODc1LHk6MjczLjgyNTU1OTYxNjA4ODg3LHo6LTExLjI4MDQ3MjI3ODU5NDk3fSx7eDozNjUuMDM1NDc2Njg0NTcwMyx5OjI3My40NTQ4NTY4NzI1NTg2LHo6LTE4Ljc5MTA2MjgzMTg3ODY2Mn0se3g6MzgwLjYxOTAxMDkyNTI5Mjk3LHk6MjQ5Ljg4NDgwNTY3OTMyMTMsejouMTU1MDExNjc2MjUxODg4Mjh9LHt4OjM5MS4xNDE1ODYzMDM3MTA5NCx5OjI1NC43OTM0NjI3NTMyOTU5LHo6Mi4wOTA2NTE1NDE5NDgzMTg1fSx7eDozNzguMTc2MTE2OTQzMzU5NCx5OjI2NC45NjEyMjM2MDIyOTQ5LHo6LTEyLjYwNTE4NDMxNjYzNTEzMn0se3g6NDAwLjk1NDA1NTc4NjEzMjgseToxNzkuOTk1OTIzMDQyMjk3MzYsejoyNy44MjQ3Nzg1NTY4MjM3MyxuYW1lOlwiZmFjZU92YWxcIn0se3g6Mzk4LjAwMzg4MzM2MTgxNjQseToxODguNTA2NTY1MDkzOTk0MTQsejoxNi4wOTQ5NTI4MjE3MzE1Njd9LHt4OjM5NC44NzE3NDk4Nzc5Mjk3LHk6MTk5LjAzNTk1OTI0Mzc3NDQsejo2LjIyNjcyNzM2NjQ0NzQ0OSxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6MzgyLjEwOTI2MDU1OTA4MjAzLHk6MzE2LjgzOTI2NTgyMzM2NDI2LHo6LTguOTQ2MTc5NzQ3NTgxNDgyfSx7eDozNjYuNTE1ODg0Mzk5NDE0MDYseToyMDAuMzI1ODM3MTM1MzE0OTQsejotNS4yNDYzMjQ1MzkxODQ1NyxuYW1lOlwibGVmdEV5ZWJyb3dcIn0se3g6MzY3LjQ4OTM1Njk5NDYyODkseToxODMuODcyMTA4NDU5NDcyNjYsejoxLjkwMzkwODEwMzcwNDQ1MjV9LHt4OjM2OC42MjQzNDM4NzIwNzAzLHk6MTY4LjgxMjc1NjUzODM5MTEsejo4LjczNjA5MzA0NDI4MTAwNixuYW1lOlwiZmFjZU92YWxcIn0se3g6Mzk4Ljk2MTc1Mzg0NTIxNDg0LHk6MjM0Ljk2NzUxNzg1Mjc4MzIsejoxMy43MTM5NzM3NjA2MDQ4NTh9LHt4OjQxMi45NjQ1NTM4MzMwMDc4LHk6MjQyLjIzMDQyNDg4MDk4MTQ1LHo6MjMuMjcyOTA1MzQ5NzMxNDQ1fSx7eDozNzIuMDUyNTc0MTU3NzE0ODQseToyMzEuNDE5MTkxMzYwNDczNjMsejo5LjIyNjI5NDc1NTkzNTY2OX0se3g6NDA2LjA3MjIzNTEwNzQyMTkseToyMjMuNTg5NjU4NzM3MTgyNjIsejoxOC4zNzA4OTA2MTczNzA2MDV9LHt4OjM2OC4yNzQ0MjE2OTE4OTQ1Myx5OjI0MC4yMDM5MzM3MTU4MjAzLHo6LTQuMTY2NzEzNjU0OTk0OTY1fSx7eDozNzIuMzU3NTIxMDU3MTI4OSx5OjI2MC42NjQ0MjQ4OTYyNDAyMyx6Oi0yNC45NzY5NDAxNTUwMjkyOTd9LHt4OjQxOS4yMjQ0MzM4OTg5MjU4LHk6MjQ3LjkwNzkyNDY1MjA5OTYsejozMC4yOTkxMjcxMDE4OTgxOTN9LHt4OjQwOS40Mzg4NTgwMzIyMjY1Nix5OjI0Ni42MDkxMzQ2NzQwNzIyNyx6OjE2LjM5ODQxMTk4OTIxMjAzNn0se3g6NDAxLjY5MTM5ODYyMDYwNTQ3LHk6MjQ4Ljc2MzI4NDY4MzIyNzU0LHo6OS4zOTU1MzE0MTU5MzkzMzF9LHt4OjM4OS43NjA4MTg0ODE0NDUzLHk6MjQ3LjU2OTE1MDkyNDY4MjYyLHo6NS44NDE1NjkzMDQ0NjYyNDh9LHt4OjM4MC41NDYxODgzNTQ0OTIyLHk6MjQ0LjU1OTg0MTE1NjAwNTg2LHo6NC4yNjMwMDM0Njg1MTM0ODl9LHt4OjM3My4yNTgxNzEwODE1NDI5Nyx5OjI0MC44MDIxNDUwMDQyNzI0Nix6OjIuNTM1NjI2MjkyMjI4Njk4N30se3g6MzU4Ljc3MDg2NjM5NDA0Mjk3LHk6MjI5LjM1NjE1MDYyNzEzNjIzLHo6LTEwLjM4NzYwNTQyODY5NTY3OX0se3g6NDE5LjU3OTM5MTQ3OTQ5MjIseToyNjIuODQ3ODcxNzgwMzk1NSx6OjI2LjUxNzU3MjQwMjk1NDF9LHt4OjQxMC44ODA4ODk4OTI1NzgxLHk6MjIyLjUxMzcyODE0MTc4NDY3LHo6MjIuMTk5MTMwMDU4Mjg4NTc0fSx7eDozNTguNDU3MTQ1NjkwOTE3OTcseToyNjguOTE0NjcwOTQ0MjEzODcsejotMzMuMTcwMzA5MDY2NzcyNDZ9LHt4OjM3My40MTI5MzMzNDk2MDk0LHk6MjUxLjYzODU4NDEzNjk2MjksejotNS43NzE1NDA0MDMzNjYwODl9LHt4OjQyMi41NDA4MTcyNjA3NDIyLHk6MjM5LjIzOTE5Njc3NzM0Mzc1LHo6NzQuMDQzNzg4OTA5OTEyMTEsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM2Ny44MTcxOTIwNzc2MzY3LHk6MjM2LjU4MDQwNTIzNTI5MDUzLHo6MS44MjA3NDg4OTU0MDY3MjN9LHt4OjM3OC41MTk1OTIyODUxNTYyNSx5OjI2Ni4yNTMyMzI5NTU5MzI2LHo6LTUuNzQ4MTk4MDMyMzc5MTV9LHt4OjQwMy4zNDcyNDQyNjI2OTUzLHk6MjI5LjA1MTEyMjY2NTQwNTI3LHo6MTkuNjg5NzY0OTc2NTAxNDY1fSx7eDozNzIuMzQ4NDAzOTMwNjY0MDYseToyNTYuNjQ1MTE2ODA2MDMwMyx6Oi0yMS44NzIzMjk3MTE5MTQwNjJ9LHt4OjQyMi41NDU2NjE5MjYyNjk1Myx5OjI4OS4xNTg3ODI5NTg5ODQ0LHo6NjguNjc0OTEyNDUyNjk3NzUsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM3MS45Mjk3NDA5MDU3NjE3LHk6MjI4LjkwMTE2MjE0NzUyMTk3LHo6MTEuNDMyMjAxODYyMzM1MjA1LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM2Ni4yMTM2MDc3ODgwODU5NCx5OjI1MS42MTU4OTYyMjQ5NzU2LHo6LTI4LjE5ODI2MzY0NTE3MjEyfSx7eDo0MDkuMTU3MTgwNzg2MTMyOCx5OjMyMS4zMTU2MjIzMjk3MTE5LHo6MjAuMjI2NjUyNjIyMjIyOX0se3g6NDA4LjUyOTQzNDIwNDEwMTU2LHk6MzMxLjQ0MjM4NDcxOTg0ODYzLHo6MzEuMDkyNzg5MTczMTI2MjIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjQyNC4yNzg4MzE0ODE5MzM2LHk6MjY3LjE5OTIzMDE5NDA5MTgsejo1MC40Njc0MjQzOTI3MDAxOTV9LHt4OjQxNS42MDM1MjMyNTQzOTQ1Myx5OjMxMS42NTI4NjA2NDE0Nzk1LHo6MzAuNTc5MjQyNzA2Mjk4ODI4fSx7eDo0MTguMTI3OTM3MzE2ODk0NTMseToyMjEuNTk5MjczNjgxNjQwNjIsejo0Ni4yNjU2OTc0NzkyNDgwNX0se3g6Mzg1LjY4Mjg2ODk1NzUxOTUzLHk6MzQ2LjAxODQ5NTU1OTY5MjQsejotNS43MDE1MTE1MDIyNjU5M30se3g6MzU3LjgyOTM2MDk2MTkxNDA2LHk6MjcxLjM3NTgzNzMyNjA0OTgsejotMjQuODM2ODgxMTYwNzM2MDg0fSx7eDozNzkuNTg4NjIzMDQ2ODc1LHk6MjU3LjUwNzE3MTYzMDg1OTQsejotMy43NTUyOTQ2ODA1OTUzOTh9LHt4OjQxNy40NTkyNTkwMzMyMDMxLHk6MjM0LjcxOTQ4MTQ2ODIwMDY4LHo6MzQuNTQ3NTQzNTI1Njk1OH0se3g6MzkzLjQ2ODQzNzE5NDgyNDIseToyMzEuNTg5Njc5NzE4MDE3NTgsejoxMS40MDg4NTk0OTEzNDgyNjcsbmFtZTpcImxlZnRFeWVcIn0se3g6Mzg3Ljg4NjQyODgzMzAwNzgseToyMzIuMTQyNDU3OTYyMDM2MTMsejo5LjUxODA4MjE0MTg3NjIyLG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM4Mi40OTgxNjg5NDUzMTI1LHk6MzA3LjU2NTQ4ODgxNTMwNzYsejotNy41MjIyNjA1NDY2ODQyNjUsbmFtZTpcImxpcHNcIn0se3g6NDE5LjAwMTY5MzcyNTU4NTk0LHk6Mjc3LjgzMzI4MDU2MzM1NDUsejoyNi40MjQyMDI5MTkwMDYzNDh9LHt4OjM3My42Mjk1MzE4NjAzNTE1Nix5OjM1Ny42Mzc1MTAyOTk2ODI2LHo6LTUuNzU5ODY5MjE3ODcyNjIsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM5Mi44NzA4MjY3MjExOTE0LHk6MzQ3LjcyNDQ2NjMyMzg1MjU0LHo6MTAuMTU0MTc2OTUwNDU0NzEyLG5hbWU6XCJmYWNlT3ZhbFwifSx7eDo0MDAuMzk1MzU1MjI0NjA5NCx5OjM0MS4wMDA1MTg3OTg4MjgxLHo6MTkuMzk3OTc4NzgyNjUzODEsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM4Mi4yNTQ0MDk3OTAwMzkwNix5OjIzMS42NjkzNTkyMDcxNTMzMix6OjguOTk4NzAwOTc2MzcxNzY1LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM3Ny4xNDU1MDAxODMxMDU0Nyx5OjIzMC40MjI4Njg3Mjg2Mzc3LHo6OS44MDQwMzI0NDQ5NTM5MTgsbmFtZTpcImxlZnRFeWVcIn0se3g6MzczLjgzNTg2ODgzNTQ0OTIseToyMjkuNjQ5NTA1NjE1MjM0MzgsejoxMS4yOTIxNDQwNjAxMzQ4ODgsbmFtZTpcImxlZnRFeWVcIn0se3g6NDE0LjU3OTQ2Nzc3MzQzNzUseToyMjEuNjc4OTEwMjU1NDMyMTMsejoyOS40MTIwOTc5MzA5MDgyMDN9LHt4OjM3Ny4wMDY3MjE0OTY1ODIwMyx5OjIyNS42NjIwMTIxMDAyMTk3Myx6OjkuMzYwNTE3MjYzNDEyNDc2LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM4Mi4yOTUzMDMzNDQ3MjY1Nix5OjIyNC44NDMxMTU4MDY1Nzk2LHo6OC4zMjE3NTYxMjQ0OTY0NixuYW1lOlwibGVmdEV5ZVwifSx7eDozODcuNTEzMzUxNDQwNDI5Nyx5OjIyNC40OTUwNzIzNjQ4MDcxMyx6OjguOTE3MDAwODg5Nzc4MTM3LG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM5My4xNTkwNjUyNDY1ODIwMyx5OjIyNS4yNDc5NTA1NTM4OTQwNCx6OjEwLjczNzc0OTMzODE1MDAyNCxuYW1lOlwibGVmdEV5ZVwifSx7eDozOTcuMDU1NTQ5NjIxNTgyMDMseToyMjYuNTUzNTkyNjgxODg0NzcsejoxMy4wMDIwMTUzNTIyNDkxNDYsbmFtZTpcImxlZnRFeWVcIn0se3g6NDIwLjUyOTkzNzc0NDE0MDYseToyMjEuMDE0NjY2NTU3MzEyLHo6NjUuNDA2OTA0MjIwNTgxMDUsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjM5Ny4wNjkyMDYyMzc3OTI5Nyx5OjIzMC42NjYxNTU4MTUxMjQ1LHo6MTMuODA3MzQ1NjI4NzM4NDAzLG5hbWU6XCJsZWZ0RXllXCJ9LHt4OjM3Ny45NDY0NzIxNjc5Njg3NSx5OjI4NS4xNjQ3MDkwOTExODY1LHo6LTEzLjMwNTQ3MjEzNTU0MzgyM30se3g6MzcyLjExMTg5MjcwMDE5NTMseToyNjcuMTI2NzMxODcyNTU4Nix6Oi0xOC44Mzc3NDc1NzM4NTI1NH0se3g6MzY0Ljk5Njg3MTk0ODI0MjIseToyODIuMjQ0MTE5NjQ0MTY1MDQsejotMTkuODE4MTUwOTk3MTYxODY1fSx7eDo0MDEuOTczODc2OTUzMTI1LHk6MzMxLjIwMTMxNDkyNjE0NzQ2LHo6MTEuNTY2NDI0MzY5ODEyMDEyfSx7eDozOTQuMzA4MzE5MDkxNzk2OSx5OjMzOC44NjY5Mzk1NDQ2Nzc3Myx6OjMuMTQyNTQyNTQxMDI3MDY5fSx7eDozNzMuOTgyMDg2MTgxNjQwNix5OjM1MS40NTA0NjIzNDEzMDg2LHo6LTEzLjUwMzg4NzY1MzM1MDgzfSx7eDo0MTQuMzg4ODg1NDk4MDQ2OSx5OjMyMS4yNDczNTgzMjIxNDM1NSx6OjQ1LjUxODcyMjUzNDE3OTY5LG5hbWU6XCJmYWNlT3ZhbFwifSx7eDozNzMuNDQyMzQ0NjY1NTI3MzQseToyMjcuMzMxNjMzNTY3ODEwMDYsejoxMC42MjY4NzAzOTM3NTMwNTIsbmFtZTpcImxlZnRFeWVcIn0se3g6MzY0LjA3MzE0MzAwNTM3MTEseToyNDAuMzE1Mzk5MTY5OTIxODgsejotMTMuODA3MzQ1NjI4NzM4NDAzfSx7eDozODQuMjY1ODIzMzY0MjU3OCx5OjM1My4zNzkzMDY3OTMyMTI5LHo6LjczODU4NTA2OTc3NTU4MTQsbmFtZTpcImZhY2VPdmFsXCJ9LHt4OjQyMy4yMDUyNjEyMzA0Njg3NSx5OjI4My41MTc2MTgxNzkzMjEzLHo6NDcuMTUyNzI0MjY2MDUyMjQ2fSx7eDozNjkuNDI3OTg2MTQ1MDE5NTMseTozMDQuMDg5ODg5NTI2MzY3Mix6Oi0xNC42NDc2OTEyNDk4NDc0MTIsbmFtZTpcImxpcHNcIn0se3g6MzcwLjYzODEyMjU1ODU5Mzc1LHk6MzA1LjkwMDUxNjUxMDAwOTc3LHo6LTE2LjIxMTY2ODI1Mjk0NDk0Nn0se3g6MzcxLjkxMTkyNjI2OTUzMTI1LHk6MzA5LjAxNjc3MTMxNjUyODMsejotMTcuODQ1NjczNTYxMDk2MTl9LHt4OjM3My4wNTgzOTUzODU3NDIyLHk6MzEzLjM1NDUzOTg3MTIxNTgsejotMTcuMzc4ODE1NDEyNTIxMzYyLG5hbWU6XCJsaXBzXCJ9LHt4OjM3NS4zOTkwNTU0ODA5NTcwMyx5OjMyMS4wOTI4OTE2OTMxMTUyMyx6Oi0xMy4xMTg3MjgzOTkyNzY3MzN9LHt4OjM3OS4yNTY3ODI1MzE3MzgzLHk6MzA0LjM1ODI1MzQ3OTAwMzksejotNy45MjQ5MjYyODA5NzUzNDJ9LHt4OjM4MS4xODc5NzMwMjI0NjA5NCx5OjMwMy43MDMxMzY0NDQwOTE4LHo6LTcuODQzMjI2MTk0MzgxNzE0fSx7eDozODMuMDkxODUwMjgwNzYxNyx5OjMwMi40ODg0NjA1NDA3NzE1LHo6LTcuNjUwNjQ2NTY3MzQ0NjY1NSxuYW1lOlwibGlwc1wifSx7eDozODkuMDk0NjE5NzUwOTc2NTYseToyOTcuMTQ3NTMxNTA5Mzk5NCx6Oi01LjU0OTc4MjUxNDU3MjE0MzZ9LHt4OjQxMS42NDA4OTIwMjg4MDg2LHk6MjgwLjI0ODk4NTI5MDUyNzM0LHo6MTIuMDIxNjExOTI4OTM5ODJ9LHt4OjM2My4zMTEwODA5MzI2MTcyLHk6MjM0LjI3NjIwODg3NzU2MzQ4LHo6LTYuNzc1Mjg2NzkzNzA4ODAxfSx7eDozNjYuMDQ3NDM5NTc1MTk1Myx5OjIyMy4yOTg3MjEzMTM0NzY1Nix6OjYuODI3ODA4NjE4NTQ1NTMyfSx7eDozNzAuMzQ0Mjc2NDI4MjIyNjYseToyMjUuMTQ1NzExODk4ODAzNyx6OjkuNTU4OTMxNTg5MTI2NTg3fSx7eDozNzcuNTM3MTU1MTUxMzY3Mix5OjMwMy42MDA3OTc2NTMxOTgyNCx6Oi03LjM1ODg2MDM3MzQ5NzAwOSxuYW1lOlwibGlwc1wifSx7eDo0MTIuOTU1NzgwMDI5Mjk2OSx5OjI5OS41MzU3OTkwMjY0ODkyNix6OjE5LjM5Nzk3ODc4MjY1MzgxfSx7eDozNjAuMDgxMDI0MTY5OTIxOSx5OjIyMS43MjAxMjMyOTEwMTU2Mix6Oi0yLjE1MzM4NTcyODU5NzY0MX0se3g6Mzc5LjgyNzg0MjcxMjQwMjM0LHk6MzI5LjQ3NzIzMzg4NjcxODc1LHo6LTEwLjQ4MDk3ODQ4ODkyMjEyfSx7eDozNTkuMDg0Nzc3ODMyMDMxMjUseToyMzUuNzkxMTQ5MTM5NDA0Myx6Oi0xOC4wNzkxMDIwMzkzMzcxNTh9LHt4OjM2OS42Njg4NDYxMzAzNzExLHk6MjUxLjU0MDc5NDM3MjU1ODYsejotMTQuOTYyODIxMDA2Nzc0OTAyfSx7eDozNjkuNTU1NTExNDc0NjA5NCx5OjMzMy41MzA3MzEyMDExNzE5LHo6LTE1LjY3NDc4MDYwNzIyMzUxfSx7eDozOTQuMDE5MzE3NjI2OTUzMSx5OjMxNS42OTczMTcxMjM0MTMxLHo6LS45OTIwNzQ3NTc4MTQ0MDczfSx7eDozODMuNzg5OTc4MDI3MzQzNzUseToyNzIuNzI2ODY5NTgzMTI5OSx6Oi00LjY4OTAxMjE2OTgzNzk1Mn0se3g6Mzg3LjY3NzY1MDQ1MTY2MDE2LHk6MzIzLjY3MjI3NTU0MzIxMjksejotNS42NDAyMzYxMzkyOTc0ODV9LHt4OjM5Ny44NzY5MzAyMzY4MTY0LHk6MjcyLjEzMzEyMTQ5MDQ3ODUsejotLjkzOTU1MzE1NjQ5NTA5NDN9LHt4OjM4OS44NzQ3NjM0ODg3Njk1Myx5OjI4MC41NjMwMTExNjk0MzM2LHo6LTQuMjkyMTgyMDI4MjkzNjF9LHt4OjQwMy44Mzg4ODI0NDYyODkwNix5OjI4NS4xMTY3ODY5NTY3ODcxLHo6My4wMjI5MTAwNTg0OTgzODI2fSx7eDozNzIuNTQ2NzMwMDQxNTAzOSx5OjM0My4xMDcwMzI3NzU4Nzg5LHo6LTE2LjE1MzMxMDUzNzMzODI1N30se3g6Mzc0LjExMTI1MTgzMTA1NDcseToyNTYuMzcyMTQ2NjA2NDQ1Myx6Oi0xMC41NzQzNDkxNjQ5NjI3Njl9LHt4OjM5OS43Mzc4NTQwMDM5MDYyNSx5OjMyMS43NzUxNTk4MzU4MTU0Myx6OjQuODQ5NDk0Njk1NjYzNDUyfSx7eDozOTIuMDMzNjUzMjU5Mjc3MzQseTozMzAuNTY0NDc5ODI3ODgwODYsejotMS4zNDA3NTk4NDM1ODc4NzU0fSx7eDozOTguNTkxMzQ2NzQwNzIyNjYseTozMDUuOTM5MDI1ODc4OTA2MjUsejoxLjUxNzI5MDYyMTk5NTkyNn0se3g6NDE3Ljk1OTk3NjE5NjI4OTA2LHk6MjkwLjk3MTY5ODc2MDk4NjMsejoyNi44OTEwNTk4NzU0ODgyOH0se3g6NDA2LjA0NTQxNzc4NTY0NDUzLHk6MzA3LjM1MTU0MTUxOTE2NTA0LHo6OC42NjYwNjQxNDMxODA4NDd9LHt4OjQyMC43NTMyODgyNjkwNDI5Nyx5OjI5OC40MDc1MjYwMTYyMzUzNSx6OjQxLjc4Mzg1MjU3NzIwOTQ3fSx7eDozOTUuNDUyMjcwNTA3ODEyNSx5OjI5MS40MTUzNTc1ODk3MjE3LHo6LTIuMTc1MjY5NzIyOTM4NTM3Nn0se3g6MzY4LjY0NTIxMDI2NjExMzMseToyNDUuODg4Mjk5OTQyMDE2Nix6Oi05LjQ1Mzg4ODUzNTQ5OTU3M30se3g6MzcwLjM0OTAwNjY1MjgzMjAzLHk6MjYzLjU2NjkwNDA2Nzk5MzE2LHo6LTI2Ljc1MTAwMzI2NTM4MDg2fSx7eDozNzQuOTg0Nzc5MzU3OTEwMTYseToyNjYuNjEyNjM0NjU4ODEzNSx6Oi0xOS43NzE0NjYyNTUxODc5OX0se3g6MzY2Ljk5ODQwNTQ1NjU0Mjk3LHk6MjU4LjEyMTQwNDY0NzgyNzE1LHo6LTMxLjM3MjkwNDc3NzUyNjg1NX0se3g6MzcxLjAwNjE2NDU1MDc4MTI1LHk6MjE3LjYzNDc5NzA5NjI1MjQ0LHo6NS42MDUyMjE5ODY3NzA2M30se3g6MzgxLjMwNTc3MDg3NDAyMzQ0LHk6MjE0LjE0MDg3Mjk1NTMyMjI3LHo6NC45ODM3MTYzMDkwNzA1ODd9LHt4OjM5MC4xNDk2MTI0MjY3NTc4LHk6MjEzLjM4MjIxNTQ5OTg3NzkzLHo6NS41OTM1NTA4MDEyNzcxNjF9LHt4OjM5Ny43Njk2OTkwOTY2Nzk3LHk6MjE0LjM2NTk3ODI0MDk2Njgsejo4LjU3ODUyODE2NTgxNzI2fSx7eDo0MDMuMTY1MjA2OTA5MTc5Nyx5OjIxNy42NTUwOTYwNTQwNzcxNSx6OjEzLjAxMzY4NTk0MTY5NjE2N30se3g6NDA3LjM1NTE5NDA5MTc5NjkseToyMzAuNzI1MjUwMjQ0MTQwNjIsejoyMi40NDQyMzE1MTAxNjIzNTR9LHt4OjQyNC4wODc2NzcwMDE5NTMxLHk6MjUxLjc4MzkyNDEwMjc4MzIsejo1MS4xNjc3MTIyMTE2MDg4OX0se3g6NDAzLjUwMTk2ODM4Mzc4OTA2LHk6MjM5Ljg4NzU3NjEwMzIxMDQ1LHo6MTUuODAzMTY2NjI3ODgzOTExfSx7eDozOTcuMzE3MTk5NzA3MDMxMjUseToyNDEuNDk4MDYwMjI2NDQwNDMsejoxMS4yMzM3ODc1MzY2MjEwOTR9LHt4OjM4OC45OTQyNTUwNjU5MTc5Nyx5OjI0MS40MzY2OTEyODQxNzk3LHo6Ny45NDgyNjkyNDgwMDg3Mjh9LHt4OjM4MC43ODA0NDg5MTM1NzQyLHk6MjM5Ljc4MDc4ODQyMTYzMDg2LHo6Ni42MDAyMTQ4Mzg5ODE2Mjh9LHt4OjM3NC4wMTMzNjY2OTkyMTg3NSx5OjIzNy4xMTk0NjQ4NzQyNjc1OCx6OjYuMzQ5Mjc4MDkyMzg0MzM4fSx7eDozNjkuMzkxMjUwNjEwMzUxNTYseToyMzQuMzUzNTEzNzE3NjUxMzcsejo1Ljk4NzQ2MjQwMTM5MDA3Nn0se3g6NDIyLjk3MzA5ODc1NDg4MjgseToyNTUuNzY0NTUxMTYyNzE5NzMsejo3Ni42MTE1MDkzMjMxMjAxMixuYW1lOlwiZmFjZU92YWxcIn0se3g6Mzc0LjczOTE1MTAwMDk3NjU2LHk6MjY5LjI0MjE0MzYzMDk4MTQ1LHo6LTE2LjYwODQ5ODA5NjQ2NjA2NH0se3g6MzY0LjYxNjgxMzY1OTY2Nzk3LHk6MjQ1LjcxMDg4NzkwODkzNTU1LHo6LTIwLjAyODIzODI5NjUwODc5fSx7eDozNjUuMzgzNDUzMzY5MTQwNix5OjI2My4zNDE3NDE1NjE4ODk2NSx6Oi0zMi4zMjk5NjQ2Mzc3NTYzNX0se3g6MzYxLjU4MjUyNzE2MDY0NDUzLHk6MjY3LjgyNzM2Nzc4MjU5MjgsejotMzAuMzQ1ODE2NjEyMjQzNjUyfSx7eDozNjUuMzcyMDg1NTcxMjg5MDYseToyNjUuMDI0OTY3MTkzNjAzNSx6Oi0yOS4xNzg2NjcwNjg0ODE0NDV9LHt4OjM3Mi43MjYwNTg5NTk5NjA5NCx5OjI3Mi4wNTEzNTM0NTQ1ODk4NCx6Oi0xNC44MzQ0MzQ5ODYxMTQ1MDJ9LHt4OjM2MC40ODYxNDUwMTk1MzEyNSx5OjI2OC4zNDgyNzQyMzA5NTcwMyx6Oi0zMi4xODk5MDU2NDM0NjMxMzV9LHt4OjM1OS45NTE2Mjk2Mzg2NzE5LHk6MjcwLjgwNDkyMDE5NjUzMzIsejotMjQuNjUwMTM5ODA4NjU0Nzg1fSx7eDozNjkuNTA0OTI4NTg4ODY3Mix5OjIyOS4wMTk0NTExNDEzNTc0Mix6OjEwLjEwNzQ4OTgyNDI5NTA0NH0se3g6MzY1LjU0NDc3NjkxNjUwMzkseToyMzAuMjQwOTY0ODg5NTI2Mzcsejo1LjU5MzU1MDgwMTI3NzE2MX0se3g6MzYzLjUwNjY5ODYwODM5ODQ0LHk6MjMwLjYyMDgzNzIxMTYwODksejouNDM2MjIxMDYzMTM3MDU0NDR9LHt4OjM5OS4zNTI5NTEwNDk4MDQ3LHk6MjI3LjY1Njc3NDUyMDg3NDAyLHo6MTUuMzU5NjUwODUwMjk2MDIsbmFtZTpcImxlZnRFeWVcIn0se3g6NDAyLjU2OTMxMzA0OTMxNjQseToyMjQuNjAxOTAyOTYxNzMwOTYsejoxNS45MzE1NTI2NDg1NDQzMTJ9XSxib3g6e3hNaW46Mjc3LjgzMTg5NzczNTU5NTcseU1pbjoxNjguNzc0MTc1NjQzOTIwOSx4TWF4OjQyNC4yNzg4MzE0ODE5MzM2LHlNYXg6MzU5LjgzNDg5MDM2NTYwMDYsd2lkdGg6MTQ2LjQ0NjkzMzc0NjMzNzksaGVpZ2h0OjE5MS4wNjA3MTQ3MjE2Nzk3fX0sU0FNUExFX0ZBQ0VMQU5ETUFSS0VSX1JFU1VMVDp7ZmFjZUxhbmRtYXJrczpbW3t4Oi41NzYwNzc3NTkyNjU4OTk3LHk6Ljg2MzkwNzAzOTE2NTQ5NjgsejotLjAzMDk5Nzk1NjE3MTYzMTgxM30se3g6LjU3MjA5NDczODQ4MzQyOSx5Oi43ODg2Mjg5MzU4MTM5MDM4LHo6LS4wNzE4OTYyNDAxMTUxNjU3MX0se3g6LjU3MjM1NTE1MTE3NjQ1MjYseTouODA3NTM4MjcwOTUwMzE3NCx6Oi0uMDM1NzgxNjg4OTg4MjA4Nzd9LHt4Oi41NTQ4NDIwNTQ4NDM5MDI2LHk6LjcxODgzNjU0NTk0NDIxMzksejotLjA1Nzc4Nzg3NjU3NjE4NTIyNn0se3g6LjU3MDYwNzc4MTQxMDIxNzMseTouNzY3NDk3NDc5OTE1NjE4OSx6Oi0uMDc3NDAzOTk5ODY1MDU1MDh9LHt4Oi41NjgxMzc4MjQ1MzUzNjk5LHk6LjczODc3NjgwMzAxNjY2MjYsejotLjA3MzU2Mjg0NTU4NzczMDQxfSx7eDouNTYyMTUzNTE4MTk5OTIwNyx5Oi42NjgxMTY1MDk5MTQzOTgyLHo6LS4wNDE4OTg3NDk3Njg3MzM5OH0se3g6LjQ2NjEzNTgyOTY4NzExODUzLHk6LjY2Nzk4MTIwNzM3MDc1ODEsejouMDExMjg5NjgxMzA3OTcxNDc4fSx7eDouNTU3OTkzMjkyODA4NTMyNyx5Oi42MTc0MTA2NTk3OTAwMzkxLHo6LS4wMzUwMjgyMTU0OTc3MzIxNn0se3g6LjU1NjM0NTE2NDc3NTg0ODQseTouNTkwNTYwMDE5MDE2MjY1OSx6Oi0uMDM5Mjg2NTg3Mzg3MzIzMzh9LHt4Oi41NDg3ODMyNDI3MDI0ODQxLHk6LjQ5MDA1NzI1OTc5ODA0OTksejotLjAyOTg5ODkzNzc5MTU4NTkyMn0se3g6LjU3NjU1NDQxNzYxMDE2ODUseTouODY5MjE0NDc1MTU0ODc2Nyx6Oi0uMDI4MzE0Mjc3NTI5NzE2NDl9LHt4Oi41NzcxMTE0MjMwMTU1OTQ1LHk6Ljg3MzY0NDIzMjc0OTkzOSx6Oi0uMDIzNDU3Nzk5MTA2ODM2MzJ9LHt4Oi41NzcxOTA1Nzc5ODM4NTYyLHk6Ljg3NzAxNjAwNzkwMDIzOCx6Oi0uMDE2NjU4Njg5ODI2NzI2OTEzfSx7eDouNTc3ODA1ODc2NzMxODcyNix5Oi44NzcwMTE2NTY3NjExNjk0LHo6LS4wMTQ1MDU0OTI1MjMzMTI1Njl9LHt4Oi41NzgzNzY2NTA4MTAyNDE3LHk6Ljg4MzUwMDA5OTE4MjEyODksejotLjAxNTk5NjQwMjEyOTUzMDkwN30se3g6LjU3OTI0NDAxNzYwMTAxMzIseTouODkxMzgxMDg0OTE4OTc1OCx6Oi0uMDE5MjQ1NzkyMTgwMjk5NzZ9LHt4Oi41Nzk2NzY4MDY5MjY3MjczLHk6Ljg5OTYzMzQ2NzE5NzQxODIsejotLjAxODI2MTcxMjA0NDQ3NzQ2M30se3g6LjU4MTcyODgxNjAzMjQwOTcseTouOTI1NTgxMzk1NjI2MDY4MSx6Oi0uMDA3MTI2ODQ5MTQ0Njk3MTg5fSx7eDouNTcyNjU5MjU0MDc0MDk2Nyx5Oi43OTkyNDczMjQ0NjY3MDUzLHo6LS4wNjQzNTIxMzk4MzA1ODkzfSx7eDouNTU3OTQxOTEzNjA0NzM2Myx5Oi43OTk2OTg5NDg4NjAxNjg1LHo6LS4wNDU2NjY4NDM2NTI3MjUyMn0se3g6LjQyMTYxOTk4MTUyNzMyODUseTouNTk1ODc2Mjc2NDkzMDcyNSx6Oi4wNjc3NjQ5NjAyMjkzOTY4Mn0se3g6LjUwNTIyNjk2OTcxODkzMzEseTouNjc5NjUzOTQyNTg0OTkxNSx6Oi0uMDAxMDczNzc4MjU3NzA1MjcxMn0se3g6LjQ5MjQzMDI2OTcxODE3MDE3LHk6LjY4Mzg4NjU4NzYxOTc4MTUsejotLjAwMDUyMjczMjQ0MzY0MTg3MTJ9LHt4Oi40Nzk2OTcwNzg0NjY0MTU0LHk6LjY4NTYyOTAxMDIwMDUwMDUsejouMDAyNjg0MjQ1ODE3MzYzMjYyfSx7eDouNDYxODM1NjIyNzg3NDc1Nix5Oi42NzY0NTY5ODc4NTc4MTg2LHo6LjAxMzQzOTYyMjcwNzY2NDk2N30se3g6LjUxNjAzODA2MDE4ODI5MzUseTouNjczNzI4MjI3NjE1MzU2NCx6Oi0xNzYwNzM0ODEyNzA1Nzc3NmUtMjF9LHt4Oi40ODA3MDk2MTIzNjk1MzczNSx5Oi42MjU1ODcwNDYxNDYzOTI4LHo6LS4wMDgzMzk2NzQyMTIwMzg1MTd9LHt4Oi40OTcxOTc4MDY4MzUxNzQ1Nix5Oi42MjU2ODA4MDQyNTI2MjQ1LHo6LS4wMDgwMjc5NTU4ODk3MDE4NDN9LHt4Oi40NjY3NDM0NjkyMzgyODEyNSx5Oi42MzE3NjIzODUzNjgzNDcyLHo6LS4wMDQ0NjAxOTk3MzYwNTg3MTJ9LHt4Oi40NTgyNDkyNzA5MTU5ODUxLHk6LjY0MTExODA0OTYyMTU4Mix6Oi4wMDExOTA1NjEzMzU1MzM4NTczfSx7eDouNDU0MDg2NjkxMTQxMTI4NTQseTouNjkxMTQ1ODk2OTExNjIxMSx6Oi4wMjA1MTQ3NDg5OTA1MzU3MzZ9LHt4Oi41MzUzMTIyOTQ5NjAwMjIseTouOTYxOTk4NjQxNDkwOTM2Myx6Oi4wMTI0OTk0NjI4MTMxMzg5NjJ9LHt4Oi40NjA4NDYwMDY4NzAyNjk4LHk6LjY2Mjg3MjU1Mjg3MTcwNDEsejouMDE1MTc1NjQyNDQ1NjgzNDh9LHt4Oi40MjA2NzMxOTE1NDczOTM4LHk6LjY4Mjg0NTgzMDkxNzM1ODQsejouMDc4NDg2NDg3MjY5NDAxNTV9LHt4Oi40MzkwNjI0NDYzNTU4MTk3LHk6LjY3OTYxMDY2OTYxMjg4NDUsejouMDMyODMxNDIyOTg0NjAwMDd9LHt4Oi41MDI5OTY4NjE5MzQ2NjE5LHk6Ljc3MDE1NzAzOTE2NTQ5NjgsejotLjAwOTczNDQ4MTU3MzEwNDg1OH0se3g6LjU1OTUwMjcyMDgzMjgyNDcseTouODYwNzMyMzE2OTcwODI1Mix6Oi0uMDMwMDQzMjU1NTM3NzQ4MzM3fSx7eDouNTYyMTI2OTk0MTMyOTk1Nix5Oi44NzM4Mzc0NzEwMDgzMDA4LHo6LS4wMjE3MDk1Nzk5NzQ0MTI5MTh9LHt4Oi41NDUxNDk5ODE5NzU1NTU0LHk6Ljg2NTUyNzMzMTgyOTA3MSx6Oi0uMDIyMDE0MDc3NzUyODI4NTk4fSx7eDouNTM1MTE4NDAxMDUwNTY3Nix5Oi44NzA1MDk4MDMyOTUxMzU1LHo6LS4wMTE2MDI4MDAzMzk0NjAzNzN9LHt4Oi41NDk1MDE0MTkwNjczODI4LHk6Ljg3NDQ5NTYyNTQ5NTkxMDYsejotLjAxNjQ5MDk0MzcyOTg3NzQ3Mn0se3g6LjUzOTUxNzA0NTAyMTA1NzEseTouODc1OTQ0MDc3OTY4NTk3NCx6Oi0uMDA3MzMzMzYyOTQwNjk4ODYyfSx7eDouNTE4MzYyNDAyOTE1OTU0Nix5Oi44OTU5NzU0NzA1NDI5MDc3LHo6LjAxMDUyMDc3MzkzOTc4ODM0Mn0se3g6LjU2MDQzNDkzNzQ3NzExMTgseTouNzg5NTQ0OTk5NTk5NDU2OCx6Oi0uMDcwODIwMzc2Mjc2OTY5OTF9LHt4Oi41NTczODEyNzIzMTU5NzkseTouNzY4NzQ4OTk4NjQxOTY3OCx6Oi0uMDc1OTA1ODg5MjcyNjg5ODJ9LHt4Oi40NDMyOTAxNDQyMDUwOTM0LHk6LjYzMDg4OTc3MzM2ODgzNTQsejouMDAyNzE1MzI1NDQ4NjYyMDQyNn0se3g6LjUyNTgzMjUzMzgzNjM2NDcseTouNzE1MTIyNTgwNTI4MjU5Myx6Oi0uMDE0Njc2NTE4NzM4MjY5ODA2fSx7eDouNTI3MTgyNzU3ODU0NDYxNyx5Oi43ODMzMTE2MDU0NTM0OTEyLHo6LS4wMzc2NDMzMjA4NTg0Nzg1NDZ9LHt4Oi41MjU3MzgyOTg4OTI5NzQ5LHk6Ljc3MTc4MTYyMzM2MzQ5NDksejotLjAzNDAxOTIwOTQ0NDUyMjg2fSx7eDouNDY1MTY0MDk1MTYzMzQ1MzQseTouNzcwNTEwNjczNTIyOTQ5Mix6Oi4wMDY1NzQ3NzYwMjM2MjYzMjc1fSx7eDouNTU1ODg5MzA4NDUyNjA2Mix5Oi43NDIwOTk3NjE5NjI4OTA2LHo6LS4wNjk0NDk1MjkwNTE3ODA3fSx7eDouNDcyMDQwODMyMDQyNjk0MSx5Oi42MDY2MDM4NjA4NTUxMDI1LHo6LS4wMjEyMDQzNTYxMDQxMzU1MTN9LHt4Oi40NTQzMjU3MzU1NjkwMDAyNCx5Oi42MTU4NTQwODQ0OTE3Mjk3LHo6LS4wMTEwNTQ2ODQ0MDgwMDkwNTJ9LHt4Oi40MzA1MTUxNDAyOTUwMjg3LHk6LjU2MDgwNTM4MDM0NDM5MDksejouMDM5NjgzMDI5MDU1NTk1NH0se3g6LjUzMTA4NjU2NDA2NDAyNTkseTouNjE1NzQ4NDY1MDYxMTg3Nyx6Oi0uMDMwODExNzYwNTc0NTc5MjR9LHt4Oi41MTE0NjY2MjIzNTI2MDAxLHk6LjYzMjk3NDkyMjY1NzAxMjksejotLjAwMzM1OTk4MjA0NTM2NzM2fSx7eDouNTA2NDM1NzUxOTE0OTc4LHk6Ljg3ODY1NDM2MDc3MTE3OTIsejouMDEyOTgwODc2NDkwNDczNzQ3fSx7eDouNDQ4MDQ3MjIwNzA2OTM5Nyx5Oi44NjQwNjEzNTU1OTA4MjAzLHo6LjEyNTY5NjUxMDA3NjUyMjgzfSx7eDouNTM3MjA1ODE1MzE1MjQ2Nix5Oi43OTQyNTgxMTc2NzU3ODEyLHo6LS4wMzE2ODM2MTYzNDAxNjAzN30se3g6LjU0ODgzNzk1OTc2NjM4NzkseTouODAwMTYzMDMwNjI0Mzg5Nix6Oi0uMDMyODA5MTc5Mjc2MjI3OTV9LHt4Oi41MjEzMzg4MjA0NTc0NTg1LHk6Ljg3OTQzODE2MTg0OTk3NTYsejouMDExODkyNjA2NTA0MjYxNDk0fSx7eDouNTI0MjA1NTY1NDUyNTc1Nyx5Oi44Nzg5MjIyMjQwNDQ3OTk4LHo6LjAwODM3MDIyNTMxNzc3NjIwM30se3g6LjQ0NzcxNzUxNzYxNDM2NDYseTouNjAzOTk1MDI1MTU3OTI4NSx6Oi0uMDA1MDc5OTk3MjM3NzcxNzQ5NX0se3g6LjUyNjk2NDAwODgwODEzNix5Oi43OTE2NzQ4NTIzNzEyMTU4LHo6LS4wMjk2ODYxNDE3NTkxNTcxOH0se3g6LjQ5NzEyNTU2NjAwNTcwNjgseTouNjA1MDcwNjUwNTc3NTQ1Mix6Oi0uMDI4MTc1Njc4MTA0MTYyMjE2fSx7eDouNDkzODExOTA1Mzg0MDYzNyx5Oi41ODgyNDUzOTE4NDU3MDMxLHo6LS4wMzIxMDk0MTMyOTU5ODQyN30se3g6LjQ3NTcxNDM1NTcwNzE2ODYseTouNTA5NDg3OTg2NTY0NjM2Mix6Oi0uMDEzMDA3MzA4MzU2NDYzOTF9LHt4Oi40Mzk0NzI4MjQzMzUwOTgyNyx5Oi41ODE2NjQ4MDA2NDM5MjA5LHo6LjAxNDE1MTc3NDM0NjgyODQ2fSx7eDouNDg1NjY0MDM5ODUwMjM1LHk6LjU0Nzc4NjQxNDYyMzI2MDUsejotLjAyMzY4NTMzMjM4NzY4NTc3Nn0se3g6LjQzNjM1OTMxNjExMDYxMDk2LHk6LjYyMjY0MzgyODM5MjAyODgsejouMDEzNjA2MTQ4NzcxOTQxNjYyfSx7eDouNDI5MTAyNTEwMjEzODUxOTMseTouNjEwMjcyNjQ1OTUwMzE3NCx6Oi4wMzkyNjU2NDAwNzk5NzUxM30se3g6LjU2MDU0MDI1ODg4NDQyOTkseTouODY4MDA5OTI0ODg4NjEwOCx6Oi0uMDI3MzE4MTU5MTE4Mjk0NzE2fSx7eDouNTQ3NDgxNjU2MDc0NTIzOSx5Oi44NzAyODYxMDcwNjMyOTM1LHo6LS4wMTk2ODYzNjczNjI3Mzc2NTZ9LHt4Oi41MzczMDIxMzY0MjEyMDM2LHk6Ljg3Mjg4Mzg1NjI5NjUzOTMsejotLjAxMDQ4NDkyODI2NTIxMzk2Nn0se3g6LjU0MDczNTEyNTU0MTY4Nyx5Oi43OTc5MTY3MTAzNzY3Mzk1LHo6LS4wMjkwNzMyNTMyNzM5NjM5Mjh9LHt4Oi41MjI4NTg1MDA0ODA2NTE5LHk6Ljg3OTEzNTc4NzQ4NzAzLHo6LjAwOTkxNTEwOTcyMzgwNjM4MX0se3g6LjUzMDQ5NzY3MDE3MzY0NSx5Oi44ODE1MjUzOTczMDA3MjAyLHo6LjAwMjA1MjQ3ODQ5MjI1OTk3OTJ9LHt4Oi41MjU5OTEyNjEwMDU0MDE2LHk6Ljg3OTA1NTI2MTYxMTkzODUsejouMDA3ODk1OTcwNzE3MDcyNDg3fSx7eDouNTQzMzkwNjMxNjc1NzIwMix5Oi43ODgyMzEwNzQ4MTAwMjgxLHo6LS4wNTEyMTkwNTM1NjY0NTU4NH0se3g6LjU0MTM4ODIxMzYzNDQ5MSx5Oi44Nzc3MjE5NjUzMTI5NTc4LHo6LS4wMDQ2NjgwNDQzOTIwMTk1MX0se3g6LjU1MTU4MjIxNzIxNjQ5MTcseTouODc2NzAyMzA4NjU0Nzg1Mix6Oi0uMDEwNDc1OTQ2NTkwMzA0Mzc1fSx7eDouNTYzNzAwMzc3OTQxMTMxNix5Oi44NzcwNTk4MTczMTQxNDgsejotLjAxNTI3MzYyNTAzMTExMzYyNX0se3g6LjU2NDAyOTkzMjAyMjA5NDcseTouOTI2MzQyMzA4NTIxMjcwOCx6Oi0uMDA2NTg3MjQ5NjkyNTI5NDR9LHt4Oi41NjQyMzAwMjQ4MTQ2MDU3LHk6Ljg5OTMwNzQ4OTM5NTE0MTYsejotLjAxNzY1MzQ4MDE3MjE1NzI4OH0se3g6LjU2MzczMzYzNzMzMjkxNjMseTouODkxMDM2MDkzMjM1MDE1OSx6Oi0uMDE4NTI4MDcwMzAwODE3NDl9LHt4Oi41NjM3MTM0MzEzNTgzMzc0LHk6Ljg4MzcyNzY2OTcxNTg4MTMsejotLjAxNDgyNTkyNTIzMDk3OTkyfSx7eDouNTY0MjA1NTI3MzA1NjAzLHk6Ljg3Njg5NjQ0MDk4MjgxODYsejotLjAxMzMxMTU1MDAyMTE3MTU3fSx7eDouNTQxOTg2NzYzNDc3MzI1NCx5Oi44Nzc4MzczNTk5MDUyNDI5LHo6LS4wMDM3NzIwMzk0MzIwNzg2fSx7eDouNTQwNDQ2ODc3NDc5NTUzMix5Oi44ODA2OTYxNzc0ODI2MDUsejotLjAwNTYxMDM1NDI0NDcwOTAxNX0se3g6LjUzOTIzMzg2MzM1MzcyOTIseTouODg0NTcyMTQ4MzIzMDU5MSx6Oi0uMDA3MzUyMDI1NzEzNzcxNTgyfSx7eDouNTM4NDY5NjcyMjAzMDY0LHk6Ljg4OTExNzM2MDExNTA1MTMsejotLjAwNTE1NDk5MTk4ODA5MjY2MX0se3g6LjUxODkyNTAxMTE1Nzk4OTUseTouODQ1Mjc0MTUwMzcxNTUxNSx6Oi0uMDA5NzU1MDcwMzIxMjYxODgzfSx7eDouNDI1ODk3NTA4ODU5NjM0NCx5Oi43NjYyMjgwNzk3OTU4Mzc0LHo6LjEzODczNTExNTUyODEwNjd9LHt4Oi41NzI1NzI1MjkzMTU5NDg1LHk6LjgwNDE1NzI1NzA4MDA3ODEsejotLjA0NTgzOTA3ODcyNDM4NDMxfSx7eDouNTM0MjA2MTUxOTYyMjgwMyx5Oi44Nzg1ODMzMTIwMzQ2MDY5LHo6LjAwMjY1OTk3NDE1NDA4NDkyMX0se3g6LjUzMjQwMzExMTQ1NzgyNDcseTouODgwNDA3MTU0NTYwMDg5MSx6Oi4wMDE3ODMyMDAzMDY4MTc4ODkyfSx7eDouNTUzODgxODgzNjIxMjE1OCx5Oi44MDc4NDA3NjQ1MjI1NTI1LHo6LS4wMzI1NDUzOTg5MjA3NzQ0Nn0se3g6LjUzMjU0MzE4MjM3MzA0NjkseTouODAyNjgzMjkzODE5NDI3NSx6Oi0uMDE5MTQwMzczOTE1NDMzODg0fSx7eDouNTUxNDA3Njk0ODE2NTg5NCx5Oi44MDQzOTAzMTEyNDExNDk5LHo6LS4wMzMxMzUzNTQ1MTg4OTAzOH0se3g6LjUxMzE4NTYyMDMwNzkyMjQseTouNzI4NDc3MTgwMDA0MTE5OSx6Oi0uMDA5Mzk5ODUzNjQ2NzU1MjE5fSx7eDouNDkzMzE1MDQxMDY1MjE2MDYseTouNzQ0Mzk4MDU3NDYwNzg0OSx6Oi0uMDA1MjI1MjMwOTM5Njg2Mjk4fSx7eDouNTIzOTYxNzgyNDU1NDQ0Myx5Oi43ODA3NDUxNDg2NTg3NTI0LHo6LS4wMjU4ODEwMjc4MDI4MjQ5NzR9LHt4Oi40NDczNjA2MDUwMDE0NDk2LHk6LjUzMTU4MjcxMzEyNzEzNjIsejouMDExMTY0Nzg2Mjk0MTAyNjY5fSx7eDouNDU3MTg3NTkyOTgzMjQ1ODUseTouNTYwNDk0MTI0ODg5MzczOCx6Oi0uMDA1OTQzMzAxNTk5NDcyNzYxfSx7eDouNDY3MDAwNTczODczNTE5OSx5Oi41OTA5MzI3MjY4NjAwNDY0LHo6LS4wMTk2ODE3NjEwNDEyODM2MDd9LHt4Oi41MzExNTcwMTY3NTQxNTA0LHk6LjkwNzYyNjE1MjAzODU3NDIsejouMDAzODk0NzYzNTMzMDI1OTh9LHt4Oi41MjQ5OTIzNDY3NjM2MTA4LHk6LjU4OTM1NjM2MjgxOTY3MTYsejotLjAzNzk4MTkxOTk0NDI4NjM0Nn0se3g6LjUxNjY5MzIzNDQ0MzY2NDYseTouNTQyOTU1MTAwNTM2MzQ2NCx6Oi0uMDMzMTk3MDQxNjAwOTQyNjF9LHt4Oi41MDg1MDMwMTk4MDk3MjI5LHk6LjQ5Njc2MjA2NzA3OTU0NDA3LHo6LS4wMjY5MTI3NTI1Mzg5MTk0NX0se3g6LjQ2ODc3MjAyMzkxNjI0NDUseTouNjgzNDU2NTk5NzEyMzcxOCx6Oi4wMDgxMTM1MDYyNTAwODM0NDd9LHt4Oi40NDI2NDE0OTY2NTgzMjUyLHk6LjcwNjk1MzE2NzkxNTM0NDIsejouMDI4NTc3MjcxODQ4OTE3MDA3fSx7eDouNTIzMDM3Mzc0MDE5NjIyOCx5Oi42Njc1NzEzNjU4MzMyODI1LHo6LjAwMTc3Mzc3MjQxMTk3OTczNX0se3g6LjQ0ODEyNDAyMTI5MTczMjgseTouNjUyNzg3MjA4NTU3MTI4OSx6Oi4wMTI0MTQ4NTAyOTQ1ODk5OTZ9LHt4Oi41MzM5ODU2NzQzODEyNTYxLHk6LjcwMTIzNjc4NDQ1ODE2MDQsejotLjAyMDIyMDE4ODQyMzk5MTIwM30se3g6LjUzNDcyMjMyODE4NjAzNTIseTouNzc2MTE5MDUzMzYzOCx6Oi0uMDUxNDE1OTUwMDU5ODkwNzV9LHt4Oi40MzE1MDY3MjMxNjU1MTIxLHk6LjcyMTE5NTc1NzM4OTA2ODYsejouMDQzODE0MDU5MzQ2OTE0Mjl9LHt4Oi40NTIwMzM1MTk3NDQ4NzMwNSx5Oi43MjA2MTgwMDk1NjcyNjA3LHo6LjAxNzI4ODA3MDE3MjA3MTQ1N30se3g6LjQ2ODkyNDUyMjM5OTkwMjM0LHk6LjcyNjU0MzYwNTMyNzYwNjIsejouMDA1NjAyOTg4ODgwMTI3NjY4fSx7eDouNDkzMTQ2NzQ3MzUwNjkyNzUseTouNzIwMjI4MjU0Nzk1MDc0NSx6Oi0uMDAwNjQwODIwNTM3MjI4MTM3M30se3g6LjUxMDQ5MjU2MzI0NzY4MDcseTouNzA5MTgyNzM5MjU3ODEyNSx6Oi0uMDAzNjI5MTg3NTg3NjQ4NjN9LHt4Oi41MjMyMTQyMjEwMDA2NzE0LHk6LjY5ODU1Mzc0MDk3ODI0MSx6Oi0uMDA3ODc4NjcwNDY4OTI2NDN9LHt4Oi41NDk3ODgzNTU4MjczMzE1LHk6LjY3NDM2MDUxMzY4NzEzMzgsejotLjAzNjM0OTEwNjU4MDAxOX0se3g6LjQzNjU4NTAzODkwMDM3NTM3LHk6Ljc2MjcxMDAzNDg0NzI1OTUsejouMDQyNTU1MzY5NDM2NzQwODc1fSx7eDouNDM5NzY0ODg3MDk0NDk3Nyx5Oi42NTI4NjQ2MzQ5OTA2OTIxLHo6LjAxNzk1NjA5NDgxNjMyNzA5NX0se3g6LjU2NTMzMzI0NzE4NDc1MzQseTouNzk5MjgwMjg1ODM1MjY2MSx6Oi0uMDYzNjUwNTc4MjYwNDIxNzV9LHt4Oi41Mjg1NTYzNDY4OTMzMTA1LHk6LjczNjgxMDU2NDk5NDgxMix6Oi0uMDE4ODM2OTg4MTM2MTcyMjk1fSx7eDouNDE4MDY3ODcyNTI0MjYxNSx5Oi42NzkyNTYwODE1ODExMTU3LHo6LjEyMjg0Njc5NzEwODY1MDIxfSx7eDouNTMyODQyOTkzNzM2MjY3MSx5Oi42ODY1ODcyMTQ0Njk5MDk3LHo6LS4wMTA0ODQ3MjMzNzQyNDc1NTF9LHt4Oi41MjMwMjgzMTQxMTM2MTY5LHk6Ljc4MDk0MTYwNTU2NzkzMjEsejotLjAxMTkyMjM5ODU4MjEwMDg2OH0se3g6LjQ1NTE3NzEyODMxNDk3MTkseTouNjY1MDc3NTA3NDk1ODgwMSx6Oi4wMTc3NDQ5MzA0NjEwNDkwOH0se3g6LjUzMzcyMDM3NDEwNzM2MDgseTouNzYxODkyODU1MTY3Mzg4OSx6Oi0uMDQ2OTcxMDYwMzM1NjM2MTR9LHt4Oi40MzQ2Mzk3NTE5MTExNjMzMyx5Oi44MTMzNDc4MTY0NjcyODUyLHo6LjEzNTQ4NDk5MzQ1Nzc5NDJ9LHt4Oi41MjI1NzA3MjkyNTU2NzYzLHk6LjY2MDUyODM2MTc5NzMzMjgsejouMDA0OTgwNTE1Njg4NjU3NzYxfSx7eDouNTQ0MTkzMzg3MDMxNTU1Mix5Oi43NDk3MTk5NzczNzg4NDUyLHo6LS4wNjA5MTUxMjM2NzEyOTMyNn0se3g6LjQ3NzQwMDc3OTcyNDEyMTEseTouOTE1OTE4MzUwMjE5NzI2Nix6Oi4wNTk2MjI3MzQ3ODUwNzk5NTZ9LHt4Oi40ODA2ODc2MTgyNTU2MTUyMyx5Oi45MzY0OTQxNzE2MTk0MTUzLHo6LjA4NDA0OTQ0ODM3MDkzMzUzfSx7eDouNDI2ODI5MjQ4NjY2NzYzMyx5Oi43NjU3NTI4NTE5NjMwNDMyLHo6LjA5MDUxMDk3MTg0NDE5NjMyfSx7eDouNDYwNTE5MTM0OTk4MzIxNTMseTouODg4MDQ4NTg5MjI5NTgzNyx6Oi4wNzM4NDc0NDI4NjUzNzE3fSx7eDouNDI0MzQyMDY2MDQ5NTc1OCx5Oi42NDM0MzgyMjAwMjQxMDg5LHo6LjA2MjMwNTA1MTgzMzM5MTE5fSx7eDouNTM0MjE1NzQ4MzEwMDg5MSx5Oi45ODM1NjM0MjMxNTY3MzgzLHo6LjAyMTY2Mjk3MTAwNDg0MzcxMn0se3g6LjU2NjgxMDk2NTUzODAyNDkseTouODA0MjE4NzA5NDY4ODQxNix6Oi0uMDQ0OTM3MDc0MTg0NDE3NzI1fSx7eDouNTE3NjM0MTUzMzY2MDg4OSx5Oi43NTMwNTg3MzE1NTU5Mzg3LHo6LS4wMTI5Njc0NTQyNjk1MjgzODl9LHt4Oi40MzAyMDYyOTg4MjgxMjUseTouNjgzNTYwNTUwMjEyODYwMSx6Oi4wNDYxMjI4NDE1MzY5OTg3NX0se3g6LjQ3OTQyMzE5NTEyMzY3MjUseTouNjczMjExNDU1MzQ1MTUzOCx6Oi4wMDM5NzAwNDQ2NjUwMzg1ODZ9LHt4Oi40OTA3MzM0NzQ0OTMwMjY3Myx5Oi42NzIyNDM1MzU1MTg2NDYyLHo6LjAwMDg2OTI1MTQzODQxNjU0MDZ9LHt4Oi41Mjk0MTE2MTM5NDExOTI2LHk6Ljg4NDY3NzUyOTMzNTAyMix6Oi4wMDQ0MTM4OTAxODY2OTcyNDV9LHt4Oi40NDMwMTIyMzc1NDg4MjgxLHk6LjgwMjM1MzU2MDkyNDUzLHo6LjA0OTg3MjgyMzA1OTU1ODg3fSx7eDouNTYwMzgyNTQ0OTk0MzU0Mix5OjEuMDA5MjQ0MjAzNTY3NTA0OSx6Oi4wMjY0MTczNTk3MDk3Mzk2ODV9LHt4Oi41MTg2NTk4MzAwOTMzODM4LHk6Ljk4Mjg2NTk4OTIwODIyMTQsejouMDUxMzU5ODgwNzE1NjA4Nn0se3g6LjUwMTA1MzY5MDkxMDMzOTQseTouOTY0MDkzMjY3OTE3NjMzMSx6Oi4wNjU5MTU5NjQ1NDM4MTk0M30se3g6LjU1MjQ3Njk0MjUzOTIxNTEseTouNTM5NDQxNzA0NzUwMDYxLHo6LS4wMzU4MTYwNDczNDA2MzE0ODV9LHt4Oi41ODc5OTk3NjExMDQ1ODM3LHk6MS4wMDkxNDcyODY0MTUxLHo6LjAyMjg1MDY4ODU0Njg5NTk4fSx7eDouNTAxNjE5Mzk4NTkzOTAyNix5Oi42Njg0NDM3OTkwMTg4NTk5LHo6LjAwMDI4NDE1OTQxMDUxMjA3NDgzfSx7eDouNTExOTUyODE3NDQwMDMzLHk6LjY2NDIxOTczNzA1MjkxNzUsejouMDAyMTE0NDcxOTc5NDM5MjU4Nn0se3g6LjUxOTQzNDMzMjg0NzU5NTIseTouNjYyMzQ2OTU5MTE0MDc0Nyx6Oi4wMDQ2NzQxODEzNDIxMjQ5Mzl9LHt4Oi40MzIxMjMwMzUxOTI0ODk2LHk6LjY0OTYzNTU1MzM1OTk4NTQsejouMDMxMjQ2OTcxMzM4OTg3MzV9LHt4Oi41MDg2ODYzNjM2OTcwNTIseTouNjQ3OTU2NTUwMTIxMzA3NCx6Oi0uMDAwNDQ3NjU5OTg2MDkzNjQwMzN9LHt4Oi40OTYzOTg2Mjc3NTgwMjYxLHk6LjY0MzEwMzI0MTkyMDQ3MTIsejotLjAwMzI1MDc2ODg3Mzg0MDU3MDR9LHt4Oi40ODQ1NTQyMDEzNjQ1MTcyLHk6LjY0MzA3Nzg1MDM0MTc5NjksejotLjAwMjkwMzYyNDQzNzc0OTM4Nn0se3g6LjQ3MzM2MTI1MzczODQwMzMseTouNjQ3NTA2ODMzMDc2NDc3LHo6LjAwMDIzMzQ3MjQ3MDQyNjkzMTk4fSx7eDouNDY2ODY1NDUwMTQzODE0MSx5Oi42NTMzNDY1OTgxNDgzNDYsejouMDA0NzYyNTcyMjM2MzU5MTE5fSx7eDouNDE4MTUwNTE0MzY0MjQyNTUseTouNjMzNzA4MTE5MzkyMzk1LHo6LjA5ODA5NDM1OTA0MDI2MDMxfSx7eDouNDcxNTk5NDI5ODQ1ODA5OTQseTouNjcxMTQ4NTM4NTg5NDc3NSx6Oi4wMDc4NDk5MzU0NDIyMDkyNDR9LHt4Oi41NzM0Mzk2NTc2ODgxNDA5LHk6LjgyNTYxNDAzNTEyOTU0NzEsejotLjAzMTU1MjE5OTI3NDMwMTUzfSx7eDouNTMwNjUyNDAzODMxNDgxOSx5Oi44MzM3OTkwNjQxNTkzOTMzLHo6LS4wMTgzNTE0MjYzNDgwOTAxNzJ9LHt4Oi41MzcxNzI5MTM1NTEzMzA2LHk6Ljc5MTA4MzA5NzQ1Nzg4NTcsejotLjAzNzI4NjY4MDE5MTc1NTI5NX0se3g6LjU1NDk1MzQ1NTkyNDk4NzgseTouODI3NTI3NTgyNjQ1NDE2Myx6Oi0uMDMwNjY0ODI1ODExOTgyMTU1fSx7eDouNTU5NzQzMjI1NTc0NDkzNCx5Oi42NDE4NTQxNjY5ODQ1NTgxLHo6LS4wMzMxODg0NzM0MzMyNTYxNX0se3g6LjQ5NTg0ODQxNzI4MjEwNDUseTouOTQyOTU2OTI0NDM4NDc2Nix6Oi4wNDgzNDA2NzgyMTUwMjY4NTV9LHt4Oi41MTQwNTA3ODE3MjY4MzcyLHk6Ljk2MzQwMjgwNzcxMjU1NDksejouMDM1ODk4NDczMTEzNzc1MjV9LHt4Oi41NTg3NjkzNDUyODM1MDgzLHk6Ljk5NTEwOTczNjkxOTQwMzEsejouMDA5MDg3Mjg2ODg5NTUzMDd9LHt4Oi40NjQxMTE4OTQzNjkxMjUzNyx5Oi45MDUxODU1MjA2NDg5NTYzLHo6LjEwNjAxOTM1NTM1NjY5MzI3fSx7eDouNTE4MTYwOTM5MjE2NjEzOCx5Oi42NTU0MzE2ODc4MzE4Nzg3LHo6LjAwMjU0NjA3MTMwNzczMzY1NX0se3g6LjU0MzY1OTA5MDk5NTc4ODYseTouNzA4NTg0MTI5ODEwMzMzMyx6Oi0uMDM4NDQ0MzY2MzA2MDY2NTF9LHt4Oi41ODcyMTg3NjE0NDQwOTE4LHk6Ljk5NjAzODI1ODA3NTcxNDEsejouMDA2MzQyMzI3Njg3ODg5MzM3NX0se3g6LjUzNzk2NTM1NzMwMzYxOTQseTouOTk4OTEyNTcyODYwNzE3OCx6Oi4wMzYzNjMyOTk5MzYwNTYxNH0se3g6LjQzNTAzMjY5NTUzMTg0NTEseTouODA4ODU2NTQ2ODc4ODE0Nyx6Oi4wOTE0NzcwNDM5MjY3MTU4NX0se3g6LjU1MjMwODQ5OTgxMzA3OTgseTouODc3MzQyMjgzNzI1NzM4NSx6Oi0uMDA5MDY4NDg3MjEyMDYxODgyfSx7eDouNTUxMDE0OTU5ODEyMTY0Myx5Oi44ODE2OTMxODQzNzU3NjI5LHo6LS4wMTEwNDM4NTMxMjY0NjYyNzR9LHt4Oi41NTAzNzkzOTU0ODQ5MjQzLHk6Ljg4Nzc2Njk1NzI4MzAyLHo6LS4wMTM0ODc5OTQ2NzA4Njc5Mn0se3g6LjU1MDE1NDkyNDM5MjcwMDIseTouODk1NDM3MDYxNzg2NjUxNix6Oi0uMDEyMTQyMTg5Nzc4Mzg3NTQ3fSx7eDouNTQ2MDcyNzgxMDg1OTY4LHk6LjkxOTI1MjQ1NTIzNDUyNzYsejotLjAwMzE1NzU2MzA0MTg5NTYyOH0se3g6LjUzMTQ2NjE4NjA0NjYwMDMseTouODc3MTY2Njg4NDQyMjMwMix6Oi4wMDA1MDc1MTQxMDg5MDM3MDYxfSx7eDouNTI5MzMyNDU4OTcyOTMwOSx5Oi44NzYyNTQ3OTY5ODE4MTE1LHo6LjAwMDM5MTc3NzM3MTk4NzcwMDQ2fSx7eDouNTI3NTY5ODkwMDIyMjc3OCx5Oi44NzUwNjA5NzU1NTE2MDUyLHo6NDc3MzI3NTU3NzQ2MzIwOTZlLTIxfSx7eDouNTEwNDI3MTE3MzQ3NzE3Myx5Oi44NjA3MzMyMTEwNDA0OTY4LHo6LjAwMTI5MzQ2NDMzMDk1NjMzOTh9LHt4Oi40NTkzODcwMDQzNzU0NTc3Nix5Oi44MTM0OTE4MjEyODkwNjI1LHo6LjAyMzU2OTY5MDA2MzU5NTc3Mn0se3g6LjU0MTg5NDczMzkwNTc5MjIseTouNjg2NDEwMDY5NDY1NjM3Mix6Oi0uMDI3MzMzOTA5NjQ1Njc2NjEzfSx7eDouNTMxOTE0MjM0MTYxMzc3LHk6LjY0NTYxMzA3NDMwMjY3MzMsejotLjAwNTQzNDE0MDU2MzAxMTE2OX0se3g6LjUyMzY5NzAxODYyMzM1Mix5Oi42NDc4ODUyNjI5NjYxNTYsejotLjAwMDI0NjY0NjYzOTQyNTMwNzV9LHt4Oi41MzM4MTkxMzkwMDM3NTM3LHk6Ljg3ODM2ODczNTMxMzQxNTUsejouMDAyMjY4NzY4ODQ2OTg4Njc4fSx7eDouNDYyMjY2MDU3NzI5NzIxMDcseTouODYxMDI3Nzc3MTk0OTc2OCx6Oi4wNDcxODk1Mjk5ODUxODk0NH0se3g6LjU0MzQ0NDI3NTg1NjAxODEseTouNjQ1NjE4MTQwNjk3NDc5Mix6Oi0uMDIzMjczNTAxNTQ1MTkwODF9LHt4Oi41Mzk5NzU0NjQzNDQwMjQ3LHk6Ljk0MDIxOTUyMTUyMjUyMix6Oi4wMDUwNzUzNDM4ODQ1Mjc2ODN9LHt4Oi41NjYxNDU3Nzc3MDIzMzE1LHk6LjcxNDU3ODM5MDEyMTQ2LHo6LS4wNjI0MjEwMTYzOTUwOTIwMX0se3g6LjU1MjMxNDg3NzUxMDA3MDgseTouNjk3NDg3MDU2MjU1MzQwNix6Oi0uMDQ4NjMwNzAzMjQwNjMzMDF9LHt4Oi41NjM5OTU5NTczNzQ1NzI4LHk6LjY5MjMzNzgxMDk5MzE5NDYsejotLjA1MTgwNzYxMjE4MDcwOTg0fSx7eDouNTM2NzU5MjU3MzE2NTg5NCx5Oi43NDIzMjE3Mjk2NjAwMzQyLHo6LS4wMzYyMzAyNzcyNzAwNzg2Nn0se3g6LjU4NTM2ODk5MDg5ODEzMjMseTouOTc1MjA2NDk0MzMxMzU5OSx6Oi0uMDAyMzYxOTc0MjEzMjcyMzMzfSx7eDouNTgzNTIzNTExODg2NTk2Nyx5Oi45NDkzNjg1OTYwNzY5NjUzLHo6LS4wMDM5NDE3NDMxNjg5Nzk4ODN9LHt4Oi41NjE1MDE4NjA2MTg1OTEzLHk6Ljk0OTE5NDYxMDExODg2Nix6Oi0uMDAxNTk1Mzk2NTQ4NTA5NTk3OH0se3g6LjUwNjg1NjE0MzQ3NDU3ODkseTouOTA0ODIxOTMyMzE1ODI2NCx6Oi4wMTg2MjY4NDA3ODUxNDU3Nn0se3g6LjUxMzQwNjc1MzU0MDAzOTEseTouNzk3MTgyNTAwMzYyMzk2Mix6Oi0uMDA4NDg1NjYxODE5NTc3MjE3fSx7eDouNTIyMzg5NzA5OTQ5NDkzNCx5Oi45MjU1ODk5MTkwOTAyNzEsejouMDEyNDk2NTcyOTE5MTg5OTN9LHt4Oi40ODUwMDU1NTc1MzcwNzg4Nix5Oi43OTU5NDc4NDk3NTA1MTg4LHo6LS4wMDMyMDY1NzQ1OTA4NzY2OTg1fSx7eDouNTAzNzczNDUwODUxNDQwNCx5Oi44MTg0NTk2MzAwMTI1MTIyLHo6LS4wMDQ5MzIxMDM2Nzg1ODQwOTl9LHt4Oi40NzY2MzYxMTE3MzYyOTc2LHk6LjgyODgwNjQ1OTkwMzcxNyx6Oi4wMTAyNzY4ODk0Mjg0OTYzNn0se3g6LjU1ODk4MjcyOTkxMTgwNDIseTouOTc0NjU2MzQzNDYwMDgzLHo6LjAwMDk2NjY4ODYxODA2MzkyNjd9LHt4Oi41Mjk0NTgyODQzNzgwNTE4LHk6Ljc1NDEyMTY2MTE4NjIxODMsejotLjAyNTYwMzA0NjY0MDc1Mzc0Nn0se3g6LjQ5NzMwMDIwNzYxNDg5ODcseTouOTIwODk5MDkzMTUxMDkyNSx6Oi4wMzE5MzE0NTI0NTMxMzY0NDR9LHt4Oi41MTYzNTUxNTY4OTg0OTg1LHk6Ljk0MzI3OTA4NzU0MzQ4NzUsejouMDI0MzIxMzQwMDI0NDcxMjgzfSx7eDouNDkzOTk2NjIwMTc4MjIyNjYseTouODgxNDg2MjM3MDQ5MTAyOCx6Oi4wMTg2ODczOTkxMDQyMzc1NTZ9LHt4Oi40NDk0ODE2NjYwODgxMDQyNSx5Oi44MzYxMzc1OTI3OTI1MTEsejouMDU3MDIwMzQ3NTY1NDEyNTJ9LHt4Oi40Nzg5ODQ0NDUzMzM0ODA4Myx5Oi44ODM2NjEwOTEzMjc2NjcyLHo6LjAzMTUwNjk1MTg5ODMzNjQxfSx7eDouNDQ1NDQ3OTIxNzUyOTI5Nyx5Oi44NDk5NDM4MTY2NjE4MzQ3LHo6LjA4ODY4NTI1OTIyMjk4NDMxfSx7eDouNDk1NzI5NTk1NDIyNzQ0NzUseTouODQ1MjgyMzc1ODEyNTMwNSx6Oi4wMDM2MTExNjUzMzE2NzY2MDI0fSx7eDouNTM2MjUwMjMzNjUwMjA3NSx5Oi43MjIyNTg1Njc4MTAwNTg2LHo6LS4wMjc5MTIzNTIyMzQxMjUxMzd9LHt4Oi41MzkzNzcwMzM3MTA0Nzk3LHk6Ljc4NTA3MjIwNzQ1MDg2NjcsejotLjA1NDE1Mzk5NzQ1MTA2Njk3fSx7eDouNTMxMzk5NjY3MjYzMDMxLHk6Ljc4OTg0MTgzMDczMDQzODIsejotLjAzODgzMzQ2OTE1MjQ1MDU2fSx7eDouNTQ1MTYyNzM3MzY5NTM3NCx5Oi43NzE3MDM2NjA0ODgxMjg3LHo6LS4wNjQ4MDI1MzQ4NzgyNTM5NH0se3g6LjUyMDYzOTU5ODM2OTU5ODQseTouNjI4Nzc0NTgzMzM5NjkxMix6Oi0uMDEwNTIxMTM4MDg2OTE1MDE2fSx7eDouNDk3NDc4MjQ2Njg4ODQyOCx5Oi42MTkxOTM4NTE5NDc3ODQ0LHo6LS4wMTQwOTgyNDAwNjI1OTQ0MTR9LHt4Oi40Nzc0MTQ1MTg1OTQ3NDE4LHk6LjYxOTMxMzA2MTIzNzMzNTIsejotLjAxMzY0MzMzNzQxMzY2ODYzM30se3g6LjQ2MTYwOTg0MDM5MzA2NjQseTouNjI1OTg5MDE5ODcwNzU4MSx6Oi0uMDA4NDQ4MjAyMTYyOTgxMDMzfSx7eDouNDUxNjQ3ODQ3ODkwODUzOSx5Oi42MzY4NDYxODQ3MzA1Mjk4LHo6OTA1MDMwOTc0NTM2MjAyOGUtMjB9LHt4Oi40NDg1MDk2MDM3Mzg3ODQ4LHk6LjY3MTkxMjA3NDA4OTA1MDMsejouMDIyOTg0NzIwNzY2NTQ0MzQyfSx7eDouNDIxNzc2NTkyNzMxNDc1ODMseTouNzI0MDY2NzM0MzEzOTY0OCx6Oi4wODUxMTY3MzY1OTA4NjIyN30se3g6LjQ2MTYyMTUyMjkwMzQ0MjQseTouNjk4ODIzMTUzOTcyNjI1Nyx6Oi4wMTQyMzg0NzQ4OTA1ODk3MTR9LHt4Oi40NzU1Nzk4ODc2Mjg1NTUzLHk6LjcwMzQ2MDg3MjE3MzMwOTMsejouMDA2MjU1OTA5ODAwNTI5NDh9LHt4Oi40OTI0OTkyMDI0ODk4NTI5LHk6LjcwMDU4ODUyNDM0MTU4MzMsejouMDAwOTM5MTczOTczMTY1NDUyNX0se3g6LjUwODIyNTQ0MDk3OTAwMzkseTouNjkzMzg0MDUxMzIyOTM3LHo6LS4wMDA5NDY0MDM4MzAzMTIxOTI0fSx7eDouNTIwMzExMjk1OTg2MTc1NSx5Oi42ODQ5NzA3OTYxMDgyNDU4LHo6LS4wMDIyMTE0NzY5MDg5OTY3MDEyfSx7eDouNTI4Njc1OTEzODEwNzMseTouNjc3OTA3NTg2MDk3NzE3Myx6Oi0uMDAyOTYyNTM4NTA2ODM1Njk5fSx7eDouNDIxMzk1MzkxMjI1ODE0OCx5Oi43MjE5ODExNjc3OTMyNzM5LHo6LjEzNTA4OTQ1NzAzNTA2NDd9LHt4Oi41MzIwODI5NzQ5MTA3MzYxLHk6Ljc5NDg1ODk5MjA5OTc2Mix6Oi0uMDMxODE1MDMzNDA2MDE5MjF9LHt4Oi41NDUyNzk1MDI4Njg2NTIzLHk6LjcyODY1NzAwNzIxNzQwNzIsejotLjA0NzcxNTM5OTQxNDMwMDkyfSx7eDouNTQ5NjQwNzc0NzI2ODY3Nyx5Oi43ODY2OTMzMzQ1Nzk0Njc4LHo6LS4wNjQ1MjAwMzEyMTM3NjAzOH0se3g6LjU1NzA0MDI3NDE0MzIxOSx5Oi43OTYyMDg0NDEyNTc0NzY4LHo6LS4wNTgzNzM0NDM3ODIzMjk1Nn0se3g6LjU0OTE3NjgxMjE3MTkzNix5Oi43ODk1MjQ3OTM2MjQ4Nzc5LHo6LS4wNTc3NjExNDAxNjc3MTMxNjV9LHt4Oi41MzYyODkwMzYyNzM5NTYzLHk6LjgwMDU4MzY2MDYwMjU2OTYsejotLjAyNjkwMzc3NDU4OTMwMDE1Nn0se3g6LjU2MDIwMDAzNTU3MjA1Mix5Oi43OTgzNzMxMDMxNDE3ODQ3LHo6LS4wNjE3MjU1NTY4NTA0MzMzNX0se3g6LjU2MTY5NDQ0MzIyNTg2MDYseTouODAyMjc1MzU5NjMwNTg0Nyx6Oi0uMDQ1MjAwOTk5ODI2MTkyODU2fSx7eDouNTI3MzMyODQyMzUwMDA2MSx5Oi42NjExMjg0MDE3NTYyODY2LHo6LjAwMjkwMjE1MjAxNjc1ODkxODh9LHt4Oi41MzQ4NTA1Mzc3NzY5NDcseTouNjY2MDAxMjAwNjc1OTY0NCx6Oi0uMDA1MjE1NTEwMjYwMzEzNzQ5fSx7eDouNTM5NDg2MDUwNjA1NzczOSx5Oi42NzAxMzc1MjQ2MDQ3OTc0LHo6LS4wMTQ5MzE5MTcxOTA1NTE3NTh9LHt4Oi40NjM0MzA3MzI0ODg2MzIyLHk6LjY1ODI5MTc1NzEwNjc4MSx6Oi4wMDkyOTU3MTY4ODE3NTIwMTR9LHt4Oi40NTM4MzkzMDIwNjI5ODgzLHk6LjY1MTk5MzIxNTA4NDA3NTksejouMDA5MzAzMzA3MTYwNzM1MTN9LHt4Oi41Nzc2MDMxNjEzMzQ5OTE1LHk6LjcxNTkyOTg2NTgzNzA5NzIsejotLjA1NzM2NTkxMjk0NDA3ODQ0NX0se3g6LjY1MDQ4NTUxNTU5NDQ4MjQseTouNjQ2MTc3OTQ3NTIxMjA5Nyx6Oi4wMTQxODQ4MzQ0MzU1ODIxNjF9LHt4Oi41ODYwMTU0MDMyNzA3MjE0LHk6Ljc5NjIyNjYyMDY3NDEzMzMsejotLjA0NTIyODQzNjU4OTI0MTAzfSx7eDouNjg0MjA0OTM2MDI3NTI2OSx5Oi41NjMxNjM3NTczMjQyMTg4LHo6LjA3MjA3OTY3MzQwOTQ2MTk4fSx7eDouNjE1MjU2MDcxMDkwNjk4Mix5Oi42Njc0OTYyNjM5ODA4NjU1LHo6LjAwMDc1MjkyNTk4OTIxODA1NjJ9LHt4Oi42MjgwOTQ4NTE5NzA2NzI2LHk6LjY2ODQzMjY1Mjk1MDI4NjksejouMDAxNjg5MjU4NjEzNjIzNjc4N30se3g6LjY0MDg2MjUyNDUwOTQyOTkseTouNjY2Mzg5MjI2OTEzNDUyMSx6Oi4wMDUzMzEyMjY2MjQ1NDg0MzV9LHt4Oi42NTU3ODE0NDc4ODc0MjA3LHk6LjY1MzQ2Nzg5MzYwMDQ2MzksejouMDE2NDY0MTM0Njc4MjQ0NTl9LHt4Oi42MDM1NjYzNDg1NTI3MDM5LHk6LjY2Mzk3MDE3MjQwNTI0MjksejouMDAxMzc5OTYzMDEwNTQ5NTQ1M30se3g6LjYzMjkwNTMwNDQzMTkxNTMseTouNjA4MDEwNDcwODY3MTU3LHo6LS4wMDYxOTU4OTkwOTkxMTE1NTd9LHt4Oi42MTY3MjYwNDA4NDAxNDg5LHk6LjYxMTc1MzM0NDUzNTgyNzYsejotLjAwNjMxOTk1MTI2NjA1MDMzOX0se3g6LjY0NzEwMTM0MjY3ODA3MDEseTouNjExMjQ0OTc2NTIwNTM4Myx6Oi0uMDAxNzg0MzU1OTYxNzE3NjY1Mn0se3g6LjY1NjA5MDE5OTk0NzM1NzIseTouNjE4NTc3NjU5MTMwMDk2NCx6Oi4wMDQwNDcyNTczNjAwNzA5NDR9LHt4Oi42NjY2OTQ2NDExMTMyODEyLHk6LjY2NTExNzY4MTAyNjQ1ODcsejouMDIzNjQ3NTc4NDMzMTU2MDEzfSx7eDouNjMxMTM0NTEwMDQwMjgzMix5Oi45NDk1Mzk2MDE4MDI4MjU5LHo6LjAxNDAwNDA3ODY5MzY4NzkxNn0se3g6LjY1NDQ2NTU1NjE0NDcxNDQseTouNjM5NzkwMTc3MzQ1Mjc1OSx6Oi4wMTgwOTYwOTY4MTM2Nzg3NH0se3g6LjY5NjU4MDg4Njg0MDgyMDMseTouNjQ4MjY3NTA3NTUzMTAwNix6Oi4wODMwNDkwNDQwMTMwMjMzOH0se3g6LjY3OTgxNzI1OTMxMTY3Nix5Oi42NTAxODgxNDgwMjE2OTgsejouMDM2MzI2ODg4OTQ4Njc4OTd9LHt4Oi42MzM2NTE2NzM3OTM3OTI3LHk6Ljc1NDE0NTgwMTA2NzM1MjMsejotLjAwNzc0Mjc4MzUyMDM3MDcyMn0se3g6LjU5MjE3MDExOTI4NTU4MzUseTouODU2NzY2ODE5OTUzOTE4NSx6Oi0uMDI5Mzk5MTIzMDQyODIxODg0fSx7eDouNTkxNjYzNjU4NjE4OTI3LHk6Ljg3MDIxNTY1NDM3MzE2OSx6Oi0uMDIxMDM3MjkxNzM1NDEwNjl9LHt4Oi42MDY4MzY3OTU4MDY4ODQ4LHk6Ljg1ODQxOTUzNzU0NDI1MDUsejotLjAyMDY2ODA4NTY2NDUxMDcyN30se3g6LjYxNzY2MTc3NDE1ODQ3NzgseTouODYwOTY1MzcxMTMxODk3LHo6LS4wMDk3OTAwOTU1MDA2NDgwMjJ9LHt4Oi42MDQwNjM0NTEyOTAxMzA2LHk6Ljg2ODY2MTI4NDQ0NjcxNjMsejotLjAxNTI4OTU2NDYxNjk3ODE2OH0se3g6LjYxNDM3MzY4MzkyOTQ0MzQseTouODY3MTE3MDQ3MzA5ODc1NSx6Oi0uMDA1NzEyMjE2NzE5OTg1MDA4fSx7eDouNjM3MzEwNTA0OTEzMzMwMSx5Oi44ODE1NjU2OTAwNDA1ODg0LHo6LjAxMjY3MjU1MDk3NjI3NjM5OH0se3g6LjU4MzI1MDU4MjIxODE3MDIseTouNzg2NjMxMjg2MTQ0MjU2Nix6Oi0uMDcwNTE1MzQ5NTA3MzMxODV9LHt4Oi41ODM2Njc1NzYzMTMwMTg4LHk6Ljc2NTg2OTI1OTgzNDI4OTYsejotLjA3NTY2MTEwNzg5Nzc1ODQ4fSx7eDouNjcwOTUzMTU0NTYzOTAzOCx5Oi42MDQ4OTg5ODkyMDA1OTIsejouMDA1OTUxNTY1NjkwMzM4NjEyfSx7eDouNjAyOTg5MTk2Nzc3MzQzOCx5Oi43MDU2NTIxMTc3MjkxODcsejotLjAxMzM4ODI3NjEwMDE1ODY5MX0se3g6LjYxMzE2MjIxOTUyNDM4MzUseTouNzcyODM5NjA1ODA4MjU4MSx6Oi0uMDM2MjQ4NDc5MDM4NDc2OTQ0fSx7eDouNjEyMzE2MzEwNDA1NzMxMix5Oi43NjEyMDIwMzczMzQ0NDIxLHo6LS4wMzI2NDcyMTg1NTUyMTIwMn0se3g6LjY2OTYxODc4NTM4MTMxNzEseTouNzQ0NzA2OTI4NzMwMDExLHo6LjAwOTY3MzcwMjUzMDU2Mjg3OH0se3g6LjU4MDMxMDIyNTQ4Njc1NTQseTouNzM4NTk2ODU2NTk0MDg1Nyx6Oi0uMDY4OTE1MjMzMDE2MDE0MX0se3g6LjY0MDQzNDkyMDc4NzgxMTMseTouNTg3Nzk5OTY2MzM1Mjk2Nix6Oi0uMDE5Mjk3NTY5OTkwMTU4MDh9LHt4Oi42NTg4NDY3OTU1NTg5Mjk0LHk6LjU5Mjk0NTQ1NjUwNDgyMTgsejotLjAwODQ4NzI1NzE3NTE0NzUzM30se3g6LjY3MjAzMzc4Njc3MzY4MTYseTouNTMwNjMxNDIyOTk2NTIxLHo6LjA0MzQzNzQyMTMyMTg2ODg5Nn0se3g6LjU4NDMwNTQ2NTIyMTQwNSx5Oi42MDk5MDA1MzQxNTI5ODQ2LHo6LS4wMzAzMDEzNjc4NjQwMTI3MTh9LHt4Oi42MDM0MjgzNjM4MDAwNDg4LHk6LjYyMTc0NTI4ODM3MjAzOTgsejotLjAwMTk3MDE4MzgwMjc2ODU4OH0se3g6LjY0NjA5Mjc3MjQ4MzgyNTcseTouODYwODY2MzA4MjEyMjgwMyx6Oi4wMTU1NDE2MjUyMDkxNTI2OTl9LHt4Oi42OTU3ODE1Mjg5NDk3Mzc1LHk6LjgzMjYxMDMwOTEyMzk5MjksejouMTMwMTUyMzQ0NzAzNjc0MzJ9LHt4Oi42MDQzMzYyNjE3NDkyNjc2LHk6Ljc4NjE2ODI3NzI2MzY0MTQsejotLjAzMDQ3NjkwMTY4MDIzMTA5NH0se3g6LjU5NDI5MzQ3NTE1MTA2Mix5Oi43OTQyMTAzMTQ3NTA2NzE0LHo6LS4wMzIyMTg4MjEzNDY3NTk3OTZ9LHt4Oi42MzI0MDU3NTc5MDQwNTI3LHk6Ljg2NjUxMzk2NzUxNDAzODEsejouMDE0MjU1ODA2ODAzNzAzMzA4fSx7eDouNjI5NjE0NzcwNDEyNDQ1MSx5Oi44NjY3NzMzNjY5MjgxMDA2LHo6LjAxMDM4ODI4NTg1Mjk2ODY5M30se3g6LjY2MzY0NDU1MjIzMDgzNSx5Oi41Nzk4NjQyNjM1MzQ1NDU5LHo6LS4wMDIyMzAxMDcwODU3NzkzMDkzfSx7eDouNjE0MDYzMDg0MTI1NTE4OCx5Oi43ODA5Mjg4NTAxNzM5NTAyLHo6LS4wMjgzNTY3OTA1NDI2MDI1NH0se3g6LjYxNTkwODE0NTkwNDU0MSx5Oi41OTIxNjk4MjEyNjIzNTk2LHo6LS4wMjY4MDQ4NjA2ODEyOTUzOTV9LHt4Oi42MTcxODExMjIzMDMwMDkseTouNTc0ODY2MTc1NjUxNTUwMyx6Oi0uMDMwNjA2MDU1NjMyMjMzNjJ9LHt4Oi42MjIyMjA3NTQ2MjM0MTMxLHk6LjQ5MTM3NjcyNzgxOTQ0Mjc1LHo6LS4wMTExNTE2NzMyNzIyNTIwODN9LHt4Oi42NjY5MzU3NDE5MDEzOTc3LHk6LjU1NDE2MDcxNDE0OTQ3NTEsejouMDE3NDY2MTcwNzEzMzA1NDczfSx7eDouNjE4Mjk4MTcyOTUwNzQ0Nix5Oi41MzIwNDI1NjI5NjE1Nzg0LHo6LS4wMjE3OTM1OTA4NTg1Nzg2ODJ9LHt4Oi42NzYwNTU0MzEzNjU5NjY4LHk6LjU5NTA1MjE4MjY3NDQwOCx6Oi4wMTcxMTU3MDA5ODk5NjE2MjR9LHt4Oi42ODAxNDYzOTYxNjAxMjU3LHk6LjU4MDA3MjA0NTMyNjIzMjksejouMDQzMTI3MTYwNTE5MzYxNDk2fSx7eDouNTkyMjIxMDgxMjU2ODY2NSx5Oi44NjQ0MDE3NTc3MTcxMzI2LHo6LS4wMjY2Mjg5MzU3MDk1OTU2OH0se3g6LjYwNTQ1NTUxNzc2ODg1OTkseTouODYzNzg3NDcyMjQ4MDc3NCx6Oi0uMDE4MzYzNzUzMzMzNjg3NzgyfSx7eDouNjE2MTg4OTQzMzg2MDc3OSx5Oi44NjQxMTY0ODk4ODcyMzc1LHo6LS4wMDg4MDg5NDkwMzA5MzU3NjR9LHt4Oi42MDE3MjQ5ODIyNjE2NTc3LHk6Ljc5MDE0MDMzMDc5MTQ3MzQsejotLjAyODEyNjYzMDkzMjA5MjY2N30se3g6LjYzMTQ0NjEyMzEyMzE2OSx5Oi44NjY0ODE3ODEwMDU4NTk0LHo6LjAxMjExMjg2NTIyNDQ4MDYyOX0se3g6LjYyNDkxOTg5MTM1NzQyMTkseTouODcxNjUxMTEzMDMzMjk0Nyx6Oi4wMDM4ODI4MjU4NDAyNjQ1NTl9LHt4Oi42MjgxOTE1OTAzMDkxNDMxLHk6Ljg2NzMwMTg4MTMxMzMyNCx6Oi4wMDk4OTE0NDEwOTE4OTUxMDN9LHt4Oi41OTg2ODQzMTA5MTMwODU5LHk6Ljc4MTM5MzE3MDM1Njc1MDUsejotLjA1MDIyNzYxMjI1NzAwMzc4NH0se3g6LjYxMjY0MDczODQ4NzI0MzcseTouODY5Mjc1Njg5MTI1MDYxLHo6LS4wMDMxMjU1NzE0MTI5NjU2NTUzfSx7eDouNjAyNzI3MTE1MTU0MjY2NCx5Oi44NzExODQyODk0NTU0MTM4LHo6LS4wMDkzMjQxNjIyNjcxNDg0OTV9LHt4Oi41OTA4ODEzNDc2NTYyNSx5Oi44NzQyMDQ0NTY4MDYxODI5LHo6LS4wMTQ2MDg2NjA3MTI4MzgxNzN9LHt4Oi41OTg0NjA0MzU4NjczMDk2LHk6LjkyMTYxODUyMTIxMzUzMTUsejotLjAwNTk4MTk4OTY3MDU0NDg2M30se3g6LjU5NTAzOTg0NDUxMjkzOTUseTouODk2NDcwNzI1NTM2MzQ2NCx6Oi0uMDE3MDM0NzM5MjU1OTA1MTV9LHt4Oi41OTQxNTY4NjEzMDUyMzY4LHk6Ljg4ODI0MTA1MjYyNzU2MzUsejotLjAxNzc4NDc4NTQ3OTMwNzE3NX0se3g6LjU5Mjg4MDY2NjI1NTk1MDkseTouODgwMzg4MzE5NDkyMzQwMSx6Oi0uMDE0MTUzMTI4NDg5ODUxOTUyfSx7eDouNTkwOTY2MTA1NDYxMTIwNix5Oi44NzQ4MTAzOTc2MjQ5Njk1LHo6LS4wMTI2MDk5NzkxMzc3NzgyODJ9LHt4Oi42MTI4MDE2NzEwMjgxMzcyLHk6Ljg3MDI1NDU3NjIwNjIwNzMsejotLjAwMjI1NTA1NDY1NjQxNjE3Nzd9LHt4Oi42MTUwODQ2NDgxMzIzMjQyLHk6Ljg3MjY4MDQyNTY0MzkyMDksejotLjAwNDE0MDE5OTYyNzcyNzI3fSx7eDouNjE3MzA5MzkxNDk4NTY1Nyx5Oi44NzcwMTkwNDc3MzcxMjE2LHo6LS4wMDU5NzA5OTQwMTA1Njc2NjV9LHt4Oi42MTkzMzU0MTI5NzkxMjYseTouODgxNDgwMDk3NzcwNjkwOSx6Oi0uMDAzNjg2NDAyNDU4Njk3NTU3NH0se3g6LjYyOTI2Mzc1ODY1OTM2MjgseTouODMxNDU1ODI2NzU5MzM4NCx6Oi0uMDA3NzE0ODc1OTczNzYxMDgyfSx7eDouNzAyMjc1Mjc2MTg0MDgyLHk6LjczMjA2Njc1MDUyNjQyODIsejouMTQzMzYyMTM0Njk1MDUzMX0se3g6LjYyMDQ4MzUxNzY0Njc4OTYseTouODY4OTE3NzYzMjMzMTg0OCx6Oi4wMDQ0ODY5MTcwNTI0MTc5OTM1fSx7eDouNjIyMzUwODcxNTYyOTU3OCx5Oi44NzA0ODUxMjY5NzIxOTg1LHo6LjAwMzUyMDgyODkwNDU4NDA1fSx7eDouNTkwNDQ4MjYwMzA3MzEyLHk6LjgwMjk3Mjc5MzU3OTEwMTYsejotLjAzMjAwODI4NjU2NTU0MjIyfSx7eDouNjA5NzQyMzQzNDI1NzUwNyx5Oi43OTMzNzQxMjExODkxMTc0LHo6LS4wMTgwNDI1NTUwNzg4NjQwOTh9LHt4Oi41OTIyOTU3NjU4NzY3Nyx5Oi43OTkzNzY3MjYxNTA1MTI3LHo6LS4wMzI1NjQ1NjkyNjQ2NTAzNDV9LHt4Oi42MTcxMzY0MTg4MTk0Mjc1LHk6LjcxNTM3MjAyNTk2NjY0NDMsejotLjAwNzY3MjQzNzQ2NjY4MTAwNH0se3g6LjYzODk3NDc4NTgwNDc0ODUseTouNzI2MzkwNTQwNTk5ODIzLHo6LS4wMDI5OTkwNjc3NzIxNzk4NDJ9LHt4Oi42MTUxOTQwMjI2NTU0ODcxLHk6Ljc2OTQxMjEwMDMxNTA5NCx6Oi0uMDI0NDI3NTIxOTczODQ4MzQzfSx7eDouNjUyNjc3NjU1MjIwMDMxNyx5Oi41MDU4NjgxMzY4ODI3ODIsejouMDE0MTI2Mzc5OTc0MTg2NDJ9LHt4Oi42NDc1ODIyMzI5NTIxMTc5LHk6LjUzNzU0NTQ0MjU4MTE3NjgsejotLjAwMzM4OTkxMjg5MDI3MDM1MjR9LHt4Oi42NDMzMzU2NDA0MzA0NTA0LHk6LjU3MTQ1MjAyMTU5ODgxNTksejotLjAxNzQyODc5NjczODM4NjE1NH0se3g6LjYyNjk0OTY2NzkzMDYwMyx5Oi44OTYyMTE2ODM3NTAxNTI2LHo6LjAwNTYwMjczNjk1NzM3MTIzNX0se3g6LjU4Njg0MTY0Mjg1NjU5NzkseTouNTgyOTAwMjI2MTE2MTgwNCx6Oi0uMDM3Mjc3Mjk2MTg1NDkzNDd9LHt4Oi41ODc3MjI5NTcxMzQyNDY4LHk6LjUzNDUwMzU3OTEzOTcwOTUsejotLjAzMjM5Njk2NDcyODgzMjI0NX0se3g6LjU4ODcwNjYxMjU4Njk3NTEseTouNDg2NTUwODM3NzU1MjAzMjUsejotLjAyNTg1NjUzNTg4MTc1NzczNn0se3g6LjY1MDcxOTc2MTg0ODQ0OTcseTouNjYxMjI4Mjk5MTQwOTMwMix6Oi4wMTExMTQ2MTMxNTMwNDA0MDl9LHt4Oi42ODAzMDY2NzMwNDk5MjY4LHk6LjY3Nzk5MjA0NTg3OTM2NCx6Oi4wMzIxMjUzNjEyNjM3NTE5ODR9LHt4Oi41OTYzMTk0MzcwMjY5Nzc1LHk6LjY1OTg2MzIzMzU2NjI4NDIsejouMDAyOTc2OTI4MzcxOTM2MDgzfSx7eDouNjY3NTM2MTk5MDkyODY1LHk6LjYyNzQyNTU1MTQxNDQ4OTcsejouMDE1NjE4MjYxODgxMTcyNjU3fSx7eDouNTkzMDc0MDgzMzI4MjQ3MSx5Oi42OTQwMDQxNzgwNDcxODAyLHo6LS4wMTkyMTc3OTg0ODYzNTE5Njd9LHt4Oi42MDUzMzQ2Mzk1NDkyNTU0LHk6Ljc2NzY1MTc5NjM0MDk0MjQsejotLjA1MDMwODMwOTQ5NTQ0OTA2Nn0se3g6LjY5MzQ0NzM1MTQ1NTY4ODUseTouNjg4NDI5ODkyMDYzMTQwOSx6Oi4wNDc5NDQ2MjM5NzY5NDU4OH0se3g6LjY3MzgwMDc2NjQ2ODA0ODEseTouNjkzNDAxMTU3ODU1OTg3NSx6Oi4wMjA2OTcxNjE1NTUyOTAyMjJ9LHt4Oi42NTg4MDg0Njk3NzIzMzg5LHk6LjcwMzMxNDE4NTE0MjUxNzEsejouMDA4NDYyMzM0MDUxNzI4MjQ5fSx7eDouNjM0NjA3MjU1NDU4ODMxOCx5Oi43MDI5NTAyMzkxODE1MTg2LHo6LjAwMTU0MjE2NzYyMTY2NDcwM30se3g6LjYxNTc4MTY2NDg0ODMyNzYseTouNjk2NjUyNTkxMjI4NDg1MSx6Oi0uMDAyMDA5MjE4MDkzMDA3ODAzfSx7eDouNjAxNTU3NDMzNjA1MTk0MSx5Oi42ODg5Mjg0ODQ5MTY2ODcsejotLjAwNjU4ODIyNTcxODU4NzYzN30se3g6LjU3NDY4MzYwNjYyNDYwMzMseTouNjcxMTA2OTM0NTQ3NDI0Myx6Oi0uMDM1OTc1ODkyMDk2NzU3ODl9LHt4Oi42OTQ3NTIxNTY3MzQ0NjY2LHk6LjczMDk0NzkxMTczOTM0OTQsejouMDQ2NzA3OTM5MzU2NTY1NDc1fSx7eDouNjc1OTEwMTE1MjQyMDA0NCx5Oi42MjQ5MTIwODMxNDg5NTYzLHo6LjAyMTY1NDM0MTM2OTg2NzMyNX0se3g6LjU3OTQ3NzMxMDE4MDY2NDEseTouNzk3MTYxNTE5NTI3NDM1Myx6Oi0uMDYzMzkzMjY1MDA4OTI2Mzl9LHt4Oi42MDQxODQ5ODUxNjA4Mjc2LHk6LjcyNzUxNDkyMjYxODg2Nix6Oi0uMDE3NTEyNTQxMjY0Mjk1NTc4fSx7eDouNjk2ODg0NDUzMjk2NjYxNCx5Oi42NDQwOTUwMDM2MDQ4ODg5LHo6LjEyNzI3OTk2NzA2OTYyNTg1fSx7eDouNTkxMDg1MzE0NzUwNjcxNCx5Oi42NzkzMjU1MjA5OTIyNzksejotLjAwOTQ5NzcxNTE2MDI1MDY2NH0se3g6LjYxNTczNzU1NzQxMTE5MzgseTouNzY5NTY3NzI4MDQyNjAyNSx6Oi0uMDEwNjI0MjkwNDQzOTU2ODUyfSx7eDouNjYwNjQ5NDc4NDM1NTE2NCx5Oi42NDEwNDg5Njc4MzgyODc0LHo6LjAyMDgxNTg5NzczMjk3MzF9LHt4Oi42MDQwNjg3NTYxMDM1MTU2LHk6Ljc1MzE0NzA2NTYzOTQ5NTgsejotLjA0NTg4NzAxOTQ4NTIzNTIxNH0se3g6LjcwMTIxNTYyNDgwOTI2NTEseTouNzgwMjQ3MTUxODUxNjU0LHo6LjE0MDI4NzMwOTg4NTAyNTAyfSx7eDouNTk1MTQ5NTc2NjYzOTcxLHk6LjY1Mjc3ODI2Nzg2MDQxMjYsejouMDA2MzA4NzU3NzAwMDI2MDM1fSx7eDouNTkyNTUwMDM5MjkxMzgxOCx5Oi43NDM2NjY1ODkyNjAxMDEzLHo6LS4wNjAxNTE3NTU4MDk3ODM5MzZ9LHt4Oi42NzgwMTk4ODEyNDg0NzQxLHk6Ljg5MDU2OTM4ODg2NjQyNDYsejouMDYyNjA2MDczOTE1OTU4NH0se3g6LjY3Njc0NjY2NjQzMTQyNyx5Oi45MTEzODgwMzk1ODg5MjgyLHo6LjA4NzI2MDAzNzY2MDU5ODc1fSx7eDouNzAzMDY4NjE0MDA2MDQyNSx5Oi43MzEyNjg3NjM1NDIxNzUzLHo6LjA5NTI5Nzc0NjM2MDMwMTk3fSx7eDouNjg4OTg3MTM1ODg3MTQ2LHk6Ljg1ODg0MTcxNzI0MzE5NDYsejouMDc3NTI4NjQ4MDc4NDQxNjJ9LHt4Oi42ODgzNjkxNTQ5MzAxMTQ3LHk6LjYxMDk5NjA2NzUyMzk1NjMsejouMDY2Njk2MTI5NzM5Mjg0NTJ9LHt4Oi42MzU4OTA2MDMwNjU0OTA3LHk6Ljk3MDIwNjU1ODcwNDM3NjIsejouMDIzMTIwOTAwNjE2MDQ5NzY3fSx7eDouNTc4MTUzOTY3ODU3MzYwOCx5Oi44MDIzNjM0NTUyOTU1NjI3LHo6LS4wNDQ3NjM5MTg5NjYwNTQ5MTZ9LHt4Oi42MTcwMzE2OTM0NTg1NTcxLHk6Ljc0MDgzNTA3MDYxMDA0NjQsejotLjAxMTM3NTQ2MDc3MzcwNjQzNn0se3g6LjY4ODU0MjM2NjAyNzgzMix5Oi42NTE2Mjg0MzQ2NTgwNTA1LHo6LjA1MDIwNjAyNzkyNTAxNDQ5Nn0se3g6LjYzODUxNDkzNTk3MDMwNjQseTouNjU0MDcxNDUwMjMzNDU5NSx6Oi4wMDY0NjI5NDE0MTE4ODI2Mzl9LHt4Oi42Mjc5MzgyMTA5NjQyMDI5LHk6LjY1NjM2MTU3OTg5NTAxOTUsejouMDAzMDYyODQ2MTM5MDczMzcyfSx7eDouNjI2ODg5NTI2ODQ0MDI0Nyx5Oi44NzM2NzMyMDA2MDcyOTk4LHo6LjAwNjI3OTM2NzAyMjIxNjMyfSx7eDouNjk0NDk0NjA1MDY0MzkyMSx5Oi43NzA5MTgxMzA4NzQ2MzM4LHo6LjA1MzgyNDEzNDE3MTAwOTA2NH0se3g6LjYxNDYxNzEwOTI5ODcwNix5OjEuMDAyMjExMjEzMTExODc3NCx6Oi4wMjcxOTg5NDA1MTU1MTgxOX0se3g6LjY0OTM3MTkyMjAxNjE0MzgseTouOTY2NTE2NzkyNzc0MjAwNCx6Oi4wNTM1NjM3ODQ4MDc5MjA0NTZ9LHt4Oi42NjI0NTg3MTc4MjMwMjg2LHk6Ljk0MzUzMDc5Nzk1ODM3NCx6Oi4wNjg2MDU0Mzc4NzQ3OTR9LHt4Oi42MTYyNTI4OTkxNjk5MjE5LHk6LjY1NTg2OTMwNTEzMzgxOTYsejouMDAyMTg3ODU1MDc2MDQ0Nzk4fSx7eDouNjA1ODE2ODQxMTI1NDg4Myx5Oi42NTQzMjg0NjU0NjE3MzEsejouMDAzNjE5MzU4NDA5MTk2MTM4NH0se3g6LjU5ODc5MTg5NzI5NjkwNTUseTouNjUzNjkzNDk3MTgwOTM4Nyx6Oi4wMDYxMzQ1MzAwNjM3MTg1NTd9LHt4Oi42ODMxMDM3NDAyMTUzMDE1LHk6LjYxOTU2NDI5NDgxNTA2MzUsejouMDM1MTE3OTAxODYxNjY3NjN9LHt4Oi42MDYyNTgyNzMxMjQ2OTQ4LHk6LjYzNTYzOTg0NjMyNDkyMDcsejouMDAxMjgwMzEyODkyMDQ5NTUxfSx7eDouNjE3NDk0ODgxMTUzMTA2Nyx5Oi42Mjc3NjExODUxNjkyMix6Oi0uMDAxMzY0MjQ2ODI1Njg3NTg3M30se3g6LjYyOTcyNDYyMTc3Mjc2NjEseTouNjI1Mzc5MjY0MzU0NzA1OCx6Oi0uMDAwNzAzNDE1NjAwNTgyOTU3M30se3g6LjY0MDcwOTE2MTc1ODQyMjkseTouNjI3NTc4NjE2MTQyMjczLHo6LjAwMjgxNDQ3MDU1NzQ5NTk1MTd9LHt4Oi42NDc5NjIyNzIxNjcyMDU4LHk6LjYzMjI2NTA5MDk0MjM4MjgsejouMDA3NTAyNzMzNzI5Nzc5NzJ9LHt4Oi42OTE1MDkxMjc2MTY4ODIzLHk6LjU5OTA3MDQyOTgwMTk0MDksejouMTAyNzA5NDU3Mjc4MjUxNjV9LHt4Oi42NDU3MTYzMDk1NDc0MjQzLHk6LjY1MDQ0NTM0MjA2MzkwMzgsejouMDEwNjk2MDc3NzE5MzMwNzg4fSx7eDouNjE2NDIyMjk1NTcwMzczNSx5Oi44MjMxOTM2MDk3MTQ1MDgxLHo6LS4wMTY3NzIwNTk3MjM3MzQ4NTZ9LHt4Oi42MDQyNDAxMTk0NTcyNDQ5LHk6Ljc4MzA5NzY4NDM4MzM5MjMsejotLjAzNjMwOTEwNDQxMjc5NDExfSx7eDouNTkyMjIxNjc3MzAzMzE0Mix5Oi44MjI4Mzg3MjM2NTk1MTU0LHo6LS4wMjk5OTIzNzU1MjI4NTE5NDR9LHt4Oi42NjQ2MTExMDExNTA1MTI3LHk6LjkyMDk3MDA4MjI4MzAyLHo6LjA1MDk2NzI5NDcyMjc5NTQ4Nn0se3g6LjY1MTIzMjg5ODIzNTMyMSx5Oi45NDYwMTA3MDg4MDg4OTg5LHo6LjAzODAwMDE1ODk2NTU4NzYxNn0se3g6LjYxNDA5NzcxNDQyNDEzMzMseTouOTg4MjQ3MjE1NzQ3ODMzMyx6Oi4wMDk4ODIwOTE1NDQ1Njg1Mzl9LHt4Oi42ODcwNzgxMTgzMjQyNzk4LHk6Ljg3Njg2NzUzMjczMDEwMjUsejouMTA5ODA5MzI0MTQ1MzE3MDh9LHt4Oi41OTg2ODU2ODE4MTk5MTU4LHk6LjY0NTY0Mzg4OTkwNDAyMjIsejouMDAzOTk5MDEwNjU5NzU0Mjc2fSx7eDouNTg1OTgxNTQ3ODMyNDg5LHk6LjcwMzQ0ODE3NjM4Mzk3MjIsejotLjAzNzc3MjI4Mjk1ODAzMDd9LHt4Oi42MzQyMDMxMzU5NjcyNTQ2LHk6Ljk4Njc0NDg4MDY3NjI2OTUsejouMDM3ODY1MjE0MDQ5ODE2MTN9LHt4Oi43MDEzOTUwOTQzOTQ2ODM4LHk6Ljc3NjA0OTAxNzkwNjE4OSx6Oi4wOTU5ODIwNTk4MzYzODc2M30se3g6LjYwMzAyMDY2ODAyOTc4NTIseTouODcxOTEzMzEzODY1NjYxNix6Oi0uMDA3OTMxMTQ4NjMzMzYwODYzfSx7eDouNjA1MDU5MjA2NDg1NzQ4Myx5Oi44NzY3MTU2MDA0OTA1NzAxLHo6LS4wMDk3OTE5MjU1NDk1MDcxNDF9LHt4Oi42MDczNDY4OTIzNTY4NzI2LHk6Ljg4MzEzODIzOTM4MzY5NzUsejotLjAxMjM2MTAwODY3MzkwNjMyNn0se3g6LjYwODc5NzcyOTAxNTM1MDMseTouODkwMTQzNjMyODg4Nzk0LHo6LS4wMTA5ODE0ODMzODQ5NjY4NX0se3g6LjYxNDc3MDUzMTY1NDM1NzkseTouOTExMDA4NDc3MjEwOTk4NSx6Oi0uMDAxODgyMzU3NTIyODQ1MjY4Mn0se3g6LjYyMjU3Nzk2NTI1OTU1Mix5Oi44NjcwNjA0ODI1MDE5ODM2LHo6LjAwMjYwOTE5MDI5ODI0NDM1N30se3g6LjYyNDEyMzYzMjkwNzg2NzQseTouODY1MTM0NDE4MDEwNzExNyx6Oi4wMDI1NTM0MzgwNjkyOTg4NjM0fSx7eDouNjI1NzA4NDYwODA3ODAwMyx5Oi44NjM4NDA4MTg0MDUxNTE0LHo6LjAwMjMzMDAwNzQ5NzIyMTIzMTV9LHt4Oi42Mzk5MzEzMjExNDQxMDQseTouODQ0OTY3MTI2ODQ2MzEzNSx6Oi4wMDM4MTIzMTE2ODI4NTAxMjI1fSx7eDouNjgxMDkwNjUyOTQyNjU3NSx5Oi43ODU2NjI1MzE4NTI3MjIyLHo6LjAyNzE3NzY0Njc1NjE3MjE4fSx7eDouNTgzNTMyNDUyNTgzMzEzLHk6LjY4MTE5OTQ5MTAyNDAxNzMsejotLjAyNjU4ODg1NzE3MzkxOTY3OH0se3g6LjU4NTU2NjA0Mzg1Mzc1OTgseTouNjM5MzgxOTQ1MTMzMjA5Mix6Oi0uMDA0NTEyODQ0NjA3MjM0MDAxfSx7eDouNTkzMjIwMTc0MzEyNTkxNix5Oi42Mzk4MDI5MzI3MzkyNTc4LHo6LjAwMDgwMjA0NjYxOTM1NTY3ODZ9LHt4Oi42MjAwODc5ODEyMjQwNjAxLHk6Ljg2ODMzNTE4NzQzNTE1MDEsejouMDA0MTcwMTY3MjU5ODcxOTZ9LHt4Oi42ODQyNTU5NTc2MDM0NTQ2LHk6LjgzMzA1MzQxMDA1MzI1MzIsejouMDUwODM2MzE3MjQxMTkxODY0fSx7eDouNTc1NDQxMjQxMjY0MzQzMyx5Oi42NDE4MjIxNTkyOTAzMTM3LHo6LS4wMjI4MzgwNTk4MTI3ODQxOTV9LHt4Oi42MjMyNzkwMzUwOTE0MDAxLHk6LjkyOTUyOTcyNjUwNTI3OTUsejouMDA2MzM5NTIwMjE1OTg4MTU5fSx7eDouNTc2NDA2Nzc2OTA1MDU5OCx5Oi42OTQ1NDY2Mzk5MTkyODEsejotLjA0ODI1ODAzMjY0OTc1NTQ4fSx7eDouNTk3Nzg4OTI5OTM5MjcseTouNzM0MzkyNzYyMTg0MTQzMSx6Oi0uMDM1MDA0Mzc3MzY1MTEyMzA1fSx7eDouNjA0MjgxMDY3ODQ4MjA1Nix5Oi45NDQxNDQwMTA1NDM4MjMyLHo6LS4wMDEwOTcwNTcwMTQ3MDM3NTA2fSx7eDouNjQ5NjM3MjIyMjkwMDM5MSx5Oi44ODY5MDc4MTU5MzMyMjc1LHo6LjAyMTAzNjIzNTYxNTYxMTA3Nn0se3g6LjYyNzQwMTIzMjcxOTQyMTQseTouNzgzMDMxMDQ2MzkwNTMzNCx6Oi0uMDA2NjU4NDQwOTIxNDU1NjIyfSx7eDouNjM3NzkyNzA2NDg5NTYzLHk6LjkxMDQ5OTk4OTk4NjQxOTcsejouMDE0MjkwMjUwODM3ODAyODg3fSx7eDouNjU0OTkzNDE0ODc4ODQ1Mix5Oi43NzQ4NjA5MTg1MjE4ODExLHo6LS4wMDA2NjcyOTczMzk1MzI1MjQzfSx7eDouNjQwNDAwNTI4OTA3Nzc1OSx5Oi44MDEyMjA3MTUwNDU5MjksejotLjAwMjY2NDI1NTQ0Mzk2MDQyODJ9LHt4Oi42NjcxNDU2Njk0NjAyOTY2LHk6LjgwNDU1NDY0MTI0Njc5NTcsejouMDEzMTgwODExODg5NDY5NjI0fSx7eDouNjEwNzQ4MzUwNjIwMjY5OCx5Oi45NjgwNjU4NTc4ODcyNjgxLHo6LjAwMTc3ODk5MjI0MjE3OTgxMX0se3g6LjYwNjAzNDM5ODA3ODkxODUseTouNzQ0NTg3MjQyNjAzMzAyLHo6LS4wMjQzODIzMzQyMDI1Mjh9LHt4Oi42NjAyNzUxNjEyNjYzMjY5LHk6Ljg5OTg5NDUzNTU0MTUzNDQsejouMDM0NDk0MDcyMTk4ODY3OH0se3g6LjY0NjM3NzUwMzg3MTkxNzcseTouOTI2MjU2MjM5NDE0MjE1MSx6Oi4wMjYxNzYyMzI4NDQ1OTExNH0se3g6LjY1Nzk4NTIxMDQxODcwMTIseTouODYwMjMwNDQ1ODYxODE2NCx6Oi4wMjE1ODY3MTYxNzUwNzkzNDZ9LHt4Oi42OTI2MTY1MjIzMTIxNjQzLHk6LjgwNTMzNDAzMTU4MTg3ODcsejouMDYxMDc1MDgwMTg2MTI4NjE2fSx7eDouNjcyNDczMTkyMjE0OTY1OCx5Oi44NTk0Mzk5NjkwNjI4MDUyLHo6LjAzNDU3OTM0NzgxOTA4OTg5fSx7eDouNjk3NTcyMTcxNjg4MDc5OCx5Oi44MTgzMjQ1MDYyODI4MDY0LHo6LjA5MzAwNzc0MzM1ODYxMjA2fSx7eDouNjUxMjg3Nzk0MTEzMTU5Mix5Oi44MjU4MjIxNzQ1NDkxMDI4LHo6LjAwNjMyNDA1OTMyOTkyNjk2OH0se3g6LjU5NDg4NzM3NTgzMTYwNCx5Oi43MTQ4MzcyNTMwOTM3MTk1LHo6LS4wMjY4OTg0NzkwODkxNDA4OTJ9LHt4Oi42MDE3NDQwNTU3NDc5ODU4LHk6Ljc3NzM1MDc4MzM0ODA4MzUsejotLjA1MzEyNDIwODAwMzI4MjU1fSx7eDouNjA5NjU3MTY4Mzg4MzY2Nyx5Oi43ODA2OTk4NDkxMjg3MjMxLHo6LS4wMzc2NDYyNTYzODcyMzM3MzR9LHt4Oi41OTUyOTkzMDM1MzE2NDY3LHk6Ljc2NTQzNjc2ODUzMTc5OTMsejotLjA2Mzk4NDA1MTM0Njc3ODg3fSx7eDouNTk1MDAyMTE0NzcyNzk2Nix5Oi42MjAxMzA0NzkzMzU3ODQ5LHo6LS4wMDkyOTc1NDc4NjE5MzM3MDh9LHt4Oi42MTY1NDM4ODkwNDU3MTUzLHk6LjYwNTI5MDA1NTI3NDk2MzQsejotLjAxMjQ1NTU3MzMwNTQ4NzYzM30se3g6LjYzNjI2NjE3MTkzMjIyMDUseTouNjAxNTk2ODkxODgwMDM1NCx6Oi0uMDExNjQ5MjIwMjUwNTQ2OTMyfSx7eDouNjUyMjcyNzYwODY4MDcyNSx5Oi42MDQ2NDAwNjY2MjM2ODc3LHo6LS4wMDU5MDMzMzI0OTQxOTkyNzZ9LHt4Oi42NjI1NDA5NzIyMzI4MTg2LHk6LjYxMjgxNDEyODM5ODg5NTMsejouMDAzMDA0MjQ5NjUwOTg1MDAyNX0se3g6LjY2ODgwOTk1MDM1MTcxNTEseTouNjQ1NzcxMjA1NDI1MjYyNSx6Oi4wMjYzMjI3MDM4MDg1NDYwNjZ9LHt4Oi43MDEzNDQwNzI4MTg3NTYxLHk6LjY4OTM2NjYzODY2MDQzMDksejouMDg5ODQzMzE3ODY2MzI1Mzh9LHt4Oi42NjA4NjIzMjY2MjIwMDkzLHk6LjY3NDk0MDY0NTY5NDczMjcsejouMDE3MjExNjY4MTkzMzQwM30se3g6LjY0ODIzMjUxOTYyNjYxNzQseTouNjgyMzcyNjI5NjQyNDg2Nix6Oi4wMDg4ODEzOTg0NzY2NjAyNTJ9LHt4Oi42MzEzMjY1NTYyMDU3NDk1LHk6LjY4NDIwMjU1MTg0MTczNTgsejouMDAzMTMwODYxNzkwODUwNzU4Nn0se3g6LjYxNDcwMTYyODY4NDk5NzYseTouNjgwOTczMTcyMTg3ODA1Mix6Oi4wMDA3NjMwNzcxNzI0NTA3MjEzfSx7eDouNjAxODgzNDExNDA3NDcwNyx5Oi42NzU1MzcyMjg1ODQyODk2LHo6LS4wMDA4ODM0MzIxMDUxODM2MDE0fSx7eDouNTkyNTAyNzEzMjAzNDMwMix5Oi42NzA2ODEzNTczODM3MjgsejotLjAwMTk2ODc0ODQwMTg1MDQ2Mn0se3g6LjcwMDEyNzM2MzIwNDk1Nix5Oi42ODcxMTAzNjQ0MzcxMDMzLHo6LjEzOTgwNTAwNDAwMDY2Mzc2fSx7eDouNjA5NTY2NTY5MzI4MzA4MSx5Oi43ODUzMTg5NzA2ODAyMzY4LHo6LS4wMzA3NDc0Nzg4Mjc4MzQxM30se3g6LjU4ODA0MjM3ODQyNTU5ODEseTouNzIyOTI4NzAyODMxMjY4Myx6Oi0uMDQ2OTE1MDA5NjE3ODA1NDh9LHt4Oi41OTMwMTgyMzM3NzYwOTI1LHk6Ljc4MTE1MTQxMzkxNzU0MTUsejotLjA2Mzk4MzM1ODQ0Mjc4MzM2fSx7eDouNTg2NzcyMjAzNDQ1NDM0Nix5Oi43OTIyNjYwMTEyMzgwOTgxLHo6LS4wNTc5NDk3MTA2MzczMzEwMX0se3g6LjU5MzMyNzk5OTExNDk5MDIseTouNzg0Mjg0ODg5Njk4MDI4Nix6Oi0uMDU3MTQwNjcwNzE2NzYyNTR9LHt4Oi42MDYzNTM1ODA5NTE2OTA3LHk6Ljc5MjAyMTg3MDYxMzA5ODEsejotLjAyNTkwNjg1NzEwMzEwOTM2fSx7eDouNTgzOTQ1Mjc0MzUzMDI3Myx5Oi43OTQ5NzgxNDE3ODQ2NjgsejotLjA2MTUyMTI1MDc1NDU5NDh9LHt4Oi41ODI4MTI2MDcyODgzNjA2LHk6LjgwMDA4MDAwMTM1NDIxNzUsejotLjA0NDk3MjI1OTU1MTI4Njd9LHt4Oi41OTA5NjAzODM0MTUyMjIyLHk6LjY1NDEyMTMzOTMyMTEzNjUsejouMDAzOTkxODkwMjMzMDEwMDU0fSx7eDouNTg1MjE4MTkxMTQ2ODUwNix5Oi42NjAyOTM4NzcxMjQ3ODY0LHo6LS4wMDQ0Mjg0MzgzNzY2MzUzMTN9LHt4Oi41ODI1NzM3NzE0NzY3NDU2LHk6LjY2NTEwNjM1NjE0Mzk1MTQsejotLjAxNDM0NTI5MDEzOTMxNzUxM30se3g6LjY1MTczNDM1MjExMTgxNjQseTouNjM2MjM4NTE1Mzc3MDQ0Nyx6Oi4wMTIxNTE4OTA0MzQzMjQ3NDF9LHt4Oi42NjE1MDUyODE5MjUyMDE0LHk6LjYyODE1Nzc5NDQ3NTU1NTQsejouMDEyMzY4MjE1MjQ3OTg4N30se3g6LjQ4NTY4NzMxNTQ2NDAxOTgseTouNjU2ODk0NTY0NjI4NjAxMSx6Oi4wMDA3MjAwMzgwNzg3MjUzMzh9LHt4Oi40OTk4ODQwNjg5NjU5MTE4Nyx5Oi42NTQ3NDEwNDg4MTI4NjYyLHo6LjAwMDY5NDk3MjY5NTc4Mjc4MDZ9LHt4Oi40ODQzODkzOTQ1MjE3MTMyNix5Oi42MzkyOTczMDY1Mzc2MjgyLHo6LjAwMDcwNTUyNTkxOTMyOTM3NX0se3g6LjQ3MTQzMTM0NDc0NzU0MzMzLHk6LjY1ODk1MTE2MzI5MTkzMTIsejouMDAwNjk4MDMzMTM4MTc4Mjg4OX0se3g6LjQ4NzA0NjE4MjE1NTYwOTEzLHk6LjY3NTI3OTc5NjEyMzUwNDYsejouMDAwNjkyMTE3Nzg0NjM3OTU3OH0se3g6LjYyNDM3MDIxNzMyMzMwMzIseTouNjQwNDYxODAyNDgyNjA1LHo6LTY1OTIxMjY3Mzc4MTQzOTdlLTIwfSx7eDouNjM5MDk2Nzk2NTEyNjAzOCx5Oi42Mzg1MTczNzk3NjA3NDIyLHo6LS4wMDAxNjEwNTQzNTQ5NzU5MzEzNX0se3g6LjYyMzA1MzY2OTkyOTUwNDQseTouNjIyNDgyNTM4MjIzMjY2Nix6Oi0uMDAwMTYxMzY0OTY1NjA2NDgwODR9LHt4Oi42MDk1Mzk3NDcyMzgxNTkyLHk6LjY0MTkxNzg4NDM0OTgyMyx6Oi0uMDAwMTgwMzU1NjM2OTg1MDQxMn0se3g6LjYyNTA5OTY1ODk2NjA2NDUseTouNjU4NjI0NzY4MjU3MTQxMSx6Oi0uMDAwMTc4NTUxNTA1MDg2OTQzNX1dXSxmYWNlQmxlbmRzaGFwZXM6W3tjYXRlZ29yaWVzOlt7aW5kZXg6MCxzY29yZTo1MTg3MTc0MzM4MDYxNTk1ZS0yMSxjYXRlZ29yeU5hbWU6XCJfbmV1dHJhbFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxLHNjb3JlOi4yNDUyMTUwNDM0MjU1NixjYXRlZ29yeU5hbWU6XCJicm93RG93bkxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MixzY29yZTouMTk4Nzc0MzM3NzY4NTU0NyxjYXRlZ29yeU5hbWU6XCJicm93RG93blJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjMsc2NvcmU6LjAxMzQwMDQ0ODQ4NjIwODkxNixjYXRlZ29yeU5hbWU6XCJicm93SW5uZXJVcFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0LHNjb3JlOi4wMTIzNjE1NjA5NDgxOTMwNzMsY2F0ZWdvcnlOYW1lOlwiYnJvd091dGVyVXBMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjUsc2NvcmU6LjAxOTMwNTA5NjkzOTIwNjEyMyxjYXRlZ29yeU5hbWU6XCJicm93T3V0ZXJVcFJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjYsc2NvcmU6Mjg0MjYzNTY5NDgzMzAwNjdlLTIxLGNhdGVnb3J5TmFtZTpcImNoZWVrUHVmZlwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo3LHNjb3JlOjMuNDUwMDExMjYzMzM5NTQ3NGUtNyxjYXRlZ29yeU5hbWU6XCJjaGVla1NxdWludExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6OCxzY29yZTo0LjgzNzg5MDUxNDg2MzgzZS03LGNhdGVnb3J5TmFtZTpcImNoZWVrU3F1aW50UmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6OSxzY29yZTouMDc2NTA0NDgzODE5MDA3ODcsY2F0ZWdvcnlOYW1lOlwiZXllQmxpbmtMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjEwLHNjb3JlOi4wNTA3MDAxMjgwNzg0NjA2OSxjYXRlZ29yeU5hbWU6XCJleWVCbGlua1JpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjExLHNjb3JlOi4xMzk3ODkwMDAxNTM1NDE1NixjYXRlZ29yeU5hbWU6XCJleWVMb29rRG93bkxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MTIsc2NvcmU6LjE0MTk4NjEzMTY2ODA5MDgyLGNhdGVnb3J5TmFtZTpcImV5ZUxvb2tEb3duUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MTMsc2NvcmU6LjIxNzc3NjYxMTQ0NzMzNDMsY2F0ZWdvcnlOYW1lOlwiZXllTG9va0luTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxNCxzY29yZTouMDE0NzM5MzU3ODY2MzQ2ODM2LGNhdGVnb3J5TmFtZTpcImV5ZUxvb2tJblJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjE1LHNjb3JlOi4wMjM2MTUxMjkyOTIwMTEyNixjYXRlZ29yeU5hbWU6XCJleWVMb29rT3V0TGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoxNixzY29yZTouMTk2Nzk2MDQ0NzA3Mjk4MjgsY2F0ZWdvcnlOYW1lOlwiZXllTG9va091dFJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjE3LHNjb3JlOi4wNDg3NDYxNjg2MTM0MzM4NCxjYXRlZ29yeU5hbWU6XCJleWVMb29rVXBMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjE4LHNjb3JlOi4wNDkzOTIzNzYwOTUwNTY1MzQsY2F0ZWdvcnlOYW1lOlwiZXllTG9va1VwUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MTksc2NvcmU6LjM0OTQ0MzMxNjQ1OTY1NTc2LGNhdGVnb3J5TmFtZTpcImV5ZVNxdWludExlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MjAsc2NvcmU6LjI5Mzk3MTY4NzU1NTMxMzEsY2F0ZWdvcnlOYW1lOlwiZXllU3F1aW50UmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MjEsc2NvcmU6LjAwNTk1NTA0MjMxNzUwOTY1MSxjYXRlZ29yeU5hbWU6XCJleWVXaWRlTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyMixzY29yZTouMDA2Nzc2MTE3NzE5NzA5ODczLGNhdGVnb3J5TmFtZTpcImV5ZVdpZGVSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyMyxzY29yZToxNjk0MjQzNjU1OTQ3NTAyN2UtMjEsY2F0ZWdvcnlOYW1lOlwiamF3Rm9yd2FyZFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDoyNCxzY29yZTouMDA0NTE2NTQ5NDA4NDM1ODIxNSxjYXRlZ29yeU5hbWU6XCJqYXdMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjI1LHNjb3JlOi4wNzgwMzk0MDAyNzk1MjE5NCxjYXRlZ29yeU5hbWU6XCJqYXdPcGVuXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjI2LHNjb3JlOjIwOTAwNTc3NTEwNDc0MjVlLTIwLGNhdGVnb3J5TmFtZTpcImphd1JpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjI3LHNjb3JlOi4wNjAzMjAzNTg3MjM0MDIwMixjYXRlZ29yeU5hbWU6XCJtb3V0aENsb3NlXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjI4LHNjb3JlOi4wMDIyODg4MjA5MjA1MTIwOCxjYXRlZ29yeU5hbWU6XCJtb3V0aERpbXBsZUxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6Mjksc2NvcmU6LjAwNzgxNzYyMzIwNTQ4Mjk2LGNhdGVnb3J5TmFtZTpcIm1vdXRoRGltcGxlUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MzAsc2NvcmU6LjAwMTcwOTM5MzEwOTE5NDkzNDQsY2F0ZWdvcnlOYW1lOlwibW91dGhGcm93bkxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MzEsc2NvcmU6LjAwMTkzMTkxMDYzNTkwMzQ3NzcsY2F0ZWdvcnlOYW1lOlwibW91dGhGcm93blJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjMyLHNjb3JlOjg0ODUyMzc3NzY3Njc0NjJlLTIwLGNhdGVnb3J5TmFtZTpcIm1vdXRoRnVubmVsXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjMzLHNjb3JlOi4wMDA5MDUxMzU1MzAwNDcxMTg3LGNhdGVnb3J5TmFtZTpcIm1vdXRoTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDozNCxzY29yZTouMDAwMzYzMDQ1NDMwMjc2NTQyOSxjYXRlZ29yeU5hbWU6XCJtb3V0aExvd2VyRG93bkxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MzUsc2NvcmU6LjAwMDE3NjAxMjM4NTA1NDQ5MTQ2LGNhdGVnb3J5TmFtZTpcIm1vdXRoTG93ZXJEb3duUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6MzYsc2NvcmU6LjEyODY1MTYxODk1NzUxOTUzLGNhdGVnb3J5TmFtZTpcIm1vdXRoUHJlc3NMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjM3LHNjb3JlOi4yMDEzNzIwNzIxMDA2MzkzNCxjYXRlZ29yeU5hbWU6XCJtb3V0aFByZXNzUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6Mzgsc2NvcmU6LjAwMjIyMDMyODQzMTU3NjQ5MDQsY2F0ZWdvcnlOYW1lOlwibW91dGhQdWNrZXJcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6Mzksc2NvcmU6LjAwMDkwOTYzNzcxNzk5NTc5MjYsY2F0ZWdvcnlOYW1lOlwibW91dGhSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0MCxzY29yZTouMzQxODk3MjE5NDE5NDc5MzcsY2F0ZWdvcnlOYW1lOlwibW91dGhSb2xsTG93ZXJcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDEsc2NvcmU6LjExNDA5Njg5NDg2MDI2NzY0LGNhdGVnb3J5TmFtZTpcIm1vdXRoUm9sbFVwcGVyXCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQyLHNjb3JlOi4xNzE3MjUzNjI1MzkyOTEzOCxjYXRlZ29yeU5hbWU6XCJtb3V0aFNocnVnTG93ZXJcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDMsc2NvcmU6LjAwNDAzODQyNDY5Njc3MzI5MSxjYXRlZ29yeU5hbWU6XCJtb3V0aFNocnVnVXBwZXJcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDQsc2NvcmU6LjAwMDIzMjA1MjMwNTM2NDA0OTk3LGNhdGVnb3J5TmFtZTpcIm1vdXRoU21pbGVMZWZ0XCIsZGlzcGxheU5hbWU6XCJcIn0se2luZGV4OjQ1LHNjb3JlOi4wMDAxOTMxMzYxOTEyMjg0MDQ2NCxjYXRlZ29yeU5hbWU6XCJtb3V0aFNtaWxlUmlnaHRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NDYsc2NvcmU6LjAwMTg1NzEzMDU1NTQzNjAxNTEsY2F0ZWdvcnlOYW1lOlwibW91dGhTdHJldGNoTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0NyxzY29yZTouMDAyMzgxMzIzODM2NzQzODMxNixjYXRlZ29yeU5hbWU6XCJtb3V0aFN0cmV0Y2hSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0OCxzY29yZToyNDMyMzEwMDY2MDY5NDc2M2UtMjEsY2F0ZWdvcnlOYW1lOlwibW91dGhVcHBlclVwTGVmdFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo0OSxzY29yZTozMTYxNTUyMDEyODk4MDI4ZS0yMCxjYXRlZ29yeU5hbWU6XCJtb3V0aFVwcGVyVXBSaWdodFwiLGRpc3BsYXlOYW1lOlwiXCJ9LHtpbmRleDo1MCxzY29yZToxLjA4MTk4NDA2Njc4NjM5ZS03LGNhdGVnb3J5TmFtZTpcIm5vc2VTbmVlckxlZnRcIixkaXNwbGF5TmFtZTpcIlwifSx7aW5kZXg6NTEsc2NvcmU6MTI2NTI1Mjc2MzAwNTI2NDZlLTIyLGNhdGVnb3J5TmFtZTpcIm5vc2VTbmVlclJpZ2h0XCIsZGlzcGxheU5hbWU6XCJcIn1dLGhlYWRJbmRleDotMSxoZWFkTmFtZTpcIlwifV0sZmFjaWFsVHJhbnNmb3JtYXRpb25NYXRyaXhlczpbe3Jvd3M6NCxjb2x1bW5zOjQsZGF0YTpbLjk5NDc1MTc1MTQyMjg4MjEsLjEwMjMwNTQ0MjA5NDgwMjg2LC4wMDEzNjc5OTMxODcxNTkyOTk5LDAsLS4xMDIzMDk5NzIwNDc4MDU3OSwuOTk0NzQ0Nzc3Njc5NDQzNCwuMDAzODE2MzIwMzI4MDQxOTExLDAsLS4wMDA5NzAzNDg0MjQ3NDM4NjEsLS4wMDM5MzYyMjk3MzkzMzgxNTk2LC45OTk5OTE0MTY5MzExNTIzLDAsMi44ODg4ODIxNjAxODY3Njc2LC03LjgwODkzNDIxMTczMDk1NywtMzAuNTIxMDkxNDYxMTgxNjQsMV19XX19LEV0PXQuY3JlYXRlQ29udGV4dCh7fSksU3Q9e2Jhc2VQYXRoOlwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AbWVkaWFwaXBlL3Rhc2tzLXZpc2lvbkAwLjEwLjgvd2FzbVwiLG9wdGlvbnM6e2Jhc2VPcHRpb25zOnttb2RlbEFzc2V0UGF0aDpcImh0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbS9tZWRpYXBpcGUtbW9kZWxzL2ZhY2VfbGFuZG1hcmtlci9mYWNlX2xhbmRtYXJrZXIvZmxvYXQxNi8xL2ZhY2VfbGFuZG1hcmtlci50YXNrXCIsZGVsZWdhdGU6XCJHUFVcIn0scnVubmluZ01vZGU6XCJWSURFT1wiLG91dHB1dEZhY2VCbGVuZHNoYXBlczohMCxvdXRwdXRGYWNpYWxUcmFuc2Zvcm1hdGlvbk1hdHJpeGVzOiEwfX07ZnVuY3Rpb24gVHQoKXtyZXR1cm4gdC51c2VDb250ZXh0KEV0KX1mdW5jdGlvbiBDdChlLHQpe3JldHVybiBlLmNsb25lKCkuYWRkKHQpLm11bHRpcGx5U2NhbGFyKC41KX1mdW5jdGlvbiBQdChlLHQscil7Y29uc3Qgbj1lLmxvY2FsVG9Xb3JsZCh0KTtyZXR1cm4gci53b3JsZFRvTG9jYWwobil9Y29uc3QgUnQ9dC5jcmVhdGVDb250ZXh0KHt9KSxEdD10LmZvcndhcmRSZWYoKCh7Y2FtZXJhOmUsYXV0b3N0YXJ0OnI9ITAsd2ViY2FtOm49ITAsd2ViY2FtVmlkZW9UZXh0dXJlU3JjOm8sbWFudWFsVXBkYXRlOmk9ITEsbWFudWFsRGV0ZWN0Omw9ITEsb25WaWRlb0ZyYW1lOmMsc21vb3RoVGltZTp1PS4yNSxvZmZzZXQ6ZD0hMCxvZmZzZXRTY2FsYXI6bT04MCxleWVzOmY9ITEsZXllc0FzT3JpZ2luOnA9ITAsZGVwdGg6aD0uMTUsZGVidWc6eD0hMSxmYWNlbWVzaDp5LG1ha2VEZWZhdWx0OnZ9LGcpPT57dmFyIHosdztjb25zdCBiPWEudXNlVGhyZWUoKGU9PmUuc2NlbmUpKSxNPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksRT1hLnVzZVRocmVlKChlPT5lLnNldCkpLFM9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSxUPWV8fE0sUj10LnVzZVJlZihudWxsKSxGPXQudXNlUmVmKG51bGwpLFtrXT10LnVzZVN0YXRlKCgoKT0+bmV3IEQuT2JqZWN0M0QpKSxbX109dC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSxbQV09dC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSxbTF09dC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSxbQl09dC51c2VTdGF0ZSgoKCk9Pm5ldyBELlZlY3RvcjMpKSxVPXQudXNlQ2FsbGJhY2soKCgpPT57ay5wYXJlbnQ9VC5wYXJlbnQ7Y29uc3QgZT1GLmN1cnJlbnQ7aWYoZSl7Y29uc3R7b3V0ZXJSZWY6dCxleWVSaWdodFJlZjpyLGV5ZUxlZnRSZWY6bn09ZTtpZihyLmN1cnJlbnQmJm4uY3VycmVudCl7Y29uc3R7aXJpc0RpclJlZjplfT1yLmN1cnJlbnQse2lyaXNEaXJSZWY6YX09bi5jdXJyZW50O2UuY3VycmVudCYmYS5jdXJyZW50JiZ0LmN1cnJlbnQmJihfLmNvcHkoUHQoZS5jdXJyZW50LG5ldyBELlZlY3RvcjMoMCwwLDApLHQuY3VycmVudCkpLEEuY29weShQdChhLmN1cnJlbnQsbmV3IEQuVmVjdG9yMygwLDAsMCksdC5jdXJyZW50KSksay5wb3NpdGlvbi5jb3B5KFB0KHQuY3VycmVudCxDdChfLEEpLFQucGFyZW50fHxiKSksTC5jb3B5KFB0KGUuY3VycmVudCxuZXcgRC5WZWN0b3IzKDAsMCwxKSx0LmN1cnJlbnQpKSxCLmNvcHkoUHQoYS5jdXJyZW50LG5ldyBELlZlY3RvcjMoMCwwLDEpLHQuY3VycmVudCkpLGsubG9va0F0KHQuY3VycmVudC5sb2NhbFRvV29ybGQoQ3QoTCxCKSkpKX1lbHNlIHQuY3VycmVudCYmKGsucG9zaXRpb24uY29weShQdCh0LmN1cnJlbnQsbmV3IEQuVmVjdG9yMygwLDAsMCksVC5wYXJlbnR8fGIpKSxrLmxvb2tBdCh0LmN1cnJlbnQubG9jYWxUb1dvcmxkKG5ldyBELlZlY3RvcjMoMCwwLDEpKSkpfXJldHVybiBrfSksW1QsQSxCLF8sTCxiLGtdKSxbSV09dC51c2VTdGF0ZSgoKCk9Pm5ldyBELk9iamVjdDNEKSksVj10LnVzZUNhbGxiYWNrKChmdW5jdGlvbihlLHQpe2lmKFQpe3ZhciByO2lmKG51bGwhPT0ocj10KSYmdm9pZCAwIT09cnx8KHQ9VSgpKSx1PjApe2NvbnN0IHI9MWUtOTtzLmVhc2luZy5kYW1wMyhJLnBvc2l0aW9uLHQucG9zaXRpb24sdSxlLHZvaWQgMCx2b2lkIDAscikscy5lYXNpbmcuZGFtcEUoSS5yb3RhdGlvbix0LnJvdGF0aW9uLHUsZSx2b2lkIDAsdm9pZCAwLHIpfWVsc2UgSS5wb3NpdGlvbi5jb3B5KHQucG9zaXRpb24pLEkucm90YXRpb24uY29weSh0LnJvdGF0aW9uKTtULnBvc2l0aW9uLmNvcHkoSS5wb3NpdGlvbiksVC5yb3RhdGlvbi5jb3B5KEkucm90YXRpb24pfX0pLFtULFUsdSxJLnBvc2l0aW9uLEkucm90YXRpb25dKSxbTyxOXT10LnVzZVN0YXRlKCksaj1UdCgpLFc9dC51c2VDYWxsYmFjaygoKGUsdCk9Pntjb25zdCByPW51bGw9PWo/dm9pZCAwOmouZGV0ZWN0Rm9yVmlkZW8oZSx0KTtOKHIpfSksW2pdKTthLnVzZUZyYW1lKCgoZSx0KT0+e2l8fFYodCl9KSk7Y29uc3QgRz10LnVzZU1lbW8oKCgpPT5PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoRC5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlKSx7ZGV0ZWN0OlcsY29tcHV0ZVRhcmdldDpVLHVwZGF0ZTpWLGZhY2VtZXNoQXBpUmVmOkYsd2ViY2FtQXBpUmVmOlIscGxheTooKT0+e3ZhciBlO251bGw9PShlPVIuY3VycmVudCl8fG51bGw9PShlPWUudmlkZW9UZXh0dXJlQXBpUmVmLmN1cnJlbnQpfHxlLnRleHR1cmUuc291cmNlLmRhdGEucGxheSgpfSxwYXVzZTooKT0+e3ZhciBlO251bGw9PShlPVIuY3VycmVudCl8fG51bGw9PShlPWUudmlkZW9UZXh0dXJlQXBpUmVmLmN1cnJlbnQpfHxlLnRleHR1cmUuc291cmNlLmRhdGEucGF1c2UoKX19KSksW1csVSxWXSk7dC51c2VJbXBlcmF0aXZlSGFuZGxlKGcsKCgpPT5HKSxbR10pLHQudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9ZT0+e2x8fFcoZS50ZXh0dXJlLnNvdXJjZS5kYXRhLGUudGltZSksYyYmYyhlKX07cmV0dXJuIEcuYWRkRXZlbnRMaXN0ZW5lcihcInZpZGVvRnJhbWVcIixlKSwoKT0+e0cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpZGVvRnJhbWVcIixlKX19KSxbRyxXLGosbCxjXSksdC51c2VFZmZlY3QoKCgpPT57aWYodil7Y29uc3QgZT1TKCkuY29udHJvbHM7cmV0dXJuIEUoe2NvbnRyb2xzOkd9KSwoKT0+RSh7Y29udHJvbHM6ZX0pfX0pLFt2LEcsUyxFXSk7Y29uc3QgSD1udWxsPT1PP3ZvaWQgMDpPLmZhY2VMYW5kbWFya3NbMF0sJD1udWxsPT1PfHxudWxsPT0oej1PLmZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4ZXMpP3ZvaWQgMDp6WzBdLHE9bnVsbD09T3x8bnVsbD09KHc9Ty5mYWNlQmxlbmRzaGFwZXMpP3ZvaWQgMDp3WzBdO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoUnQuUHJvdmlkZXIse3ZhbHVlOkd9LG4mJlAuY3JlYXRlRWxlbWVudCh0LlN1c3BlbnNlLHtmYWxsYmFjazpudWxsfSxQLmNyZWF0ZUVsZW1lbnQoa3Qse3JlZjpSLGF1dG9zdGFydDpyLHZpZGVvVGV4dHVyZVNyYzpvfSkpLFAuY3JlYXRlRWxlbWVudCh6dCxDLmRlZmF1bHQoe3JlZjpGfSx5LHtwb2ludHM6SCxkZXB0aDpoLGZhY2lhbFRyYW5zZm9ybWF0aW9uTWF0cml4OiQsZmFjZUJsZW5kc2hhcGVzOnEsZXllczpmLGV5ZXNBc09yaWdpbjpwLG9mZnNldDpkLG9mZnNldFNjYWxhcjptLGRlYnVnOngsXCJyb3RhdGlvbi16XCI6TWF0aC5QSSx2aXNpYmxlOnh9KSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHtzaWRlOkQuRG91YmxlU2lkZX0pKSl9KSksRnQ9KCk9PnQudXNlQ29udGV4dChSdCksa3Q9dC5mb3J3YXJkUmVmKCgoe3ZpZGVvVGV4dHVyZVNyYzplLGF1dG9zdGFydDpyPSEwfSxuKT0+e2NvbnN0IGE9dC51c2VSZWYobnVsbCksbz1GdCgpLGk9Zi5zdXNwZW5kKChhc3luYygpPT5lP1Byb21pc2UucmVzb2x2ZShudWxsKTphd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7YXVkaW86ITEsdmlkZW86e2ZhY2luZ01vZGU6XCJ1c2VyXCJ9fSkpLFtlXSk7dC51c2VFZmZlY3QoKCgpPT4oby5kaXNwYXRjaEV2ZW50KHt0eXBlOlwic3RyZWFtXCIsc3RyZWFtOml9KSwoKT0+e251bGw9PWl8fGkuZ2V0VHJhY2tzKCkuZm9yRWFjaCgoZT0+ZS5zdG9wKCkpKSxmLmNsZWFyKFtlXSl9KSksW2ksbyxlXSk7Y29uc3Qgcz10LnVzZU1lbW8oKCgpPT4oe3ZpZGVvVGV4dHVyZUFwaVJlZjphfSkpLFtdKTtyZXR1cm4gdC51c2VJbXBlcmF0aXZlSGFuZGxlKG4sKCgpPT5zKSxbc10pLFAuY3JlYXRlRWxlbWVudCh0LlN1c3BlbnNlLHtmYWxsYmFjazpudWxsfSxQLmNyZWF0ZUVsZW1lbnQoX3Qse3JlZjphLHNyYzplfHxpLHN0YXJ0OnJ9KSl9KSksX3Q9dC5mb3J3YXJkUmVmKCgoe3NyYzplLHN0YXJ0OnJ9LG4pPT57Y29uc3QgYT15dChlLHtzdGFydDpyfSksbz1hLnNvdXJjZS5kYXRhLGk9RnQoKSxzPXQudXNlQ2FsbGJhY2soKGU9PntpLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJ2aWRlb0ZyYW1lXCIsdGV4dHVyZTphLHRpbWU6ZX0pfSksW2EsaV0pO0F0KG8scyk7Y29uc3QgbD10LnVzZU1lbW8oKCgpPT4oe3RleHR1cmU6YX0pKSxbYV0pO3JldHVybiB0LnVzZUltcGVyYXRpdmVIYW5kbGUobiwoKCk9PmwpLFtsXSksUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCl9KSksQXQ9KGUscik9Pnt0LnVzZUVmZmVjdCgoKCk9PntpZighZXx8IWUucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaylyZXR1cm47bGV0IHQ7cmV0dXJuIGUucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaygoZnVuY3Rpb24gbiguLi5hKXtyKC4uLmEpLHQ9ZS5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKG4pfSkpLCgpPT5lLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayh0KX0pLFtlLHJdKX0sTHQ9UC5jcmVhdGVDb250ZXh0KG51bGwpO2Z1bmN0aW9uIEJ0KCl7cmV0dXJuIFAudXNlQ29udGV4dChMdCl9ZnVuY3Rpb24gVXQoe3BvaW50czplPTUwfSl7Y29uc3R7cGF0aDp0fT1CdCgpLFtyLG5dPVAudXNlU3RhdGUoW10pLFthXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuTWVzaEJhc2ljTWF0ZXJpYWwoe2NvbG9yOlwiYmxhY2tcIn0pKSksW29dPVAudXNlU3RhdGUoKCgpPT5uZXcgRC5TcGhlcmVHZW9tZXRyeSguMDI1LDE2LDE2KSkpLGk9UC51c2VSZWYoW10pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9Pnt0LmN1cnZlcyE9PWkuY3VycmVudCYmKG4odC5nZXRQb2ludHMoZSkpLGkuY3VycmVudD10LmN1cnZlcyl9KSksUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxyLm1hcCgoKGUsdCk9PlAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7a2V5OnQsbWF0ZXJpYWw6YSxnZW9tZXRyeTpvLHBvc2l0aW9uOltlLngsZS55LGUuel19KSkpKX1jb25zdCBJdD1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxjdXJ2ZXM6dD1bXSxvYmplY3Q6cixkZWJ1ZzpuPSExLHNtb290aDpvPSExLGZvY3VzOmksb2Zmc2V0OmwsZXBzOmM9MWUtNSxkYW1waW5nOnU9LjEsZm9jdXNEYW1waW5nOmQ9LjEsbWF4U3BlZWQ6bT0xLzAsLi4uZn0scCk9Pntjb25zdHtjYW1lcmE6aH09YS51c2VUaHJlZSgpLHg9UC51c2VSZWYoKSxbeV09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELkN1cnZlUGF0aCkpLHY9UC51c2VSZWYobnVsbCE9bD9sOjApLGc9UC51c2VNZW1vKCgoKT0+KHtmb2N1czppLG9iamVjdDoobnVsbD09cj92b2lkIDA6ci5jdXJyZW50KWluc3RhbmNlb2YgRC5PYmplY3QzRD9yOntjdXJyZW50Omh9LHBhdGg6eSxjdXJyZW50OnYuY3VycmVudCxvZmZzZXQ6di5jdXJyZW50LHBvaW50Om5ldyBELlZlY3RvcjMsdGFuZ2VudDpuZXcgRC5WZWN0b3IzLG5leHQ6bmV3IEQuVmVjdG9yM30pKSxbaSxyXSk7UC51c2VMYXlvdXRFZmZlY3QoKCgpPT57dmFyIGU7eS5jdXJ2ZXM9W107Y29uc3Qgcj10Lmxlbmd0aD4wP3Q6bnVsbD09KGU9eC5jdXJyZW50KT92b2lkIDA6ZS5fX3IzZi5vYmplY3RzO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7bisrKXkuYWRkKHJbbl0pO2lmKG8pe2NvbnN0IGU9eS5nZXRQb2ludHMoXCJudW1iZXJcIj09dHlwZW9mIG8/bzoxKSx0PW5ldyBELkNhdG11bGxSb21DdXJ2ZTMoZSk7eS5jdXJ2ZXM9W3RdfXkudXBkYXRlQXJjTGVuZ3RocygpfSkpLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShwLCgoKT0+eC5jdXJyZW50KSxbXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57di5jdXJyZW50PXMubWlzYy5yZXBlYXQodi5jdXJyZW50LDEpfSksW2xdKTtsZXQgej0wO2NvbnN0W3ddPVAudXNlU3RhdGUoKCgpPT5uZXcgRC5WZWN0b3IzKSk7cmV0dXJuIGEudXNlRnJhbWUoKChlLHQpPT57aWYoej1nLm9mZnNldCxzLmVhc2luZy5kYW1wKHYsXCJjdXJyZW50XCIsdm9pZCAwIT09bD9sOmcuY3VycmVudCx1LHQsbSx2b2lkIDAsYyksZy5vZmZzZXQ9cy5taXNjLnJlcGVhdCh2LmN1cnJlbnQsMSkseS5nZXRDdXJ2ZUxlbmd0aHMoKS5sZW5ndGg+MCl7eS5nZXRQb2ludEF0KGcub2Zmc2V0LGcucG9pbnQpLHkuZ2V0VGFuZ2VudEF0KGcub2Zmc2V0LGcudGFuZ2VudCkubm9ybWFsaXplKCkseS5nZXRQb2ludEF0KHMubWlzYy5yZXBlYXQodi5jdXJyZW50LSh6LWcub2Zmc2V0KSwxKSxnLm5leHQpO2NvbnN0IGU9KG51bGw9PXI/dm9pZCAwOnIuY3VycmVudClpbnN0YW5jZW9mIEQuT2JqZWN0M0Q/ci5jdXJyZW50Omg7ZS5wb3NpdGlvbi5jb3B5KGcucG9pbnQpLGkmJnMuZWFzaW5nLmRhbXBMb29rQXQoZSwoZT0+KG51bGw9PWU/dm9pZCAwOmUuY3VycmVudClpbnN0YW5jZW9mIEQuT2JqZWN0M0QpKGkpP2kuY3VycmVudC5nZXRXb3JsZFBvc2l0aW9uKHcpOmksZCx0LG0sdm9pZCAwLGMpfX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLEMuZGVmYXVsdCh7cmVmOnh9LGYpLFAuY3JlYXRlRWxlbWVudChMdC5Qcm92aWRlcix7dmFsdWU6Z30sZSxuJiZQLmNyZWF0ZUVsZW1lbnQoVXQsbnVsbCkpKX0pKTtmdW5jdGlvbiBWdCh7ZGVmYXVsdFNjZW5lOmUsZGVmYXVsdENhbWVyYTp0LHJlbmRlclByaW9yaXR5OnI9MX0pe2NvbnN0e2dsOm4sc2NlbmU6byxjYW1lcmE6aX09YS51c2VUaHJlZSgpO2xldCBzO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3M9bi5hdXRvQ2xlYXIsMT09PXImJihuLmF1dG9DbGVhcj0hMCxuLnJlbmRlcihlLHQpKSxuLmF1dG9DbGVhcj0hMSxuLmNsZWFyRGVwdGgoKSxuLnJlbmRlcihvLGkpLG4uYXV0b0NsZWFyPXN9KSxyKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtvblBvaW50ZXJPdmVyOigpPT5udWxsfSl9ZnVuY3Rpb24gT3Qoe2NoaWxkcmVuOmUscmVuZGVyUHJpb3JpdHk6dD0xfSl7Y29uc3R7c2NlbmU6cixjYW1lcmE6bn09YS51c2VUaHJlZSgpLFtvXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuU2NlbmUpKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxhLmNyZWF0ZVBvcnRhbChQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGUsUC5jcmVhdGVFbGVtZW50KFZ0LHtkZWZhdWx0U2NlbmU6cixkZWZhdWx0Q2FtZXJhOm4scmVuZGVyUHJpb3JpdHk6dH0pKSxvLHtldmVudHM6e3ByaW9yaXR5OnQrMX19KSl9Y29uc3QgTnQ9UC5jcmVhdGVDb250ZXh0KHt9KSxqdD0oKT0+UC51c2VDb250ZXh0KE50KSxXdD0yKk1hdGguUEksR3Q9bmV3IG4uT2JqZWN0M0QsSHQ9bmV3IG4uTWF0cml4NCxbJHQscXRdPVtuZXcgbi5RdWF0ZXJuaW9uLG5ldyBuLlF1YXRlcm5pb25dLFh0PW5ldyBuLlZlY3RvcjMsWnQ9bmV3IG4uVmVjdG9yMyxZdD1cIiNmMGYwZjBcIixRdD1cIiM5OTlcIixLdD1cImJsYWNrXCIsSnQ9XCJibGFja1wiLGVyPVtcIlJpZ2h0XCIsXCJMZWZ0XCIsXCJUb3BcIixcIkJvdHRvbVwiLFwiRnJvbnRcIixcIkJhY2tcIl0sdHI9ZT0+bmV3IG4uVmVjdG9yMyguLi5lKS5tdWx0aXBseVNjYWxhciguMzgpLHJyPVtbMSwxLDFdLFsxLDEsLTFdLFsxLC0xLDFdLFsxLC0xLC0xXSxbLTEsMSwxXSxbLTEsMSwtMV0sWy0xLC0xLDFdLFstMSwtMSwtMV1dLm1hcCh0ciksbnI9Wy4yNSwuMjUsLjI1XSxhcj1bWzEsMSwwXSxbMSwwLDFdLFsxLDAsLTFdLFsxLC0xLDBdLFswLDEsMV0sWzAsMSwtMV0sWzAsLTEsMV0sWzAsLTEsLTFdLFstMSwxLDBdLFstMSwwLDFdLFstMSwwLC0xXSxbLTEsLTEsMF1dLm1hcCh0ciksb3I9YXIubWFwKChlPT5lLnRvQXJyYXkoKS5tYXAoKGU9PjA9PWU/LjU6LjI1KSkpKSxpcj0oe2hvdmVyOmUsaW5kZXg6dCxmb250OnI9XCIyMHB4IEludGVyIHZhciwgQXJpYWwsIHNhbnMtc2VyaWZcIixmYWNlczpvPWVyLGNvbG9yOmk9WXQsaG92ZXJDb2xvcjpzPVF0LHRleHRDb2xvcjpsPUt0LHN0cm9rZUNvbG9yOmM9SnQsb3BhY2l0eTp1PTF9KT0+e2NvbnN0IGQ9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLG09UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtlLndpZHRoPTEyOCxlLmhlaWdodD0xMjg7Y29uc3QgYT1lLmdldENvbnRleHQoXCIyZFwiKTtyZXR1cm4gYS5maWxsU3R5bGU9aSxhLmZpbGxSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxhLnN0cm9rZVN0eWxlPWMsYS5zdHJva2VSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxhLmZvbnQ9cixhLnRleHRBbGlnbj1cImNlbnRlclwiLGEuZmlsbFN0eWxlPWwsYS5maWxsVGV4dChvW3RdLnRvVXBwZXJDYXNlKCksNjQsNzYpLG5ldyBuLkNhbnZhc1RleHR1cmUoZSl9KSxbdCxvLHIsaSxsLGNdKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7bWFwOm0sXCJtYXAtYW5pc290cm9weVwiOmQuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKXx8MSxhdHRhY2g6YG1hdGVyaWFsLSR7dH1gLGNvbG9yOmU/czpcIndoaXRlXCIsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTp1fSl9LHNyPWU9Pntjb25zdHt0d2VlbkNhbWVyYTp0fT1qdCgpLFtyLG5dPVAudXNlU3RhdGUobnVsbCk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7b25Qb2ludGVyT3V0OmU9PntlLnN0b3BQcm9wYWdhdGlvbigpLG4obnVsbCl9LG9uUG9pbnRlck1vdmU6ZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksbihNYXRoLmZsb29yKGUuZmFjZUluZGV4LzIpKX0sb25DbGljazplLm9uQ2xpY2t8fChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSx0KGUuZmFjZS5ub3JtYWwpfSl9LFsuLi5BcnJheSg2KV0ubWFwKCgodCxuKT0+UC5jcmVhdGVFbGVtZW50KGlyLEMuZGVmYXVsdCh7a2V5Om4saW5kZXg6bixob3ZlcjpyPT09bn0sZSkpKSksUC5jcmVhdGVFbGVtZW50KFwiYm94R2VvbWV0cnlcIixudWxsKSl9LGxyPSh7b25DbGljazplLGRpbWVuc2lvbnM6dCxwb3NpdGlvbjpyLGhvdmVyQ29sb3I6bj1RdH0pPT57Y29uc3R7dHdlZW5DYW1lcmE6YX09anQoKSxbbyxpXT1QLnVzZVN0YXRlKCExKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtzY2FsZToxLjAxLHBvc2l0aW9uOnIsb25Qb2ludGVyT3ZlcjplPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxpKCEwKX0sb25Qb2ludGVyT3V0OmU9PntlLnN0b3BQcm9wYWdhdGlvbigpLGkoITEpfSxvbkNsaWNrOmV8fChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxhKHIpfSl9LFAuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse2NvbG9yOm8/bjpcIndoaXRlXCIsdHJhbnNwYXJlbnQ6ITAsb3BhY2l0eTouNix2aXNpYmxlOm99KSxQLmNyZWF0ZUVsZW1lbnQoXCJib3hHZW9tZXRyeVwiLHthcmdzOnR9KSl9O2Z1bmN0aW9uIGNyKHtzY2FsZTplPVsuOCwuMDUsLjA1XSxjb2xvcjp0LHJvdGF0aW9uOnJ9KXtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cm90YXRpb246cn0sUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtwb3NpdGlvbjpbLjQsMCwwXX0sUC5jcmVhdGVFbGVtZW50KFwiYm94R2VvbWV0cnlcIix7YXJnczplfSksUC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7Y29sb3I6dCx0b25lTWFwcGVkOiExfSkpKX1mdW5jdGlvbiB1cih7b25DbGljazplLGZvbnQ6dCxkaXNhYmxlZDpyLGFyY1N0eWxlOm8sbGFiZWw6aSxsYWJlbENvbG9yOnMsYXhpc0hlYWRTY2FsZTpsPTEsLi4uY30pe2NvbnN0IHU9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGQ9UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtlLndpZHRoPTY0LGUuaGVpZ2h0PTY0O2NvbnN0IHI9ZS5nZXRDb250ZXh0KFwiMmRcIik7cmV0dXJuIHIuYmVnaW5QYXRoKCksci5hcmMoMzIsMzIsMTYsMCwyKk1hdGguUEkpLHIuY2xvc2VQYXRoKCksci5maWxsU3R5bGU9byxyLmZpbGwoKSxpJiYoci5mb250PXQsci50ZXh0QWxpZ249XCJjZW50ZXJcIixyLmZpbGxTdHlsZT1zLHIuZmlsbFRleHQoaSwzMiw0MSkpLG5ldyBuLkNhbnZhc1RleHR1cmUoZSl9KSxbbyxpLHMsdF0pLFttLGZdPVAudXNlU3RhdGUoITEpLHA9KGk/MTouNzUpKihtPzEuMjoxKSpsO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJzcHJpdGVcIixDLmRlZmF1bHQoe3NjYWxlOnAsb25Qb2ludGVyT3ZlcjpyP3ZvaWQgMDplPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxmKCEwKX0sb25Qb2ludGVyT3V0OnI/dm9pZCAwOmV8fChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxmKCExKX0pfSxjKSxQLmNyZWF0ZUVsZW1lbnQoXCJzcHJpdGVNYXRlcmlhbFwiLHttYXA6ZCxcIm1hcC1hbmlzb3Ryb3B5XCI6dS5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpfHwxLGFscGhhVGVzdDouMyxvcGFjaXR5Omk/MTouNzUsdG9uZU1hcHBlZDohMX0pKX1jb25zdCBkcj1FZSh7Y2VsbFNpemU6LjUsc2VjdGlvblNpemU6MSxmYWRlRGlzdGFuY2U6MTAwLGZhZGVTdHJlbmd0aDoxLGNlbGxUaGlja25lc3M6LjUsc2VjdGlvblRoaWNrbmVzczoxLGNlbGxDb2xvcjpuZXcgRC5Db2xvcixzZWN0aW9uQ29sb3I6bmV3IEQuQ29sb3IsaW5maW5pdGVHcmlkOiExLGZvbGxvd0NhbWVyYTohMSx3b3JsZENhbVByb2pQb3NpdGlvbjpuZXcgRC5WZWN0b3IzLHdvcmxkUGxhbmVQb3NpdGlvbjpuZXcgRC5WZWN0b3IzfSxcIlxcbiAgICB2YXJ5aW5nIHZlYzMgbG9jYWxQb3NpdGlvbjtcXG4gICAgdmFyeWluZyB2ZWM0IHdvcmxkUG9zaXRpb247XFxuXFxuICAgIHVuaWZvcm0gdmVjMyB3b3JsZENhbVByb2pQb3NpdGlvbjtcXG4gICAgdW5pZm9ybSB2ZWMzIHdvcmxkUGxhbmVQb3NpdGlvbjtcXG4gICAgdW5pZm9ybSBmbG9hdCBmYWRlRGlzdGFuY2U7XFxuICAgIHVuaWZvcm0gYm9vbCBpbmZpbml0ZUdyaWQ7XFxuICAgIHVuaWZvcm0gYm9vbCBmb2xsb3dDYW1lcmE7XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBsb2NhbFBvc2l0aW9uID0gcG9zaXRpb24ueHp5O1xcbiAgICAgIGlmIChpbmZpbml0ZUdyaWQpIGxvY2FsUG9zaXRpb24gKj0gMS4wICsgZmFkZURpc3RhbmNlO1xcbiAgICAgIFxcbiAgICAgIHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQobG9jYWxQb3NpdGlvbiwgMS4wKTtcXG4gICAgICBpZiAoZm9sbG93Q2FtZXJhKSB7XFxuICAgICAgICB3b3JsZFBvc2l0aW9uLnh5eiArPSAod29ybGRDYW1Qcm9qUG9zaXRpb24gLSB3b3JsZFBsYW5lUG9zaXRpb24pO1xcbiAgICAgICAgbG9jYWxQb3NpdGlvbiA9IChpbnZlcnNlKG1vZGVsTWF0cml4KSAqIHdvcmxkUG9zaXRpb24pLnh5ejtcXG4gICAgICB9XFxuXFxuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuICAgIH1cXG4gIFwiLGBcXG4gICAgdmFyeWluZyB2ZWMzIGxvY2FsUG9zaXRpb247XFxuICAgIHZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1xcblxcbiAgICB1bmlmb3JtIHZlYzMgd29ybGRDYW1Qcm9qUG9zaXRpb247XFxuICAgIHVuaWZvcm0gZmxvYXQgY2VsbFNpemU7XFxuICAgIHVuaWZvcm0gZmxvYXQgc2VjdGlvblNpemU7XFxuICAgIHVuaWZvcm0gdmVjMyBjZWxsQ29sb3I7XFxuICAgIHVuaWZvcm0gdmVjMyBzZWN0aW9uQ29sb3I7XFxuICAgIHVuaWZvcm0gZmxvYXQgZmFkZURpc3RhbmNlO1xcbiAgICB1bmlmb3JtIGZsb2F0IGZhZGVTdHJlbmd0aDtcXG4gICAgdW5pZm9ybSBmbG9hdCBjZWxsVGhpY2tuZXNzO1xcbiAgICB1bmlmb3JtIGZsb2F0IHNlY3Rpb25UaGlja25lc3M7XFxuXFxuICAgIGZsb2F0IGdldEdyaWQoZmxvYXQgc2l6ZSwgZmxvYXQgdGhpY2tuZXNzKSB7XFxuICAgICAgdmVjMiByID0gbG9jYWxQb3NpdGlvbi54eiAvIHNpemU7XFxuICAgICAgdmVjMiBncmlkID0gYWJzKGZyYWN0KHIgLSAwLjUpIC0gMC41KSAvIGZ3aWR0aChyKTtcXG4gICAgICBmbG9hdCBsaW5lID0gbWluKGdyaWQueCwgZ3JpZC55KSArIDEuMCAtIHRoaWNrbmVzcztcXG4gICAgICByZXR1cm4gMS4wIC0gbWluKGxpbmUsIDEuMCk7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGZsb2F0IGcxID0gZ2V0R3JpZChjZWxsU2l6ZSwgY2VsbFRoaWNrbmVzcyk7XFxuICAgICAgZmxvYXQgZzIgPSBnZXRHcmlkKHNlY3Rpb25TaXplLCBzZWN0aW9uVGhpY2tuZXNzKTtcXG5cXG4gICAgICBmbG9hdCBkaXN0ID0gZGlzdGFuY2Uod29ybGRDYW1Qcm9qUG9zaXRpb24sIHdvcmxkUG9zaXRpb24ueHl6KTtcXG4gICAgICBmbG9hdCBkID0gMS4wIC0gbWluKGRpc3QgLyBmYWRlRGlzdGFuY2UsIDEuMCk7XFxuICAgICAgdmVjMyBjb2xvciA9IG1peChjZWxsQ29sb3IsIHNlY3Rpb25Db2xvciwgbWluKDEuMCwgc2VjdGlvblRoaWNrbmVzcyAqIGcyKSk7XFxuXFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgKGcxICsgZzIpICogcG93KGQsIGZhZGVTdHJlbmd0aCkpO1xcbiAgICAgIGdsX0ZyYWdDb2xvci5hID0gbWl4KDAuNzUgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLmEsIGcyKTtcXG4gICAgICBpZiAoZ2xfRnJhZ0NvbG9yLmEgPD0gMC4wKSBkaXNjYXJkO1xcblxcbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgICAjaW5jbHVkZSA8JHtDZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICB9XFxuICBgKSxtcj1QLmZvcndhcmRSZWYoKCh7YXJnczplLGNlbGxDb2xvcjp0PVwiIzAwMDAwMFwiLHNlY3Rpb25Db2xvcjpyPVwiIzIwODBmZlwiLGNlbGxTaXplOm49LjUsc2VjdGlvblNpemU6bz0xLGZvbGxvd0NhbWVyYTppPSExLGluZmluaXRlR3JpZDpzPSExLGZhZGVEaXN0YW5jZTpsPTEwMCxmYWRlU3RyZW5ndGg6Yz0xLGNlbGxUaGlja25lc3M6dT0uNSxzZWN0aW9uVGhpY2tuZXNzOmQ9MSxzaWRlOm09RC5CYWNrU2lkZSwuLi5mfSxwKT0+e2EuZXh0ZW5kKHtHcmlkTWF0ZXJpYWw6ZHJ9KTtjb25zdCBoPVAudXNlUmVmKG51bGwpLHg9bmV3IEQuUGxhbmUseT1uZXcgRC5WZWN0b3IzKDAsMSwwKSx2PW5ldyBELlZlY3RvcjMoMCwwLDApO2EudXNlRnJhbWUoKGU9Pnt4LnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHksdikuYXBwbHlNYXRyaXg0KGguY3VycmVudC5tYXRyaXhXb3JsZCk7Y29uc3QgdD1oLmN1cnJlbnQubWF0ZXJpYWwscj10LnVuaWZvcm1zLndvcmxkQ2FtUHJvalBvc2l0aW9uLG49dC51bmlmb3Jtcy53b3JsZFBsYW5lUG9zaXRpb247eC5wcm9qZWN0UG9pbnQoZS5jYW1lcmEucG9zaXRpb24sci52YWx1ZSksbi52YWx1ZS5zZXQoMCwwLDApLmFwcGx5TWF0cml4NChoLmN1cnJlbnQubWF0cml4V29ybGQpfSkpO2NvbnN0IGc9e2NlbGxTaXplOm4sc2VjdGlvblNpemU6byxjZWxsQ29sb3I6dCxzZWN0aW9uQ29sb3I6cixjZWxsVGhpY2tuZXNzOnUsc2VjdGlvblRoaWNrbmVzczpkfSx6PXtmYWRlRGlzdGFuY2U6bCxmYWRlU3RyZW5ndGg6YyxpbmZpbml0ZUdyaWQ6cyxmb2xsb3dDYW1lcmE6aX07cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIixDLmRlZmF1bHQoe3JlZjprLmRlZmF1bHQoW2gscF0pLGZydXN0dW1DdWxsZWQ6ITF9LGYpLFAuY3JlYXRlRWxlbWVudChcImdyaWRNYXRlcmlhbFwiLEMuZGVmYXVsdCh7dHJhbnNwYXJlbnQ6ITAsXCJleHRlbnNpb25zLWRlcml2YXRpdmVzXCI6ITAsc2lkZTptfSxnLHopKSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6ZX0pKX0pKTtmdW5jdGlvbiBmcihlLHtwYXRoOnR9KXtjb25zdFtyXT1hLnVzZUxvYWRlcihuLkN1YmVUZXh0dXJlTG9hZGVyLFtlXSwoZT0+ZS5zZXRQYXRoKHQpKSk7cmV0dXJuIHJ9ZnVuY3Rpb24gcHIoZSl7cmV0dXJuIGEudXNlTG9hZGVyKGQuRkJYTG9hZGVyLGUpfWZyLnByZWxvYWQ9KGUse3BhdGg6dH0pPT5hLnVzZUxvYWRlci5wcmVsb2FkKG4uQ3ViZVRleHR1cmVMb2FkZXIsW2VdLChlPT5lLnNldFBhdGgodCkpKSxwci5wcmVsb2FkPWU9PmEudXNlTG9hZGVyLnByZWxvYWQoZC5GQlhMb2FkZXIsZSkscHIuY2xlYXI9ZT0+YS51c2VMb2FkZXIuY2xlYXIoZC5GQlhMb2FkZXIsZSk7Y29uc3QgaHI9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvcG1uZHJzL2RyZWktYXNzZXRzQG1hc3RlclwiO2Z1bmN0aW9uIHhyKGUscj1gJHtocn0vYmFzaXMvYCl7Y29uc3Qgbj1hLnVzZVRocmVlKChlPT5lLmdsKSksbz1hLnVzZUxvYWRlcihkLktUWDJMb2FkZXIsU2UoZSk/T2JqZWN0LnZhbHVlcyhlKTplLChlPT57ZS5kZXRlY3RTdXBwb3J0KG4pLGUuc2V0VHJhbnNjb2RlclBhdGgocil9KSk7aWYodC51c2VFZmZlY3QoKCgpPT57KEFycmF5LmlzQXJyYXkobyk/bzpbb10pLmZvckVhY2gobi5pbml0VGV4dHVyZSl9KSxbbixvXSksU2UoZSkpe2NvbnN0IHQ9T2JqZWN0LmtleXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKChlPT5PYmplY3QuYXNzaWduKHIse1tlXTpvW3QuaW5kZXhPZihlKV19KSkpLHJ9cmV0dXJuIG99ZnVuY3Rpb24geXIoZSx0KXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UodCk6bnVsbCE9ZSYmKGUuY3VycmVudD10KX14ci5wcmVsb2FkPShlLHQ9YCR7aHJ9L2Jhc2lzL2ApPT5hLnVzZUxvYWRlci5wcmVsb2FkKGQuS1RYMkxvYWRlcixlLChlPT57ZS5zZXRUcmFuc2NvZGVyUGF0aCh0KX0pKSx4ci5jbGVhcj1lPT5hLnVzZUxvYWRlci5jbGVhcihkLktUWDJMb2FkZXIsZSk7ZnVuY3Rpb24gdnIoZSx0LC4uLnIpe2NvbnN0IG49UC51c2VSZWYoKSxvPWEudXNlVGhyZWUoKGU9PmUuc2NlbmUpKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57bGV0IGE7aWYoZSYmbnVsbCE9ZSYmZS5jdXJyZW50JiZ0JiYobi5jdXJyZW50PWE9bmV3IHQoZS5jdXJyZW50LC4uLnIpKSxhKXJldHVybiBhLnRyYXZlcnNlKChlPT5lLnJheWNhc3Q9KCk9Pm51bGwpKSxvLmFkZChhKSwoKT0+e24uY3VycmVudD12b2lkIDAsby5yZW1vdmUoYSksbnVsbD09YS5kaXNwb3NlfHxhLmRpc3Bvc2UoKX19KSxbbyx0LGUsLi4ucl0pLGEudXNlRnJhbWUoKCgpPT57dmFyIGU7bnVsbD09KGU9bi5jdXJyZW50KXx8bnVsbD09ZS51cGRhdGV8fGUudXBkYXRlKCl9KSksbn1jb25zdCBncj1lPT5lLmlzTWVzaDtjb25zdCB6cj1QLmZvcndhcmRSZWYoKCh7ZW5hYmxlZDplPSEwLGZpcnN0SGl0T25seTp0PSExLGNoaWxkcmVuOnIsc3RyYXRlZ3k6bz13LlNBSCx2ZXJib3NlOmk9ITEsc2V0Qm91bmRpbmdCb3g6cz0hMCxtYXhEZXB0aDpsPTQwLG1heExlYWZUcmlzOmM9MTAsaW5kaXJlY3Q6dT0hMSwuLi5kfSxtKT0+e2NvbnN0IGY9UC51c2VSZWYobnVsbCkscD1hLnVzZVRocmVlKChlPT5lLnJheWNhc3RlcikpO3JldHVybiBQLnVzZUltcGVyYXRpdmVIYW5kbGUobSwoKCk9PmYuY3VycmVudCksW10pLFAudXNlRWZmZWN0KCgoKT0+e2lmKGUpe2NvbnN0IGU9e3N0cmF0ZWd5Om8sdmVyYm9zZTppLHNldEJvdW5kaW5nQm94OnMsbWF4RGVwdGg6bCxtYXhMZWFmVHJpczpjLGluZGlyZWN0OnV9LHI9Zi5jdXJyZW50O3JldHVybiBwLmZpcnN0SGl0T25seT10LHIudHJhdmVyc2UoKHQ9Pntncih0KSYmIXQuZ2VvbWV0cnkuYm91bmRzVHJlZSYmdC5yYXljYXN0PT09bi5NZXNoLnByb3RvdHlwZS5yYXljYXN0JiYodC5yYXljYXN0PXcuYWNjZWxlcmF0ZWRSYXljYXN0LHQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kc1RyZWU9dy5jb21wdXRlQm91bmRzVHJlZSx0Lmdlb21ldHJ5LmRpc3Bvc2VCb3VuZHNUcmVlPXcuZGlzcG9zZUJvdW5kc1RyZWUsdC5nZW9tZXRyeS5jb21wdXRlQm91bmRzVHJlZShlKSl9KSksKCk9PntkZWxldGUgcC5maXJzdEhpdE9ubHksci50cmF2ZXJzZSgoZT0+e2dyKGUpJiZlLmdlb21ldHJ5LmJvdW5kc1RyZWUmJihlLmdlb21ldHJ5LmRpc3Bvc2VCb3VuZHNUcmVlKCksZS5yYXljYXN0PW4uTWVzaC5wcm90b3R5cGUucmF5Y2FzdCl9KSl9fX0pLFtdKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLEMuZGVmYXVsdCh7cmVmOmZ9LGQpLHIpfSkpO2Z1bmN0aW9uIHdyKGUpe2NvbnN0IHQ9UC51c2VSZWYobnVsbCkscj1QLnVzZVJlZighMSksbj1QLnVzZVJlZighMSksbz1QLnVzZVJlZihlKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57by5jdXJyZW50PWV9KSxbZV0pLFAudXNlRWZmZWN0KCgoKT0+e2NvbnN0IGU9dC5jdXJyZW50O2lmKGUpe2NvbnN0IHQ9YS5hZGRFZmZlY3QoKCgpPT4oci5jdXJyZW50PSExLCEwKSkpLGk9ZS5vbkJlZm9yZVJlbmRlcjtlLm9uQmVmb3JlUmVuZGVyPSgpPT5yLmN1cnJlbnQ9ITA7Y29uc3Qgcz1hLmFkZEFmdGVyRWZmZWN0KCgoKT0+KHIuY3VycmVudCE9PW4uY3VycmVudCYmKG51bGw9PW8uY3VycmVudHx8by5jdXJyZW50KG4uY3VycmVudD1yLmN1cnJlbnQpKSwhMCkpKTtyZXR1cm4oKT0+e2Uub25CZWZvcmVSZW5kZXI9aSx0KCkscygpfX19KSxbXSksdH1jb25zdCBicj1cIlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggRElTVEFOQ0UgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4gICNpZmRlZiBCT1hfUFJPSkVDVEVEX0VOVl9NQVBcXG4gICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4gICNlbmRpZlxcbiNlbmRpZlxcblwiLE1yPVwiXFxuI2lmZGVmIEJPWF9QUk9KRUNURURfRU5WX01BUFxcbiAgdW5pZm9ybSB2ZWMzIGVudk1hcFNpemU7XFxuICB1bmlmb3JtIHZlYzMgZW52TWFwUG9zaXRpb247XFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAgIFxcbiAgdmVjMyBwYXJhbGxheENvcnJlY3ROb3JtYWwoIHZlYzMgdiwgdmVjMyBjdWJlU2l6ZSwgdmVjMyBjdWJlUG9zICkge1xcbiAgICB2ZWMzIG5EaXIgPSBub3JtYWxpemUoIHYgKTtcXG4gICAgdmVjMyByYm1heCA9ICggLjUgKiBjdWJlU2l6ZSArIGN1YmVQb3MgLSB2V29ybGRQb3NpdGlvbiApIC8gbkRpcjtcXG4gICAgdmVjMyByYm1pbiA9ICggLS41ICogY3ViZVNpemUgKyBjdWJlUG9zIC0gdldvcmxkUG9zaXRpb24gKSAvIG5EaXI7XFxuICAgIHZlYzMgcmJtaW5tYXg7XFxuICAgIHJibWlubWF4LnggPSAoIG5EaXIueCA+IDAuICkgPyByYm1heC54IDogcmJtaW4ueDtcXG4gICAgcmJtaW5tYXgueSA9ICggbkRpci55ID4gMC4gKSA/IHJibWF4LnkgOiByYm1pbi55O1xcbiAgICByYm1pbm1heC56ID0gKCBuRGlyLnogPiAwLiApID8gcmJtYXgueiA6IHJibWluLno7XFxuICAgIGZsb2F0IGNvcnJlY3Rpb24gPSBtaW4oIG1pbiggcmJtaW5tYXgueCwgcmJtaW5tYXgueSApLCByYm1pbm1heC56ICk7XFxuICAgIHZlYzMgYm94SW50ZXJzZWN0aW9uID0gdldvcmxkUG9zaXRpb24gKyBuRGlyICogY29ycmVjdGlvbjsgICAgXFxuICAgIHJldHVybiBib3hJbnRlcnNlY3Rpb24gLSBjdWJlUG9zO1xcbiAgfVxcbiNlbmRpZlxcblwiLEVyPVwiXFxuI2lmZGVmIEJPWF9QUk9KRUNURURfRU5WX01BUFxcbiAgd29ybGROb3JtYWwgPSBwYXJhbGxheENvcnJlY3ROb3JtYWwoIHdvcmxkTm9ybWFsLCBlbnZNYXBTaXplLCBlbnZNYXBQb3NpdGlvbiApO1xcbiNlbmRpZlxcblwiLFNyPVwiXFxuI2lmZGVmIEJPWF9QUk9KRUNURURfRU5WX01BUFxcbiAgcmVmbGVjdFZlYyA9IHBhcmFsbGF4Q29ycmVjdE5vcm1hbCggcmVmbGVjdFZlYywgZW52TWFwU2l6ZSwgZW52TWFwUG9zaXRpb24gKTtcXG4jZW5kaWZcXG5cIjtjb25zdCBUcj1uZXcgRC5Cb3gzLENyPW5ldyBELlZlY3RvcjM7Y29uc3QgUHI9ZT0+TWF0aC5zcXJ0KDEtTWF0aC5wb3coZS0xLDIpKTtjbGFzcyBScntjb25zdHJ1Y3Rvcih7c2l6ZTplPTI1NixtYXhBZ2U6dD03NTAscmFkaXVzOnI9LjMsaW50ZW5zaXR5Om49LjIsaW50ZXJwb2xhdGU6YT0wLHNtb290aGluZzpvPTAsbWluRm9yY2U6aT0uMyxibGVuZDpzPVwic2NyZWVuXCIsZWFzZTpsPVByfT17fSl7dGhpcy5zaXplPWUsdGhpcy5tYXhBZ2U9dCx0aGlzLnJhZGl1cz1yLHRoaXMuaW50ZW5zaXR5PW4sdGhpcy5lYXNlPWwsdGhpcy5pbnRlcnBvbGF0ZT1hLHRoaXMuc21vb3RoaW5nPW8sdGhpcy5taW5Gb3JjZT1pLHRoaXMuYmxlbmQ9cyx0aGlzLnRyYWlsPVtdLHRoaXMuZm9yY2U9MCx0aGlzLmluaXRUZXh0dXJlKCl9aW5pdFRleHR1cmUoKXt0aGlzLmNhbnZhcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHRoaXMuY2FudmFzLndpZHRoPXRoaXMuY2FudmFzLmhlaWdodD10aGlzLnNpemUsdGhpcy5jdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLHRoaXMuY3R4LmZpbGxTdHlsZT1cImJsYWNrXCIsdGhpcy5jdHguZmlsbFJlY3QoMCwwLHRoaXMuY2FudmFzLndpZHRoLHRoaXMuY2FudmFzLmhlaWdodCksdGhpcy50ZXh0dXJlPW5ldyBuLlRleHR1cmUodGhpcy5jYW52YXMpLHRoaXMuY2FudmFzLmlkPVwidG91Y2hUZXh0dXJlXCIsdGhpcy5jYW52YXMuc3R5bGUud2lkdGg9dGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0PWAke3RoaXMuY2FudmFzLndpZHRofXB4YH11cGRhdGUoZSl7dGhpcy5jbGVhcigpLHRoaXMudHJhaWwuZm9yRWFjaCgoKHQscik9Pnt0LmFnZSs9MWUzKmUsdC5hZ2U+dGhpcy5tYXhBZ2UmJnRoaXMudHJhaWwuc3BsaWNlKHIsMSl9KSksdGhpcy50cmFpbC5sZW5ndGh8fCh0aGlzLmZvcmNlPTApLHRoaXMudHJhaWwuZm9yRWFjaCgoZT0+e3RoaXMuZHJhd1RvdWNoKGUpfSkpLHRoaXMudGV4dHVyZS5uZWVkc1VwZGF0ZT0hMH1jbGVhcigpe3RoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1vdmVyXCIsdGhpcy5jdHguZmlsbFN0eWxlPVwiYmxhY2tcIix0aGlzLmN0eC5maWxsUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsdGhpcy5jYW52YXMuaGVpZ2h0KX1hZGRUb3VjaChlKXtjb25zdCB0PXRoaXMudHJhaWxbdGhpcy50cmFpbC5sZW5ndGgtMV07aWYodCl7Y29uc3Qgcj10LngtZS54LG49dC55LWUueSxhPXIqcituKm4sbz1NYXRoLm1heCh0aGlzLm1pbkZvcmNlLE1hdGgubWluKDFlNCphLDEpKTtpZih0aGlzLmZvcmNlPWZ1bmN0aW9uKGUsdCxyPS45KXtyZXR1cm4gdCpyK2UqKDEtcil9KG8sdGhpcy5mb3JjZSx0aGlzLnNtb290aGluZyksdGhpcy5pbnRlcnBvbGF0ZSl7Y29uc3QgZT1NYXRoLmNlaWwoYS9NYXRoLnBvdyguNSp0aGlzLnJhZGl1cy90aGlzLmludGVycG9sYXRlLDIpKTtpZihlPjEpZm9yKGxldCBhPTE7YTxlO2ErKyl0aGlzLnRyYWlsLnB1c2goe3g6dC54LXIvZSphLHk6dC55LW4vZSphLGFnZTowLGZvcmNlOm99KX19dGhpcy50cmFpbC5wdXNoKHt4OmUueCx5OmUueSxhZ2U6MCxmb3JjZTp0aGlzLmZvcmNlfSl9ZHJhd1RvdWNoKGUpe2NvbnN0IHQ9e3g6ZS54KnRoaXMuc2l6ZSx5OigxLWUueSkqdGhpcy5zaXplfTtsZXQgcj0xO3I9ZS5hZ2U8LjMqdGhpcy5tYXhBZ2U/dGhpcy5lYXNlKGUuYWdlLyguMyp0aGlzLm1heEFnZSkpOnRoaXMuZWFzZSgxLShlLmFnZS0uMyp0aGlzLm1heEFnZSkvKC43KnRoaXMubWF4QWdlKSkscio9ZS5mb3JjZSx0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249dGhpcy5ibGVuZDtjb25zdCBuPXRoaXMuc2l6ZSp0aGlzLnJhZGl1cypyLGE9dGhpcy5jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodC54LHQueSxNYXRoLm1heCgwLC4yNSpuKSx0LngsdC55LE1hdGgubWF4KDAsbikpO2EuYWRkQ29sb3JTdG9wKDAsYHJnYmEoMjU1LCAyNTUsIDI1NSwgJHt0aGlzLmludGVuc2l0eX0pYCksYS5hZGRDb2xvclN0b3AoMSxcInJnYmEoMCwgMCwgMCwgMC4wKVwiKSx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5maWxsU3R5bGU9YSx0aGlzLmN0eC5hcmModC54LHQueSxNYXRoLm1heCgwLG4pLDAsMipNYXRoLlBJKSx0aGlzLmN0eC5maWxsKCl9fWNvbnN0IERyPVAuZm9yd2FyZFJlZigoZnVuY3Rpb24oe2NoaWxkcmVuOmUsZGlzYWJsZTp0LGRpc2FibGVYOnIsZGlzYWJsZVk6YSxkaXNhYmxlWjpvLGxlZnQ6aSxyaWdodDpzLHRvcDpsLGJvdHRvbTpjLGZyb250OnUsYmFjazpkLG9uQ2VudGVyZWQ6bSxwcmVjaXNlOmY9ITAsY2FjaGVLZXk6cD0wLC4uLmh9LHgpe2NvbnN0IHk9UC51c2VSZWYobnVsbCksdj1QLnVzZVJlZihudWxsKSxnPVAudXNlUmVmKG51bGwpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt2LmN1cnJlbnQubWF0cml4V29ybGQuaWRlbnRpdHkoKTtjb25zdCBlPShuZXcgbi5Cb3gzKS5zZXRGcm9tT2JqZWN0KGcuY3VycmVudCxmKSxwPW5ldyBuLlZlY3RvcjMsaD1uZXcgbi5TcGhlcmUseD1lLm1heC54LWUubWluLngsej1lLm1heC55LWUubWluLnksdz1lLm1heC56LWUubWluLno7ZS5nZXRDZW50ZXIocCksZS5nZXRCb3VuZGluZ1NwaGVyZShoKTtjb25zdCBiPWw/ei8yOmM/LXovMjowLE09aT8teC8yOnM/eC8yOjAsRT11P3cvMjpkPy13LzI6MDt2LmN1cnJlbnQucG9zaXRpb24uc2V0KHR8fHI/MDotcC54K00sdHx8YT8wOi1wLnkrYix0fHxvPzA6LXAueitFKSx2b2lkIDAhPT1tJiZtKHtwYXJlbnQ6eS5jdXJyZW50LnBhcmVudCxjb250YWluZXI6eS5jdXJyZW50LHdpZHRoOngsaGVpZ2h0OnosZGVwdGg6dyxib3VuZGluZ0JveDplLGJvdW5kaW5nU3BoZXJlOmgsY2VudGVyOnAsdmVydGljYWxBbGlnbm1lbnQ6Yixob3Jpem9udGFsQWxpZ25tZW50Ok0sZGVwdGhBbGlnbm1lbnQ6RX0pfSksW3AsbSxsLGksdSx0LHIsYSxvLGYscyxjLGRdKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUoeCwoKCk9PnkuY3VycmVudCksW10pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6eX0saCksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnZ9LFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpnfSxlKSkpfSkpLEZyPVAuZm9yd2FyZFJlZigoKHtmb250OmUsY29sb3I6dD1cIiNjYmNiY2JcIixiZXZlbFNpemU6cj0uMDQsZGVidWc6bj0hMSxjaGlsZHJlbjphLC4uLm99LGkpPT57Y29uc3RbcyxsXT1QLnVzZVN0YXRlKDApLGM9UC51c2VDYWxsYmFjaygoKGU9MSk9PmwocytlKSksW3NdKSx1PVAudXNlQ2FsbGJhY2soKChlPTEpPT5sKHMtZSkpLFtzXSksZD1QLnVzZU1lbW8oKCgpPT4oe2luY3I6YyxkZWNyOnV9KSksW2MsdV0pO3JldHVybiBQLnVzZUltcGVyYXRpdmVIYW5kbGUoaSwoKCk9PmQpLFtkXSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixvLFAuY3JlYXRlRWxlbWVudChQLlN1c3BlbnNlLHtmYWxsYmFjazpudWxsfSxQLmNyZWF0ZUVsZW1lbnQoRHIse3RvcDohMCxjYWNoZUtleTpKU09OLnN0cmluZ2lmeSh7Y291bnRlcjpzLGZvbnQ6ZX0pfSxQLmNyZWF0ZUVsZW1lbnQod2Use2JldmVsRW5hYmxlZDohMCxiZXZlbFNpemU6cixmb250OmV9LG4/UC5jcmVhdGVFbGVtZW50KFwibWVzaE5vcm1hbE1hdGVyaWFsXCIse3dpcmVmcmFtZTohMH0pOlAuY3JlYXRlRWxlbWVudChcIm1lc2hTdGFuZGFyZE1hdGVyaWFsXCIse2NvbG9yOnR9KSxzKSkpLGEpfSkpLGtyPVAuZm9yd2FyZFJlZigoKHtzdGFydEZyYW1lOmUsZW5kRnJhbWU6dCxmcHM6cixmcmFtZU5hbWU6bix0ZXh0dXJlRGF0YVVSTDpvLHRleHR1cmVJbWFnZVVSTDppLGxvb3A6cyxudW1iZXJPZkZyYW1lczpsLGF1dG9QbGF5OmMsYW5pbWF0aW9uTmFtZXM6dSxvblN0YXJ0OmQsb25FbmQ6bSxvbkxvb3BFbmQ6ZixvbkZyYW1lOnAscGxheTpoLHBhdXNlOngsZmxpcFg6eSxhbHBoYVRlc3Q6dixjaGlsZHJlbjpnLGFzU3ByaXRlOnoscmVzZXRPbkVuZDp3LC4uLmJ9LE0pPT57Y29uc3QgRT1QLnVzZVJlZihudWxsKSxbUyxUXT1QLnVzZVN0YXRlKCExKSxSPVAudXNlUmVmKCExKSxGPVAudXNlUmVmKCksaz1QLnVzZVJlZigpLF89UC51c2VSZWYod2luZG93LnBlcmZvcm1hbmNlLm5vdygpKSxBPVAudXNlUmVmKCksTD1QLnVzZVJlZihlfHwwKSxCPVAudXNlUmVmKG58fFwiXCIpLFU9MWUzLyhyfHwzMCksW0ksVl09UC51c2VTdGF0ZShuZXcgRC5UZXh0dXJlKSxPPVAudXNlUmVmKDApLFtOLGpdPVAudXNlU3RhdGUoWzEsMSwxXSksVz15Py0xOjEsW0csSF09UC51c2VTdGF0ZShudWxsPT16fHx6KSwkPVAudXNlUmVmKHgpO2NvbnN0IHE9KGUsdCk9Pntjb25zdCByPXQvZTtyZXR1cm4gay5jdXJyZW50JiZrLmN1cnJlbnQuc2NhbGUuc2V0KDEsciwxKSxbMSxyLDFdfTtQLnVzZUVmZmVjdCgoKCk9PntpZihvJiZpKSFmdW5jdGlvbihlLHQscil7Y29uc3Qgbj1uZXcgRC5UZXh0dXJlTG9hZGVyLGE9ZmV0Y2goZSkudGhlbigoZT0+ZS5qc29uKCkpKSxvPW5ldyBQcm9taXNlKChlPT57bi5sb2FkKHQsZSl9KSk7UHJvbWlzZS5hbGwoW2Esb10pLnRoZW4oKGU9PntyKGVbMF0sZVsxXSl9KSl9KG8saSxYKTtlbHNlIGlmKGkpe2NvbnN0IGU9bmV3IEQuVGV4dHVyZUxvYWRlcjtuZXcgUHJvbWlzZSgodD0+e2UubG9hZChpLHQpfSkpLnRoZW4oKGU9PntYKG51bGwsZSl9KSl9fSksW10pLFAudXNlRWZmZWN0KCgoKT0+e0gobnVsbD09enx8eil9KSxbel0pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e1koKX0pLFtJLHldKSxQLnVzZUVmZmVjdCgoKCk9PntjJiYoJC5jdXJyZW50PSExKX0pLFtjXSksUC51c2VFZmZlY3QoKCgpPT57aWYoQi5jdXJyZW50IT09biYmbiYmKEwuY3VycmVudD0wLEIuY3VycmVudD1uLFIuY3VycmVudD0hMSxZKCksRS5jdXJyZW50KSl7Y29uc3R7dzplLGg6dH09SyhFLmN1cnJlbnQuZnJhbWVzKS5zb3VyY2VTaXplLHI9cShlLHQpO2oocil9fSksW25dKTtjb25zdCBYPShlLHQpPT57aWYobnVsbD09PWUpe2lmKGwpe2NvbnN0IGU9dC5pbWFnZS53aWR0aCxyPXQuaW1hZ2UuaGVpZ2h0LG49ZS9sLGE9cjtpZihBLmN1cnJlbnQ9dCxPLmN1cnJlbnQ9bCxFLmN1cnJlbnQ9e2ZyYW1lczpbXSxtZXRhOnt2ZXJzaW9uOlwiMS4wXCIsc2l6ZTp7dzplLGg6cn0sc2NhbGU6XCIxXCJ9fSxwYXJzZUludChuLnRvU3RyaW5nKCksMTApPT09bilmb3IobGV0IGU9MDtlPGw7ZSsrKUUuY3VycmVudC5mcmFtZXMucHVzaCh7ZnJhbWU6e3g6ZSpuLHk6MCx3Om4saDphfSxyb3RhdGVkOiExLHRyaW1tZWQ6ITEsc3ByaXRlU291cmNlU2l6ZTp7eDowLHk6MCx3Om4saDphfSxzb3VyY2VTaXplOnt3Om4saDpyfX0pfX1lbHNle0UuY3VycmVudD1lLEUuY3VycmVudC5mcmFtZXM9QXJyYXkuaXNBcnJheShlLmZyYW1lcyk/ZS5mcmFtZXM6WigpLE8uY3VycmVudD1BcnJheS5pc0FycmF5KGUuZnJhbWVzKT9lLmZyYW1lcy5sZW5ndGg6T2JqZWN0LmtleXMoZS5mcmFtZXMpLmxlbmd0aCxBLmN1cnJlbnQ9dDtjb25zdHt3OnIsaDpufT1LKGUuZnJhbWVzKS5zb3VyY2VTaXplLGE9cShyLG4pO2ooYSksRi5jdXJyZW50JiYoRi5jdXJyZW50Lm1hcD10KX10LnByZW11bHRpcGx5QWxwaGE9ITEsVih0KX0sWj0oKT0+e2NvbnN0IGU9e30sdD1FLmN1cnJlbnQscj11O2lmKHIpe2ZvcihsZXQgbj0wO248ci5sZW5ndGg7bisrKXtlW3Jbbl1dPVtdO2Zvcihjb25zdCBhIGluIHQuZnJhbWVzKXtjb25zdCBvPXQuZnJhbWVzW2FdLGk9by5mcmFtZSxzPWkueCxsPWkueSxjPWkudyx1PWkuaCxkPW8uc291cmNlU2l6ZS53LG09by5zb3VyY2VTaXplLmg7LTEhPT1hLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihyW25dLnRvTG93ZXJDYXNlKCkpJiZlW3Jbbl1dLnB1c2goe3g6cyx5OmwsdzpjLGg6dSxmcmFtZTppLHNvdXJjZVNpemU6e3c6ZCxoOm19fSl9fXJldHVybiBlfWlmKG4pe2NvbnN0IGU9W107Zm9yKGNvbnN0IHIgaW4gdC5mcmFtZXMpZS5wdXNoKHQuZnJhbWVzW3JdKTtyZXR1cm4gZX19LFk9KCk9PntpZighRS5jdXJyZW50KXJldHVybjtjb25zdHttZXRhOntzaXplOmV9LGZyYW1lczp0fT1FLmN1cnJlbnQse3c6cixoOmF9PUFycmF5LmlzQXJyYXkodCk/dFswXS5zb3VyY2VTaXplOm4mJnRbbl0/dFtuXVswXS5zb3VyY2VTaXplOnt3OjAsaDowfTtGLmN1cnJlbnQubWFwLndyYXBTPUYuY3VycmVudC5tYXAud3JhcFQ9RC5SZXBlYXRXcmFwcGluZyxGLmN1cnJlbnQubWFwLmNlbnRlci5zZXQoMCwwKSxGLmN1cnJlbnQubWFwLnJlcGVhdC5zZXQoMSpXLyhlLncvciksMS8oZS5oL2EpKTtjb25zdCBvPTEvKChlLmgtMSkvYSk7Ri5jdXJyZW50Lm1hcC5vZmZzZXQueD0wLEYuY3VycmVudC5tYXAub2Zmc2V0Lnk9MS1vLFQoITApLGQmJmQoe2N1cnJlbnRGcmFtZU5hbWU6bixjdXJyZW50RnJhbWU6TC5jdXJyZW50fSl9LFE9KGUsdCxyLG4pPT57bGV0IGE9MCxvPTA7cShlLHQpO2NvbnN0IGk9KHIudy0xKS9lLHM9KHIuaC0xKS90LHtmcmFtZTp7eDpsLHk6Y30sc291cmNlU2l6ZTp7dzp1LGg6ZH19PW5bTC5jdXJyZW50XSxtPTEvaSxmPTEvczthPVc+MD9tKihsL3UpOm0qKGwvdSktRi5jdXJyZW50Lm1hcC5yZXBlYXQueCxvPU1hdGguYWJzKDEtZiktZiooYy9kKSxGLmN1cnJlbnQubWFwLm9mZnNldC54PWEsRi5jdXJyZW50Lm1hcC5vZmZzZXQueT1vfTthLnVzZUZyYW1lKCgocixhKT0+e3ZhciBvLGk7bnVsbCE9KG89RS5jdXJyZW50KSYmby5mcmFtZXMmJm51bGwhPShpPUYuY3VycmVudCkmJmkubWFwJiYoJC5jdXJyZW50fHxSLmN1cnJlbnR8fCFjJiYhaHx8KCgoKT0+e2NvbnN0IHI9d2luZG93LnBlcmZvcm1hbmNlLm5vdygpLGE9ci1fLmN1cnJlbnQse21ldGE6e3NpemU6b30sZnJhbWVzOml9PUUuY3VycmVudCx7dzpsLGg6Y309SyhpKS5zb3VyY2VTaXplLHU9QXJyYXkuaXNBcnJheShpKT9pOm4/aVtuXTpbXSxkPXR8fHUubGVuZ3RoLTE7TC5jdXJyZW50PmQmJihMLmN1cnJlbnQ9cyYmbnVsbCE9ZT9lOjAscz9udWxsPT1mfHxmKHtjdXJyZW50RnJhbWVOYW1lOm4sY3VycmVudEZyYW1lOkwuY3VycmVudH0pOihudWxsPT1tfHxtKHtjdXJyZW50RnJhbWVOYW1lOm4sY3VycmVudEZyYW1lOkwuY3VycmVudH0pLFIuY3VycmVudD0hdyx3JiYoJC5jdXJyZW50PSEwKSksIXMpfHxhPD1VfHwoXy5jdXJyZW50PXItYSVVLFEobCxjLG8sdSksTC5jdXJyZW50Kz0xKX0pKCkscCYmcCh7Y3VycmVudEZyYW1lTmFtZTpCLmN1cnJlbnQsY3VycmVudEZyYW1lOkwuY3VycmVudH0pKSl9KSk7Y29uc3QgSz1lPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZVswXTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUpe2NvbnN0IHQ9T2JqZWN0LmtleXMoZSk7cmV0dXJuIG4/ZVtuXVswXTplW3RbMF1dWzBdfXJldHVybnt3OjAsaDowfX07cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6TX0sYiksUC5jcmVhdGVFbGVtZW50KFAuU3VzcGVuc2Use2ZhbGxiYWNrOm51bGx9LEcmJlAuY3JlYXRlRWxlbWVudChcInNwcml0ZVwiLHtyZWY6ayxzY2FsZTpOfSxQLmNyZWF0ZUVsZW1lbnQoXCJzcHJpdGVNYXRlcmlhbFwiLHt0b25lTWFwcGVkOiExLHJlZjpGLG1hcDpJLHRyYW5zcGFyZW50OiEwLGFscGhhVGVzdDpudWxsIT12P3Y6MH0pKSwhRyYmUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZWY6ayxzY2FsZTpOfSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6WzEsMV19KSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0b25lTWFwcGVkOiExLHNpZGU6RC5Eb3VibGVTaWRlLHJlZjpGLG1hcDpJLHRyYW5zcGFyZW50OiEwLGFscGhhVGVzdDpudWxsIT12P3Y6MH0pKSksZyl9KSksX3I9UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsY3VydmU6dH0scik9Pntjb25zdFtuXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuU2NlbmUpKSxbbyxpXT1QLnVzZVN0YXRlKCkscz1QLnVzZVJlZigpO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PntzLmN1cnJlbnQ9bmV3IGQuRmxvdyhuLmNoaWxkcmVuWzBdKSxpKHMuY3VycmVudC5vYmplY3QzRCl9KSxbZV0pLFAudXNlRWZmZWN0KCgoKT0+e3ZhciBlO3QmJihudWxsPT0oZT1zLmN1cnJlbnQpfHxlLnVwZGF0ZUN1cnZlKDAsdCkpfSksW3RdKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUociwoKCk9Pih7bW92ZUFsb25nQ3VydmU6ZT0+e3ZhciB0O251bGw9PSh0PXMuY3VycmVudCl8fHQubW92ZUFsb25nQ3VydmUoZSl9fSkpKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGEuY3JlYXRlUG9ydGFsKGUsbiksbyYmUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIse29iamVjdDpvfSkpfSkpO2NsYXNzIEFyIGV4dGVuZHMgbi5NZXNoUGh5c2ljYWxNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPXt9KXtzdXBlcihlKSx0aGlzLnNldFZhbHVlcyhlKSx0aGlzLl90aW1lPXt2YWx1ZTowfSx0aGlzLl9kaXN0b3J0PXt2YWx1ZTouNH0sdGhpcy5fcmFkaXVzPXt2YWx1ZToxfX1vbkJlZm9yZUNvbXBpbGUoZSl7ZS51bmlmb3Jtcy50aW1lPXRoaXMuX3RpbWUsZS51bmlmb3Jtcy5yYWRpdXM9dGhpcy5fcmFkaXVzLGUudW5pZm9ybXMuZGlzdG9ydD10aGlzLl9kaXN0b3J0LGUudmVydGV4U2hhZGVyPWBcXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0O1xcbiAgICAgICNkZWZpbmUgR0xTTElGWSAxXFxudmVjMyBtb2QyODkodmVjMyB4KXtyZXR1cm4geC1mbG9vcih4KigxLjAvMjg5LjApKSoyODkuMDt9dmVjNCBtb2QyODkodmVjNCB4KXtyZXR1cm4geC1mbG9vcih4KigxLjAvMjg5LjApKSoyODkuMDt9dmVjNCBwZXJtdXRlKHZlYzQgeCl7cmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTt9dmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcil7cmV0dXJuIDEuNzkyODQyOTE0MDAxNTktMC44NTM3MzQ3MjA5NTMxNCpyO31mbG9hdCBzbm9pc2UodmVjMyB2KXtjb25zdCB2ZWMyIEM9dmVjMigxLjAvNi4wLDEuMC8zLjApO2NvbnN0IHZlYzQgRD12ZWM0KDAuMCwwLjUsMS4wLDIuMCk7dmVjMyBpPWZsb29yKHYrZG90KHYsQy55eXkpKTt2ZWMzIHgwPXYtaStkb3QoaSxDLnh4eCk7dmVjMyBnPXN0ZXAoeDAueXp4LHgwLnh5eik7dmVjMyBsPTEuMC1nO3ZlYzMgaTE9bWluKGcueHl6LGwuenh5KTt2ZWMzIGkyPW1heChnLnh5eixsLnp4eSk7dmVjMyB4MT14MC1pMStDLnh4eDt2ZWMzIHgyPXgwLWkyK0MueXl5O3ZlYzMgeDM9eDAtRC55eXk7aT1tb2QyODkoaSk7dmVjNCBwPXBlcm11dGUocGVybXV0ZShwZXJtdXRlKGkueit2ZWM0KDAuMCxpMS56LGkyLnosMS4wKSkraS55K3ZlYzQoMC4wLGkxLnksaTIueSwxLjApKStpLngrdmVjNCgwLjAsaTEueCxpMi54LDEuMCkpO2Zsb2F0IG5fPTAuMTQyODU3MTQyODU3O3ZlYzMgbnM9bl8qRC53eXotRC54eng7dmVjNCBqPXAtNDkuMCpmbG9vcihwKm5zLnoqbnMueik7dmVjNCB4Xz1mbG9vcihqKm5zLnopO3ZlYzQgeV89Zmxvb3Ioai03LjAqeF8pO3ZlYzQgeD14Xypucy54K25zLnl5eXk7dmVjNCB5PXlfKm5zLngrbnMueXl5eTt2ZWM0IGg9MS4wLWFicyh4KS1hYnMoeSk7dmVjNCBiMD12ZWM0KHgueHkseS54eSk7dmVjNCBiMT12ZWM0KHguencseS56dyk7dmVjNCBzMD1mbG9vcihiMCkqMi4wKzEuMDt2ZWM0IHMxPWZsb29yKGIxKSoyLjArMS4wO3ZlYzQgc2g9LXN0ZXAoaCx2ZWM0KDAuMCkpO3ZlYzQgYTA9YjAueHp5dytzMC54enl3KnNoLnh4eXk7dmVjNCBhMT1iMS54enl3K3MxLnh6eXcqc2guenp3dzt2ZWMzIHAwPXZlYzMoYTAueHksaC54KTt2ZWMzIHAxPXZlYzMoYTAuencsaC55KTt2ZWMzIHAyPXZlYzMoYTEueHksaC56KTt2ZWMzIHAzPXZlYzMoYTEuencsaC53KTt2ZWM0IG5vcm09dGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksZG90KHAxLHAxKSxkb3QocDIscDIpLGRvdChwMyxwMykpKTtwMCo9bm9ybS54O3AxKj1ub3JtLnk7cDIqPW5vcm0uejtwMyo9bm9ybS53O3ZlYzQgbT1tYXgoMC42LXZlYzQoZG90KHgwLHgwKSxkb3QoeDEseDEpLGRvdCh4Mix4MiksZG90KHgzLHgzKSksMC4wKTttPW0qbTtyZXR1cm4gNDIuMCpkb3QobSptLHZlYzQoZG90KHAwLHgwKSxkb3QocDEseDEpLGRvdChwMix4MiksZG90KHAzLHgzKSkpO31cXG4gICAgICAke2UudmVydGV4U2hhZGVyfVxcbiAgICBgLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlwiLFwiXFxuICAgICAgICBmbG9hdCB1cGRhdGVUaW1lID0gdGltZSAvIDUwLjA7XFxuICAgICAgICBmbG9hdCBub2lzZSA9IHNub2lzZSh2ZWMzKHBvc2l0aW9uIC8gMi4wICsgdXBkYXRlVGltZSAqIDUuMCkpO1xcbiAgICAgICAgdmVjMyB0cmFuc2Zvcm1lZCA9IHZlYzMocG9zaXRpb24gKiAobm9pc2UgKiBwb3coZGlzdG9ydCwgMi4wKSArIHJhZGl1cykpO1xcbiAgICAgICAgXCIpfWdldCB0aW1lKCl7cmV0dXJuIHRoaXMuX3RpbWUudmFsdWV9c2V0IHRpbWUoZSl7dGhpcy5fdGltZS52YWx1ZT1lfWdldCBkaXN0b3J0KCl7cmV0dXJuIHRoaXMuX2Rpc3RvcnQudmFsdWV9c2V0IGRpc3RvcnQoZSl7dGhpcy5fZGlzdG9ydC52YWx1ZT1lfWdldCByYWRpdXMoKXtyZXR1cm4gdGhpcy5fcmFkaXVzLnZhbHVlfXNldCByYWRpdXMoZSl7dGhpcy5fcmFkaXVzLnZhbHVlPWV9fWNvbnN0IExyPVAuZm9yd2FyZFJlZigoKHtzcGVlZDplPTEsLi4udH0scik9Pntjb25zdFtuXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEFyKSk7cmV0dXJuIGEudXNlRnJhbWUoKHQ9Pm4mJihuLnRpbWU9dC5jbG9jay5nZXRFbGFwc2VkVGltZSgpKmUpKSksUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtvYmplY3Q6bixyZWY6cixhdHRhY2g6XCJtYXRlcmlhbFwifSx0KSl9KSk7Y2xhc3MgQnIgZXh0ZW5kcyBuLk1lc2hTdGFuZGFyZE1hdGVyaWFse2NvbnN0cnVjdG9yKGU9e30pe3N1cGVyKGUpLHRoaXMuc2V0VmFsdWVzKGUpLHRoaXMuX3RpbWU9e3ZhbHVlOjB9LHRoaXMuX2ZhY3Rvcj17dmFsdWU6MX19b25CZWZvcmVDb21waWxlKGUpe2UudW5pZm9ybXMudGltZT10aGlzLl90aW1lLGUudW5pZm9ybXMuZmFjdG9yPXRoaXMuX2ZhY3RvcixlLnZlcnRleFNoYWRlcj1gXFxuICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgZmFjdG9yO1xcbiAgICAgICR7ZS52ZXJ0ZXhTaGFkZXJ9XFxuICAgIGAsZS52ZXJ0ZXhTaGFkZXI9ZS52ZXJ0ZXhTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XCIsXCJmbG9hdCB0aGV0YSA9IHNpbiggdGltZSArIHBvc2l0aW9uLnkgKSAvIDIuMCAqIGZhY3RvcjtcXG4gICAgICAgIGZsb2F0IGMgPSBjb3MoIHRoZXRhICk7XFxuICAgICAgICBmbG9hdCBzID0gc2luKCB0aGV0YSApO1xcbiAgICAgICAgbWF0MyBtID0gbWF0MyggYywgMCwgcywgMCwgMSwgMCwgLXMsIDAsIGMgKTtcXG4gICAgICAgIHZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApICogbTtcXG4gICAgICAgIHZOb3JtYWwgPSB2Tm9ybWFsICogbTtcIil9Z2V0IHRpbWUoKXtyZXR1cm4gdGhpcy5fdGltZS52YWx1ZX1zZXQgdGltZShlKXt0aGlzLl90aW1lLnZhbHVlPWV9Z2V0IGZhY3Rvcigpe3JldHVybiB0aGlzLl9mYWN0b3IudmFsdWV9c2V0IGZhY3RvcihlKXt0aGlzLl9mYWN0b3IudmFsdWU9ZX19Y29uc3QgVXI9UC5mb3J3YXJkUmVmKCgoe3NwZWVkOmU9MSwuLi50fSxyKT0+e2NvbnN0W25dPVAudXNlU3RhdGUoKCgpPT5uZXcgQnIpKTtyZXR1cm4gYS51c2VGcmFtZSgodD0+biYmKG4udGltZT10LmNsb2NrLmdldEVsYXBzZWRUaW1lKCkqZSkpKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe29iamVjdDpuLHJlZjpyLGF0dGFjaDpcIm1hdGVyaWFsXCJ9LHQpKX0pKTtjbGFzcyBJciBleHRlbmRzIEQuU2hhZGVyTWF0ZXJpYWx7Y29uc3RydWN0b3IoZT1uZXcgRC5WZWN0b3IyKXtzdXBlcih7dW5pZm9ybXM6e2lucHV0QnVmZmVyOm5ldyBELlVuaWZvcm0obnVsbCksZGVwdGhCdWZmZXI6bmV3IEQuVW5pZm9ybShudWxsKSxyZXNvbHV0aW9uOm5ldyBELlVuaWZvcm0obmV3IEQuVmVjdG9yMiksdGV4ZWxTaXplOm5ldyBELlVuaWZvcm0obmV3IEQuVmVjdG9yMiksaGFsZlRleGVsU2l6ZTpuZXcgRC5Vbmlmb3JtKG5ldyBELlZlY3RvcjIpLGtlcm5lbDpuZXcgRC5Vbmlmb3JtKDApLHNjYWxlOm5ldyBELlVuaWZvcm0oMSksY2FtZXJhTmVhcjpuZXcgRC5Vbmlmb3JtKDApLGNhbWVyYUZhcjpuZXcgRC5Vbmlmb3JtKDEpLG1pbkRlcHRoVGhyZXNob2xkOm5ldyBELlVuaWZvcm0oMCksbWF4RGVwdGhUaHJlc2hvbGQ6bmV3IEQuVW5pZm9ybSgxKSxkZXB0aFNjYWxlOm5ldyBELlVuaWZvcm0oMCksZGVwdGhUb0JsdXJSYXRpb0JpYXM6bmV3IEQuVW5pZm9ybSguMjUpfSxmcmFnbWVudFNoYWRlcjpgI2luY2x1ZGUgPGNvbW1vbj5cXG4gICAgICAgICNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD4gICAgICBcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGlucHV0QnVmZmVyO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGVwdGhCdWZmZXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWluRGVwdGhUaHJlc2hvbGQ7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1heERlcHRoVGhyZXNob2xkO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkZXB0aFNjYWxlO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBkZXB0aFRvQmx1clJhdGlvQmlhcztcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2MDtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYxO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjI7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2MztcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZmxvYXQgZGVwdGhGYWN0b3IgPSAwLjA7XFxuICAgICAgICAgIFxcbiAgICAgICAgICAjaWZkZWYgVVNFX0RFUFRIXFxuICAgICAgICAgICAgdmVjNCBkZXB0aCA9IHRleHR1cmUyRChkZXB0aEJ1ZmZlciwgdlV2KTtcXG4gICAgICAgICAgICBkZXB0aEZhY3RvciA9IHNtb290aHN0ZXAobWluRGVwdGhUaHJlc2hvbGQsIG1heERlcHRoVGhyZXNob2xkLCAxLjAtKGRlcHRoLnIgKiBkZXB0aC5hKSk7XFxuICAgICAgICAgICAgZGVwdGhGYWN0b3IgKj0gZGVwdGhTY2FsZTtcXG4gICAgICAgICAgICBkZXB0aEZhY3RvciA9IG1heCgwLjAsIG1pbigxLjAsIGRlcHRoRmFjdG9yICsgMC4yNSkpO1xcbiAgICAgICAgICAjZW5kaWZcXG4gICAgICAgICAgXFxuICAgICAgICAgIHZlYzQgc3VtID0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCBtaXgodlV2MCwgdlV2LCBkZXB0aEZhY3RvcikpO1xcbiAgICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCBtaXgodlV2MSwgdlV2LCBkZXB0aEZhY3RvcikpO1xcbiAgICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCBtaXgodlV2MiwgdlV2LCBkZXB0aEZhY3RvcikpO1xcbiAgICAgICAgICBzdW0gKz0gdGV4dHVyZTJEKGlucHV0QnVmZmVyLCBtaXgodlV2MywgdlV2LCBkZXB0aEZhY3RvcikpO1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBzdW0gKiAwLjI1IDtcXG5cXG4gICAgICAgICAgI2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG4gICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICAgICAjaW5jbHVkZSA8JHtDZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICAgICAgfWAsdmVydGV4U2hhZGVyOlwidW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXG4gICAgICAgIHVuaWZvcm0gdmVjMiBoYWxmVGV4ZWxTaXplO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBrZXJuZWw7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYwO1xcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjE7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2MjtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXYzO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICB2ZWMyIHV2ID0gcG9zaXRpb24ueHkgKiAwLjUgKyAwLjU7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcblxcbiAgICAgICAgICB2ZWMyIGRVdiA9ICh0ZXhlbFNpemUgKiB2ZWMyKGtlcm5lbCkgKyBoYWxmVGV4ZWxTaXplKSAqIHNjYWxlO1xcbiAgICAgICAgICB2VXYwID0gdmVjMih1di54IC0gZFV2LngsIHV2LnkgKyBkVXYueSk7XFxuICAgICAgICAgIHZVdjEgPSB2ZWMyKHV2LnggKyBkVXYueCwgdXYueSArIGRVdi55KTtcXG4gICAgICAgICAgdlV2MiA9IHZlYzIodXYueCArIGRVdi54LCB1di55IC0gZFV2LnkpO1xcbiAgICAgICAgICB2VXYzID0gdmVjMih1di54IC0gZFV2LngsIHV2LnkgLSBkVXYueSk7XFxuXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSwgMS4wLCAxLjApO1xcbiAgICAgICAgfVwiLGJsZW5kaW5nOkQuTm9CbGVuZGluZyxkZXB0aFdyaXRlOiExLGRlcHRoVGVzdDohMX0pLHRoaXMudG9uZU1hcHBlZD0hMSx0aGlzLnNldFRleGVsU2l6ZShlLngsZS55KSx0aGlzLmtlcm5lbD1uZXcgRmxvYXQzMkFycmF5KFswLDEsMiwyLDNdKX1zZXRUZXhlbFNpemUoZSx0KXt0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoZSx0KSx0aGlzLnVuaWZvcm1zLmhhbGZUZXhlbFNpemUudmFsdWUuc2V0KGUsdCkubXVsdGlwbHlTY2FsYXIoLjUpfXNldFJlc29sdXRpb24oZSl7dGhpcy51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlLmNvcHkoZSl9fWNsYXNzIFZye2NvbnN0cnVjdG9yKHtnbDplLHJlc29sdXRpb246dCx3aWR0aDpyPTUwMCxoZWlnaHQ6YT01MDAsbWluRGVwdGhUaHJlc2hvbGQ6bz0wLG1heERlcHRoVGhyZXNob2xkOmk9MSxkZXB0aFNjYWxlOnM9MCxkZXB0aFRvQmx1clJhdGlvQmlhczpsPS4yNX0pe3RoaXMucmVuZGVyVG9TY3JlZW49ITEsdGhpcy5yZW5kZXJUYXJnZXRBPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHQsdCx7bWluRmlsdGVyOm4uTGluZWFyRmlsdGVyLG1hZ0ZpbHRlcjpuLkxpbmVhckZpbHRlcixzdGVuY2lsQnVmZmVyOiExLGRlcHRoQnVmZmVyOiExLHR5cGU6bi5IYWxmRmxvYXRUeXBlfSksdGhpcy5yZW5kZXJUYXJnZXRCPXRoaXMucmVuZGVyVGFyZ2V0QS5jbG9uZSgpLHRoaXMuY29udm9sdXRpb25NYXRlcmlhbD1uZXcgSXIsdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnNldFRleGVsU2l6ZSgxL3IsMS9hKSx0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwuc2V0UmVzb2x1dGlvbihuZXcgbi5WZWN0b3IyKHIsYSkpLHRoaXMuc2NlbmU9bmV3IG4uU2NlbmUsdGhpcy5jYW1lcmE9bmV3IG4uQ2FtZXJhLHRoaXMuY29udm9sdXRpb25NYXRlcmlhbC51bmlmb3Jtcy5taW5EZXB0aFRocmVzaG9sZC52YWx1ZT1vLHRoaXMuY29udm9sdXRpb25NYXRlcmlhbC51bmlmb3Jtcy5tYXhEZXB0aFRocmVzaG9sZC52YWx1ZT1pLHRoaXMuY29udm9sdXRpb25NYXRlcmlhbC51bmlmb3Jtcy5kZXB0aFNjYWxlLnZhbHVlPXMsdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLnVuaWZvcm1zLmRlcHRoVG9CbHVyUmF0aW9CaWFzLnZhbHVlPWwsdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsLmRlZmluZXMuVVNFX0RFUFRIPXM+MDtjb25zdCBjPW5ldyBGbG9hdDMyQXJyYXkoWy0xLC0xLDAsMywtMSwwLC0xLDMsMF0pLHU9bmV3IEZsb2F0MzJBcnJheShbMCwwLDIsMCwwLDJdKSxkPW5ldyBuLkJ1ZmZlckdlb21ldHJ5O2Quc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIixuZXcgbi5CdWZmZXJBdHRyaWJ1dGUoYywzKSksZC5zZXRBdHRyaWJ1dGUoXCJ1dlwiLG5ldyBuLkJ1ZmZlckF0dHJpYnV0ZSh1LDIpKSx0aGlzLnNjcmVlbj1uZXcgbi5NZXNoKGQsdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsKSx0aGlzLnNjcmVlbi5mcnVzdHVtQ3VsbGVkPSExLHRoaXMuc2NlbmUuYWRkKHRoaXMuc2NyZWVuKX1yZW5kZXIoZSx0LHIpe2NvbnN0IG49dGhpcy5zY2VuZSxhPXRoaXMuY2FtZXJhLG89dGhpcy5yZW5kZXJUYXJnZXRBLGk9dGhpcy5yZW5kZXJUYXJnZXRCO2xldCBzPXRoaXMuY29udm9sdXRpb25NYXRlcmlhbCxsPXMudW5pZm9ybXM7bC5kZXB0aEJ1ZmZlci52YWx1ZT10LmRlcHRoVGV4dHVyZTtjb25zdCBjPXMua2VybmVsO2xldCB1LGQsbSxmPXQ7Zm9yKGQ9MCxtPWMubGVuZ3RoLTE7ZDxtOysrZCl1PTA9PSgxJmQpP286aSxsLmtlcm5lbC52YWx1ZT1jW2RdLGwuaW5wdXRCdWZmZXIudmFsdWU9Zi50ZXh0dXJlLGUuc2V0UmVuZGVyVGFyZ2V0KHUpLGUucmVuZGVyKG4sYSksZj11O2wua2VybmVsLnZhbHVlPWNbZF0sbC5pbnB1dEJ1ZmZlci52YWx1ZT1mLnRleHR1cmUsZS5zZXRSZW5kZXJUYXJnZXQodGhpcy5yZW5kZXJUb1NjcmVlbj9udWxsOnIpLGUucmVuZGVyKG4sYSl9fWNsYXNzIE9yIGV4dGVuZHMgbi5NZXNoU3RhbmRhcmRNYXRlcmlhbHtjb25zdHJ1Y3RvcihlPXt9KXtzdXBlcihlKSx0aGlzLl90RGVwdGg9e3ZhbHVlOm51bGx9LHRoaXMuX2Rpc3RvcnRpb25NYXA9e3ZhbHVlOm51bGx9LHRoaXMuX3REaWZmdXNlPXt2YWx1ZTpudWxsfSx0aGlzLl90RGlmZnVzZUJsdXI9e3ZhbHVlOm51bGx9LHRoaXMuX3RleHR1cmVNYXRyaXg9e3ZhbHVlOm51bGx9LHRoaXMuX2hhc0JsdXI9e3ZhbHVlOiExfSx0aGlzLl9taXJyb3I9e3ZhbHVlOjB9LHRoaXMuX21peEJsdXI9e3ZhbHVlOjB9LHRoaXMuX2JsdXJTdHJlbmd0aD17dmFsdWU6LjV9LHRoaXMuX21pbkRlcHRoVGhyZXNob2xkPXt2YWx1ZTouOX0sdGhpcy5fbWF4RGVwdGhUaHJlc2hvbGQ9e3ZhbHVlOjF9LHRoaXMuX2RlcHRoU2NhbGU9e3ZhbHVlOjB9LHRoaXMuX2RlcHRoVG9CbHVyUmF0aW9CaWFzPXt2YWx1ZTouMjV9LHRoaXMuX2Rpc3RvcnRpb249e3ZhbHVlOjF9LHRoaXMuX21peENvbnRyYXN0PXt2YWx1ZToxfSx0aGlzLnNldFZhbHVlcyhlKX1vbkJlZm9yZUNvbXBpbGUoZSl7dmFyIHQ7bnVsbCE9KHQ9ZS5kZWZpbmVzKSYmdC5VU0VfVVZ8fChlLmRlZmluZXMuVVNFX1VWPVwiXCIpLGUudW5pZm9ybXMuaGFzQmx1cj10aGlzLl9oYXNCbHVyLGUudW5pZm9ybXMudERpZmZ1c2U9dGhpcy5fdERpZmZ1c2UsZS51bmlmb3Jtcy50RGVwdGg9dGhpcy5fdERlcHRoLGUudW5pZm9ybXMuZGlzdG9ydGlvbk1hcD10aGlzLl9kaXN0b3J0aW9uTWFwLGUudW5pZm9ybXMudERpZmZ1c2VCbHVyPXRoaXMuX3REaWZmdXNlQmx1cixlLnVuaWZvcm1zLnRleHR1cmVNYXRyaXg9dGhpcy5fdGV4dHVyZU1hdHJpeCxlLnVuaWZvcm1zLm1pcnJvcj10aGlzLl9taXJyb3IsZS51bmlmb3Jtcy5taXhCbHVyPXRoaXMuX21peEJsdXIsZS51bmlmb3Jtcy5taXhTdHJlbmd0aD10aGlzLl9ibHVyU3RyZW5ndGgsZS51bmlmb3Jtcy5taW5EZXB0aFRocmVzaG9sZD10aGlzLl9taW5EZXB0aFRocmVzaG9sZCxlLnVuaWZvcm1zLm1heERlcHRoVGhyZXNob2xkPXRoaXMuX21heERlcHRoVGhyZXNob2xkLGUudW5pZm9ybXMuZGVwdGhTY2FsZT10aGlzLl9kZXB0aFNjYWxlLGUudW5pZm9ybXMuZGVwdGhUb0JsdXJSYXRpb0JpYXM9dGhpcy5fZGVwdGhUb0JsdXJSYXRpb0JpYXMsZS51bmlmb3Jtcy5kaXN0b3J0aW9uPXRoaXMuX2Rpc3RvcnRpb24sZS51bmlmb3Jtcy5taXhDb250cmFzdD10aGlzLl9taXhDb250cmFzdCxlLnZlcnRleFNoYWRlcj1gXFxuICAgICAgICB1bmlmb3JtIG1hdDQgdGV4dHVyZU1hdHJpeDtcXG4gICAgICAgIHZhcnlpbmcgdmVjNCBteV92VXY7XFxuICAgICAgJHtlLnZlcnRleFNoYWRlcn1gLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XCIsXCIjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuICAgICAgICBteV92VXYgPSB0ZXh0dXJlTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiKSxlLmZyYWdtZW50U2hhZGVyPWBcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2VCbHVyO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdERlcHRoO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGlzdG9ydGlvbk1hcDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG5cXHRcXHRcXHQgIHVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcbiAgICAgICAgdW5pZm9ybSBib29sIGhhc0JsdXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1peEJsdXI7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1pcnJvcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWl4U3RyZW5ndGg7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IG1pbkRlcHRoVGhyZXNob2xkO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBtYXhEZXB0aFRocmVzaG9sZDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWl4Q29udHJhc3Q7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoU2NhbGU7XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGRlcHRoVG9CbHVyUmF0aW9CaWFzO1xcbiAgICAgICAgdmFyeWluZyB2ZWM0IG15X3ZVdjtcXG4gICAgICAgICR7ZS5mcmFnbWVudFNoYWRlcn1gLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlwiLFwiI2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcbiAgICAgIGZsb2F0IGRpc3RvcnRpb25GYWN0b3IgPSAwLjA7XFxuICAgICAgI2lmZGVmIFVTRV9ESVNUT1JUSU9OXFxuICAgICAgICBkaXN0b3J0aW9uRmFjdG9yID0gdGV4dHVyZTJEKGRpc3RvcnRpb25NYXAsIHZVdikuciAqIGRpc3RvcnRpb247XFxuICAgICAgI2VuZGlmXFxuXFxuICAgICAgdmVjNCBuZXdfdlV2ID0gbXlfdlV2O1xcbiAgICAgIG5ld192VXYueCArPSBkaXN0b3J0aW9uRmFjdG9yO1xcbiAgICAgIG5ld192VXYueSArPSBkaXN0b3J0aW9uRmFjdG9yO1xcblxcbiAgICAgIHZlYzQgYmFzZSA9IHRleHR1cmUyRFByb2oodERpZmZ1c2UsIG5ld192VXYpO1xcbiAgICAgIHZlYzQgYmx1ciA9IHRleHR1cmUyRFByb2oodERpZmZ1c2VCbHVyLCBuZXdfdlV2KTtcXG5cXG4gICAgICB2ZWM0IG1lcmdlID0gYmFzZTtcXG5cXG4gICAgICAjaWZkZWYgVVNFX05PUk1BTE1BUFxcbiAgICAgICAgdmVjMiBub3JtYWxfdXYgPSB2ZWMyKDAuMCk7XFxuICAgICAgICB2ZWM0IG5vcm1hbENvbG9yID0gdGV4dHVyZTJEKG5vcm1hbE1hcCwgdlV2ICogbm9ybWFsU2NhbGUpO1xcbiAgICAgICAgdmVjMyBteV9ub3JtYWwgPSBub3JtYWxpemUoIHZlYzMoIG5vcm1hbENvbG9yLnIgKiAyLjAgLSAxLjAsIG5vcm1hbENvbG9yLmIsICBub3JtYWxDb2xvci5nICogMi4wIC0gMS4wICkgKTtcXG4gICAgICAgIHZlYzMgY29vcmQgPSBuZXdfdlV2Lnh5eiAvIG5ld192VXYudztcXG4gICAgICAgIG5vcm1hbF91diA9IGNvb3JkLnh5ICsgY29vcmQueiAqIG15X25vcm1hbC54eiAqIDAuMDU7XFxuICAgICAgICB2ZWM0IGJhc2Vfbm9ybWFsID0gdGV4dHVyZTJEKHREaWZmdXNlLCBub3JtYWxfdXYpO1xcbiAgICAgICAgdmVjNCBibHVyX25vcm1hbCA9IHRleHR1cmUyRCh0RGlmZnVzZUJsdXIsIG5vcm1hbF91dik7XFxuICAgICAgICBtZXJnZSA9IGJhc2Vfbm9ybWFsO1xcbiAgICAgICAgYmx1ciA9IGJsdXJfbm9ybWFsO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIGZsb2F0IGRlcHRoRmFjdG9yID0gMC4wMDAxO1xcbiAgICAgIGZsb2F0IGJsdXJGYWN0b3IgPSAwLjA7XFxuXFxuICAgICAgI2lmZGVmIFVTRV9ERVBUSFxcbiAgICAgICAgdmVjNCBkZXB0aCA9IHRleHR1cmUyRFByb2oodERlcHRoLCBuZXdfdlV2KTtcXG4gICAgICAgIGRlcHRoRmFjdG9yID0gc21vb3Roc3RlcChtaW5EZXB0aFRocmVzaG9sZCwgbWF4RGVwdGhUaHJlc2hvbGQsIDEuMC0oZGVwdGguciAqIGRlcHRoLmEpKTtcXG4gICAgICAgIGRlcHRoRmFjdG9yICo9IGRlcHRoU2NhbGU7XFxuICAgICAgICBkZXB0aEZhY3RvciA9IG1heCgwLjAwMDEsIG1pbigxLjAsIGRlcHRoRmFjdG9yKSk7XFxuXFxuICAgICAgICAjaWZkZWYgVVNFX0JMVVJcXG4gICAgICAgICAgYmx1ciA9IGJsdXIgKiBtaW4oMS4wLCBkZXB0aEZhY3RvciArIGRlcHRoVG9CbHVyUmF0aW9CaWFzKTtcXG4gICAgICAgICAgbWVyZ2UgPSBtZXJnZSAqIG1pbigxLjAsIGRlcHRoRmFjdG9yICsgMC41KTtcXG4gICAgICAgICNlbHNlXFxuICAgICAgICAgIG1lcmdlID0gbWVyZ2UgKiBkZXB0aEZhY3RvcjtcXG4gICAgICAgICNlbmRpZlxcblxcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIGZsb2F0IHJlZmxlY3RvclJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4gICAgICAjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcbiAgICAgICAgdmVjNCByZWZsZWN0b3JUZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2VXYgKTtcXG4gICAgICAgIHJlZmxlY3RvclJvdWdobmVzc0ZhY3RvciAqPSByZWZsZWN0b3JUZXhlbFJvdWdobmVzcy5nO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgICNpZmRlZiBVU0VfQkxVUlxcbiAgICAgICAgYmx1ckZhY3RvciA9IG1pbigxLjAsIG1peEJsdXIgKiByZWZsZWN0b3JSb3VnaG5lc3NGYWN0b3IpO1xcbiAgICAgICAgbWVyZ2UgPSBtaXgobWVyZ2UsIGJsdXIsIGJsdXJGYWN0b3IpO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgIHZlYzQgbmV3TWVyZ2UgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgbmV3TWVyZ2UuciA9IChtZXJnZS5yIC0gMC41KSAqIG1peENvbnRyYXN0ICsgMC41O1xcbiAgICAgIG5ld01lcmdlLmcgPSAobWVyZ2UuZyAtIDAuNSkgKiBtaXhDb250cmFzdCArIDAuNTtcXG4gICAgICBuZXdNZXJnZS5iID0gKG1lcmdlLmIgLSAwLjUpICogbWl4Q29udHJhc3QgKyAwLjU7XFxuXFxuICAgICAgZGlmZnVzZUNvbG9yLnJnYiA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoKDEuMCAtIG1pbigxLjAsIG1pcnJvcikpICsgbmV3TWVyZ2UucmdiICogbWl4U3RyZW5ndGgpO1xcbiAgICAgIFwiKX1nZXQgdERpZmZ1c2UoKXtyZXR1cm4gdGhpcy5fdERpZmZ1c2UudmFsdWV9c2V0IHREaWZmdXNlKGUpe3RoaXMuX3REaWZmdXNlLnZhbHVlPWV9Z2V0IHREZXB0aCgpe3JldHVybiB0aGlzLl90RGVwdGgudmFsdWV9c2V0IHREZXB0aChlKXt0aGlzLl90RGVwdGgudmFsdWU9ZX1nZXQgZGlzdG9ydGlvbk1hcCgpe3JldHVybiB0aGlzLl9kaXN0b3J0aW9uTWFwLnZhbHVlfXNldCBkaXN0b3J0aW9uTWFwKGUpe3RoaXMuX2Rpc3RvcnRpb25NYXAudmFsdWU9ZX1nZXQgdERpZmZ1c2VCbHVyKCl7cmV0dXJuIHRoaXMuX3REaWZmdXNlQmx1ci52YWx1ZX1zZXQgdERpZmZ1c2VCbHVyKGUpe3RoaXMuX3REaWZmdXNlQmx1ci52YWx1ZT1lfWdldCB0ZXh0dXJlTWF0cml4KCl7cmV0dXJuIHRoaXMuX3RleHR1cmVNYXRyaXgudmFsdWV9c2V0IHRleHR1cmVNYXRyaXgoZSl7dGhpcy5fdGV4dHVyZU1hdHJpeC52YWx1ZT1lfWdldCBoYXNCbHVyKCl7cmV0dXJuIHRoaXMuX2hhc0JsdXIudmFsdWV9c2V0IGhhc0JsdXIoZSl7dGhpcy5faGFzQmx1ci52YWx1ZT1lfWdldCBtaXJyb3IoKXtyZXR1cm4gdGhpcy5fbWlycm9yLnZhbHVlfXNldCBtaXJyb3IoZSl7dGhpcy5fbWlycm9yLnZhbHVlPWV9Z2V0IG1peEJsdXIoKXtyZXR1cm4gdGhpcy5fbWl4Qmx1ci52YWx1ZX1zZXQgbWl4Qmx1cihlKXt0aGlzLl9taXhCbHVyLnZhbHVlPWV9Z2V0IG1peFN0cmVuZ3RoKCl7cmV0dXJuIHRoaXMuX2JsdXJTdHJlbmd0aC52YWx1ZX1zZXQgbWl4U3RyZW5ndGgoZSl7dGhpcy5fYmx1clN0cmVuZ3RoLnZhbHVlPWV9Z2V0IG1pbkRlcHRoVGhyZXNob2xkKCl7cmV0dXJuIHRoaXMuX21pbkRlcHRoVGhyZXNob2xkLnZhbHVlfXNldCBtaW5EZXB0aFRocmVzaG9sZChlKXt0aGlzLl9taW5EZXB0aFRocmVzaG9sZC52YWx1ZT1lfWdldCBtYXhEZXB0aFRocmVzaG9sZCgpe3JldHVybiB0aGlzLl9tYXhEZXB0aFRocmVzaG9sZC52YWx1ZX1zZXQgbWF4RGVwdGhUaHJlc2hvbGQoZSl7dGhpcy5fbWF4RGVwdGhUaHJlc2hvbGQudmFsdWU9ZX1nZXQgZGVwdGhTY2FsZSgpe3JldHVybiB0aGlzLl9kZXB0aFNjYWxlLnZhbHVlfXNldCBkZXB0aFNjYWxlKGUpe3RoaXMuX2RlcHRoU2NhbGUudmFsdWU9ZX1nZXQgZGVwdGhUb0JsdXJSYXRpb0JpYXMoKXtyZXR1cm4gdGhpcy5fZGVwdGhUb0JsdXJSYXRpb0JpYXMudmFsdWV9c2V0IGRlcHRoVG9CbHVyUmF0aW9CaWFzKGUpe3RoaXMuX2RlcHRoVG9CbHVyUmF0aW9CaWFzLnZhbHVlPWV9Z2V0IGRpc3RvcnRpb24oKXtyZXR1cm4gdGhpcy5fZGlzdG9ydGlvbi52YWx1ZX1zZXQgZGlzdG9ydGlvbihlKXt0aGlzLl9kaXN0b3J0aW9uLnZhbHVlPWV9Z2V0IG1peENvbnRyYXN0KCl7cmV0dXJuIHRoaXMuX21peENvbnRyYXN0LnZhbHVlfXNldCBtaXhDb250cmFzdChlKXt0aGlzLl9taXhDb250cmFzdC52YWx1ZT1lfX1jb25zdCBOcj1QLmZvcndhcmRSZWYoKCh7bWl4Qmx1cjplPTAsbWl4U3RyZW5ndGg6dD0xLHJlc29sdXRpb246cj0yNTYsYmx1cjpvPVswLDBdLG1pbkRlcHRoVGhyZXNob2xkOmk9LjksbWF4RGVwdGhUaHJlc2hvbGQ6cz0xLGRlcHRoU2NhbGU6bD0wLGRlcHRoVG9CbHVyUmF0aW9CaWFzOmM9LjI1LG1pcnJvcjp1PTAsZGlzdG9ydGlvbjpkPTEsbWl4Q29udHJhc3Q6bT0xLGRpc3RvcnRpb25NYXA6ZixyZWZsZWN0b3JPZmZzZXQ6cD0wLC4uLmh9LHgpPT57YS5leHRlbmQoe01lc2hSZWZsZWN0b3JNYXRlcmlhbEltcGw6T3J9KTtjb25zdCB5PWEudXNlVGhyZWUoKCh7Z2w6ZX0pPT5lKSksdj1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSxnPWEudXNlVGhyZWUoKCh7c2NlbmU6ZX0pPT5lKSksej0obz1BcnJheS5pc0FycmF5KG8pP286W28sb10pWzBdK29bMV0+MCx3PVAudXNlUmVmKG51bGwpLFtiXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGxhbmUpKSxbTV09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbRV09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbU109UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbVF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLk1hdHJpeDQpKSxbUl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMoMCwwLC0xKSkpLFtEXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtGXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtfXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtBXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtMXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uTWF0cml4NCkpLFtCXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGVyc3BlY3RpdmVDYW1lcmEpKSxVPVAudXNlQ2FsbGJhY2soKCgpPT57dmFyIGU7Y29uc3QgdD13LmN1cnJlbnQucGFyZW50fHwobnVsbD09KGU9dy5jdXJyZW50KT92b2lkIDA6ZS5fX3IzZi5wYXJlbnQpO2lmKCF0KXJldHVybjtpZihFLnNldEZyb21NYXRyaXhQb3NpdGlvbih0Lm1hdHJpeFdvcmxkKSxTLnNldEZyb21NYXRyaXhQb3NpdGlvbih2Lm1hdHJpeFdvcmxkKSxULmV4dHJhY3RSb3RhdGlvbih0Lm1hdHJpeFdvcmxkKSxNLnNldCgwLDAsMSksTS5hcHBseU1hdHJpeDQoVCksRS5hZGRTY2FsZWRWZWN0b3IoTSxwKSxGLnN1YlZlY3RvcnMoRSxTKSxGLmRvdChNKT4wKXJldHVybjtGLnJlZmxlY3QoTSkubmVnYXRlKCksRi5hZGQoRSksVC5leHRyYWN0Um90YXRpb24odi5tYXRyaXhXb3JsZCksUi5zZXQoMCwwLC0xKSxSLmFwcGx5TWF0cml4NChUKSxSLmFkZChTKSxfLnN1YlZlY3RvcnMoRSxSKSxfLnJlZmxlY3QoTSkubmVnYXRlKCksXy5hZGQoRSksQi5wb3NpdGlvbi5jb3B5KEYpLEIudXAuc2V0KDAsMSwwKSxCLnVwLmFwcGx5TWF0cml4NChUKSxCLnVwLnJlZmxlY3QoTSksQi5sb29rQXQoXyksQi5mYXI9di5mYXIsQi51cGRhdGVNYXRyaXhXb3JsZCgpLEIucHJvamVjdGlvbk1hdHJpeC5jb3B5KHYucHJvamVjdGlvbk1hdHJpeCksTC5zZXQoLjUsMCwwLC41LDAsLjUsMCwuNSwwLDAsLjUsLjUsMCwwLDAsMSksTC5tdWx0aXBseShCLnByb2plY3Rpb25NYXRyaXgpLEwubXVsdGlwbHkoQi5tYXRyaXhXb3JsZEludmVyc2UpLEwubXVsdGlwbHkodC5tYXRyaXhXb3JsZCksYi5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludChNLEUpLGIuYXBwbHlNYXRyaXg0KEIubWF0cml4V29ybGRJbnZlcnNlKSxELnNldChiLm5vcm1hbC54LGIubm9ybWFsLnksYi5ub3JtYWwueixiLmNvbnN0YW50KTtjb25zdCByPUIucHJvamVjdGlvbk1hdHJpeDtBLng9KE1hdGguc2lnbihELngpK3IuZWxlbWVudHNbOF0pL3IuZWxlbWVudHNbMF0sQS55PShNYXRoLnNpZ24oRC55KStyLmVsZW1lbnRzWzldKS9yLmVsZW1lbnRzWzVdLEEuej0tMSxBLnc9KDErci5lbGVtZW50c1sxMF0pL3IuZWxlbWVudHNbMTRdLEQubXVsdGlwbHlTY2FsYXIoMi9ELmRvdChBKSksci5lbGVtZW50c1syXT1ELngsci5lbGVtZW50c1s2XT1ELnksci5lbGVtZW50c1sxMF09RC56KzEsci5lbGVtZW50c1sxNF09RC53fSksW3YscF0pLFtJLFYsTyxOXT1QLnVzZU1lbW8oKCgpPT57Y29uc3QgYT17bWluRmlsdGVyOm4uTGluZWFyRmlsdGVyLG1hZ0ZpbHRlcjpuLkxpbmVhckZpbHRlcix0eXBlOm4uSGFsZkZsb2F0VHlwZX0scD1uZXcgbi5XZWJHTFJlbmRlclRhcmdldChyLHIsYSk7cC5kZXB0aEJ1ZmZlcj0hMCxwLmRlcHRoVGV4dHVyZT1uZXcgbi5EZXB0aFRleHR1cmUocixyKSxwLmRlcHRoVGV4dHVyZS5mb3JtYXQ9bi5EZXB0aEZvcm1hdCxwLmRlcHRoVGV4dHVyZS50eXBlPW4uVW5zaWduZWRTaG9ydFR5cGU7Y29uc3QgaD1uZXcgbi5XZWJHTFJlbmRlclRhcmdldChyLHIsYSk7cmV0dXJuW3AsaCxuZXcgVnIoe2dsOnkscmVzb2x1dGlvbjpyLHdpZHRoOm9bMF0saGVpZ2h0Om9bMV0sbWluRGVwdGhUaHJlc2hvbGQ6aSxtYXhEZXB0aFRocmVzaG9sZDpzLGRlcHRoU2NhbGU6bCxkZXB0aFRvQmx1clJhdGlvQmlhczpjfSkse21pcnJvcjp1LHRleHR1cmVNYXRyaXg6TCxtaXhCbHVyOmUsdERpZmZ1c2U6cC50ZXh0dXJlLHREZXB0aDpwLmRlcHRoVGV4dHVyZSx0RGlmZnVzZUJsdXI6aC50ZXh0dXJlLGhhc0JsdXI6eixtaXhTdHJlbmd0aDp0LG1pbkRlcHRoVGhyZXNob2xkOmksbWF4RGVwdGhUaHJlc2hvbGQ6cyxkZXB0aFNjYWxlOmwsZGVwdGhUb0JsdXJSYXRpb0JpYXM6YyxkaXN0b3J0aW9uOmQsZGlzdG9ydGlvbk1hcDpmLG1peENvbnRyYXN0Om0sXCJkZWZpbmVzLVVTRV9CTFVSXCI6ej9cIlwiOnZvaWQgMCxcImRlZmluZXMtVVNFX0RFUFRIXCI6bD4wP1wiXCI6dm9pZCAwLFwiZGVmaW5lcy1VU0VfRElTVE9SVElPTlwiOmY/XCJcIjp2b2lkIDB9XX0pLFt5LG8sTCxyLHUseixlLHQsaSxzLGwsYyxkLGYsbV0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e3ZhciBlO2NvbnN0IHQ9dy5jdXJyZW50LnBhcmVudHx8KG51bGw9PShlPXcuY3VycmVudCk/dm9pZCAwOmUuX19yM2YucGFyZW50KTtpZighdClyZXR1cm47dC52aXNpYmxlPSExO2NvbnN0IHI9eS54ci5lbmFibGVkLG49eS5zaGFkb3dNYXAuYXV0b1VwZGF0ZTtVKCkseS54ci5lbmFibGVkPSExLHkuc2hhZG93TWFwLmF1dG9VcGRhdGU9ITEseS5zZXRSZW5kZXJUYXJnZXQoSSkseS5zdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLHkuYXV0b0NsZWFyfHx5LmNsZWFyKCkseS5yZW5kZXIoZyxCKSx6JiZPLnJlbmRlcih5LEksVikseS54ci5lbmFibGVkPXIseS5zaGFkb3dNYXAuYXV0b1VwZGF0ZT1uLHQudmlzaWJsZT0hMCx5LnNldFJlbmRlclRhcmdldChudWxsKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoUmVmbGVjdG9yTWF0ZXJpYWxJbXBsXCIsQy5kZWZhdWx0KHthdHRhY2g6XCJtYXRlcmlhbFwiLGtleTpcImtleVwiK05bXCJkZWZpbmVzLVVTRV9CTFVSXCJdK05bXCJkZWZpbmVzLVVTRV9ERVBUSFwiXStOW1wiZGVmaW5lcy1VU0VfRElTVE9SVElPTlwiXSxyZWY6ay5kZWZhdWx0KFt3LHhdKX0sTixoKSl9KSksanI9RWUoe2Vudk1hcDpudWxsLGJvdW5jZXM6Myxpb3I6Mi40LGNvcnJlY3RNaXBzOiEwLGFiZXJyYXRpb25TdHJlbmd0aDouMDEsZnJlc25lbDowLGJ2aDpuZXcgdy5NZXNoQlZIVW5pZm9ybVN0cnVjdCxjb2xvcjpuZXcgRC5Db2xvcihcIndoaXRlXCIpLHJlc29sdXRpb246bmV3IEQuVmVjdG9yMix2aWV3TWF0cml4SW52ZXJzZTpuZXcgRC5NYXRyaXg0LHByb2plY3Rpb25NYXRyaXhJbnZlcnNlOm5ldyBELk1hdHJpeDR9LFwiXFxuICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeEludmVyc2U7XFxuXFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247ICBcXG4gIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiAgdmFyeWluZyBtYXQ0IHZNb2RlbE1hdHJpeEludmVyc2U7XFxuXFxuICAjaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG4gICAgdmFyeWluZyB2ZWMzIHZJbnN0YW5jZUNvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2b2lkIG1haW4oKSB7ICAgICAgICBcXG4gICAgdmVjNCB0cmFuc2Zvcm1lZE5vcm1hbCA9IHZlYzQobm9ybWFsLCAwLjApO1xcbiAgICB2ZWM0IHRyYW5zZm9ybWVkUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiAgICAjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICB0cmFuc2Zvcm1lZE5vcm1hbCA9IGluc3RhbmNlTWF0cml4ICogdHJhbnNmb3JtZWROb3JtYWw7XFxuICAgICAgdHJhbnNmb3JtZWRQb3NpdGlvbiA9IGluc3RhbmNlTWF0cml4ICogdHJhbnNmb3JtZWRQb3NpdGlvbjtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIHZNb2RlbE1hdHJpeEludmVyc2UgPSBpbnZlcnNlKG1vZGVsTWF0cml4ICogaW5zdGFuY2VNYXRyaXgpO1xcbiAgICAjZWxzZVxcbiAgICAgIHZNb2RlbE1hdHJpeEludmVyc2UgPSBpbnZlcnNlKG1vZGVsTWF0cml4KTtcXG4gICAgI2VuZGlmXFxuXFxuICAgICNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlxcbiAgICAgIHZJbnN0YW5jZUNvbG9yID0gaW5zdGFuY2VDb2xvci5yZ2I7XFxuICAgICNlbmRpZlxcblxcbiAgICB2V29ybGRQb3NpdGlvbiA9IChtb2RlbE1hdHJpeCAqIHRyYW5zZm9ybWVkUG9zaXRpb24pLnh5ejtcXG4gICAgdk5vcm1hbCA9IG5vcm1hbGl6ZSgodmlld01hdHJpeEludmVyc2UgKiB2ZWM0KG5vcm1hbE1hdHJpeCAqIHRyYW5zZm9ybWVkTm9ybWFsLnh5eiwgMC4wKSkueHl6KTtcXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdHJhbnNmb3JtZWRQb3NpdGlvbjtcXG4gIH1cIixgXFxuICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG4gIHByZWNpc2lvbiBoaWdocCBpc2FtcGxlcjJEO1xcbiAgcHJlY2lzaW9uIGhpZ2hwIHVzYW1wbGVyMkQ7XFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICB2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4gIHZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXhJbnZlcnNlO1xcblxcbiAgI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SXFxuICAgIHZhcnlpbmcgdmVjMyB2SW5zdGFuY2VDb2xvcjtcXG4gICNlbmRpZlxcbiAgICBcXG4gICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFTVxcbiAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG4gICNlbHNlXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG4gICNlbmRpZlxcbiAgICBcXG4gIHVuaWZvcm0gZmxvYXQgYm91bmNlcztcXG4gICR7dy5zaGFkZXJTdHJ1Y3RzfVxcbiAgJHt3LnNoYWRlckludGVyc2VjdEZ1bmN0aW9ufVxcbiAgdW5pZm9ybSBCVkggYnZoO1xcbiAgdW5pZm9ybSBmbG9hdCBpb3I7XFxuICB1bmlmb3JtIGJvb2wgY29ycmVjdE1pcHM7XFxuICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gIHVuaWZvcm0gZmxvYXQgZnJlc25lbDtcXG4gIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG4gIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcXG4gIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4SW52ZXJzZTtcXG4gIHVuaWZvcm0gZmxvYXQgYWJlcnJhdGlvblN0cmVuZ3RoO1xcbiAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xcbiAgXFxuICBmbG9hdCBmcmVzbmVsRnVuYyh2ZWMzIHZpZXdEaXJlY3Rpb24sIHZlYzMgd29ybGROb3JtYWwpIHtcXG4gICAgcmV0dXJuIHBvdyggMS4wICsgZG90KCB2aWV3RGlyZWN0aW9uLCB3b3JsZE5vcm1hbCksIDEwLjAgKTtcXG4gIH1cXG4gICAgXFxuICB2ZWMzIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgbm9ybWFsLCBmbG9hdCBpb3IsIG1hdDQgbW9kZWxNYXRyaXhJbnZlcnNlKSB7XFxuICAgIHZlYzMgcmF5T3JpZ2luID0gcm87XFxuICAgIHZlYzMgcmF5RGlyZWN0aW9uID0gcmQ7XFxuICAgIHJheURpcmVjdGlvbiA9IHJlZnJhY3QocmF5RGlyZWN0aW9uLCBub3JtYWwsIDEuMCAvIGlvcik7XFxuICAgIHJheU9yaWdpbiA9IHZXb3JsZFBvc2l0aW9uICsgcmF5RGlyZWN0aW9uICogMC4wMDE7XFxuICAgIHJheU9yaWdpbiA9IChtb2RlbE1hdHJpeEludmVyc2UgKiB2ZWM0KHJheU9yaWdpbiwgMS4wKSkueHl6O1xcbiAgICByYXlEaXJlY3Rpb24gPSBub3JtYWxpemUoKG1vZGVsTWF0cml4SW52ZXJzZSAqIHZlYzQocmF5RGlyZWN0aW9uLCAwLjApKS54eXopO1xcbiAgICBmb3IoZmxvYXQgaSA9IDAuMDsgaSA8IGJvdW5jZXM7IGkrKykge1xcbiAgICAgIHV2ZWM0IGZhY2VJbmRpY2VzID0gdXZlYzQoIDB1ICk7XFxuICAgICAgdmVjMyBmYWNlTm9ybWFsID0gdmVjMyggMC4wLCAwLjAsIDEuMCApO1xcbiAgICAgIHZlYzMgYmFyeWNvb3JkID0gdmVjMyggMC4wICk7XFxuICAgICAgZmxvYXQgc2lkZSA9IDEuMDtcXG4gICAgICBmbG9hdCBkaXN0ID0gMC4wO1xcbiAgICAgIGJ2aEludGVyc2VjdEZpcnN0SGl0KCBidmgsIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBkaXN0ICk7XFxuICAgICAgdmVjMyBoaXRQb3MgPSByYXlPcmlnaW4gKyByYXlEaXJlY3Rpb24gKiBtYXgoZGlzdCAtIDAuMDAxLCAwLjApOyAgICAgIFxcbiAgICAgIHZlYzMgdGVtcERpciA9IHJlZnJhY3QocmF5RGlyZWN0aW9uLCBmYWNlTm9ybWFsLCBpb3IpO1xcbiAgICAgIGlmIChsZW5ndGgodGVtcERpcikgIT0gMC4wKSB7XFxuICAgICAgICByYXlEaXJlY3Rpb24gPSB0ZW1wRGlyO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIHJheURpcmVjdGlvbiA9IHJlZmxlY3QocmF5RGlyZWN0aW9uLCBmYWNlTm9ybWFsKTtcXG4gICAgICByYXlPcmlnaW4gPSBoaXRQb3MgKyByYXlEaXJlY3Rpb24gKiAwLjAxO1xcbiAgICB9XFxuICAgIHJheURpcmVjdGlvbiA9IG5vcm1hbGl6ZSgobW9kZWxNYXRyaXggKiB2ZWM0KHJheURpcmVjdGlvbiwgMC4wKSkueHl6KTtcXG4gICAgcmV0dXJuIHJheURpcmVjdGlvbjtcXG4gIH1cXG4gICAgXFxuICAjaW5jbHVkZSA8Y29tbW9uPlxcbiAgI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4gICAgXFxuICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRU1cXG4gICAgdmVjNCB0ZXh0dXJlR3JhZGllbnQoc2FtcGxlckN1YmUgZW52TWFwLCB2ZWMzIHJheURpcmVjdGlvbiwgdmVjMyBkaXJlY3Rpb25DYW1QZXJmZWN0KSB7XFxuICAgICAgcmV0dXJuIHRleHR1cmVHcmFkKGVudk1hcCwgcmF5RGlyZWN0aW9uLCBkRmR4KGNvcnJlY3RNaXBzID8gZGlyZWN0aW9uQ2FtUGVyZmVjdDogcmF5RGlyZWN0aW9uKSwgZEZkeShjb3JyZWN0TWlwcyA/IGRpcmVjdGlvbkNhbVBlcmZlY3Q6IHJheURpcmVjdGlvbikpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICB2ZWM0IHRleHR1cmVHcmFkaWVudChzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIHJheURpcmVjdGlvbiwgdmVjMyBkaXJlY3Rpb25DYW1QZXJmZWN0KSB7XFxuICAgICAgdmVjMiB1dnYgPSBlcXVpcmVjdFV2KCByYXlEaXJlY3Rpb24gKTtcXG4gICAgICB2ZWMyIHNtb290aFV2ID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uQ2FtUGVyZmVjdCApO1xcbiAgICAgIHJldHVybiB0ZXh0dXJlR3JhZChlbnZNYXAsIHV2diwgZEZkeChjb3JyZWN0TWlwcyA/IHNtb290aFV2IDogdXZ2KSwgZEZkeShjb3JyZWN0TWlwcyA/IHNtb290aFV2IDogdXZ2KSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgXFxuICB2b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgICB2ZWMzIGRpcmVjdGlvbkNhbVBlcmZlY3QgPSAocHJvamVjdGlvbk1hdHJpeEludmVyc2UgKiB2ZWM0KHV2ICogMi4wIC0gMS4wLCAwLjAsIDEuMCkpLnh5ejtcXG4gICAgZGlyZWN0aW9uQ2FtUGVyZmVjdCA9ICh2aWV3TWF0cml4SW52ZXJzZSAqIHZlYzQoZGlyZWN0aW9uQ2FtUGVyZmVjdCwgMC4wKSkueHl6O1xcbiAgICBkaXJlY3Rpb25DYW1QZXJmZWN0ID0gbm9ybWFsaXplKGRpcmVjdGlvbkNhbVBlcmZlY3QpO1xcbiAgICB2ZWMzIG5vcm1hbCA9IHZOb3JtYWw7XFxuICAgIHZlYzMgcmF5T3JpZ2luID0gY2FtZXJhUG9zaXRpb247XFxuICAgIHZlYzMgcmF5RGlyZWN0aW9uID0gbm9ybWFsaXplKHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24pO1xcbiAgICB2ZWMzIGZpbmFsQ29sb3I7XFxuICAgICNpZmRlZiBDSFJPTUFUSUNfQUJFUlJBVElPTlNcXG4gICAgICB2ZWMzIHJheURpcmVjdGlvbkcgPSB0b3RhbEludGVybmFsUmVmbGVjdGlvbihyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbm9ybWFsLCBtYXgoaW9yLCAxLjApLCB2TW9kZWxNYXRyaXhJbnZlcnNlKTtcXG4gICAgICAjaWZkZWYgRkFTVF9DSFJPTUEgXFxuICAgICAgICB2ZWMzIHJheURpcmVjdGlvblIgPSBub3JtYWxpemUocmF5RGlyZWN0aW9uRyArIDEuMCAqIHZlYzMoYWJlcnJhdGlvblN0cmVuZ3RoIC8gMi4wKSk7XFxuICAgICAgICB2ZWMzIHJheURpcmVjdGlvbkIgPSBub3JtYWxpemUocmF5RGlyZWN0aW9uRyAtIDEuMCAqIHZlYzMoYWJlcnJhdGlvblN0cmVuZ3RoIC8gMi4wKSk7XFxuICAgICAgI2Vsc2VcXG4gICAgICAgIHZlYzMgcmF5RGlyZWN0aW9uUiA9IHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBub3JtYWwsIG1heChpb3IgKiAoMS4wIC0gYWJlcnJhdGlvblN0cmVuZ3RoKSwgMS4wKSwgdk1vZGVsTWF0cml4SW52ZXJzZSk7XFxuICAgICAgICB2ZWMzIHJheURpcmVjdGlvbkIgPSB0b3RhbEludGVybmFsUmVmbGVjdGlvbihyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbm9ybWFsLCBtYXgoaW9yICogKDEuMCArIGFiZXJyYXRpb25TdHJlbmd0aCksIDEuMCksIHZNb2RlbE1hdHJpeEludmVyc2UpO1xcbiAgICAgICNlbmRpZlxcbiAgICAgIGZsb2F0IGZpbmFsQ29sb3JSID0gdGV4dHVyZUdyYWRpZW50KGVudk1hcCwgcmF5RGlyZWN0aW9uUiwgZGlyZWN0aW9uQ2FtUGVyZmVjdCkucjtcXG4gICAgICBmbG9hdCBmaW5hbENvbG9yRyA9IHRleHR1cmVHcmFkaWVudChlbnZNYXAsIHJheURpcmVjdGlvbkcsIGRpcmVjdGlvbkNhbVBlcmZlY3QpLmc7XFxuICAgICAgZmxvYXQgZmluYWxDb2xvckIgPSB0ZXh0dXJlR3JhZGllbnQoZW52TWFwLCByYXlEaXJlY3Rpb25CLCBkaXJlY3Rpb25DYW1QZXJmZWN0KS5iO1xcbiAgICAgIGZpbmFsQ29sb3IgPSB2ZWMzKGZpbmFsQ29sb3JSLCBmaW5hbENvbG9yRywgZmluYWxDb2xvckIpO1xcbiAgICAjZWxzZVxcbiAgICAgIHJheURpcmVjdGlvbiA9IHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBub3JtYWwsIG1heChpb3IsIDEuMCksIHZNb2RlbE1hdHJpeEludmVyc2UpO1xcbiAgICAgIGZpbmFsQ29sb3IgPSB0ZXh0dXJlR3JhZGllbnQoZW52TWFwLCByYXlEaXJlY3Rpb24sIGRpcmVjdGlvbkNhbVBlcmZlY3QpLnJnYjsgICAgXFxuICAgICNlbmRpZlxcblxcbiAgICBmaW5hbENvbG9yICo9IGNvbG9yO1xcbiAgICAjaWZkZWYgVVNFX0lOU1RBTkNJTkdfQ09MT1JcXG4gICAgICBmaW5hbENvbG9yICo9IHZJbnN0YW5jZUNvbG9yO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgdmVjMyB2aWV3RGlyZWN0aW9uID0gbm9ybWFsaXplKHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24pO1xcbiAgICBmbG9hdCBuRnJlc25lbCA9IGZyZXNuZWxGdW5jKHZpZXdEaXJlY3Rpb24sIG5vcm1hbCkgKiBmcmVzbmVsO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChmaW5hbENvbG9yLCB2ZWMzKDEuMCksIG5GcmVzbmVsKSwgMS4wKTsgICAgICBcXG4gICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAjaW5jbHVkZSA8JHtDZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgfWApO2NvbnN0IFdyPUVlKHt9LFwidm9pZCBtYWluKCkgeyB9XCIsXCJ2b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTsgZGlzY2FyZDsgIH1cIik7Y2xhc3MgR3IgZXh0ZW5kcyBELk1lc2hQaHlzaWNhbE1hdGVyaWFse2NvbnN0cnVjdG9yKGU9Nix0PSExKXtzdXBlcigpLHRoaXMudW5pZm9ybXM9e2Nocm9tYXRpY0FiZXJyYXRpb246e3ZhbHVlOi4wNX0sdHJhbnNtaXNzaW9uOnt2YWx1ZTowfSxfdHJhbnNtaXNzaW9uOnt2YWx1ZToxfSx0cmFuc21pc3Npb25NYXA6e3ZhbHVlOm51bGx9LHJvdWdobmVzczp7dmFsdWU6MH0sdGhpY2tuZXNzOnt2YWx1ZTowfSx0aGlja25lc3NNYXA6e3ZhbHVlOm51bGx9LGF0dGVudWF0aW9uRGlzdGFuY2U6e3ZhbHVlOjEvMH0sYXR0ZW51YXRpb25Db2xvcjp7dmFsdWU6bmV3IEQuQ29sb3IoXCJ3aGl0ZVwiKX0sYW5pc290cm9waWNCbHVyOnt2YWx1ZTouMX0sdGltZTp7dmFsdWU6MH0sZGlzdG9ydGlvbjp7dmFsdWU6MH0sZGlzdG9ydGlvblNjYWxlOnt2YWx1ZTouNX0sdGVtcG9yYWxEaXN0b3J0aW9uOnt2YWx1ZTowfSxidWZmZXI6e3ZhbHVlOm51bGx9fSx0aGlzLm9uQmVmb3JlQ29tcGlsZT1yPT57ci51bmlmb3Jtcz17Li4uci51bmlmb3JtcywuLi50aGlzLnVuaWZvcm1zfSx0aGlzLmFuaXNvdHJvcHk+MCYmKHIuZGVmaW5lcy5VU0VfQU5JU09UUk9QWT1cIlwiKSx0P3IuZGVmaW5lcy5VU0VfU0FNUExFUj1cIlwiOnIuZGVmaW5lcy5VU0VfVFJBTlNNSVNTSU9OPVwiXCIsci5mcmFnbWVudFNoYWRlcj1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgY2hyb21hdGljQWJlcnJhdGlvbjsgICAgICAgICBcXG4gICAgICB1bmlmb3JtIGZsb2F0IGFuaXNvdHJvcGljQmx1cjsgICAgICBcXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBkaXN0b3J0aW9uO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvblNjYWxlO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgdGVtcG9yYWxEaXN0b3J0aW9uO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIGJ1ZmZlcjtcXG5cXG4gICAgICB2ZWMzIHJhbmRvbTModmVjMyBjKSB7XFxuICAgICAgICBmbG9hdCBqID0gNDA5Ni4wKnNpbihkb3QoYyx2ZWMzKDE3LjAsIDU5LjQsIDE1LjApKSk7XFxuICAgICAgICB2ZWMzIHI7XFxuICAgICAgICByLnogPSBmcmFjdCg1MTIuMCpqKTtcXG4gICAgICAgIGogKj0gLjEyNTtcXG4gICAgICAgIHIueCA9IGZyYWN0KDUxMi4wKmopO1xcbiAgICAgICAgaiAqPSAuMTI1O1xcbiAgICAgICAgci55ID0gZnJhY3QoNTEyLjAqaik7XFxuICAgICAgICByZXR1cm4gci0wLjU7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHNlZWQgPSAwLjA7XFxuICAgICAgdWludCBoYXNoKCB1aW50IHggKSB7XFxuICAgICAgICB4ICs9ICggeCA8PCAxMHUgKTtcXG4gICAgICAgIHggXj0gKCB4ID4+ICA2dSApO1xcbiAgICAgICAgeCArPSAoIHggPDwgIDN1ICk7XFxuICAgICAgICB4IF49ICggeCA+PiAxMXUgKTtcXG4gICAgICAgIHggKz0gKCB4IDw8IDE1dSApO1xcbiAgICAgICAgcmV0dXJuIHg7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIENvbXBvdW5kIHZlcnNpb25zIG9mIHRoZSBoYXNoaW5nIGFsZ29yaXRobSBJIHdoaXBwZWQgdG9nZXRoZXIuXFxuICAgICAgdWludCBoYXNoKCB1dmVjMiB2ICkgeyByZXR1cm4gaGFzaCggdi54IF4gaGFzaCh2LnkpICAgICAgICAgICAgICAgICAgICAgICAgICk7IH1cXG4gICAgICB1aW50IGhhc2goIHV2ZWMzIHYgKSB7IHJldHVybiBoYXNoKCB2LnggXiBoYXNoKHYueSkgXiBoYXNoKHYueikgICAgICAgICAgICAgKTsgfVxcbiAgICAgIHVpbnQgaGFzaCggdXZlYzQgdiApIHsgcmV0dXJuIGhhc2goIHYueCBeIGhhc2godi55KSBeIGhhc2godi56KSBeIGhhc2godi53KSApOyB9XFxuXFxuICAgICAgLy8gQ29uc3RydWN0IGEgZmxvYXQgd2l0aCBoYWxmLW9wZW4gcmFuZ2UgWzA6MV0gdXNpbmcgbG93IDIzIGJpdHMuXFxuICAgICAgLy8gQWxsIHplcm9lcyB5aWVsZHMgMC4wLCBhbGwgb25lcyB5aWVsZHMgdGhlIG5leHQgc21hbGxlc3QgcmVwcmVzZW50YWJsZSB2YWx1ZSBiZWxvdyAxLjAuXFxuICAgICAgZmxvYXQgZmxvYXRDb25zdHJ1Y3QoIHVpbnQgbSApIHtcXG4gICAgICAgIGNvbnN0IHVpbnQgaWVlZU1hbnRpc3NhID0gMHgwMDdGRkZGRnU7IC8vIGJpbmFyeTMyIG1hbnRpc3NhIGJpdG1hc2tcXG4gICAgICAgIGNvbnN0IHVpbnQgaWVlZU9uZSAgICAgID0gMHgzRjgwMDAwMHU7IC8vIDEuMCBpbiBJRUVFIGJpbmFyeTMyXFxuICAgICAgICBtICY9IGllZWVNYW50aXNzYTsgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9ubHkgbWFudGlzc2EgYml0cyAoZnJhY3Rpb25hbCBwYXJ0KVxcbiAgICAgICAgbSB8PSBpZWVlT25lOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGZyYWN0aW9uYWwgcGFydCB0byAxLjBcXG4gICAgICAgIGZsb2F0ICBmID0gdWludEJpdHNUb0Zsb2F0KCBtICk7ICAgICAgIC8vIFJhbmdlIFsxOjJdXFxuICAgICAgICByZXR1cm4gZiAtIDEuMDsgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYW5nZSBbMDoxXVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBQc2V1ZG8tcmFuZG9tIHZhbHVlIGluIGhhbGYtb3BlbiByYW5nZSBbMDoxXS5cXG4gICAgICBmbG9hdCByYW5kb20oIGZsb2F0IHggKSB7IHJldHVybiBmbG9hdENvbnN0cnVjdChoYXNoKGZsb2F0Qml0c1RvVWludCh4KSkpOyB9XFxuICAgICAgZmxvYXQgcmFuZG9tKCB2ZWMyICB2ICkgeyByZXR1cm4gZmxvYXRDb25zdHJ1Y3QoaGFzaChmbG9hdEJpdHNUb1VpbnQodikpKTsgfVxcbiAgICAgIGZsb2F0IHJhbmRvbSggdmVjMyAgdiApIHsgcmV0dXJuIGZsb2F0Q29uc3RydWN0KGhhc2goZmxvYXRCaXRzVG9VaW50KHYpKSk7IH1cXG4gICAgICBmbG9hdCByYW5kb20oIHZlYzQgIHYgKSB7IHJldHVybiBmbG9hdENvbnN0cnVjdChoYXNoKGZsb2F0Qml0c1RvVWludCh2KSkpOyB9XFxuXFxuICAgICAgZmxvYXQgcmFuZCgpIHtcXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IHJhbmRvbSh2ZWMzKGdsX0ZyYWdDb29yZC54eSwgc2VlZCkpO1xcbiAgICAgICAgc2VlZCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBmbG9hdCBGMyA9ICAwLjMzMzMzMzM7XFxuICAgICAgY29uc3QgZmxvYXQgRzMgPSAgMC4xNjY2NjY3O1xcblxcbiAgICAgIGZsb2F0IHNub2lzZSh2ZWMzIHApIHtcXG4gICAgICAgIHZlYzMgcyA9IGZsb29yKHAgKyBkb3QocCwgdmVjMyhGMykpKTtcXG4gICAgICAgIHZlYzMgeCA9IHAgLSBzICsgZG90KHMsIHZlYzMoRzMpKTtcXG4gICAgICAgIHZlYzMgZSA9IHN0ZXAodmVjMygwLjApLCB4IC0geC55engpO1xcbiAgICAgICAgdmVjMyBpMSA9IGUqKDEuMCAtIGUuenh5KTtcXG4gICAgICAgIHZlYzMgaTIgPSAxLjAgLSBlLnp4eSooMS4wIC0gZSk7XFxuICAgICAgICB2ZWMzIHgxID0geCAtIGkxICsgRzM7XFxuICAgICAgICB2ZWMzIHgyID0geCAtIGkyICsgMi4wKkczO1xcbiAgICAgICAgdmVjMyB4MyA9IHggLSAxLjAgKyAzLjAqRzM7XFxuICAgICAgICB2ZWM0IHcsIGQ7XFxuICAgICAgICB3LnggPSBkb3QoeCwgeCk7XFxuICAgICAgICB3LnkgPSBkb3QoeDEsIHgxKTtcXG4gICAgICAgIHcueiA9IGRvdCh4MiwgeDIpO1xcbiAgICAgICAgdy53ID0gZG90KHgzLCB4Myk7XFxuICAgICAgICB3ID0gbWF4KDAuNiAtIHcsIDAuMCk7XFxuICAgICAgICBkLnggPSBkb3QocmFuZG9tMyhzKSwgeCk7XFxuICAgICAgICBkLnkgPSBkb3QocmFuZG9tMyhzICsgaTEpLCB4MSk7XFxuICAgICAgICBkLnogPSBkb3QocmFuZG9tMyhzICsgaTIpLCB4Mik7XFxuICAgICAgICBkLncgPSBkb3QocmFuZG9tMyhzICsgMS4wKSwgeDMpO1xcbiAgICAgICAgdyAqPSB3O1xcbiAgICAgICAgdyAqPSB3O1xcbiAgICAgICAgZCAqPSB3O1xcbiAgICAgICAgcmV0dXJuIGRvdChkLCB2ZWM0KDUyLjApKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgc25vaXNlRnJhY3RhbCh2ZWMzIG0pIHtcXG4gICAgICAgIHJldHVybiAwLjUzMzMzMzMqIHNub2lzZShtKVxcbiAgICAgICAgICAgICAgKzAuMjY2NjY2Nyogc25vaXNlKDIuMCptKVxcbiAgICAgICAgICAgICAgKzAuMTMzMzMzMyogc25vaXNlKDQuMCptKVxcbiAgICAgICAgICAgICAgKzAuMDY2NjY2Nyogc25vaXNlKDguMCptKTtcXG4gICAgICB9XFxuXCIrci5mcmFnbWVudFNoYWRlcixyLmZyYWdtZW50U2hhZGVyPXIuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDx0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudD5cIixcIlxcbiAgICAgICAgI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG4gICAgICAgICAgLy8gVHJhbnNtaXNzaW9uIGNvZGUgaXMgYmFzZWQgb24gZ2xURi1TYW1wbGVyLVZpZXdlclxcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYtU2FtcGxlLVZpZXdlclxcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IF90cmFuc21pc3Npb247XFxuICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdGhpY2tuZXNzO1xcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuICAgICAgICAgIHVuaWZvcm0gdmVjMyBhdHRlbnVhdGlvbkNvbG9yO1xcbiAgICAgICAgICAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvbk1hcDtcXG4gICAgICAgICAgI2VuZGlmXFxuICAgICAgICAgICNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGhpY2tuZXNzTWFwO1xcbiAgICAgICAgICAjZW5kaWZcXG4gICAgICAgICAgdW5pZm9ybSB2ZWMyIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplO1xcbiAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25TYW1wbGVyTWFwO1xcbiAgICAgICAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XFxuICAgICAgICAgIHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbiAgICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAgICAgICAgIHZlYzMgZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBjb25zdCBpbiB2ZWMzIG4sIGNvbnN0IGluIHZlYzMgdiwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IsIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXggKSB7XFxuICAgICAgICAgICAgLy8gRGlyZWN0aW9uIG9mIHJlZnJhY3RlZCBsaWdodC5cXG4gICAgICAgICAgICB2ZWMzIHJlZnJhY3Rpb25WZWN0b3IgPSByZWZyYWN0KCAtIHYsIG5vcm1hbGl6ZSggbiApLCAxLjAgLyBpb3IgKTtcXG4gICAgICAgICAgICAvLyBDb21wdXRlIHJvdGF0aW9uLWluZGVwZW5kYW50IHNjYWxpbmcgb2YgdGhlIG1vZGVsIG1hdHJpeC5cXG4gICAgICAgICAgICB2ZWMzIG1vZGVsU2NhbGU7XFxuICAgICAgICAgICAgbW9kZWxTY2FsZS54ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMCBdLnh5eiApICk7XFxuICAgICAgICAgICAgbW9kZWxTY2FsZS55ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMSBdLnh5eiApICk7XFxuICAgICAgICAgICAgbW9kZWxTY2FsZS56ID0gbGVuZ3RoKCB2ZWMzKCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICk7XFxuICAgICAgICAgICAgLy8gVGhlIHRoaWNrbmVzcyBpcyBzcGVjaWZpZWQgaW4gbG9jYWwgc3BhY2UuXFxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZSggcmVmcmFjdGlvblZlY3RvciApICogdGhpY2tuZXNzICogbW9kZWxTY2FsZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBmbG9hdCBhcHBseUlvclRvUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG4gICAgICAgICAgICAvLyBTY2FsZSByb3VnaG5lc3Mgd2l0aCBJT1Igc28gdGhhdCBhbiBJT1Igb2YgMS4wIHJlc3VsdHMgaW4gbm8gbWljcm9mYWNldCByZWZyYWN0aW9uIGFuZFxcbiAgICAgICAgICAgIC8vIGFuIElPUiBvZiAxLjUgcmVzdWx0cyBpbiB0aGUgZGVmYXVsdCBhbW91bnQgb2YgbWljcm9mYWNldCByZWZyYWN0aW9uLlxcbiAgICAgICAgICAgIHJldHVybiByb3VnaG5lc3MgKiBjbGFtcCggaW9yICogMi4wIC0gMi4wLCAwLjAsIDEuMCApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHZlYzQgZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCBjb25zdCBpbiB2ZWMyIGZyYWdDb29yZCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBjb25zdCBpbiBmbG9hdCBpb3IgKSB7XFxuICAgICAgICAgICAgZmxvYXQgZnJhbWVidWZmZXJMb2QgPSBsb2cyKCB0cmFuc21pc3Npb25TYW1wbGVyU2l6ZS54ICkgKiBhcHBseUlvclRvUm91Z2huZXNzKCByb3VnaG5lc3MsIGlvciApOyAgICAgICAgICAgIFxcbiAgICAgICAgICAgICNpZmRlZiBVU0VfU0FNUExFUlxcbiAgICAgICAgICAgICAgI2lmZGVmIHRleHR1cmUyRExvZEVYVFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJETG9kRVhUKHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgZnJhbWVidWZmZXJMb2QpO1xcbiAgICAgICAgICAgICAgI2Vsc2VcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmUyRCh0cmFuc21pc3Npb25TYW1wbGVyTWFwLCBmcmFnQ29vcmQueHksIGZyYW1lYnVmZmVyTG9kKTtcXG4gICAgICAgICAgICAgICNlbmRpZlxcbiAgICAgICAgICAgICNlbHNlXFxuICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTJEKGJ1ZmZlciwgZnJhZ0Nvb3JkLnh5KTtcXG4gICAgICAgICAgICAjZW5kaWZcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2ZWMzIGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24oIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIGZsb2F0IHRyYW5zbWlzc2lvbkRpc3RhbmNlLCBjb25zdCBpbiB2ZWMzIGF0dGVudWF0aW9uQ29sb3IsIGNvbnN0IGluIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2UgKSB7XFxuICAgICAgICAgICAgaWYgKCBpc2luZiggYXR0ZW51YXRpb25EaXN0YW5jZSApICkge1xcbiAgICAgICAgICAgICAgLy8gQXR0ZW51YXRpb24gZGlzdGFuY2UgaXMgK+KIniwgaS5lLiB0aGUgdHJhbnNtaXR0ZWQgY29sb3IgaXMgbm90IGF0dGVudWF0ZWQgYXQgYWxsLlxcbiAgICAgICAgICAgICAgcmV0dXJuIHJhZGlhbmNlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBDb21wdXRlIGxpZ2h0IGF0dGVudWF0aW9uIHVzaW5nIEJlZXIncyBsYXcuXFxuICAgICAgICAgICAgICB2ZWMzIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgPSAtbG9nKCBhdHRlbnVhdGlvbkNvbG9yICkgLyBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcbiAgICAgICAgICAgICAgdmVjMyB0cmFuc21pdHRhbmNlID0gZXhwKCAtIGF0dGVudWF0aW9uQ29lZmZpY2llbnQgKiB0cmFuc21pc3Npb25EaXN0YW5jZSApOyAvLyBCZWVyJ3MgbGF3XFxuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNtaXR0YW5jZSAqIHJhZGlhbmNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICB2ZWM0IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oIGNvbnN0IGluIHZlYzMgbiwgY29uc3QgaW4gdmVjMyB2LCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIHZlYzMgZGlmZnVzZUNvbG9yLFxcbiAgICAgICAgICAgIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIHZlYzMgcG9zaXRpb24sIGNvbnN0IGluIG1hdDQgbW9kZWxNYXRyaXgsXFxuICAgICAgICAgICAgY29uc3QgaW4gbWF0NCB2aWV3TWF0cml4LCBjb25zdCBpbiBtYXQ0IHByb2pNYXRyaXgsIGNvbnN0IGluIGZsb2F0IGlvciwgY29uc3QgaW4gZmxvYXQgdGhpY2tuZXNzLFxcbiAgICAgICAgICAgIGNvbnN0IGluIHZlYzMgYXR0ZW51YXRpb25Db2xvciwgY29uc3QgaW4gZmxvYXQgYXR0ZW51YXRpb25EaXN0YW5jZSApIHtcXG4gICAgICAgICAgICB2ZWMzIHRyYW5zbWlzc2lvblJheSA9IGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggbiwgdiwgdGhpY2tuZXNzLCBpb3IsIG1vZGVsTWF0cml4ICk7XFxuICAgICAgICAgICAgdmVjMyByZWZyYWN0ZWRSYXlFeGl0ID0gcG9zaXRpb24gKyB0cmFuc21pc3Npb25SYXk7XFxuICAgICAgICAgICAgLy8gUHJvamVjdCByZWZyYWN0ZWQgdmVjdG9yIG9uIHRoZSBmcmFtZWJ1ZmZlciwgd2hpbGUgbWFwcGluZyB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcy5cXG4gICAgICAgICAgICB2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7XFxuICAgICAgICAgICAgdmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7XFxuICAgICAgICAgICAgcmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7XFxuICAgICAgICAgICAgcmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7XFxuICAgICAgICAgICAgLy8gU2FtcGxlIGZyYW1lYnVmZmVyIHRvIGdldCBwaXhlbCB0aGUgcmVmcmFjdGVkIHJheSBoaXRzLlxcbiAgICAgICAgICAgIHZlYzQgdHJhbnNtaXR0ZWRMaWdodCA9IGdldFRyYW5zbWlzc2lvblNhbXBsZSggcmVmcmFjdGlvbkNvb3Jkcywgcm91Z2huZXNzLCBpb3IgKTtcXG4gICAgICAgICAgICB2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IGFwcGx5Vm9sdW1lQXR0ZW51YXRpb24oIHRyYW5zbWl0dGVkTGlnaHQucmdiLCBsZW5ndGgoIHRyYW5zbWlzc2lvblJheSApLCBhdHRlbnVhdGlvbkNvbG9yLCBhdHRlbnVhdGlvbkRpc3RhbmNlICk7XFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzcGVjdWxhciBjb21wb25lbnQuXFxuICAgICAgICAgICAgdmVjMyBGID0gRW52aXJvbm1lbnRCUkRGKCBuLCB2LCBzcGVjdWxhckNvbG9yLCBzcGVjdWxhckY5MCwgcm91Z2huZXNzICk7XFxuICAgICAgICAgICAgcmV0dXJuIHZlYzQoICggMS4wIC0gRiApICogYXR0ZW51YXRlZENvbG9yICogZGlmZnVzZUNvbG9yLCB0cmFuc21pdHRlZExpZ2h0LmEgKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgI2VuZGlmXFxuXCIpLHIuZnJhZ21lbnRTaGFkZXI9ci5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9mcmFnbWVudD5cIixgICBcXG4gICAgICAgIC8vIEltcHJvdmUgdGhlIHJlZnJhY3Rpb24gdG8gdXNlIHRoZSB3b3JsZCBwb3NcXG4gICAgICAgIG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA9IF90cmFuc21pc3Npb247XFxuICAgICAgICBtYXRlcmlhbC50cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcXG4gICAgICAgIG1hdGVyaWFsLnRoaWNrbmVzcyA9IHRoaWNrbmVzcztcXG4gICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBhdHRlbnVhdGlvbkRpc3RhbmNlO1xcbiAgICAgICAgbWF0ZXJpYWwuYXR0ZW51YXRpb25Db2xvciA9IGF0dGVudWF0aW9uQ29sb3I7XFxuICAgICAgICAjaWZkZWYgVVNFX1RSQU5TTUlTU0lPTk1BUFxcbiAgICAgICAgICBtYXRlcmlhbC50cmFuc21pc3Npb24gKj0gdGV4dHVyZTJEKCB0cmFuc21pc3Npb25NYXAsIHZVdiApLnI7XFxuICAgICAgICAjZW5kaWZcXG4gICAgICAgICNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuICAgICAgICAgIG1hdGVyaWFsLnRoaWNrbmVzcyAqPSB0ZXh0dXJlMkQoIHRoaWNrbmVzc01hcCwgdlV2ICkuZztcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICAgXFxuICAgICAgICB2ZWMzIHBvcyA9IHZXb3JsZFBvc2l0aW9uO1xcbiAgICAgICAgdmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApO1xcbiAgICAgICAgdmVjMyBuID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuICAgICAgICB2ZWMzIHRyYW5zbWlzc2lvbiA9IHZlYzMoMC4wKTtcXG4gICAgICAgIGZsb2F0IHRyYW5zbWlzc2lvblIsIHRyYW5zbWlzc2lvbkIsIHRyYW5zbWlzc2lvbkc7XFxuICAgICAgICBmbG9hdCByYW5kb21Db29yZHMgPSByYW5kKCk7XFxuICAgICAgICBmbG9hdCB0aGlja25lc3Nfc21lYXIgPSB0aGlja25lc3MgKiBtYXgocG93KHJvdWdobmVzc0ZhY3RvciwgMC4zMyksIGFuaXNvdHJvcGljQmx1cik7XFxuICAgICAgICB2ZWMzIGRpc3RvcnRpb25Ob3JtYWwgPSB2ZWMzKDAuMCk7XFxuICAgICAgICB2ZWMzIHRlbXBvcmFsT2Zmc2V0ID0gdmVjMyh0aW1lLCAtdGltZSwgLXRpbWUpICogdGVtcG9yYWxEaXN0b3J0aW9uO1xcbiAgICAgICAgaWYgKGRpc3RvcnRpb24gPiAwLjApIHtcXG4gICAgICAgICAgZGlzdG9ydGlvbk5vcm1hbCA9IGRpc3RvcnRpb24gKiB2ZWMzKHNub2lzZUZyYWN0YWwodmVjMygocG9zICogZGlzdG9ydGlvblNjYWxlICsgdGVtcG9yYWxPZmZzZXQpKSksIHNub2lzZUZyYWN0YWwodmVjMyhwb3Muenh5ICogZGlzdG9ydGlvblNjYWxlIC0gdGVtcG9yYWxPZmZzZXQpKSwgc25vaXNlRnJhY3RhbCh2ZWMzKHBvcy55eHogKiBkaXN0b3J0aW9uU2NhbGUgKyB0ZW1wb3JhbE9mZnNldCkpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoZmxvYXQgaSA9IDAuMDsgaSA8ICR7ZX0uMDsgaSArKykge1xcbiAgICAgICAgICB2ZWMzIHNhbXBsZU5vcm0gPSBub3JtYWxpemUobiArIHJvdWdobmVzc0ZhY3RvciAqIHJvdWdobmVzc0ZhY3RvciAqIDIuMCAqIG5vcm1hbGl6ZSh2ZWMzKHJhbmQoKSAtIDAuNSwgcmFuZCgpIC0gMC41LCByYW5kKCkgLSAwLjUpKSAqIHBvdyhyYW5kKCksIDAuMzMpICsgZGlzdG9ydGlvbk5vcm1hbCk7XFxuICAgICAgICAgIHRyYW5zbWlzc2lvblIgPSBnZXRJQkxWb2x1bWVSZWZyYWN0aW9uKFxcbiAgICAgICAgICAgIHNhbXBsZU5vcm0sIHYsIG1hdGVyaWFsLnJvdWdobmVzcywgbWF0ZXJpYWwuZGlmZnVzZUNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCxcXG4gICAgICAgICAgICBwb3MsIG1vZGVsTWF0cml4LCB2aWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4LCBtYXRlcmlhbC5pb3IsIG1hdGVyaWFsLnRoaWNrbmVzcyAgKyB0aGlja25lc3Nfc21lYXIgKiAoaSArIHJhbmRvbUNvb3JkcykgLyBmbG9hdCgke2V9KSxcXG4gICAgICAgICAgICBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yLCBtYXRlcmlhbC5hdHRlbnVhdGlvbkRpc3RhbmNlXFxuICAgICAgICAgICkucjtcXG4gICAgICAgICAgdHJhbnNtaXNzaW9uRyA9IGdldElCTFZvbHVtZVJlZnJhY3Rpb24oXFxuICAgICAgICAgICAgc2FtcGxlTm9ybSwgdiwgbWF0ZXJpYWwucm91Z2huZXNzLCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLFxcbiAgICAgICAgICAgIHBvcywgbW9kZWxNYXRyaXgsIHZpZXdNYXRyaXgsIHByb2plY3Rpb25NYXRyaXgsIG1hdGVyaWFsLmlvciAgKiAoMS4wICsgY2hyb21hdGljQWJlcnJhdGlvbiAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pKSAsIG1hdGVyaWFsLnRoaWNrbmVzcyArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pLFxcbiAgICAgICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2VcXG4gICAgICAgICAgKS5nO1xcbiAgICAgICAgICB0cmFuc21pc3Npb25CID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG4gICAgICAgICAgICBzYW1wbGVOb3JtLCB2LCBtYXRlcmlhbC5yb3VnaG5lc3MsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuICAgICAgICAgICAgcG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgbWF0ZXJpYWwuaW9yICogKDEuMCArIDIuMCAqIGNocm9tYXRpY0FiZXJyYXRpb24gKiAoaSArIHJhbmRvbUNvb3JkcykgLyBmbG9hdCgke2V9KSksIG1hdGVyaWFsLnRoaWNrbmVzcyArIHRoaWNrbmVzc19zbWVhciAqIChpICsgcmFuZG9tQ29vcmRzKSAvIGZsb2F0KCR7ZX0pLFxcbiAgICAgICAgICAgIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3IsIG1hdGVyaWFsLmF0dGVudWF0aW9uRGlzdGFuY2VcXG4gICAgICAgICAgKS5iO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uciArPSB0cmFuc21pc3Npb25SO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uZyArPSB0cmFuc21pc3Npb25HO1xcbiAgICAgICAgICB0cmFuc21pc3Npb24uYiArPSB0cmFuc21pc3Npb25CO1xcbiAgICAgICAgfVxcbiAgICAgICAgdHJhbnNtaXNzaW9uIC89ICR7ZX0uMDtcXG4gICAgICAgIHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pc3Npb24ucmdiLCBtYXRlcmlhbC50cmFuc21pc3Npb24gKTtcXG5gKX0sT2JqZWN0LmtleXModGhpcy51bmlmb3JtcykuZm9yRWFjaCgoZT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsZSx7Z2V0OigpPT50aGlzLnVuaWZvcm1zW2VdLnZhbHVlLHNldDp0PT50aGlzLnVuaWZvcm1zW2VdLnZhbHVlPXR9KSkpfX1jb25zdCBIcj1QLmZvcndhcmRSZWYoKCh7YnVmZmVyOmUsdHJhbnNtaXNzaW9uU2FtcGxlcjp0PSExLGJhY2tzaWRlOnI9ITEsc2lkZTpuPUQuRnJvbnRTaWRlLHRyYW5zbWlzc2lvbjpvPTEsdGhpY2tuZXNzOmk9MCxiYWNrc2lkZVRoaWNrbmVzczpzPTAsc2FtcGxlczpsPTEwLHJlc29sdXRpb246YyxiYWNrc2lkZVJlc29sdXRpb246dSxiYWNrZ3JvdW5kOmQsYW5pc290cm9weTptLGFuaXNvdHJvcGljQmx1cjpmLC4uLnB9LGgpPT57YS5leHRlbmQoe01lc2hUcmFuc21pc3Npb25NYXRlcmlhbDpHcn0pO2NvbnN0IHg9UC51c2VSZWYobnVsbCksW3ldPVAudXNlU3RhdGUoKCgpPT5uZXcgV3IpKSx2PW50KHV8fGMpLGc9bnQoYyk7bGV0IHosdyxiO3JldHVybiBhLnVzZUZyYW1lKChlPT57eC5jdXJyZW50LnRpbWU9ZS5jbG9jay5nZXRFbGFwc2VkVGltZSgpLHguY3VycmVudC5idWZmZXIhPT1nLnRleHR1cmV8fHR8fChiPXguY3VycmVudC5fX3IzZi5wYXJlbnQsYiYmKHc9ZS5nbC50b25lTWFwcGluZyx6PWUuc2NlbmUuYmFja2dyb3VuZCxlLmdsLnRvbmVNYXBwaW5nPUQuTm9Ub25lTWFwcGluZyxkJiYoZS5zY2VuZS5iYWNrZ3JvdW5kPWQpLGIubWF0ZXJpYWw9eSxyJiYoZS5nbC5zZXRSZW5kZXJUYXJnZXQodiksZS5nbC5yZW5kZXIoZS5zY2VuZSxlLmNhbWVyYSksYi5tYXRlcmlhbD14LmN1cnJlbnQsYi5tYXRlcmlhbC5idWZmZXI9di50ZXh0dXJlLGIubWF0ZXJpYWwudGhpY2tuZXNzPXMsYi5tYXRlcmlhbC5zaWRlPUQuQmFja1NpZGUpLGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGcpLGUuZ2wucmVuZGVyKGUuc2NlbmUsZS5jYW1lcmEpLGIubWF0ZXJpYWw9eC5jdXJyZW50LGIubWF0ZXJpYWwudGhpY2tuZXNzPWksYi5tYXRlcmlhbC5zaWRlPW4sYi5tYXRlcmlhbC5idWZmZXI9Zy50ZXh0dXJlLGUuc2NlbmUuYmFja2dyb3VuZD16LGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KG51bGwpLGUuZ2wudG9uZU1hcHBpbmc9dykpfSkpLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShoLCgoKT0+eC5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFRyYW5zbWlzc2lvbk1hdGVyaWFsXCIsQy5kZWZhdWx0KHthcmdzOltsLHRdLHJlZjp4fSxwLHtidWZmZXI6ZXx8Zy50ZXh0dXJlLF90cmFuc21pc3Npb246byxhbmlzb3Ryb3BpY0JsdXI6bnVsbCE9Zj9mOm0sdHJhbnNtaXNzaW9uOnQ/bzowLHRoaWNrbmVzczppLHNpZGU6bn0pKX0pKSwkcj1QLmZvcndhcmRSZWYoKChlLHQpPT4oYS5leHRlbmQoe0Rpc2NhcmRNYXRlcmlhbEltcGw6V3J9KSxQLmNyZWF0ZUVsZW1lbnQoXCJkaXNjYXJkTWF0ZXJpYWxJbXBsXCIsQy5kZWZhdWx0KHtyZWY6dH0sZSkpKSkpLHFyPUNlPj0xNTQ/XCJvcGFxdWVfZnJhZ21lbnRcIjpcIm91dHB1dF9mcmFnbWVudFwiO2NsYXNzIFhyIGV4dGVuZHMgRC5Qb2ludHNNYXRlcmlhbHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlKSx0aGlzLm9uQmVmb3JlQ29tcGlsZT0oZSx0KT0+e2NvbnN0e2lzV2ViR0wyOnJ9PXQuY2FwYWJpbGl0aWVzO2UuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKGAjaW5jbHVkZSA8JHtxcn0+YCxgXFxuICAgICAgICAke3I/YCNpbmNsdWRlIDwke3FyfT5gOmAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiNpbmNsdWRlIDwke3FyfT5gfVxcbiAgICAgIHZlYzIgY3h5ID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXG4gICAgICBmbG9hdCByID0gZG90KGN4eSwgY3h5KTtcXG4gICAgICBmbG9hdCBkZWx0YSA9IGZ3aWR0aChyKTsgICAgIFxcbiAgICAgIGZsb2F0IG1hc2sgPSAxLjAgLSBzbW9vdGhzdGVwKDEuMCAtIGRlbHRhLCAxLjAgKyBkZWx0YSwgcik7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChnbF9GcmFnQ29sb3IucmdiLCBtYXNrICogZ2xfRnJhZ0NvbG9yLmEgKTtcXG4gICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgI2luY2x1ZGUgPCR7Q2U+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICAgICBgKX19fWNvbnN0IFpyPVAuZm9yd2FyZFJlZigoKGUsdCk9Pntjb25zdFtyXT1QLnVzZVN0YXRlKCgoKT0+bmV3IFhyKG51bGwpKSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLEMuZGVmYXVsdCh7fSxlLHtvYmplY3Q6cixyZWY6dCxhdHRhY2g6XCJtYXRlcmlhbFwifSkpfSkpO2Z1bmN0aW9uIFlyKGUsdCxyKXt0LnRyYXZlcnNlKCh0PT57dC5tYXRlcmlhbCYmKGUucHJvcGVydGllcy5yZW1vdmUodC5tYXRlcmlhbCksbnVsbD09dC5tYXRlcmlhbC5kaXNwb3NlfHx0Lm1hdGVyaWFsLmRpc3Bvc2UoKSl9KSksZS5pbmZvLnByb2dyYW1zLmxlbmd0aD0wLGUuY29tcGlsZSh0LHIpfWZ1bmN0aW9uIFFyKGUsdCl7Y29uc3Qgcj1lK1wiR2VvbWV0cnlcIjtyZXR1cm4gUC5mb3J3YXJkUmVmKCgoe2FyZ3M6ZSxjaGlsZHJlbjpuLC4uLmF9LG8pPT57Y29uc3QgaT1QLnVzZVJlZihudWxsKTtyZXR1cm4gUC51c2VJbXBlcmF0aXZlSGFuZGxlKG8sKCgpPT5pLmN1cnJlbnQpKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9PntudWxsPT10fHx0KGkuY3VycmVudCl9KSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLEMuZGVmYXVsdCh7cmVmOml9LGEpLFAuY3JlYXRlRWxlbWVudChyLHthdHRhY2g6XCJnZW9tZXRyeVwiLGFyZ3M6ZX0pLG4pfSkpfWNvbnN0IEtyPVFyKFwiYm94XCIpLEpyPVFyKFwiY2lyY2xlXCIpLGVuPVFyKFwiY29uZVwiKSx0bj1RcihcImN5bGluZGVyXCIpLHJuPVFyKFwic3BoZXJlXCIpLG5uPVFyKFwicGxhbmVcIiksYW49UXIoXCJ0dWJlXCIpLG9uPVFyKFwidG9ydXNcIiksc249UXIoXCJ0b3J1c0tub3RcIiksbG49UXIoXCJ0ZXRyYWhlZHJvblwiKSxjbj1RcihcInJpbmdcIiksdW49UXIoXCJwb2x5aGVkcm9uXCIpLGRuPVFyKFwiaWNvc2FoZWRyb25cIiksbW49UXIoXCJvY3RhaGVkcm9uXCIpLGZuPVFyKFwiZG9kZWNhaGVkcm9uXCIpLHBuPVFyKFwiZXh0cnVkZVwiKSxobj1RcihcImxhdGhlXCIpLHhuPVFyKFwiY2Fwc3VsZVwiKSx5bj1RcihcInNoYXBlXCIsKCh7Z2VvbWV0cnk6ZX0pPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMucG9zaXRpb24scj0obmV3IEQuQm94Mykuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSxuPW5ldyBELlZlY3RvcjM7ci5nZXRTaXplKG4pO2NvbnN0IGE9W107bGV0IG89MCxpPTAscz0wLGw9MDtmb3IobGV0IGU9MDtlPHQuY291bnQ7ZSsrKW89dC5nZXRYKGUpLGk9dC5nZXRZKGUpLHM9KG8tci5taW4ueCkvbi54LGw9KGktci5taW4ueSkvbi55LGEucHVzaChzLGwpO2Uuc2V0QXR0cmlidXRlKFwidXZcIixuZXcgRC5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGEsMikpfSkpLHZuPTFlLTU7Y29uc3QgZ249UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7YXJnczpbZT0xLHQ9MSxyPTFdPVtdLHJhZGl1czphPS4wNSxzdGVwczpvPTEsc21vb3RobmVzczppPTQsYmV2ZWxTZWdtZW50czpzPTQsY3JlYXNlQW5nbGU6bD0uNCxjaGlsZHJlbjpjLC4uLnV9LG0pe2NvbnN0IGY9UC51c2VNZW1vKCgoKT0+ZnVuY3Rpb24oZSx0LHIpe2NvbnN0IGE9bmV3IG4uU2hhcGUsbz1yLXZuO3JldHVybiBhLmFic2FyYyh2bix2bix2biwtTWF0aC5QSS8yLC1NYXRoLlBJLCEwKSxhLmFic2FyYyh2bix0LTIqbyx2bixNYXRoLlBJLE1hdGguUEkvMiwhMCksYS5hYnNhcmMoZS0yKm8sdC0yKm8sdm4sTWF0aC5QSS8yLDAsITApLGEuYWJzYXJjKGUtMipvLHZuLHZuLDAsLU1hdGguUEkvMiwhMCksYX0oZSx0LGEpKSxbZSx0LGFdKSxwPVAudXNlTWVtbygoKCk9Pih7ZGVwdGg6ci0yKmEsYmV2ZWxFbmFibGVkOiEwLGJldmVsU2VnbWVudHM6MipzLHN0ZXBzOm8sYmV2ZWxTaXplOmEtdm4sYmV2ZWxUaGlja25lc3M6YSxjdXJ2ZVNlZ21lbnRzOml9KSksW3IsYSxpXSksaD1QLnVzZVJlZihudWxsKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aC5jdXJyZW50JiYoaC5jdXJyZW50LmNlbnRlcigpLGQudG9DcmVhc2VkTm9ybWFscyhoLmN1cnJlbnQsbCkpfSksW2YscF0pLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIixDLmRlZmF1bHQoe3JlZjptfSx1KSxQLmNyZWF0ZUVsZW1lbnQoXCJleHRydWRlR2VvbWV0cnlcIix7cmVmOmgsYXJnczpbZixwXX0pLGMpfSkpO2Z1bmN0aW9uIHpuKCl7Y29uc3QgZT1uZXcgRC5CdWZmZXJHZW9tZXRyeSx0PW5ldyBGbG9hdDMyQXJyYXkoWy0xLC0xLDMsLTEsLTEsM10pO3JldHVybiBlLmJvdW5kaW5nU3BoZXJlPW5ldyBELlNwaGVyZSxlLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgRC5WZWN0b3IzLDEvMCksZS5zZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiLG5ldyBELkJ1ZmZlckF0dHJpYnV0ZSh0LDIpKSxlfWNvbnN0IHduPVAuZm9yd2FyZFJlZigoZnVuY3Rpb24oe2NoaWxkcmVuOmUsLi4udH0scil7Y29uc3Qgbj1QLnVzZU1lbW8oem4sW10pO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZWY6cixnZW9tZXRyeTpuLGZydXN0dW1DdWxsZWQ6ITF9LHQpLGUpfSkpLGJuPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHdpZHRoOnQsaGVpZ2h0OnIsZGVwdGg6bixib3gzOmEscHJlY2lzZTpvPSEwLC4uLml9LHMpPT57Y29uc3QgbD1QLnVzZVJlZihudWxsKSxjPVAudXNlUmVmKG51bGwpLHU9UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2MuY3VycmVudC5tYXRyaXhXb3JsZC5pZGVudGl0eSgpO2xldCBlPWF8fChuZXcgRC5Cb3gzKS5zZXRGcm9tT2JqZWN0KHUuY3VycmVudCxvKTtjb25zdCBpPWUubWF4LngtZS5taW4ueCxzPWUubWF4LnktZS5taW4ueSxsPWUubWF4LnotZS5taW4uejtsZXQgZD1NYXRoLm1heChpLHMsbCk7dCYmKGQ9aSksciYmKGQ9cyksbiYmKGQ9bCksYy5jdXJyZW50LnNjYWxlLnNldFNjYWxhcigxL2QpfSksW3QscixuLGEsb10pLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShzLCgoKT0+bC5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjpsfSxpKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Y30sUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnV9LGUpKSl9KSk7dmFyIE1uPWZ1bmN0aW9uKGUpe3JldHVybiBlW2UuTk9ORT0wXT1cIk5PTkVcIixlW2UuU1RBUlQ9MV09XCJTVEFSVFwiLGVbZS5BQ1RJVkU9Ml09XCJBQ1RJVkVcIixlfShNbnx8e30pO2NvbnN0IEVuPWU9PmUmJmUuaXNPcnRob2dyYXBoaWNDYW1lcmEsU249ZT0+ZSYmZS5pc0JveDMsVG49ZT0+MS1NYXRoLmV4cCgtNSplKSsuMDA3KmUsQ249UC5jcmVhdGVDb250ZXh0KG51bGwpO2Z1bmN0aW9uIFBuKHtjaGlsZHJlbjplLG1heER1cmF0aW9uOnQ9MSxtYXJnaW46cj0xLjIsb2JzZXJ2ZTpuLGZpdDpvLGNsaXA6aSxpbnRlcnBvbGF0ZUZ1bmM6cz1UbixvbkZpdDpsfSl7Y29uc3QgYz1QLnVzZVJlZihudWxsKSx7Y2FtZXJhOnUsc2l6ZTpkLGludmFsaWRhdGU6bX09YS51c2VUaHJlZSgpLGY9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLHA9UC51c2VSZWYobCk7cC5jdXJyZW50PWw7Y29uc3QgaD1QLnVzZVJlZih7Y2FtUG9zOm5ldyBELlZlY3RvcjMsY2FtUm90Om5ldyBELlF1YXRlcm5pb24sY2FtWm9vbToxfSkseD1QLnVzZVJlZih7Y2FtUG9zOnZvaWQgMCxjYW1Sb3Q6dm9pZCAwLGNhbVpvb206dm9pZCAwLGNhbVVwOnZvaWQgMCx0YXJnZXQ6dm9pZCAwfSkseT1QLnVzZVJlZihNbi5OT05FKSx2PVAudXNlUmVmKDApLFtnXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuQm94MykpLHo9UC51c2VNZW1vKCgoKT0+e2Z1bmN0aW9uIGUoKXtjb25zdCBlPWcuZ2V0U2l6ZShuZXcgRC5WZWN0b3IzKSx0PWcuZ2V0Q2VudGVyKG5ldyBELlZlY3RvcjMpLG49TWF0aC5tYXgoZS54LGUueSxlLnopLGE9RW4odSk/NCpuOm4vKDIqTWF0aC5hdGFuKE1hdGguUEkqdS5mb3YvMzYwKSksbz1Fbih1KT80Km46YS91LmFzcGVjdCxpPXIqTWF0aC5tYXgoYSxvKTtyZXR1cm57Ym94Omcsc2l6ZTplLGNlbnRlcjp0LGRpc3RhbmNlOml9fXJldHVybntnZXRTaXplOmUscmVmcmVzaChlKXtpZihTbihlKSlnLmNvcHkoZSk7ZWxzZXtjb25zdCB0PWV8fGMuY3VycmVudDtpZighdClyZXR1cm4gdGhpczt0LnVwZGF0ZVdvcmxkTWF0cml4KCEwLCEwKSxnLnNldEZyb21PYmplY3QodCl9aWYoZy5pc0VtcHR5KCkpe2NvbnN0IGU9dS5wb3NpdGlvbi5sZW5ndGgoKXx8MTA7Zy5zZXRGcm9tQ2VudGVyQW5kU2l6ZShuZXcgRC5WZWN0b3IzLG5ldyBELlZlY3RvcjMoZSxlLGUpKX1yZXR1cm4gaC5jdXJyZW50LmNhbVBvcy5jb3B5KHUucG9zaXRpb24pLGguY3VycmVudC5jYW1Sb3QuY29weSh1LnF1YXRlcm5pb24pLEVuKHUpJiYoaC5jdXJyZW50LmNhbVpvb209dS56b29tKSx4LmN1cnJlbnQuY2FtUG9zPXZvaWQgMCx4LmN1cnJlbnQuY2FtUm90PXZvaWQgMCx4LmN1cnJlbnQuY2FtWm9vbT12b2lkIDAseC5jdXJyZW50LmNhbVVwPXZvaWQgMCx4LmN1cnJlbnQudGFyZ2V0PXZvaWQgMCx0aGlzfSxyZXNldCgpe2NvbnN0e2NlbnRlcjp0LGRpc3RhbmNlOnJ9PWUoKSxuPXUucG9zaXRpb24uY2xvbmUoKS5zdWIodCkubm9ybWFsaXplKCk7eC5jdXJyZW50LmNhbVBvcz10LmNsb25lKCkuYWRkU2NhbGVkVmVjdG9yKG4scikseC5jdXJyZW50LnRhcmdldD10LmNsb25lKCk7Y29uc3QgYT0obmV3IEQuTWF0cml4NCkubG9va0F0KHguY3VycmVudC5jYW1Qb3MseC5jdXJyZW50LnRhcmdldCx1LnVwKTtyZXR1cm4geC5jdXJyZW50LmNhbVJvdD0obmV3IEQuUXVhdGVybmlvbikuc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpLHkuY3VycmVudD1Nbi5TVEFSVCx2LmN1cnJlbnQ9MCx0aGlzfSxtb3ZlVG8oZSl7cmV0dXJuIHguY3VycmVudC5jYW1Qb3M9QXJyYXkuaXNBcnJheShlKT9uZXcgRC5WZWN0b3IzKC4uLmUpOmUuY2xvbmUoKSx5LmN1cnJlbnQ9TW4uU1RBUlQsdi5jdXJyZW50PTAsdGhpc30sbG9va0F0KHt0YXJnZXQ6ZSx1cDp0fSl7eC5jdXJyZW50LnRhcmdldD1BcnJheS5pc0FycmF5KGUpP25ldyBELlZlY3RvcjMoLi4uZSk6ZS5jbG9uZSgpLHguY3VycmVudC5jYW1VcD10P0FycmF5LmlzQXJyYXkodCk/bmV3IEQuVmVjdG9yMyguLi50KTp0LmNsb25lKCk6dS51cC5jbG9uZSgpO2NvbnN0IHI9KG5ldyBELk1hdHJpeDQpLmxvb2tBdCh4LmN1cnJlbnQuY2FtUG9zfHx1LnBvc2l0aW9uLHguY3VycmVudC50YXJnZXQseC5jdXJyZW50LmNhbVVwKTtyZXR1cm4geC5jdXJyZW50LmNhbVJvdD0obmV3IEQuUXVhdGVybmlvbikuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHIpLHkuY3VycmVudD1Nbi5TVEFSVCx2LmN1cnJlbnQ9MCx0aGlzfSx0byh7cG9zaXRpb246ZSx0YXJnZXQ6dH0pe3JldHVybiB0aGlzLm1vdmVUbyhlKS5sb29rQXQoe3RhcmdldDp0fSl9LGZpdCgpe2lmKCFFbih1KSlyZXR1cm4gdGhpcy5yZXNldCgpO2xldCBlPTAsdD0wO2NvbnN0IG49W25ldyBELlZlY3RvcjMoZy5taW4ueCxnLm1pbi55LGcubWluLnopLG5ldyBELlZlY3RvcjMoZy5taW4ueCxnLm1heC55LGcubWluLnopLG5ldyBELlZlY3RvcjMoZy5taW4ueCxnLm1pbi55LGcubWF4LnopLG5ldyBELlZlY3RvcjMoZy5taW4ueCxnLm1heC55LGcubWF4LnopLG5ldyBELlZlY3RvcjMoZy5tYXgueCxnLm1heC55LGcubWF4LnopLG5ldyBELlZlY3RvcjMoZy5tYXgueCxnLm1heC55LGcubWluLnopLG5ldyBELlZlY3RvcjMoZy5tYXgueCxnLm1pbi55LGcubWF4LnopLG5ldyBELlZlY3RvcjMoZy5tYXgueCxnLm1pbi55LGcubWluLnopXSxhPXguY3VycmVudC5jYW1Qb3N8fHUucG9zaXRpb24sbz14LmN1cnJlbnQudGFyZ2V0fHwobnVsbD09Zj92b2lkIDA6Zi50YXJnZXQpLGk9eC5jdXJyZW50LmNhbVVwfHx1LnVwLHM9bz8obmV3IEQuTWF0cml4NCkubG9va0F0KGEsbyxpKS5zZXRQb3NpdGlvbihhKS5pbnZlcnQoKTp1Lm1hdHJpeFdvcmxkSW52ZXJzZTtmb3IoY29uc3QgciBvZiBuKXIuYXBwbHlNYXRyaXg0KHMpLGU9TWF0aC5tYXgoZSxNYXRoLmFicyhyLnkpKSx0PU1hdGgubWF4KHQsTWF0aC5hYnMoci54KSk7ZSo9Mix0Kj0yO2NvbnN0IGw9KHUudG9wLXUuYm90dG9tKS9lLGM9KHUucmlnaHQtdS5sZWZ0KS90O3JldHVybiB4LmN1cnJlbnQuY2FtWm9vbT1NYXRoLm1pbihsLGMpL3IseS5jdXJyZW50PU1uLlNUQVJULHYuY3VycmVudD0wLHAuY3VycmVudCYmcC5jdXJyZW50KHRoaXMuZ2V0U2l6ZSgpKSx0aGlzfSxjbGlwKCl7Y29uc3R7ZGlzdGFuY2U6dH09ZSgpO3JldHVybiB1Lm5lYXI9dC8xMDAsdS5mYXI9MTAwKnQsdS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCksZiYmKGYubWF4RGlzdGFuY2U9MTAqdCxmLnVwZGF0ZSgpKSxtKCksdGhpc319fSksW2csdSxmLHIsbV0pO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2lmKGYpe2NvbnN0IGU9KCk9PntpZihmJiZ4LmN1cnJlbnQudGFyZ2V0JiZ5LmN1cnJlbnQhPT1Nbi5OT05FKXtjb25zdCBlPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHUubWF0cml4LDIpLHQ9aC5jdXJyZW50LmNhbVBvcy5kaXN0YW5jZVRvKGYudGFyZ2V0KSxyPSh4LmN1cnJlbnQuY2FtUG9zfHxoLmN1cnJlbnQuY2FtUG9zKS5kaXN0YW5jZVRvKHguY3VycmVudC50YXJnZXQpLG49KDEtdi5jdXJyZW50KSp0K3YuY3VycmVudCpyO2YudGFyZ2V0LmNvcHkodS5wb3NpdGlvbikuYWRkU2NhbGVkVmVjdG9yKGUsLW4pLGYudXBkYXRlKCl9eS5jdXJyZW50PU1uLk5PTkV9O3JldHVybiBmLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLGUpLCgpPT5mLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzdGFydFwiLGUpfX0pLFtmXSk7Y29uc3Qgdz1QLnVzZVJlZigwKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57KG58fDA9PXcuY3VycmVudCsrKSYmKHoucmVmcmVzaCgpLG8mJnoucmVzZXQoKS5maXQoKSxpJiZ6LmNsaXAoKSl9KSxbZCxpLG8sbix1LGZdKSxhLnVzZUZyYW1lKCgoZSxyKT0+e2lmKHkuY3VycmVudD09PU1uLlNUQVJUKXkuY3VycmVudD1Nbi5BQ1RJVkUsbSgpO2Vsc2UgaWYoeS5jdXJyZW50PT09TW4uQUNUSVZFKXtpZih2LmN1cnJlbnQrPXIvdCx2LmN1cnJlbnQ+PTEpeC5jdXJyZW50LmNhbVBvcyYmdS5wb3NpdGlvbi5jb3B5KHguY3VycmVudC5jYW1Qb3MpLHguY3VycmVudC5jYW1Sb3QmJnUucXVhdGVybmlvbi5jb3B5KHguY3VycmVudC5jYW1Sb3QpLHguY3VycmVudC5jYW1VcCYmdS51cC5jb3B5KHguY3VycmVudC5jYW1VcCkseC5jdXJyZW50LmNhbVpvb20mJkVuKHUpJiYodS56b29tPXguY3VycmVudC5jYW1ab29tKSx1LnVwZGF0ZU1hdHJpeFdvcmxkKCksdS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCksZiYmeC5jdXJyZW50LnRhcmdldCYmKGYudGFyZ2V0LmNvcHkoeC5jdXJyZW50LnRhcmdldCksZi51cGRhdGUoKSkseS5jdXJyZW50PU1uLk5PTkU7ZWxzZXtjb25zdCBlPXModi5jdXJyZW50KTt4LmN1cnJlbnQuY2FtUG9zJiZ1LnBvc2l0aW9uLmxlcnBWZWN0b3JzKGguY3VycmVudC5jYW1Qb3MseC5jdXJyZW50LmNhbVBvcyxlKSx4LmN1cnJlbnQuY2FtUm90JiZ1LnF1YXRlcm5pb24uc2xlcnBRdWF0ZXJuaW9ucyhoLmN1cnJlbnQuY2FtUm90LHguY3VycmVudC5jYW1Sb3QsZSkseC5jdXJyZW50LmNhbVVwJiZ1LnVwLnNldCgwLDEsMCkuYXBwbHlRdWF0ZXJuaW9uKHUucXVhdGVybmlvbikseC5jdXJyZW50LmNhbVpvb20mJkVuKHUpJiYodS56b29tPSgxLWUpKmguY3VycmVudC5jYW1ab29tK2UqeC5jdXJyZW50LmNhbVpvb20pLHUudXBkYXRlTWF0cml4V29ybGQoKSx1LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1tKCl9fSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpjfSxQLmNyZWF0ZUVsZW1lbnQoQ24uUHJvdmlkZXIse3ZhbHVlOnp9LGUpKX1mdW5jdGlvbiBSbigpe3JldHVybiBQLnVzZUNvbnRleHQoQ24pfWNvbnN0IERuPVAuZm9yd2FyZFJlZigoKHtpbnRlbnNpdHk6ZT0xLGRlY2F5OnQsZGVjYXlSYXRlOnI9LjY1LG1heFlhdzpuPS4xLG1heFBpdGNoOm89LjEsbWF4Um9sbDppPS4xLHlhd0ZyZXF1ZW5jeTpzPS4xLHBpdGNoRnJlcXVlbmN5Omw9LjEscm9sbEZyZXF1ZW5jeTpjPS4xfSx1KT0+e2NvbnN0IG09YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxmPWEudXNlVGhyZWUoKGU9PmUuY29udHJvbHMpKSxwPVAudXNlUmVmKGUpLGg9UC51c2VSZWYobS5yb3RhdGlvbi5jbG9uZSgpKSxbeF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBkLlNpbXBsZXhOb2lzZSkpLFt5XT1QLnVzZVN0YXRlKCgoKT0+bmV3IGQuU2ltcGxleE5vaXNlKSksW3ZdPVAudXNlU3RhdGUoKCgpPT5uZXcgZC5TaW1wbGV4Tm9pc2UpKSxnPSgpPT57KHAuY3VycmVudDwwfHxwLmN1cnJlbnQ+MSkmJihwLmN1cnJlbnQ9cC5jdXJyZW50PDA/MDoxKX07cmV0dXJuIFAudXNlSW1wZXJhdGl2ZUhhbmRsZSh1LCgoKT0+KHtnZXRJbnRlbnNpdHk6KCk9PnAuY3VycmVudCxzZXRJbnRlbnNpdHk6ZT0+e3AuY3VycmVudD1lLGcoKX19KSksW10pLFAudXNlRWZmZWN0KCgoKT0+e2lmKGYpe2NvbnN0IGU9KCk9PntoLmN1cnJlbnQ9bS5yb3RhdGlvbi5jbG9uZSgpfTtyZXR1cm4gZi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSksZSgpLCgpPT57Zi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsZSl9fX0pLFttLGZdKSxhLnVzZUZyYW1lKCgoZSxhKT0+e2NvbnN0IHU9TWF0aC5wb3cocC5jdXJyZW50LDIpLGQ9bip1Kngubm9pc2UoZS5jbG9jay5lbGFwc2VkVGltZSpzLDEpLGY9byp1Knkubm9pc2UoZS5jbG9jay5lbGFwc2VkVGltZSpsLDEpLHo9aSp1KnYubm9pc2UoZS5jbG9jay5lbGFwc2VkVGltZSpjLDEpO20ucm90YXRpb24uc2V0KGguY3VycmVudC54K2YsaC5jdXJyZW50LnkrZCxoLmN1cnJlbnQueit6KSx0JiZwLmN1cnJlbnQ+MCYmKHAuY3VycmVudC09ciphLGcoKSl9KSksbnVsbH0pKSxGbj1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxlbmFibGVkOnQ9ITAsc3BlZWQ6cj0xLHJvdGF0aW9uSW50ZW5zaXR5Om49MSxmbG9hdEludGVuc2l0eTpvPTEsZmxvYXRpbmdSYW5nZTppPVstLjEsLjFdLC4uLnN9LGwpPT57Y29uc3QgYz1QLnVzZVJlZihudWxsKSx1PVAudXNlUmVmKDFlNCpNYXRoLnJhbmRvbSgpKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+e3ZhciBhLHM7aWYoIXR8fDA9PT1yKXJldHVybjtjb25zdCBsPXUuY3VycmVudCtlLmNsb2NrLmdldEVsYXBzZWRUaW1lKCk7Yy5jdXJyZW50LnJvdGF0aW9uLng9TWF0aC5jb3MobC80KnIpLzgqbixjLmN1cnJlbnQucm90YXRpb24ueT1NYXRoLnNpbihsLzQqcikvOCpuLGMuY3VycmVudC5yb3RhdGlvbi56PU1hdGguc2luKGwvNCpyKS8yMCpuO2xldCBkPU1hdGguc2luKGwvNCpyKS8xMDtkPUQuTWF0aFV0aWxzLm1hcExpbmVhcihkLC0uMSwuMSxudWxsIT09KGE9bnVsbD09aT92b2lkIDA6aVswXSkmJnZvaWQgMCE9PWE/YTotLjEsbnVsbCE9PShzPW51bGw9PWk/dm9pZCAwOmlbMV0pJiZ2b2lkIDAhPT1zP3M6LjEpLGMuY3VycmVudC5wb3NpdGlvbi55PWQqbyxjLmN1cnJlbnQudXBkYXRlTWF0cml4KCl9KSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixzLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjprLmRlZmF1bHQoW2MsbF0pLG1hdHJpeEF1dG9VcGRhdGU6ITF9LGUpKX0pKSxrbj17YXBhcnRtZW50OlwibGVib21ib18xay5oZHJcIixjaXR5OlwicG90c2RhbWVyX3BsYXR6XzFrLmhkclwiLGRhd246XCJraWFyYV8xX2Rhd25fMWsuaGRyXCIsZm9yZXN0OlwiZm9yZXN0X3Nsb3BlXzFrLmhkclwiLGxvYmJ5Olwic3RfZmFnYW5zX2ludGVyaW9yXzFrLmhkclwiLG5pZ2h0OlwiZGlraG9sb2xvX25pZ2h0XzFrLmhkclwiLHBhcms6XCJyb29pdG91X3BhcmtfMWsuaGRyXCIsc3R1ZGlvOlwic3R1ZGlvX3NtYWxsXzAzXzFrLmhkclwiLHN1bnNldDpcInZlbmljZV9zdW5zZXRfMWsuaGRyXCIsd2FyZWhvdXNlOlwiZW1wdHlfd2FyZWhvdXNlXzAxXzFrLmhkclwifSxfbj1cImh0dHBzOi8vcmF3LmdpdGhhY2suY29tL3BtbmRycy9kcmVpLWFzc2V0cy80NTYwNjBhMjZiYmViOGZkZjc5MzI2ZjIyNGI2ZDk5YjhiY2NlNzM2L2hkcmkvXCIsQW49ZT0+QXJyYXkuaXNBcnJheShlKTtmdW5jdGlvbiBMbih7ZmlsZXM6ZT1bXCIvcHgucG5nXCIsXCIvbngucG5nXCIsXCIvcHkucG5nXCIsXCIvbnkucG5nXCIsXCIvcHoucG5nXCIsXCIvbnoucG5nXCJdLHBhdGg6dD1cIlwiLHByZXNldDpyLGVuY29kaW5nOm8sZXh0ZW5zaW9uczppfT17fSl7dmFyIHM7bGV0IGwsYz1udWxsLHU9ITE7aWYocil7aWYoIShyIGluIGtuKSl0aHJvdyBuZXcgRXJyb3IoXCJQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6IFwiK09iamVjdC5rZXlzKGtuKS5qb2luKFwiLCBcIikpO2U9a25bcl0sdD1fbn1pZih1PUFuKGUpLGw9QW4oZSk/XCJjdWJlXCI6ZS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9leHJcIik/XCJleHJcIjplLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL2hkclwiKT9cImhkclwiOm51bGw9PShzPWUuc3BsaXQoXCIuXCIpLnBvcCgpKXx8bnVsbD09KHM9cy5zcGxpdChcIj9cIikpfHxudWxsPT0ocz1zLnNoaWZ0KCkpP3ZvaWQgMDpzLnRvTG93ZXJDYXNlKCksYz11P24uQ3ViZVRleHR1cmVMb2FkZXI6XCJoZHJcIj09PWw/ZC5SR0JFTG9hZGVyOlwiZXhyXCI9PT1sP2QuRVhSTG9hZGVyOm51bGwsIWMpdGhyb3cgbmV3IEVycm9yKFwidXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogXCIrZSk7Y29uc3QgbT1hLnVzZUxvYWRlcihjLHU/W2VdOmUsKGU9PntudWxsPT1lLnNldFBhdGh8fGUuc2V0UGF0aCh0KSxpJiZpKGUpfSkpLGY9dT9tWzBdOm07Zi5tYXBwaW5nPXU/bi5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6bi5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztyZXR1cm5cImNvbG9yU3BhY2VcImluIGY/Zi5jb2xvclNwYWNlPShudWxsIT1vP286dSk/XCJzcmdiXCI6XCJzcmdiLWxpbmVhclwiOmYuZW5jb2Rpbmc9KG51bGwhPW8/bzp1KT8zMDAxOjNlMyxmfWNvbnN0IEJuPWU9PntyZXR1cm4odD1lKS5jdXJyZW50JiZ0LmN1cnJlbnQuaXNTY2VuZT9lLmN1cnJlbnQ6ZTt2YXIgdH07ZnVuY3Rpb24gVW4oZSx0LHIsbixhPTApe2NvbnN0IG89Qm4odHx8ciksaT1vLmJhY2tncm91bmQscz1vLmVudmlyb25tZW50LGw9by5iYWNrZ3JvdW5kQmx1cnJpbmVzc3x8MDtyZXR1cm5cIm9ubHlcIiE9PWUmJihvLmVudmlyb25tZW50PW4pLGUmJihvLmJhY2tncm91bmQ9biksZSYmdm9pZCAwIT09by5iYWNrZ3JvdW5kQmx1cnJpbmVzcyYmKG8uYmFja2dyb3VuZEJsdXJyaW5lc3M9YSksKCk9PntcIm9ubHlcIiE9PWUmJihvLmVudmlyb25tZW50PXMpLGUmJihvLmJhY2tncm91bmQ9aSksZSYmdm9pZCAwIT09by5iYWNrZ3JvdW5kQmx1cnJpbmVzcyYmKG8uYmFja2dyb3VuZEJsdXJyaW5lc3M9bCl9fWZ1bmN0aW9uIEluKHtzY2VuZTplLGJhY2tncm91bmQ6dD0hMSxibHVyOnIsbWFwOm59KXtjb25zdCBvPWEudXNlVGhyZWUoKGU9PmUuc2NlbmUpKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57aWYobilyZXR1cm4gVW4odCxlLG8sbixyKX0pLFtvLGUsbix0LHJdKSxudWxsfWZ1bmN0aW9uIFZuKHtiYWNrZ3JvdW5kOmU9ITEsc2NlbmU6dCxibHVyOnIsLi4ubn0pe2NvbnN0IG89TG4obiksaT1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+VW4oZSx0LGksbyxyKSksW28sZSx0LGkscl0pLG51bGx9ZnVuY3Rpb24gT24oe2NoaWxkcmVuOmUsbmVhcjp0PTEsZmFyOnI9MWUzLHJlc29sdXRpb246bz0yNTYsZnJhbWVzOmk9MSxtYXA6cyxiYWNrZ3JvdW5kOmw9ITEsYmx1cjpjLHNjZW5lOnUsZmlsZXM6ZCxwYXRoOm0scHJlc2V0OmYsZXh0ZW5zaW9uczpwfSl7Y29uc3QgaD1hLnVzZVRocmVlKChlPT5lLmdsKSkseD1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSkseT1QLnVzZVJlZihudWxsKSxbdl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlNjZW5lKSksZz1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1uZXcgbi5XZWJHTEN1YmVSZW5kZXJUYXJnZXQobyk7cmV0dXJuIGUudGV4dHVyZS50eXBlPW4uSGFsZkZsb2F0VHlwZSxlfSksW29dKTtQLnVzZUxheW91dEVmZmVjdCgoKCk9PigxPT09aSYmeS5jdXJyZW50LnVwZGF0ZShoLHYpLFVuKGwsdSx4LGcudGV4dHVyZSxjKSkpLFtlLHYsZy50ZXh0dXJlLHUseCxsLGksaF0pO2xldCB6PTE7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57KGk9PT0xLzB8fHo8aSkmJih5LmN1cnJlbnQudXBkYXRlKGgsdikseisrKX0pKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGEuY3JlYXRlUG9ydGFsKFAuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsZSxQLmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIse3JlZjp5LGFyZ3M6W3QscixnXX0pLGR8fGY/UC5jcmVhdGVFbGVtZW50KFZuLHtiYWNrZ3JvdW5kOiEwLGZpbGVzOmQscHJlc2V0OmYscGF0aDptLGV4dGVuc2lvbnM6cH0pOnM/UC5jcmVhdGVFbGVtZW50KEluLHtiYWNrZ3JvdW5kOiEwLG1hcDpzLGV4dGVuc2lvbnM6cH0pOm51bGwpLHYpKX1mdW5jdGlvbiBObihlKXt2YXIgdCxyLG4sbztjb25zdCBpPUxuKGUpLHM9ZS5tYXB8fGk7UC51c2VNZW1vKCgoKT0+YS5leHRlbmQoe0dyb3VuZFByb2plY3RlZEVudkltcGw6ZC5Hcm91bmRQcm9qZWN0ZWRFbnZ9KSksW10pO2NvbnN0IGw9UC51c2VNZW1vKCgoKT0+W3NdKSxbc10pLGM9bnVsbD09KHQ9ZS5ncm91bmQpP3ZvaWQgMDp0LmhlaWdodCx1PW51bGw9PShyPWUuZ3JvdW5kKT92b2lkIDA6ci5yYWRpdXMsbT1udWxsIT09KG49bnVsbD09KG89ZS5ncm91bmQpP3ZvaWQgMDpvLnNjYWxlKSYmdm9pZCAwIT09bj9uOjFlMztyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoSW4sQy5kZWZhdWx0KHt9LGUse21hcDpzfSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VuZFByb2plY3RlZEVudkltcGxcIix7YXJnczpsLHNjYWxlOm0saGVpZ2h0OmMscmFkaXVzOnV9KSl9ZnVuY3Rpb24gam4oZSl7cmV0dXJuIGUuZ3JvdW5kP1AuY3JlYXRlRWxlbWVudChObixlKTplLm1hcD9QLmNyZWF0ZUVsZW1lbnQoSW4sZSk6ZS5jaGlsZHJlbj9QLmNyZWF0ZUVsZW1lbnQoT24sZSk6UC5jcmVhdGVFbGVtZW50KFZuLGUpfWNvbnN0IFduPVAuZm9yd2FyZFJlZigoKHtzY2FsZTplPTEwLGZyYW1lczp0PTEvMCxvcGFjaXR5OnI9MSx3aWR0aDpuPTEsaGVpZ2h0Om89MSxibHVyOmk9MSxuZWFyOnM9MCxmYXI6bD0xMCxyZXNvbHV0aW9uOmM9NTEyLHNtb290aDp1PSEwLGNvbG9yOm09XCIjMDAwMDAwXCIsZGVwdGhXcml0ZTpmPSExLHJlbmRlck9yZGVyOnAsLi4uaH0seCk9Pntjb25zdCB5PVAudXNlUmVmKG51bGwpLHY9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLGc9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHo9UC51c2VSZWYobnVsbCk7bio9QXJyYXkuaXNBcnJheShlKT9lWzBdOmV8fDEsbyo9QXJyYXkuaXNBcnJheShlKT9lWzFdOmV8fDE7Y29uc3RbdyxiLE0sRSxTLFQsUl09UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IEQuV2ViR0xSZW5kZXJUYXJnZXQoYyxjKSx0PW5ldyBELldlYkdMUmVuZGVyVGFyZ2V0KGMsYyk7dC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcz1lLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExO2NvbnN0IHI9bmV3IEQuUGxhbmVHZW9tZXRyeShuLG8pLnJvdGF0ZVgoTWF0aC5QSS8yKSxhPW5ldyBELk1lc2gociksaT1uZXcgRC5NZXNoRGVwdGhNYXRlcmlhbDtpLmRlcHRoVGVzdD1pLmRlcHRoV3JpdGU9ITEsaS5vbkJlZm9yZUNvbXBpbGU9ZT0+e2UudW5pZm9ybXM9ey4uLmUudW5pZm9ybXMsdWNvbG9yOnt2YWx1ZTpuZXcgRC5Db2xvcihtKX19LGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwidm9pZCBtYWluKCkge1wiLFwidW5pZm9ybSB2ZWMzIHVjb2xvcjtcXG4gICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIpLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwidmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7XCIsXCJ2ZWM0KCB1Y29sb3IgKiBmcmFnQ29vcmRaICogMi4wLCAoIDEuMCAtIGZyYWdDb29yZFogKSAqIDEuMCApO1wiKX07Y29uc3Qgcz1uZXcgRC5TaGFkZXJNYXRlcmlhbChkLkhvcml6b250YWxCbHVyU2hhZGVyKSxsPW5ldyBELlNoYWRlck1hdGVyaWFsKGQuVmVydGljYWxCbHVyU2hhZGVyKTtyZXR1cm4gbC5kZXB0aFRlc3Q9cy5kZXB0aFRlc3Q9ITEsW2UscixpLGEscyxsLHRdfSksW2MsbixvLGUsbV0pLEY9ZT0+e0UudmlzaWJsZT0hMCxFLm1hdGVyaWFsPVMsUy51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZT13LnRleHR1cmUsUy51bmlmb3Jtcy5oLnZhbHVlPTEqZS8yNTYsZy5zZXRSZW5kZXJUYXJnZXQoUiksZy5yZW5kZXIoRSx6LmN1cnJlbnQpLEUubWF0ZXJpYWw9VCxULnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlPVIudGV4dHVyZSxULnVuaWZvcm1zLnYudmFsdWU9MSplLzI1NixnLnNldFJlbmRlclRhcmdldCh3KSxnLnJlbmRlcihFLHouY3VycmVudCksRS52aXNpYmxlPSExfTtsZXQgayxfLEE9MDtyZXR1cm4gYS51c2VGcmFtZSgoKCk9Pnt6LmN1cnJlbnQmJih0PT09MS8wfHxBPHQpJiYoQSsrLGs9di5iYWNrZ3JvdW5kLF89di5vdmVycmlkZU1hdGVyaWFsLHkuY3VycmVudC52aXNpYmxlPSExLHYuYmFja2dyb3VuZD1udWxsLHYub3ZlcnJpZGVNYXRlcmlhbD1NLGcuc2V0UmVuZGVyVGFyZ2V0KHcpLGcucmVuZGVyKHYsei5jdXJyZW50KSxGKGkpLHUmJkYoLjQqaSksZy5zZXRSZW5kZXJUYXJnZXQobnVsbCkseS5jdXJyZW50LnZpc2libGU9ITAsdi5vdmVycmlkZU1hdGVyaWFsPV8sdi5iYWNrZ3JvdW5kPWspfSkpLFAudXNlSW1wZXJhdGl2ZUhhbmRsZSh4LCgoKT0+eS5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe1wicm90YXRpb24teFwiOk1hdGguUEkvMn0saCx7cmVmOnl9KSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JlbmRlck9yZGVyOnAsZ2VvbWV0cnk6YixzY2FsZTpbMSwtMSwxXSxyb3RhdGlvbjpbLU1hdGguUEkvMiwwLDBdfSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxtYXA6dy50ZXh0dXJlLG9wYWNpdHk6cixkZXB0aFdyaXRlOmZ9KSksUC5jcmVhdGVFbGVtZW50KFwib3J0aG9ncmFwaGljQ2FtZXJhXCIse3JlZjp6LGFyZ3M6Wy1uLzIsbi8yLG8vMiwtby8yLHMsbF19KSl9KSk7Y29uc3QgR249UC5jcmVhdGVDb250ZXh0KG51bGwpLEhuPUVlKHtjb2xvcjpuZXcgRC5Db2xvcixibGVuZDoyLGFscGhhVGVzdDouNzUsb3BhY2l0eTowLG1hcDpudWxsfSxcInZhcnlpbmcgdmVjMiB2VXY7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4pO1xcbiAgICAgdlV2ID0gdXY7XFxuICAgfVwiLGB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4gICB1bmlmb3JtIHZlYzMgY29sb3I7XFxuICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiAgIHVuaWZvcm0gZmxvYXQgYWxwaGFUZXN0O1xcbiAgIHVuaWZvcm0gZmxvYXQgYmxlbmQ7XFxuICAgdm9pZCBtYWluKCkge1xcbiAgICAgdmVjNCBzYW1wbGVkRGlmZnVzZUNvbG9yID0gdGV4dHVyZTJEKG1hcCwgdlV2KTtcXG4gICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IgKiBzYW1wbGVkRGlmZnVzZUNvbG9yLnIgKiBibGVuZCwgbWF4KDAuMCwgKDEuMCAtIChzYW1wbGVkRGlmZnVzZUNvbG9yLnIgKyBzYW1wbGVkRGlmZnVzZUNvbG9yLmcgKyBzYW1wbGVkRGlmZnVzZUNvbG9yLmIpIC8gYWxwaGFUZXN0KSkgKiBvcGFjaXR5KTtcXG4gICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgICNpbmNsdWRlIDwke0NlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgfWApLCRuPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHRlbXBvcmFsOnQsZnJhbWVzOnI9NDAsbGltaXQ6bj0xLzAsYmxlbmQ6bz0yMCxzY2FsZTppPTEwLG9wYWNpdHk6cz0xLGFscGhhVGVzdDpsPS43NSxjb2xvcjpjPVwiYmxhY2tcIixjb2xvckJsZW5kOnU9MixyZXNvbHV0aW9uOmQ9MTAyNCx0b25lTWFwcGVkOm09ITAsLi4uZn0scCk9PnthLmV4dGVuZCh7U29mdFNoYWRvd01hdGVyaWFsOkhufSk7Y29uc3QgaD1hLnVzZVRocmVlKChlPT5lLmdsKSkseD1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSkseT1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHY9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksZz1QLnVzZVJlZihudWxsKSx6PVAudXNlUmVmKG51bGwpLFt3XT1QLnVzZVN0YXRlKCgoKT0+bmV3IFhuKGgseCxkKSkpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3cuY29uZmlndXJlKGcuY3VycmVudCl9KSxbXSk7Y29uc3QgYj1QLnVzZU1lbW8oKCgpPT4oe2xpZ2h0czpuZXcgTWFwLHRlbXBvcmFsOiEhdCxmcmFtZXM6TWF0aC5tYXgoMixyKSxibGVuZDpNYXRoLm1heCgyLHI9PT0xLzA/bzpyKSxjb3VudDowLGdldE1lc2g6KCk9PmcuY3VycmVudCxyZXNldDooKT0+e3cuY2xlYXIoKTtjb25zdCBlPWcuY3VycmVudC5tYXRlcmlhbDtlLm9wYWNpdHk9MCxlLmFscGhhVGVzdD0wLGIuY291bnQ9MH0sdXBkYXRlOihlPTEpPT57Y29uc3QgdD1nLmN1cnJlbnQubWF0ZXJpYWw7Yi50ZW1wb3JhbD8odC5vcGFjaXR5PU1hdGgubWluKHMsdC5vcGFjaXR5K3MvYi5ibGVuZCksdC5hbHBoYVRlc3Q9TWF0aC5taW4obCx0LmFscGhhVGVzdCtsL2IuYmxlbmQpKToodC5vcGFjaXR5PXMsdC5hbHBoYVRlc3Q9bCksei5jdXJyZW50LnZpc2libGU9ITAsdy5wcmVwYXJlKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyliLmxpZ2h0cy5mb3JFYWNoKChlPT5lLnVwZGF0ZSgpKSksdy51cGRhdGUoeSxiLmJsZW5kKTt6LmN1cnJlbnQudmlzaWJsZT0hMSx3LmZpbmlzaCgpfX0pKSxbdyx5LHgsdCxyLG8scyxsXSk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2IucmVzZXQoKSxiLnRlbXBvcmFsfHxiLmZyYW1lcz09PTEvMHx8Yi51cGRhdGUoYi5ibGVuZCl9KSksUC51c2VJbXBlcmF0aXZlSGFuZGxlKHAsKCgpPT5iKSxbYl0pLGEudXNlRnJhbWUoKCgpPT57KGIudGVtcG9yYWx8fGIuZnJhbWVzPT09MS8wKSYmYi5jb3VudDxiLmZyYW1lcyYmYi5jb3VudDxuJiYodigpLGIudXBkYXRlKCksYi5jb3VudCsrKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLGYsUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7dHJhdmVyc2U6KCk9Pm51bGwscmVmOnp9LFAuY3JlYXRlRWxlbWVudChHbi5Qcm92aWRlcix7dmFsdWU6Yn0sZSkpLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVjZWl2ZVNoYWRvdzohMCxyZWY6ZyxzY2FsZTppLHJvdGF0aW9uOlstTWF0aC5QSS8yLDAsMF19LFAuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxQLmNyZWF0ZUVsZW1lbnQoXCJzb2Z0U2hhZG93TWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsZGVwdGhXcml0ZTohMSx0b25lTWFwcGVkOm0sY29sb3I6YyxibGVuZDp1LG1hcDp3LnByb2dyZXNzaXZlTGlnaHRNYXAyLnRleHR1cmV9KSkpfSkpLHFuPVAuZm9yd2FyZFJlZigoKHtjYXN0U2hhZG93OmU9ITAsYmlhczp0PS4wMDEsbWFwU2l6ZTpyPTUxMixzaXplOm49NSxuZWFyOmE9LjUsZmFyOm89NTAwLGZyYW1lczppPTEscG9zaXRpb246cz1bMCwwLDBdLHJhZGl1czpsPTEsYW1vdW50OmM9OCxpbnRlbnNpdHk6dT0oQ2U+PTE1NT9NYXRoLlBJOjEpLGFtYmllbnQ6ZD0uNSwuLi5tfSxmKT0+e2NvbnN0IHA9UC51c2VSZWYobnVsbCksaD1uZXcgRC5WZWN0b3IzKC4uLnMpLmxlbmd0aCgpLHg9UC51c2VDb250ZXh0KEduKSx5PVAudXNlQ2FsbGJhY2soKCgpPT57bGV0IGU7aWYocC5jdXJyZW50KWZvcihsZXQgdD0wO3Q8cC5jdXJyZW50LmNoaWxkcmVuLmxlbmd0aDt0KyspaWYoZT1wLmN1cnJlbnQuY2hpbGRyZW5bdF0sTWF0aC5yYW5kb20oKT5kKWUucG9zaXRpb24uc2V0KHNbMF0rRC5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpLHNbMV0rRC5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpLHNbMl0rRC5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKGwpKTtlbHNle2xldCB0PU1hdGguYWNvcygyKk1hdGgucmFuZG9tKCktMSktTWF0aC5QSS8yLHI9MipNYXRoLlBJKk1hdGgucmFuZG9tKCk7ZS5wb3NpdGlvbi5zZXQoTWF0aC5jb3ModCkqTWF0aC5jb3MocikqaCxNYXRoLmFicyhNYXRoLmNvcyh0KSpNYXRoLnNpbihyKSpoKSxNYXRoLnNpbih0KSpoKX19KSxbbCxkLGgsLi4uc10pLHY9UC51c2VNZW1vKCgoKT0+KHt1cGRhdGU6eX0pKSxbeV0pO3JldHVybiBQLnVzZUltcGVyYXRpdmVIYW5kbGUoZiwoKCk9PnYpLFt2XSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57dmFyIGU7Y29uc3QgdD1wLmN1cnJlbnQ7cmV0dXJuIHgmJihudWxsPT0oZT14LmxpZ2h0cyl8fGUuc2V0KHQudXVpZCx2KSksKCk9Pnt2YXIgZTtudWxsPT14fHxudWxsPT0oZT14LmxpZ2h0cyl8fGUuZGVsZXRlKHQudXVpZCl9fSksW3gsdl0pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6cH0sbSksQXJyYXkuZnJvbSh7bGVuZ3RoOmN9LCgoaSxzKT0+UC5jcmVhdGVFbGVtZW50KFwiZGlyZWN0aW9uYWxMaWdodFwiLHtrZXk6cyxjYXN0U2hhZG93OmUsXCJzaGFkb3ctYmlhc1wiOnQsXCJzaGFkb3ctbWFwU2l6ZVwiOltyLHJdLGludGVuc2l0eTp1L2N9LFAuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLHthdHRhY2g6XCJzaGFkb3ctY2FtZXJhXCIsYXJnczpbLW4sbixuLC1uLGEsb119KSkpKSl9KSk7Y2xhc3MgWG57Y29uc3RydWN0b3IoZSx0LHI9MTAyNCl7dGhpcy5yZW5kZXJlcj1lLHRoaXMucmVzPXIsdGhpcy5zY2VuZT10LHRoaXMuYnVmZmVyMUFjdGl2ZT0hMSx0aGlzLmxpZ2h0cz1bXSx0aGlzLm1lc2hlcz1bXSx0aGlzLm9iamVjdD1udWxsLHRoaXMuY2xlYXJDb2xvcj1uZXcgRC5Db2xvcix0aGlzLmNsZWFyQWxwaGE9MDtjb25zdCBuPXt0eXBlOkQuSGFsZkZsb2F0VHlwZSxtYWdGaWx0ZXI6RC5OZWFyZXN0RmlsdGVyLG1pbkZpbHRlcjpELk5lYXJlc3RGaWx0ZXJ9O3RoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDE9bmV3IEQuV2ViR0xSZW5kZXJUYXJnZXQodGhpcy5yZXMsdGhpcy5yZXMsbiksdGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMj1uZXcgRC5XZWJHTFJlbmRlclRhcmdldCh0aGlzLnJlcyx0aGlzLnJlcyxuKSx0aGlzLmRpc2NhcmRNYXQ9bmV3IFdyLHRoaXMudGFyZ2V0TWF0PW5ldyBELk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe2ZvZzohMX0pLHRoaXMucHJldmlvdXNTaGFkb3dNYXA9e3ZhbHVlOnRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEudGV4dHVyZX0sdGhpcy5hdmVyYWdpbmdXaW5kb3c9e3ZhbHVlOjEwMH0sdGhpcy50YXJnZXRNYXQub25CZWZvcmVDb21waWxlPWU9PntlLnZlcnRleFNoYWRlcj1cInZhcnlpbmcgdmVjMiB2VXY7XFxuXCIrZS52ZXJ0ZXhTaGFkZXIuc2xpY2UoMCwtMSkrXCJ2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1diAtIDAuNSkgKiAyLjAsIDEuMCwgMS4wKTsgfVwiO2NvbnN0IHQ9ZS5mcmFnbWVudFNoYWRlci5pbmRleE9mKFwidm9pZCBtYWluKCkge1wiKTtlLmZyYWdtZW50U2hhZGVyPVwidmFyeWluZyB2ZWMyIHZVdjtcXG5cIitlLmZyYWdtZW50U2hhZGVyLnNsaWNlKDAsdCkrXCJ1bmlmb3JtIHNhbXBsZXIyRCBwcmV2aW91c1NoYWRvd01hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGF2ZXJhZ2luZ1dpbmRvdztcXG5cIitlLmZyYWdtZW50U2hhZGVyLnNsaWNlKHQtMSwtMSkrXCJcXG52ZWMzIHRleGVsT2xkID0gdGV4dHVyZTJEKHByZXZpb3VzU2hhZG93TWFwLCB2VXYpLnJnYjtcXG4gICAgICAgIGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgodGV4ZWxPbGQsIGdsX0ZyYWdDb2xvci5yZ2IsIDEuMC8gYXZlcmFnaW5nV2luZG93KTtcXG4gICAgICB9XCIsZS51bmlmb3Jtcy5wcmV2aW91c1NoYWRvd01hcD10aGlzLnByZXZpb3VzU2hhZG93TWFwLGUudW5pZm9ybXMuYXZlcmFnaW5nV2luZG93PXRoaXMuYXZlcmFnaW5nV2luZG93fX1jbGVhcigpe3RoaXMucmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IpLHRoaXMuY2xlYXJBbHBoYT10aGlzLnJlbmRlcmVyLmdldENsZWFyQWxwaGEoKSx0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoXCJibGFja1wiLDEpLHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEpLHRoaXMucmVuZGVyZXIuY2xlYXIoKSx0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyKSx0aGlzLnJlbmRlcmVyLmNsZWFyKCksdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCksdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMuY2xlYXJDb2xvcix0aGlzLmNsZWFyQWxwaGEpLHRoaXMubGlnaHRzPVtdLHRoaXMubWVzaGVzPVtdLHRoaXMuc2NlbmUudHJhdmVyc2UoKGU9PnshZnVuY3Rpb24oZSl7cmV0dXJuISFlLmdlb21ldHJ5fShlKT9mdW5jdGlvbihlKXtyZXR1cm4gZS5pc0xpZ2h0fShlKSYmdGhpcy5saWdodHMucHVzaCh7b2JqZWN0OmUsaW50ZW5zaXR5OmUuaW50ZW5zaXR5fSk6dGhpcy5tZXNoZXMucHVzaCh7b2JqZWN0OmUsbWF0ZXJpYWw6ZS5tYXRlcmlhbH0pfSkpfXByZXBhcmUoKXt0aGlzLmxpZ2h0cy5mb3JFYWNoKChlPT5lLm9iamVjdC5pbnRlbnNpdHk9MCkpLHRoaXMubWVzaGVzLmZvckVhY2goKGU9PmUub2JqZWN0Lm1hdGVyaWFsPXRoaXMuZGlzY2FyZE1hdCkpfWZpbmlzaCgpe3RoaXMubGlnaHRzLmZvckVhY2goKGU9PmUub2JqZWN0LmludGVuc2l0eT1lLmludGVuc2l0eSkpLHRoaXMubWVzaGVzLmZvckVhY2goKGU9PmUub2JqZWN0Lm1hdGVyaWFsPWUubWF0ZXJpYWwpKX1jb25maWd1cmUoZSl7dGhpcy5vYmplY3Q9ZX11cGRhdGUoZSx0PTEwMCl7aWYoIXRoaXMub2JqZWN0KXJldHVybjt0aGlzLmF2ZXJhZ2luZ1dpbmRvdy52YWx1ZT10LHRoaXMub2JqZWN0Lm1hdGVyaWFsPXRoaXMudGFyZ2V0TWF0O2NvbnN0IHI9dGhpcy5idWZmZXIxQWN0aXZlP3RoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDE6dGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMixuPXRoaXMuYnVmZmVyMUFjdGl2ZT90aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyOnRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEsYT10aGlzLnNjZW5lLmJhY2tncm91bmQ7dGhpcy5zY2VuZS5iYWNrZ3JvdW5kPW51bGwsdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQociksdGhpcy5wcmV2aW91c1NoYWRvd01hcC52YWx1ZT1uLnRleHR1cmUsdGhpcy5idWZmZXIxQWN0aXZlPSF0aGlzLmJ1ZmZlcjFBY3RpdmUsdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSxlKSx0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKSx0aGlzLnNjZW5lLmJhY2tncm91bmQ9YX19Y29uc3QgWm49e3JlbWJyYW5kdDp7bWFpbjpbMSwyLDFdLGZpbGw6Wy0yLC0uNSwtMl19LHBvcnRyYWl0OnttYWluOlstMSwyLC41XSxmaWxsOlstMSwuNSwtMS41XX0sdXBmcm9udDp7bWFpbjpbMCwyLDFdLGZpbGw6Wy0xLC41LC0xLjVdfSxzb2Z0OnttYWluOlstMiw0LDRdLGZpbGw6Wy0xLC41LC0xLjVdfX07ZnVuY3Rpb24gWW4oe3JhZGl1czplLGFkanVzdENhbWVyYTp0fSl7Y29uc3Qgcj1SbigpO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9Pnt0JiZyLnJlZnJlc2goKS5jbGlwKCkuZml0KCl9KSxbZSx0XSksbnVsbH1jb25zdCBRbj1lPT4wPT09ZT8wOk1hdGgucG93KDIsMTAqZS0xMCk7Y29uc3QgS249UC5mb3J3YXJkUmVmKCgoe2ZvZzplPSExLHJlbmRlck9yZGVyOnQsZGVwdGhXcml0ZTpyPSExLGNvbG9yU3RvcDphPTAsY29sb3I6bz1cImJsYWNrXCIsb3BhY2l0eTppPS41LC4uLnN9LGwpPT57Y29uc3QgYz1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2Uud2lkdGg9MTI4LGUuaGVpZ2h0PTEyODtjb25zdCB0PWUuZ2V0Q29udGV4dChcIjJkXCIpLHI9dC5jcmVhdGVSYWRpYWxHcmFkaWVudChlLndpZHRoLzIsZS5oZWlnaHQvMiwwLGUud2lkdGgvMixlLmhlaWdodC8yLGUud2lkdGgvMik7cmV0dXJuIHIuYWRkQ29sb3JTdG9wKGEsbmV3IG4uQ29sb3IobykuZ2V0U3R5bGUoKSksci5hZGRDb2xvclN0b3AoMSxcInJnYmEoMCwwLDAsMClcIiksdC5maWxsU3R5bGU9cix0LmZpbGxSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxlfSksW28sYV0pO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZW5kZXJPcmRlcjp0LHJlZjpsLFwicm90YXRpb24teFwiOi1NYXRoLlBJLzJ9LHMpLFAuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxvcGFjaXR5OmksZm9nOmUsZGVwdGhXcml0ZTpyLHNpZGU6bi5Eb3VibGVTaWRlfSxQLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNUZXh0dXJlXCIse2F0dGFjaDpcIm1hcFwiLGFyZ3M6W2NdfSkpKX0pKTtmdW5jdGlvbiBKbihlPUQuRnJvbnRTaWRlKXtjb25zdCB0PXt2YWx1ZTpuZXcgRC5NYXRyaXg0fTtyZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRC5NZXNoTm9ybWFsTWF0ZXJpYWwoe3NpZGU6ZX0pLHt2aWV3TWF0cml4OnQsb25CZWZvcmVDb21waWxlOmU9PntlLnVuaWZvcm1zLnZpZXdNYXRyaXg9dCxlLmZyYWdtZW50U2hhZGVyPVwidmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG4gICAgICAgICB9XFxuXCIrZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKFwiI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlwiLFwiI2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcbiAgICAgICAgICAgbm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXCIpfX0pfWNvbnN0IGVhPUVlKHtjYXVzdGljc1RleHR1cmU6bnVsbCxjYXVzdGljc1RleHR1cmVCOm51bGwsY29sb3I6bmV3IEQuQ29sb3IsbGlnaHRQcm9qTWF0cml4Om5ldyBELk1hdHJpeDQsbGlnaHRWaWV3TWF0cml4Om5ldyBELk1hdHJpeDR9LFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uOyAgIFxcbiAgIHZvaWQgbWFpbigpIHtcXG4gICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuKTtcXG4gICAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4pO1xcbiAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4gICB9XCIsYHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4gIHVuaWZvcm0gdmVjMyBjb2xvcjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNhdXN0aWNzVGV4dHVyZTsgXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBjYXVzdGljc1RleHR1cmVCOyBcXG4gIHVuaWZvcm0gbWF0NCBsaWdodFByb2pNYXRyaXg7XFxuICB1bmlmb3JtIG1hdDQgbGlnaHRWaWV3TWF0cml4O1xcbiAgIHZvaWQgbWFpbigpIHtcXG4gICAgLy8gQXBwbHkgY2F1c3RpY3MgIFxcbiAgICB2ZWM0IGxpZ2h0U3BhY2VQb3MgPSBsaWdodFByb2pNYXRyaXggKiBsaWdodFZpZXdNYXRyaXggKiB2ZWM0KHZXb3JsZFBvc2l0aW9uLCAxLjApO1xcbiAgICBsaWdodFNwYWNlUG9zLnh5eiAvPSBsaWdodFNwYWNlUG9zLnc7XFxuICAgIGxpZ2h0U3BhY2VQb3MueHl6ID0gbGlnaHRTcGFjZVBvcy54eXogKiAwLjUgKyAwLjU7IFxcbiAgICB2ZWMzIGZyb250ID0gdGV4dHVyZTJEKGNhdXN0aWNzVGV4dHVyZSwgbGlnaHRTcGFjZVBvcy54eSkucmdiO1xcbiAgICB2ZWMzIGJhY2sgPSB0ZXh0dXJlMkQoY2F1c3RpY3NUZXh0dXJlQiwgbGlnaHRTcGFjZVBvcy54eSkucmdiO1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KChmcm9udCArIGJhY2spICogY29sb3IsIDEuMCk7XFxuICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgI2luY2x1ZGUgPCR7Q2U+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICB9YCksdGE9RWUoe2NhbWVyYU1hdHJpeFdvcmxkOm5ldyBELk1hdHJpeDQsY2FtZXJhUHJvamVjdGlvbk1hdHJpeEludjpuZXcgRC5NYXRyaXg0LG5vcm1hbFRleHR1cmU6bnVsbCxkZXB0aFRleHR1cmU6bnVsbCxsaWdodERpcjpuZXcgRC5WZWN0b3IzKDAsMSwwKSxsaWdodFBsYW5lTm9ybWFsOm5ldyBELlZlY3RvcjMoMCwxLDApLGxpZ2h0UGxhbmVDb25zdGFudDowLG5lYXI6LjEsZmFyOjEwMCxtb2RlbE1hdHJpeDpuZXcgRC5NYXRyaXg0LHdvcmxkUmFkaXVzOjEvNDAsaW9yOjEuMSxib3VuY2VzOjAscmVzb2x1dGlvbjoxMDI0LHNpemU6MTAsaW50ZW5zaXR5Oi41fSxcIlxcbiAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gIHZvaWQgbWFpbigpIHtcXG4gICAgICB2VXYgPSB1djtcXG4gICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiAgfVwiLFwiICBcXG4gIHVuaWZvcm0gbWF0NCBjYW1lcmFNYXRyaXhXb3JsZDtcXG4gIHVuaWZvcm0gbWF0NCBjYW1lcmFQcm9qZWN0aW9uTWF0cml4SW52O1xcbiAgdW5pZm9ybSB2ZWMzIGxpZ2h0RGlyO1xcbiAgdW5pZm9ybSB2ZWMzIGxpZ2h0UGxhbmVOb3JtYWw7XFxuICB1bmlmb3JtIGZsb2F0IGxpZ2h0UGxhbmVDb25zdGFudDtcXG4gIHVuaWZvcm0gZmxvYXQgbmVhcjtcXG4gIHVuaWZvcm0gZmxvYXQgZmFyO1xcbiAgdW5pZm9ybSBmbG9hdCB0aW1lO1xcbiAgdW5pZm9ybSBmbG9hdCB3b3JsZFJhZGl1cztcXG4gIHVuaWZvcm0gZmxvYXQgcmVzb2x1dGlvbjtcXG4gIHVuaWZvcm0gZmxvYXQgc2l6ZTtcXG4gIHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xcbiAgdW5pZm9ybSBmbG9hdCBpb3I7XFxuICBwcmVjaXNpb24gaGlnaHAgaXNhbXBsZXIyRDtcXG4gIHByZWNpc2lvbiBoaWdocCB1c2FtcGxlcjJEO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsVGV4dHVyZTtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRlcHRoVGV4dHVyZTtcXG4gIHVuaWZvcm0gZmxvYXQgYm91bmNlcztcXG4gIHZhcnlpbmcgdmVjMiB2VXY7XFxuICB2ZWMzIFdvcmxkUG9zRnJvbURlcHRoKGZsb2F0IGRlcHRoLCB2ZWMyIGNvb3JkKSB7XFxuICAgIGZsb2F0IHogPSBkZXB0aCAqIDIuMCAtIDEuMDtcXG4gICAgdmVjNCBjbGlwU3BhY2VQb3NpdGlvbiA9IHZlYzQoY29vcmQgKiAyLjAgLSAxLjAsIHosIDEuMCk7XFxuICAgIHZlYzQgdmlld1NwYWNlUG9zaXRpb24gPSBjYW1lcmFQcm9qZWN0aW9uTWF0cml4SW52ICogY2xpcFNwYWNlUG9zaXRpb247XFxuICAgIC8vIFBlcnNwZWN0aXZlIGRpdmlzaW9uXFxuICAgIHZpZXdTcGFjZVBvc2l0aW9uIC89IHZpZXdTcGFjZVBvc2l0aW9uLnc7XFxuICAgIHZlYzQgd29ybGRTcGFjZVBvc2l0aW9uID0gY2FtZXJhTWF0cml4V29ybGQgKiB2aWV3U3BhY2VQb3NpdGlvbjtcXG4gICAgcmV0dXJuIHdvcmxkU3BhY2VQb3NpdGlvbi54eXo7XFxuICB9ICAgICAgICAgICAgICAgICAgXFxuICBmbG9hdCBzZFBsYW5lKCB2ZWMzIHAsIHZlYzMgbiwgZmxvYXQgaCApIHtcXG4gICAgLy8gbiBtdXN0IGJlIG5vcm1hbGl6ZWRcXG4gICAgcmV0dXJuIGRvdChwLG4pICsgaDtcXG4gIH1cXG4gIGZsb2F0IHBsYW5lSW50ZXJzZWN0KCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWM0IHAgKSB7XFxuICAgIHJldHVybiAtKGRvdChybyxwLnh5eikrcC53KS9kb3QocmQscC54eXopO1xcbiAgfVxcbiAgdmVjMyB0b3RhbEludGVybmFsUmVmbGVjdGlvbih2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIHBvcywgdmVjMyBub3JtYWwsIGZsb2F0IGlvciwgb3V0IHZlYzMgcmF5T3JpZ2luLCBvdXQgdmVjMyByYXlEaXJlY3Rpb24pIHtcXG4gICAgcmF5T3JpZ2luID0gcm87XFxuICAgIHJheURpcmVjdGlvbiA9IHJkO1xcbiAgICByYXlEaXJlY3Rpb24gPSByZWZyYWN0KHJheURpcmVjdGlvbiwgbm9ybWFsLCAxLjAgLyBpb3IpO1xcbiAgICByYXlPcmlnaW4gPSBwb3MgKyByYXlEaXJlY3Rpb24gKiAwLjE7XFxuICAgIHJldHVybiByYXlEaXJlY3Rpb247XFxuICB9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIC8vIEVhY2ggc2FtcGxlIGNvbnNpc3RzIG9mIHJhbmRvbSBvZmZzZXQgaW4gdGhlIHggYW5kIHkgZGlyZWN0aW9uXFxuICAgIGZsb2F0IGNhdXN0aWMgPSAwLjA7XFxuICAgIGZsb2F0IGNhdXN0aWNUZXhlbFNpemUgPSAoMS4wIC8gcmVzb2x1dGlvbikgKiBzaXplICogMi4wO1xcbiAgICBmbG9hdCB0ZXhlbHNOZWVkZWQgPSB3b3JsZFJhZGl1cyAvIGNhdXN0aWNUZXhlbFNpemU7XFxuICAgIGZsb2F0IHNhbXBsZVJhZGl1cyA9IHRleGVsc05lZWRlZCAvIHJlc29sdXRpb247XFxuICAgIGZsb2F0IHN1bSA9IDAuMDtcXG4gICAgaWYgKHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHZVdikueCA9PSAxLjApIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDEuMCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZlYzIgb2Zmc2V0MSA9IHZlYzIoLTAuNSwgLTAuNSk7Ly92ZWMyKHJhbmQoKSAtIDAuNSwgcmFuZCgpIC0gMC41KTtcXG4gICAgdmVjMiBvZmZzZXQyID0gdmVjMigtMC41LCAwLjUpOy8vdmVjMihyYW5kKCkgLSAwLjUsIHJhbmQoKSAtIDAuNSk7XFxuICAgIHZlYzIgb2Zmc2V0MyA9IHZlYzIoMC41LCAwLjUpOy8vdmVjMihyYW5kKCkgLSAwLjUsIHJhbmQoKSAtIDAuNSk7XFxuICAgIHZlYzIgb2Zmc2V0NCA9IHZlYzIoMC41LCAtMC41KTsvL3ZlYzIocmFuZCgpIC0gMC41LCByYW5kKCkgLSAwLjUpO1xcbiAgICB2ZWMyIHV2MSA9IHZVdiArIG9mZnNldDEgKiBzYW1wbGVSYWRpdXM7XFxuICAgIHZlYzIgdXYyID0gdlV2ICsgb2Zmc2V0MiAqIHNhbXBsZVJhZGl1cztcXG4gICAgdmVjMiB1djMgPSB2VXYgKyBvZmZzZXQzICogc2FtcGxlUmFkaXVzO1xcbiAgICB2ZWMyIHV2NCA9IHZVdiArIG9mZnNldDQgKiBzYW1wbGVSYWRpdXM7XFxuICAgIHZlYzMgbm9ybWFsMSA9IHRleHR1cmUyRChub3JtYWxUZXh0dXJlLCB1djEsIC0xMC4wKS5yZ2IgKiAyLjAgLSAxLjA7XFxuICAgIHZlYzMgbm9ybWFsMiA9IHRleHR1cmUyRChub3JtYWxUZXh0dXJlLCB1djIsIC0xMC4wKS5yZ2IgKiAyLjAgLSAxLjA7XFxuICAgIHZlYzMgbm9ybWFsMyA9IHRleHR1cmUyRChub3JtYWxUZXh0dXJlLCB1djMsIC0xMC4wKS5yZ2IgKiAyLjAgLSAxLjA7XFxuICAgIHZlYzMgbm9ybWFsNCA9IHRleHR1cmUyRChub3JtYWxUZXh0dXJlLCB1djQsIC0xMC4wKS5yZ2IgKiAyLjAgLSAxLjA7XFxuICAgIGZsb2F0IGRlcHRoMSA9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHV2MSwgLTEwLjApLng7XFxuICAgIGZsb2F0IGRlcHRoMiA9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHV2MiwgLTEwLjApLng7XFxuICAgIGZsb2F0IGRlcHRoMyA9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHV2MywgLTEwLjApLng7XFxuICAgIGZsb2F0IGRlcHRoNCA9IHRleHR1cmUyRChkZXB0aFRleHR1cmUsIHV2NCwgLTEwLjApLng7XFxuICAgIC8vIFNhbml0eSBjaGVjayB0aGUgZGVwdGhzXFxuICAgIGlmIChkZXB0aDEgPT0gMS4wIHx8IGRlcHRoMiA9PSAxLjAgfHwgZGVwdGgzID09IDEuMCB8fCBkZXB0aDQgPT0gMS4wKSB7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAxLjApO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2ZWMzIHBvczEgPSBXb3JsZFBvc0Zyb21EZXB0aChkZXB0aDEsIHV2MSk7XFxuICAgIHZlYzMgcG9zMiA9IFdvcmxkUG9zRnJvbURlcHRoKGRlcHRoMiwgdXYyKTtcXG4gICAgdmVjMyBwb3MzID0gV29ybGRQb3NGcm9tRGVwdGgoZGVwdGgzLCB1djMpO1xcbiAgICB2ZWMzIHBvczQgPSBXb3JsZFBvc0Zyb21EZXB0aChkZXB0aDQsIHV2NCk7XFxuICAgIHZlYzMgb3JpZ2luUG9zMSA9IFdvcmxkUG9zRnJvbURlcHRoKDAuMCwgdXYxKTtcXG4gICAgdmVjMyBvcmlnaW5Qb3MyID0gV29ybGRQb3NGcm9tRGVwdGgoMC4wLCB1djIpO1xcbiAgICB2ZWMzIG9yaWdpblBvczMgPSBXb3JsZFBvc0Zyb21EZXB0aCgwLjAsIHV2Myk7XFxuICAgIHZlYzMgb3JpZ2luUG9zNCA9IFdvcmxkUG9zRnJvbURlcHRoKDAuMCwgdXY0KTtcXG4gICAgdmVjMyBlbmRQb3MxLCBlbmRQb3MyLCBlbmRQb3MzLCBlbmRQb3M0O1xcbiAgICB2ZWMzIGVuZERpcjEsIGVuZERpcjIsIGVuZERpcjMsIGVuZERpcjQ7XFxuICAgIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKG9yaWdpblBvczEsIGxpZ2h0RGlyLCBwb3MxLCBub3JtYWwxLCBpb3IsIGVuZFBvczEsIGVuZERpcjEpO1xcbiAgICB0b3RhbEludGVybmFsUmVmbGVjdGlvbihvcmlnaW5Qb3MyLCBsaWdodERpciwgcG9zMiwgbm9ybWFsMiwgaW9yLCBlbmRQb3MyLCBlbmREaXIyKTtcXG4gICAgdG90YWxJbnRlcm5hbFJlZmxlY3Rpb24ob3JpZ2luUG9zMywgbGlnaHREaXIsIHBvczMsIG5vcm1hbDMsIGlvciwgZW5kUG9zMywgZW5kRGlyMyk7XFxuICAgIHRvdGFsSW50ZXJuYWxSZWZsZWN0aW9uKG9yaWdpblBvczQsIGxpZ2h0RGlyLCBwb3M0LCBub3JtYWw0LCBpb3IsIGVuZFBvczQsIGVuZERpcjQpO1xcbiAgICBmbG9hdCBsaWdodFBvc0FyZWEgPSBsZW5ndGgoY3Jvc3Mob3JpZ2luUG9zMiAtIG9yaWdpblBvczEsIG9yaWdpblBvczMgLSBvcmlnaW5Qb3MxKSkgKyBsZW5ndGgoY3Jvc3Mob3JpZ2luUG9zMyAtIG9yaWdpblBvczEsIG9yaWdpblBvczQgLSBvcmlnaW5Qb3MxKSk7XFxuICAgIGZsb2F0IHQxID0gcGxhbmVJbnRlcnNlY3QoZW5kUG9zMSwgZW5kRGlyMSwgdmVjNChsaWdodFBsYW5lTm9ybWFsLCBsaWdodFBsYW5lQ29uc3RhbnQpKTtcXG4gICAgZmxvYXQgdDIgPSBwbGFuZUludGVyc2VjdChlbmRQb3MyLCBlbmREaXIyLCB2ZWM0KGxpZ2h0UGxhbmVOb3JtYWwsIGxpZ2h0UGxhbmVDb25zdGFudCkpO1xcbiAgICBmbG9hdCB0MyA9IHBsYW5lSW50ZXJzZWN0KGVuZFBvczMsIGVuZERpcjMsIHZlYzQobGlnaHRQbGFuZU5vcm1hbCwgbGlnaHRQbGFuZUNvbnN0YW50KSk7XFxuICAgIGZsb2F0IHQ0ID0gcGxhbmVJbnRlcnNlY3QoZW5kUG9zNCwgZW5kRGlyNCwgdmVjNChsaWdodFBsYW5lTm9ybWFsLCBsaWdodFBsYW5lQ29uc3RhbnQpKTtcXG4gICAgdmVjMyBmaW5hbFBvczEgPSBlbmRQb3MxICsgZW5kRGlyMSAqIHQxO1xcbiAgICB2ZWMzIGZpbmFsUG9zMiA9IGVuZFBvczIgKyBlbmREaXIyICogdDI7XFxuICAgIHZlYzMgZmluYWxQb3MzID0gZW5kUG9zMyArIGVuZERpcjMgKiB0MztcXG4gICAgdmVjMyBmaW5hbFBvczQgPSBlbmRQb3M0ICsgZW5kRGlyNCAqIHQ0O1xcbiAgICBmbG9hdCBmaW5hbEFyZWEgPSBsZW5ndGgoY3Jvc3MoZmluYWxQb3MyIC0gZmluYWxQb3MxLCBmaW5hbFBvczMgLSBmaW5hbFBvczEpKSArIGxlbmd0aChjcm9zcyhmaW5hbFBvczMgLSBmaW5hbFBvczEsIGZpbmFsUG9zNCAtIGZpbmFsUG9zMSkpO1xcbiAgICBjYXVzdGljICs9IGludGVuc2l0eSAqIChsaWdodFBvc0FyZWEgLyBmaW5hbEFyZWEpO1xcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFyZWEgb2YgdGhlIHRyaWFuZ2xlIGluIGxpZ2h0IHNwYWNlc1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobWF4KGNhdXN0aWMsIDAuMCkpLCAxLjApO1xcbiAgfVwiKSxyYT17ZGVwdGg6ITAsbWluRmlsdGVyOkQuTGluZWFyRmlsdGVyLG1hZ0ZpbHRlcjpELkxpbmVhckZpbHRlcix0eXBlOkQuVW5zaWduZWRCeXRlVHlwZX0sbmE9e21pbkZpbHRlcjpELkxpbmVhck1pcG1hcExpbmVhckZpbHRlcixtYWdGaWx0ZXI6RC5MaW5lYXJGaWx0ZXIsdHlwZTpELkZsb2F0VHlwZSxnZW5lcmF0ZU1pcG1hcHM6ITB9LGFhPVAuZm9yd2FyZFJlZigoKHtkZWJ1ZzplLGNoaWxkcmVuOnQsZnJhbWVzOnI9MSxpb3I6bj0xLjEsY29sb3I6bz1cIndoaXRlXCIsY2F1c3RpY3NPbmx5Omk9ITEsYmFja3NpZGU6cz0hMSxiYWNrc2lkZUlPUjpsPTEuMSx3b3JsZFJhZGl1czpjPS4zMTI1LGludGVuc2l0eTp1PS4wNSxyZXNvbHV0aW9uOm09MjAyNCxsaWdodFNvdXJjZTpmPVs1LDUsNV0sLi4ucH0saCk9PnthLmV4dGVuZCh7Q2F1c3RpY3NQcm9qZWN0aW9uTWF0ZXJpYWw6ZWF9KTtjb25zdCB4PVAudXNlUmVmKG51bGwpLHk9UC51c2VSZWYobnVsbCksdj1QLnVzZVJlZihudWxsKSxnPVAudXNlUmVmKG51bGwpLHo9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHc9dnIoZSYmeSxELkNhbWVyYUhlbHBlciksYj1udChtLG0scmEpLE09bnQobSxtLHJhKSxFPW50KG0sbSxuYSksUz1udChtLG0sbmEpLFtUXT1QLnVzZVN0YXRlKCgoKT0+Sm4oKSkpLFtSXT1QLnVzZVN0YXRlKCgoKT0+Sm4oRC5CYWNrU2lkZSkpKSxbRl09UC51c2VTdGF0ZSgoKCk9Pm5ldyB0YSkpLFtrXT1QLnVzZVN0YXRlKCgoKT0+bmV3IGQuRnVsbFNjcmVlblF1YWQoRikpKTtQLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt4LmN1cnJlbnQudXBkYXRlV29ybGRNYXRyaXgoITEsITApfSkpO2xldCBfPTA7Y29uc3QgQT1uZXcgRC5WZWN0b3IzLEw9bmV3IEQuRnJ1c3R1bSxCPW5ldyBELk1hdHJpeDQsVT1uZXcgRC5QbGFuZSxJPW5ldyBELlZlY3RvcjMsVj1uZXcgRC5WZWN0b3IzLE89bmV3IEQuQm94MyxOPW5ldyBELlZlY3RvcjMsaj1bXSxXPVtdLEc9W10sSD1bXSwkPW5ldyBELlZlY3RvcjM7Zm9yKGxldCBlPTA7ZTw4O2UrKylqLnB1c2gobmV3IEQuVmVjdG9yMyksVy5wdXNoKG5ldyBELlZlY3RvcjMpLEcucHVzaChuZXcgRC5WZWN0b3IzKSxILnB1c2gobmV3IEQuVmVjdG9yMyk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57aWYocj09PTEvMHx8XysrPHIpe3ZhciB0LGE7QXJyYXkuaXNBcnJheShmKT9JLmZyb21BcnJheShmKS5ub3JtYWxpemUoKTpJLmNvcHkoeC5jdXJyZW50LndvcmxkVG9Mb2NhbChmLmN1cnJlbnQuZ2V0V29ybGRQb3NpdGlvbihBKSkubm9ybWFsaXplKCkpLFYuY29weShJKS5tdWx0aXBseVNjYWxhcigtMSksbnVsbD09KHQ9di5jdXJyZW50LnBhcmVudCl8fHQubWF0cml4V29ybGQuaWRlbnRpdHkoKSxPLnNldEZyb21PYmplY3Qodi5jdXJyZW50LCEwKSxqWzBdLnNldChPLm1pbi54LE8ubWluLnksTy5taW4ueiksalsxXS5zZXQoTy5taW4ueCxPLm1pbi55LE8ubWF4LnopLGpbMl0uc2V0KE8ubWluLngsTy5tYXgueSxPLm1pbi56KSxqWzNdLnNldChPLm1pbi54LE8ubWF4LnksTy5tYXgueiksals0XS5zZXQoTy5tYXgueCxPLm1pbi55LE8ubWluLnopLGpbNV0uc2V0KE8ubWF4LngsTy5taW4ueSxPLm1heC56KSxqWzZdLnNldChPLm1heC54LE8ubWF4LnksTy5taW4ueiksals3XS5zZXQoTy5tYXgueCxPLm1heC55LE8ubWF4LnopO2ZvcihsZXQgZT0wO2U8ODtlKyspV1tlXS5jb3B5KGpbZV0pO08uZ2V0Q2VudGVyKE4pLGoubWFwKChlPT5lLnN1YihOKSkpO2NvbnN0IHI9VS5zZXQoViwwKTtqLm1hcCgoKGUsdCk9PnIucHJvamVjdFBvaW50KGUsR1t0XSkpKTtjb25zdCBvPUcucmVkdWNlKCgoZSx0KT0+ZS5hZGQodCkpLEEuc2V0KDAsMCwwKSkuZGl2aWRlU2NhbGFyKEcubGVuZ3RoKSxkPUcubWFwKChlPT5lLmRpc3RhbmNlVG8obykpKS5yZWR1Y2UoKChlLHQpPT5NYXRoLm1heChlLHQpKSkscD1qLm1hcCgoZT0+ZS5kb3QoSSkpKS5yZWR1Y2UoKChlLHQpPT5NYXRoLm1heChlLHQpKSk7eS5jdXJyZW50LnBvc2l0aW9uLmNvcHkoJC5jb3B5KEkpLm11bHRpcGx5U2NhbGFyKHApLmFkZChOKSkseS5jdXJyZW50Lmxvb2tBdCh2LmN1cnJlbnQubG9jYWxUb1dvcmxkKE4pKTtjb25zdCBoPUIubG9va0F0KHkuY3VycmVudC5wb3NpdGlvbixOLEEuc2V0KDAsMSwwKSk7eS5jdXJyZW50LmxlZnQ9LWQseS5jdXJyZW50LnJpZ2h0PWQseS5jdXJyZW50LnRvcD1kLHkuY3VycmVudC5ib3R0b209LWQ7Y29uc3QgQz1BLnNldCgwLGQsMCkuYXBwbHlNYXRyaXg0KGgpLFA9KHkuY3VycmVudC5wb3NpdGlvbi55K0MueSkvSS55O3kuY3VycmVudC5uZWFyPS4xLHkuY3VycmVudC5mYXI9UCx5LmN1cnJlbnQudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpLHkuY3VycmVudC51cGRhdGVNYXRyaXhXb3JsZCgpO2NvbnN0IEQ9Vy5tYXAoKChlLHQpPT5lLmFkZChIW3RdLmNvcHkoSSkubXVsdGlwbHlTY2FsYXIoLWUueS9JLnkpKSkpLF89RC5yZWR1Y2UoKChlLHQpPT5lLmFkZCh0KSksQS5zZXQoMCwwLDApKS5kaXZpZGVTY2FsYXIoRC5sZW5ndGgpLHE9MipELm1hcCgoZT0+TWF0aC5oeXBvdChlLngtXy54LGUuei1fLnopKSkucmVkdWNlKCgoZSx0KT0+TWF0aC5tYXgoZSx0KSkpO2cuY3VycmVudC5zY2FsZS5zZXRTY2FsYXIocSksZy5jdXJyZW50LnBvc2l0aW9uLmNvcHkoXyksZSYmKG51bGw9PShhPXcuY3VycmVudCl8fGEudXBkYXRlKCkpLFIudmlld01hdHJpeC52YWx1ZT1ULnZpZXdNYXRyaXgudmFsdWU9eS5jdXJyZW50Lm1hdHJpeFdvcmxkSW52ZXJzZTtjb25zdCBYPUwuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoQi5tdWx0aXBseU1hdHJpY2VzKHkuY3VycmVudC5wcm9qZWN0aW9uTWF0cml4LHkuY3VycmVudC5tYXRyaXhXb3JsZEludmVyc2UpKS5wbGFuZXNbNF07Ri5jYW1lcmFNYXRyaXhXb3JsZD15LmN1cnJlbnQubWF0cml4V29ybGQsRi5jYW1lcmFQcm9qZWN0aW9uTWF0cml4SW52PXkuY3VycmVudC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSxGLmxpZ2h0RGlyPVYsRi5saWdodFBsYW5lTm9ybWFsPVgubm9ybWFsLEYubGlnaHRQbGFuZUNvbnN0YW50PVguY29uc3RhbnQsRi5uZWFyPXkuY3VycmVudC5uZWFyLEYuZmFyPXkuY3VycmVudC5mYXIsRi5yZXNvbHV0aW9uPW0sRi5zaXplPWQsRi5pbnRlbnNpdHk9dSxGLndvcmxkUmFkaXVzPWMsdi5jdXJyZW50LnZpc2libGU9ITAsei5zZXRSZW5kZXJUYXJnZXQoYiksei5jbGVhcigpLHYuY3VycmVudC5vdmVycmlkZU1hdGVyaWFsPVQsei5yZW5kZXIodi5jdXJyZW50LHkuY3VycmVudCksei5zZXRSZW5kZXJUYXJnZXQoTSksei5jbGVhcigpLHMmJih2LmN1cnJlbnQub3ZlcnJpZGVNYXRlcmlhbD1SLHoucmVuZGVyKHYuY3VycmVudCx5LmN1cnJlbnQpKSx2LmN1cnJlbnQub3ZlcnJpZGVNYXRlcmlhbD1udWxsLEYuaW9yPW4sZy5jdXJyZW50Lm1hdGVyaWFsLmxpZ2h0UHJvak1hdHJpeD15LmN1cnJlbnQucHJvamVjdGlvbk1hdHJpeCxnLmN1cnJlbnQubWF0ZXJpYWwubGlnaHRWaWV3TWF0cml4PXkuY3VycmVudC5tYXRyaXhXb3JsZEludmVyc2UsRi5ub3JtYWxUZXh0dXJlPWIudGV4dHVyZSxGLmRlcHRoVGV4dHVyZT1iLmRlcHRoVGV4dHVyZSx6LnNldFJlbmRlclRhcmdldChFKSx6LmNsZWFyKCksay5yZW5kZXIoeiksRi5pb3I9bCxGLm5vcm1hbFRleHR1cmU9TS50ZXh0dXJlLEYuZGVwdGhUZXh0dXJlPU0uZGVwdGhUZXh0dXJlLHouc2V0UmVuZGVyVGFyZ2V0KFMpLHouY2xlYXIoKSxzJiZrLnJlbmRlcih6KSx6LnNldFJlbmRlclRhcmdldChudWxsKSxpJiYodi5jdXJyZW50LnZpc2libGU9ITEpfX0pKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUoaCwoKCk9PnguY3VycmVudCksW10pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6eH0scCksUC5jcmVhdGVFbGVtZW50KFwic2NlbmVcIix7cmVmOnZ9LFAuY3JlYXRlRWxlbWVudChcIm9ydGhvZ3JhcGhpY0NhbWVyYVwiLHtyZWY6eSx1cDpbMCwxLDBdfSksdCksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHtyZW5kZXJPcmRlcjoyLHJlZjpnLFwicm90YXRpb24teFwiOi1NYXRoLlBJLzJ9LFAuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxQLmNyZWF0ZUVsZW1lbnQoXCJjYXVzdGljc1Byb2plY3Rpb25NYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxjb2xvcjpvLGNhdXN0aWNzVGV4dHVyZTpFLnRleHR1cmUsY2F1c3RpY3NUZXh0dXJlQjpTLnRleHR1cmUsYmxlbmRpbmc6RC5DdXN0b21CbGVuZGluZyxibGVuZFNyYzpELk9uZUZhY3RvcixibGVuZERzdDpELlNyY0FscGhhRmFjdG9yLGRlcHRoV3JpdGU6ITF9KSxlJiZQLmNyZWF0ZUVsZW1lbnQoX2UsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoXCJsaW5lQmFzaWNNYXRlcmlhbFwiLHtjb2xvcjpcIiNmZmZmMDBcIix0b25lTWFwcGVkOiExfSkpKSl9KSksb2E9UC5mb3J3YXJkUmVmKCgoe21peEJsdXI6ZT0wLG1peFN0cmVuZ3RoOnQ9LjUscmVzb2x1dGlvbjpyPTI1NixibHVyOm89WzAsMF0sYXJnczppPVsxLDFdLG1pbkRlcHRoVGhyZXNob2xkOnM9LjksbWF4RGVwdGhUaHJlc2hvbGQ6bD0xLGRlcHRoU2NhbGU6Yz0wLGRlcHRoVG9CbHVyUmF0aW9CaWFzOnU9LjI1LG1pcnJvcjpkPTAsY2hpbGRyZW46bSxkZWJ1ZzpmPTAsZGlzdG9ydGlvbjpwPTEsbWl4Q29udHJhc3Q6aD0xLGRpc3RvcnRpb25NYXA6eCwuLi55fSx2KT0+e2EuZXh0ZW5kKHtNZXNoUmVmbGVjdG9yTWF0ZXJpYWw6T3J9KSxQLnVzZUVmZmVjdCgoKCk9Pntjb25zb2xlLndhcm4oXCJSZWZsZWN0b3IgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIG5leHQgbWFqb3IuIFJlcGxhY2UgaXQgd2l0aCA8TWVzaFJlZmxlY3Rvck1hdGVyaWFsIC8+IVwiKX0pLFtdKTtjb25zdCBnPWEudXNlVGhyZWUoKCh7Z2w6ZX0pPT5lKSksej1hLnVzZVRocmVlKCgoe2NhbWVyYTplfSk9PmUpKSx3PWEudXNlVGhyZWUoKCh7c2NlbmU6ZX0pPT5lKSksYj0obz1BcnJheS5pc0FycmF5KG8pP286W28sb10pWzBdK29bMV0+MCxNPVAudXNlUmVmKG51bGwpLFtFXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGxhbmUpKSxbU109UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbVF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbUl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKSxbRF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLk1hdHJpeDQpKSxbRl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMoMCwwLC0xKSkpLFtfXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtBXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtMXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yMykpLFtCXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uVmVjdG9yNCkpLFtVXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uTWF0cml4NCkpLFtJXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uUGVyc3BlY3RpdmVDYW1lcmEpKSxWPVAudXNlQ2FsbGJhY2soKCgpPT57aWYoVC5zZXRGcm9tTWF0cml4UG9zaXRpb24oTS5jdXJyZW50Lm1hdHJpeFdvcmxkKSxSLnNldEZyb21NYXRyaXhQb3NpdGlvbih6Lm1hdHJpeFdvcmxkKSxELmV4dHJhY3RSb3RhdGlvbihNLmN1cnJlbnQubWF0cml4V29ybGQpLFMuc2V0KDAsMCwxKSxTLmFwcGx5TWF0cml4NChEKSxBLnN1YlZlY3RvcnMoVCxSKSxBLmRvdChTKT4wKXJldHVybjtBLnJlZmxlY3QoUykubmVnYXRlKCksQS5hZGQoVCksRC5leHRyYWN0Um90YXRpb24oei5tYXRyaXhXb3JsZCksRi5zZXQoMCwwLC0xKSxGLmFwcGx5TWF0cml4NChEKSxGLmFkZChSKSxMLnN1YlZlY3RvcnMoVCxGKSxMLnJlZmxlY3QoUykubmVnYXRlKCksTC5hZGQoVCksSS5wb3NpdGlvbi5jb3B5KEEpLEkudXAuc2V0KDAsMSwwKSxJLnVwLmFwcGx5TWF0cml4NChEKSxJLnVwLnJlZmxlY3QoUyksSS5sb29rQXQoTCksSS5mYXI9ei5mYXIsSS51cGRhdGVNYXRyaXhXb3JsZCgpLEkucHJvamVjdGlvbk1hdHJpeC5jb3B5KHoucHJvamVjdGlvbk1hdHJpeCksVS5zZXQoLjUsMCwwLC41LDAsLjUsMCwuNSwwLDAsLjUsLjUsMCwwLDAsMSksVS5tdWx0aXBseShJLnByb2plY3Rpb25NYXRyaXgpLFUubXVsdGlwbHkoSS5tYXRyaXhXb3JsZEludmVyc2UpLFUubXVsdGlwbHkoTS5jdXJyZW50Lm1hdHJpeFdvcmxkKSxFLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KFMsVCksRS5hcHBseU1hdHJpeDQoSS5tYXRyaXhXb3JsZEludmVyc2UpLF8uc2V0KEUubm9ybWFsLngsRS5ub3JtYWwueSxFLm5vcm1hbC56LEUuY29uc3RhbnQpO2NvbnN0IGU9SS5wcm9qZWN0aW9uTWF0cml4O0IueD0oTWF0aC5zaWduKF8ueCkrZS5lbGVtZW50c1s4XSkvZS5lbGVtZW50c1swXSxCLnk9KE1hdGguc2lnbihfLnkpK2UuZWxlbWVudHNbOV0pL2UuZWxlbWVudHNbNV0sQi56PS0xLEIudz0oMStlLmVsZW1lbnRzWzEwXSkvZS5lbGVtZW50c1sxNF0sXy5tdWx0aXBseVNjYWxhcigyL18uZG90KEIpKSxlLmVsZW1lbnRzWzJdPV8ueCxlLmVsZW1lbnRzWzZdPV8ueSxlLmVsZW1lbnRzWzEwXT1fLnorMSxlLmVsZW1lbnRzWzE0XT1fLnd9KSxbXSksW08sTixqLFddPVAudXNlTWVtbygoKCk9Pntjb25zdCBhPXt0eXBlOm4uSGFsZkZsb2F0VHlwZSxtaW5GaWx0ZXI6bi5MaW5lYXJGaWx0ZXIsbWFnRmlsdGVyOm4uTGluZWFyRmlsdGVyfSxpPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHIscixhKTtpLmRlcHRoQnVmZmVyPSEwLGkuZGVwdGhUZXh0dXJlPW5ldyBuLkRlcHRoVGV4dHVyZShyLHIpLGkuZGVwdGhUZXh0dXJlLmZvcm1hdD1uLkRlcHRoRm9ybWF0LGkuZGVwdGhUZXh0dXJlLnR5cGU9bi5VbnNpZ25lZFNob3J0VHlwZTtjb25zdCBtPW5ldyBuLldlYkdMUmVuZGVyVGFyZ2V0KHIscixhKTtyZXR1cm5baSxtLG5ldyBWcih7Z2w6ZyxyZXNvbHV0aW9uOnIsd2lkdGg6b1swXSxoZWlnaHQ6b1sxXSxtaW5EZXB0aFRocmVzaG9sZDpzLG1heERlcHRoVGhyZXNob2xkOmwsZGVwdGhTY2FsZTpjLGRlcHRoVG9CbHVyUmF0aW9CaWFzOnV9KSx7bWlycm9yOmQsdGV4dHVyZU1hdHJpeDpVLG1peEJsdXI6ZSx0RGlmZnVzZTppLnRleHR1cmUsdERlcHRoOmkuZGVwdGhUZXh0dXJlLHREaWZmdXNlQmx1cjptLnRleHR1cmUsaGFzQmx1cjpiLG1peFN0cmVuZ3RoOnQsbWluRGVwdGhUaHJlc2hvbGQ6cyxtYXhEZXB0aFRocmVzaG9sZDpsLGRlcHRoU2NhbGU6YyxkZXB0aFRvQmx1clJhdGlvQmlhczp1LHRyYW5zcGFyZW50OiEwLGRlYnVnOmYsZGlzdG9ydGlvbjpwLGRpc3RvcnRpb25NYXA6eCxtaXhDb250cmFzdDpoLFwiZGVmaW5lcy1VU0VfQkxVUlwiOmI/XCJcIjp2b2lkIDAsXCJkZWZpbmVzLVVTRV9ERVBUSFwiOmM+MD9cIlwiOnZvaWQgMCxcImRlZmluZXMtVVNFX0RJU1RPUlRJT05cIjp4P1wiXCI6dm9pZCAwfV19KSxbZyxvLFUscixkLGIsZSx0LHMsbCxjLHUsZixwLHgsaF0pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e2lmKG51bGw9PU18fCFNLmN1cnJlbnQpcmV0dXJuO00uY3VycmVudC52aXNpYmxlPSExO2NvbnN0IGU9Zy54ci5lbmFibGVkLHQ9Zy5zaGFkb3dNYXAuYXV0b1VwZGF0ZTtWKCksZy54ci5lbmFibGVkPSExLGcuc2hhZG93TWFwLmF1dG9VcGRhdGU9ITEsZy5zZXRSZW5kZXJUYXJnZXQoTyksZy5zdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soITApLGcuYXV0b0NsZWFyfHxnLmNsZWFyKCksZy5yZW5kZXIodyxJKSxiJiZqLnJlbmRlcihnLE8sTiksZy54ci5lbmFibGVkPWUsZy5zaGFkb3dNYXAuYXV0b1VwZGF0ZT10LE0uY3VycmVudC52aXNpYmxlPSEwLGcuc2V0UmVuZGVyVGFyZ2V0KG51bGwpfSkpLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIixDLmRlZmF1bHQoe3JlZjprLmRlZmF1bHQoW00sdl0pfSx5KSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6aX0pLG0/bShcIm1lc2hSZWZsZWN0b3JNYXRlcmlhbFwiLFcpOlAuY3JlYXRlRWxlbWVudChcIm1lc2hSZWZsZWN0b3JNYXRlcmlhbFwiLFcpKX0pKTtjbGFzcyBpYSBleHRlbmRzIEQuU2hhZGVyTWF0ZXJpYWx7Y29uc3RydWN0b3IoKXtzdXBlcih7dW5pZm9ybXM6e2RlcHRoOnt2YWx1ZTpudWxsfSxvcGFjaXR5Ont2YWx1ZToxfSxhdHRlbnVhdGlvbjp7dmFsdWU6Mi41fSxhbmdsZVBvd2VyOnt2YWx1ZToxMn0sc3BvdFBvc2l0aW9uOnt2YWx1ZTpuZXcgRC5WZWN0b3IzKDAsMCwwKX0sbGlnaHRDb2xvcjp7dmFsdWU6bmV3IEQuQ29sb3IoXCJ3aGl0ZVwiKX0sY2FtZXJhTmVhcjp7dmFsdWU6MH0sY2FtZXJhRmFyOnt2YWx1ZToxfSxyZXNvbHV0aW9uOnt2YWx1ZTpuZXcgRC5WZWN0b3IyKDAsMCl9fSx0cmFuc3BhcmVudDohMCxkZXB0aFdyaXRlOiExLHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZWaWV3WjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkludGVuc2l0eTtcXG4gICAgICAgIHVuaWZvcm0gdmVjMyBzcG90UG9zaXRpb247XFxuICAgICAgICB1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uO1xcblxcbiAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cXG4gICAgICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgLy8gY29tcHV0ZSBpbnRlbnNpdHlcXG4gICAgICAgICAgdk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1xcbiAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEpO1xcbiAgICAgICAgICB2ZWM0IHZpZXdQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcbiAgICAgICAgICB2Vmlld1ogPSB2aWV3UG9zaXRpb24uejtcXG5cXG4gICAgICAgICAgdkludGVuc2l0eSA9IDEuMCAtIHNhdHVyYXRlKGRpc3RhbmNlKHdvcmxkUG9zaXRpb24ueHl6LCBzcG90UG9zaXRpb24pIC8gYXR0ZW51YXRpb24pO1xcblxcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3UG9zaXRpb247XFxuXFxuICAgICAgICAgICNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuICAgICAgICB9XFxuICAgICAgXCIsZnJhZ21lbnRTaGFkZXI6YFxcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuICAgICAgICB2YXJ5aW5nIGZsb2F0IHZWaWV3WjtcXG4gICAgICAgIHZhcnlpbmcgZmxvYXQgdkludGVuc2l0eTtcXG5cXG4gICAgICAgIHVuaWZvcm0gdmVjMyBsaWdodENvbG9yO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBhbmdsZVBvd2VyO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgZGVwdGg7XFxuICAgICAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhRmFyO1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbiAgICAgICAgI2luY2x1ZGUgPHBhY2tpbmc+XFxuICAgICAgICAjaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG5cXG4gICAgICAgIGZsb2F0IHJlYWREZXB0aChzYW1wbGVyMkQgZGVwdGhTYW1wbGVyLCB2ZWMyIHV2KSB7XFxuICAgICAgICAgIGZsb2F0IGZyYWdDb29yZFogPSB0ZXh0dXJlKGRlcHRoU2FtcGxlciwgdXYpLnI7XFxuXFxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIzMDcyXFxuICAgICAgICAgICNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG4gICAgICAgICAgICBmbG9hdCB2aWV3WiA9IDEuMCAtIGV4cDIoZnJhZ0Nvb3JkWiAqIGxvZyhjYW1lcmFGYXIgKyAxLjApIC8gbG9nKDIuMCkpO1xcbiAgICAgICAgICAjZWxzZVxcbiAgICAgICAgICAgIGZsb2F0IHZpZXdaID0gcGVyc3BlY3RpdmVEZXB0aFRvVmlld1ooZnJhZ0Nvb3JkWiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyKTtcXG4gICAgICAgICAgI2VuZGlmXFxuXFxuICAgICAgICAgIHJldHVybiB2aWV3WjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcbiAgICAgICAgICB2ZWMzIG5vcm1hbCA9IHZlYzModk5vcm1hbC54LCB2Tm9ybWFsLnksIGFicyh2Tm9ybWFsLnopKTtcXG4gICAgICAgICAgZmxvYXQgYW5nbGVJbnRlbnNpdHkgPSBwb3coZG90KG5vcm1hbCwgdmVjMygwLCAwLCAxKSksIGFuZ2xlUG93ZXIpO1xcbiAgICAgICAgICBmbG9hdCBpbnRlbnNpdHkgPSB2SW50ZW5zaXR5ICogYW5nbGVJbnRlbnNpdHk7XFxuXFxuICAgICAgICAgIC8vIGZhZGVzIHdoZW4geiBpcyBjbG9zZSB0byBzYW1wbGVkIGRlcHRoLCBtZWFuaW5nIHRoZSBjb25lIGlzIGludGVyc2VjdGluZyBleGlzdGluZyBnZW9tZXRyeVxcbiAgICAgICAgICBib29sIGlzU29mdCA9IHJlc29sdXRpb25bMF0gPiAwLjAgJiYgcmVzb2x1dGlvblsxXSA+IDAuMDtcXG4gICAgICAgICAgaWYgKGlzU29mdCkge1xcbiAgICAgICAgICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xcbiAgICAgICAgICAgIGludGVuc2l0eSAqPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCB2Vmlld1ogLSByZWFkRGVwdGgoZGVwdGgsIHV2KSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChsaWdodENvbG9yLCBpbnRlbnNpdHkgKiBvcGFjaXR5KTtcXG5cXG4gICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcbiAgICAgICAgICAjaW5jbHVkZSA8JHtDZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICAgICAgfVxcbiAgICAgIGB9KX19dmFyIHNhPVwiI2RlZmluZSBHTFNMSUZZIDFcXG52YXJ5aW5nIHZlYzIgdlV2O3VuaWZvcm0gc2FtcGxlcjJEIHVTaGFkb3dNYXA7dW5pZm9ybSBmbG9hdCB1VGltZTt2b2lkIG1haW4oKXt2ZWMzIGNvbG9yPXRleHR1cmUyRCh1U2hhZG93TWFwLHZVdikueHl6O2dsX0ZyYWdDb2xvcj12ZWM0KGNvbG9yLDEuKTt9XCI7Y29uc3QgbGE9ZT0+bnVsbD09ZT92b2lkIDA6ZS5pc1Nwb3RMaWdodDtmdW5jdGlvbiBjYSh7b3BhY2l0eTplPTEscmFkaXVzVG9wOnQscmFkaXVzQm90dG9tOnIsZGVwdGhCdWZmZXI6byxjb2xvcjppPVwid2hpdGVcIixkaXN0YW5jZTpzPTUsYW5nbGU6bD0uMTUsYXR0ZW51YXRpb246Yz01LGFuZ2xlUG93ZXI6dT01fSl7Y29uc3QgZD1QLnVzZVJlZihudWxsKSxtPWEudXNlVGhyZWUoKGU9PmUuc2l6ZSkpLGY9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSxwPWEudXNlVGhyZWUoKGU9PmUudmlld3BvcnQuZHByKSksW2hdPVAudXNlU3RhdGUoKCgpPT5uZXcgaWEpKSxbeF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBuLlZlY3RvcjMpKTt0PXZvaWQgMD09PXQ/LjE6dCxyPXZvaWQgMD09PXI/NypsOnIsYS51c2VGcmFtZSgoKCk9PntoLnVuaWZvcm1zLnNwb3RQb3NpdGlvbi52YWx1ZS5jb3B5KGQuY3VycmVudC5nZXRXb3JsZFBvc2l0aW9uKHgpKSxkLmN1cnJlbnQubG9va0F0KGQuY3VycmVudC5wYXJlbnQudGFyZ2V0LmdldFdvcmxkUG9zaXRpb24oeCkpfSkpO2NvbnN0IHk9UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IG4uQ3lsaW5kZXJHZW9tZXRyeSh0LHIscywxMjgsNjQsITApO3JldHVybiBlLmFwcGx5TWF0cml4NCgobmV3IG4uTWF0cml4NCkubWFrZVRyYW5zbGF0aW9uKDAsLXMvMiwwKSksZS5hcHBseU1hdHJpeDQoKG5ldyBuLk1hdHJpeDQpLm1ha2VSb3RhdGlvblgoLU1hdGguUEkvMikpLGV9KSxbcyx0LHJdKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JlZjpkLGdlb21ldHJ5OnkscmF5Y2FzdDooKT0+bnVsbH0sUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIse29iamVjdDpoLGF0dGFjaDpcIm1hdGVyaWFsXCIsXCJ1bmlmb3Jtcy1vcGFjaXR5LXZhbHVlXCI6ZSxcInVuaWZvcm1zLWxpZ2h0Q29sb3ItdmFsdWVcIjppLFwidW5pZm9ybXMtYXR0ZW51YXRpb24tdmFsdWVcIjpjLFwidW5pZm9ybXMtYW5nbGVQb3dlci12YWx1ZVwiOnUsXCJ1bmlmb3Jtcy1kZXB0aC12YWx1ZVwiOm8sXCJ1bmlmb3Jtcy1jYW1lcmFOZWFyLXZhbHVlXCI6Zi5uZWFyLFwidW5pZm9ybXMtY2FtZXJhRmFyLXZhbHVlXCI6Zi5mYXIsXCJ1bmlmb3Jtcy1yZXNvbHV0aW9uLXZhbHVlXCI6bz9bbS53aWR0aCpwLG0uaGVpZ2h0KnBdOlswLDBdfSkpKX1mdW5jdGlvbiB1YShlLHQscixvLGkpe2NvbnN0W1tzLGxdXT1QLnVzZVN0YXRlKCgoKT0+W25ldyBuLlZlY3RvcjMsbmV3IG4uVmVjdG9yM10pKTtQLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZighbGEoZS5jdXJyZW50KSl0aHJvdyBuZXcgRXJyb3IoXCJTcG90bGlnaHRTaGFkb3cgbXVzdCBiZSBhIGNoaWxkIG9mIGEgU3BvdExpZ2h0XCIpO2UuY3VycmVudC5zaGFkb3cubWFwU2l6ZS5zZXQocixvKSxlLmN1cnJlbnQuc2hhZG93Lm5lZWRzVXBkYXRlPSEwfSksW2UscixvXSksYS51c2VGcmFtZSgoKCk9PntpZighZS5jdXJyZW50KXJldHVybjtjb25zdCByPWUuY3VycmVudC5wb3NpdGlvbixuPWUuY3VycmVudC50YXJnZXQucG9zaXRpb247bC5jb3B5KG4pLnN1YihyKTt2YXIgYT1sLmxlbmd0aCgpO2wubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoYSppKSxzLmNvcHkocikuYWRkKGwpLHQuY3VycmVudC5wb3NpdGlvbi5jb3B5KHMpLHQuY3VycmVudC5sb29rQXQoZS5jdXJyZW50LnRhcmdldC5wb3NpdGlvbil9KSl9ZnVuY3Rpb24gZGEoe2Rpc3RhbmNlOmU9LjQsYWxwaGFUZXN0OnQ9LjUsbWFwOnIsc2hhZGVyOm89c2Esd2lkdGg6aT01MTIsaGVpZ2h0OnM9NTEyLHNjYWxlOmw9MSxjaGlsZHJlbjpjLC4uLnV9KXtjb25zdCBtPVAudXNlUmVmKG51bGwpLGY9dS5zcG90bGlnaHRSZWYscD11LmRlYnVnO3VhKGYsbSxpLHMsZSk7Y29uc3QgaD1QLnVzZU1lbW8oKCgpPT5uZXcgbi5XZWJHTFJlbmRlclRhcmdldChpLHMse2Zvcm1hdDpuLlJHQkFGb3JtYXQsZW5jb2Rpbmc6bi5MaW5lYXJFbmNvZGluZyxzdGVuY2lsQnVmZmVyOiExfSkpLFtpLHNdKSx4PVAudXNlUmVmKHt1U2hhZG93TWFwOnt2YWx1ZTpyfSx1VGltZTp7dmFsdWU6MH19KTtQLnVzZUVmZmVjdCgoKCk9Pnt4LmN1cnJlbnQudVNoYWRvd01hcC52YWx1ZT1yfSksW3JdKTtjb25zdCB5PVAudXNlTWVtbygoKCk9Pm5ldyBkLkZ1bGxTY3JlZW5RdWFkKG5ldyBuLlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp4LmN1cnJlbnQsdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuICAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIFwiLGZyYWdtZW50U2hhZGVyOm99KSkpLFtvXSk7cmV0dXJuIFAudXNlRWZmZWN0KCgoKT0+KCk9Pnt5Lm1hdGVyaWFsLmRpc3Bvc2UoKSx5LmRpc3Bvc2UoKX0pLFt5XSksUC51c2VFZmZlY3QoKCgpPT4oKT0+aC5kaXNwb3NlKCkpLFtoXSksYS51c2VGcmFtZSgoKHtnbDplfSx0KT0+e3guY3VycmVudC51VGltZS52YWx1ZSs9dCxlLnNldFJlbmRlclRhcmdldChoKSx5LnJlbmRlcihlKSxlLnNldFJlbmRlclRhcmdldChudWxsKX0pKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOm0sc2NhbGU6bCxjYXN0U2hhZG93OiEwfSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsbnVsbCksUC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsc2lkZTpuLkRvdWJsZVNpZGUsYWxwaGFUZXN0OnQsYWxwaGFNYXA6aC50ZXh0dXJlLFwiYWxwaGFNYXAtd3JhcFNcIjpuLlJlcGVhdFdyYXBwaW5nLFwiYWxwaGFNYXAtd3JhcFRcIjpuLlJlcGVhdFdyYXBwaW5nLG9wYWNpdHk6cD8xOjB9LGMpKSl9ZnVuY3Rpb24gbWEoe2Rpc3RhbmNlOmU9LjQsYWxwaGFUZXN0OnQ9LjUsbWFwOnIsd2lkdGg6YT01MTIsaGVpZ2h0Om89NTEyLHNjYWxlOmksY2hpbGRyZW46cywuLi5sfSl7Y29uc3QgYz1QLnVzZVJlZihudWxsKSx1PWwuc3BvdGxpZ2h0UmVmLGQ9bC5kZWJ1ZztyZXR1cm4gdWEodSxjLGEsbyxlKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmVmOmMsc2NhbGU6aSxjYXN0U2hhZG93OiEwfSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsbnVsbCksUC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAsc2lkZTpuLkRvdWJsZVNpZGUsYWxwaGFUZXN0OnQsYWxwaGFNYXA6cixcImFscGhhTWFwLXdyYXBTXCI6bi5SZXBlYXRXcmFwcGluZyxcImFscGhhTWFwLXdyYXBUXCI6bi5SZXBlYXRXcmFwcGluZyxvcGFjaXR5OmQ/MTowfSxzKSkpfWNvbnN0IGZhPVAuZm9yd2FyZFJlZigoKHtvcGFjaXR5OmU9MSxyYWRpdXNUb3A6dCxyYWRpdXNCb3R0b206cixkZXB0aEJ1ZmZlcjpuLGNvbG9yOmE9XCJ3aGl0ZVwiLGRpc3RhbmNlOm89NSxhbmdsZTppPS4xNSxhdHRlbnVhdGlvbjpzPTUsYW5nbGVQb3dlcjpsPTUsdm9sdW1ldHJpYzpjPSEwLGRlYnVnOnU9ITEsY2hpbGRyZW46ZCwuLi5tfSxmKT0+e2NvbnN0IHA9UC51c2VSZWYobnVsbCk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsbnVsbCx1JiZwLmN1cnJlbnQmJlAuY3JlYXRlRWxlbWVudChcInNwb3RMaWdodEhlbHBlclwiLHthcmdzOltwLmN1cnJlbnRdfSksUC5jcmVhdGVFbGVtZW50KFwic3BvdExpZ2h0XCIsQy5kZWZhdWx0KHtyZWY6ay5kZWZhdWx0KFtmLHBdKSxhbmdsZTppLGNvbG9yOmEsZGlzdGFuY2U6byxjYXN0U2hhZG93OiEwfSxtKSxjJiZQLmNyZWF0ZUVsZW1lbnQoY2Ese2RlYnVnOnUsb3BhY2l0eTplLHJhZGl1c1RvcDp0LHJhZGl1c0JvdHRvbTpyLGRlcHRoQnVmZmVyOm4sY29sb3I6YSxkaXN0YW5jZTpvLGFuZ2xlOmksYXR0ZW51YXRpb246cyxhbmdsZVBvd2VyOmx9KSksZCYmUC5jbG9uZUVsZW1lbnQoZCx7c3BvdGxpZ2h0UmVmOnAsZGVidWc6dX0pKX0pKSxwYT1QLmZvcndhcmRSZWYoKCh7YXJnczplLG1hcDp0LHRvbmVNYXBwZWQ6cj0hMSxjb2xvcjpuPVwid2hpdGVcIixmb3JtOm89XCJyZWN0XCIsaW50ZW5zaXR5Omk9MSxzY2FsZTpzPTEsdGFyZ2V0OmwsY2hpbGRyZW46YywuLi51fSxkKT0+e2NvbnN0IG09UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2N8fHUubWF0ZXJpYWx8fChhLmFwcGx5UHJvcHMobS5jdXJyZW50Lm1hdGVyaWFsLHtjb2xvcjpufSksbS5jdXJyZW50Lm1hdGVyaWFsLmNvbG9yLm11bHRpcGx5U2NhbGFyKGkpKX0pLFtuLGksYyx1Lm1hdGVyaWFsXSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57bCYmbS5jdXJyZW50Lmxvb2tBdChBcnJheS5pc0FycmF5KGwpP25ldyBELlZlY3RvcjMoLi4ubCk6bCl9KSxbbF0pLHM9QXJyYXkuaXNBcnJheShzKSYmMj09PXMubGVuZ3RoP1tzWzBdLHNbMV0sMV06cyxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZWY6ay5kZWZhdWx0KFttLGRdKSxzY2FsZTpzfSx1KSxcImNpcmNsZVwiPT09bz9QLmNyZWF0ZUVsZW1lbnQoXCJyaW5nR2VvbWV0cnlcIix7YXJnczpbMCwxLDY0XX0pOlwicmluZ1wiPT09bz9QLmNyZWF0ZUVsZW1lbnQoXCJyaW5nR2VvbWV0cnlcIix7YXJnczpbLjUsMSw2NF19KTpcInJlY3RcIj09PW8/UC5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLG51bGwpOlAuY3JlYXRlRWxlbWVudChvLHthcmdzOmV9KSxjfHwodS5tYXRlcmlhbD9udWxsOlAuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIse3RvbmVNYXBwZWQ6cixtYXA6dCxzaWRlOkQuRG91YmxlU2lkZX0pKSl9KSk7ZnVuY3Rpb24gaGEoZSx0LHI9bmV3IG4uVmVjdG9yMyl7Y29uc3QgYT1NYXRoLlBJKihlLS41KSxvPTIqTWF0aC5QSSoodC0uNSk7cmV0dXJuIHIueD1NYXRoLmNvcyhvKSxyLnk9TWF0aC5zaW4oYSksci56PU1hdGguc2luKG8pLHJ9Y29uc3QgeGE9UC5mb3J3YXJkUmVmKCgoe2luY2xpbmF0aW9uOmU9LjYsYXppbXV0aDp0PS4xLGRpc3RhbmNlOnI9MWUzLG1pZUNvZWZmaWNpZW50OmE9LjAwNSxtaWVEaXJlY3Rpb25hbEc6bz0uOCxyYXlsZWlnaDppPS41LHR1cmJpZGl0eTpzPTEwLHN1blBvc2l0aW9uOmw9aGEoZSx0KSwuLi5jfSx1KT0+e2NvbnN0IG09UC51c2VNZW1vKCgoKT0+KG5ldyBuLlZlY3RvcjMpLnNldFNjYWxhcihyKSksW3JdKSxbZl09UC51c2VTdGF0ZSgoKCk9Pm5ldyBkLlNreSkpO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe29iamVjdDpmLHJlZjp1LFwibWF0ZXJpYWwtdW5pZm9ybXMtbWllQ29lZmZpY2llbnQtdmFsdWVcIjphLFwibWF0ZXJpYWwtdW5pZm9ybXMtbWllRGlyZWN0aW9uYWxHLXZhbHVlXCI6byxcIm1hdGVyaWFsLXVuaWZvcm1zLXJheWxlaWdoLXZhbHVlXCI6aSxcIm1hdGVyaWFsLXVuaWZvcm1zLXN1blBvc2l0aW9uLXZhbHVlXCI6bCxcIm1hdGVyaWFsLXVuaWZvcm1zLXR1cmJpZGl0eS12YWx1ZVwiOnMsc2NhbGU6bX0sYykpfSkpO2NsYXNzIHlhIGV4dGVuZHMgbi5TaGFkZXJNYXRlcmlhbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKHt1bmlmb3Jtczp7dGltZTp7dmFsdWU6MH0sZmFkZTp7dmFsdWU6MX19LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcXG4gICAgICBhdHRyaWJ1dGUgZmxvYXQgc2l6ZTtcXG4gICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZDb2xvciA9IGNvbG9yO1xcbiAgICAgICAgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMC41KTtcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoMzAuMCAvIC1tdlBvc2l0aW9uLnopICogKDMuMCArIHNpbih0aW1lICsgMTAwLjApKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuICAgICAgfVwiLGZyYWdtZW50U2hhZGVyOmBcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCBwb2ludFRleHR1cmU7XFxuICAgICAgdW5pZm9ybSBmbG9hdCBmYWRlO1xcbiAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgb3BhY2l0eSA9IDEuMDtcXG4gICAgICAgIGlmIChmYWRlID09IDEuMCkge1xcbiAgICAgICAgICBmbG9hdCBkID0gZGlzdGFuY2UoZ2xfUG9pbnRDb29yZCwgdmVjMigwLjUsIDAuNSkpO1xcbiAgICAgICAgICBvcGFjaXR5ID0gMS4wIC8gKDEuMCArIGV4cCgxNi4wICogKGQgLSAwLjI1KSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIG9wYWNpdHkpO1xcblxcbiAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCAgICAgICNpbmNsdWRlIDwke0NlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgICAgfWB9KX19Y29uc3QgdmE9ZT0+KG5ldyBuLlZlY3RvcjMpLnNldEZyb21TcGhlcmljYWwobmV3IG4uU3BoZXJpY2FsKGUsTWF0aC5hY29zKDEtMipNYXRoLnJhbmRvbSgpKSwyKk1hdGgucmFuZG9tKCkqTWF0aC5QSSkpLGdhPVAuZm9yd2FyZFJlZigoKHtyYWRpdXM6ZT0xMDAsZGVwdGg6dD01MCxjb3VudDpyPTVlMyxzYXR1cmF0aW9uOm89MCxmYWN0b3I6aT00LGZhZGU6cz0hMSxzcGVlZDpsPTF9LGMpPT57Y29uc3QgdT1QLnVzZVJlZigpLFtkLG0sZl09UC51c2VNZW1vKCgoKT0+e2NvbnN0IGE9W10scz1bXSxsPUFycmF5LmZyb20oe2xlbmd0aDpyfSwoKCk9PiguNSsuNSpNYXRoLnJhbmRvbSgpKSppKSksYz1uZXcgbi5Db2xvcjtsZXQgdT1lK3Q7Y29uc3QgZD10L3I7Zm9yKGxldCBlPTA7ZTxyO2UrKyl1LT1kKk1hdGgucmFuZG9tKCksYS5wdXNoKC4uLnZhKHUpLnRvQXJyYXkoKSksYy5zZXRIU0woZS9yLG8sLjkpLHMucHVzaChjLnIsYy5nLGMuYik7cmV0dXJuW25ldyBGbG9hdDMyQXJyYXkoYSksbmV3IEZsb2F0MzJBcnJheShzKSxuZXcgRmxvYXQzMkFycmF5KGwpXX0pLFtyLHQsaSxlLG9dKTthLnVzZUZyYW1lKChlPT51LmN1cnJlbnQmJih1LmN1cnJlbnQudW5pZm9ybXMudGltZS52YWx1ZT1lLmNsb2NrLmdldEVsYXBzZWRUaW1lKCkqbCkpKTtjb25zdFtwXT1QLnVzZVN0YXRlKCgoKT0+bmV3IHlhKSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLHtyZWY6Y30sUC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIixudWxsLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsYXJnczpbZCwzXX0pLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLWNvbG9yXCIsYXJnczpbbSwzXX0pLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXNpemVcIixhcmdzOltmLDFdfSkpLFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtyZWY6dSxvYmplY3Q6cCxhdHRhY2g6XCJtYXRlcmlhbFwiLGJsZW5kaW5nOm4uQWRkaXRpdmVCbGVuZGluZyxcInVuaWZvcm1zLWZhZGUtdmFsdWVcIjpzLGRlcHRoV3JpdGU6ITEsdHJhbnNwYXJlbnQ6ITAsdmVydGV4Q29sb3JzOiEwfSkpfSkpLHphPShlLHQpPT57XCJ1cGRhdGVSYW5nZXNcImluIGU/ZS51cGRhdGVSYW5nZXNbMF09dDplLnVwZGF0ZVJhbmdlPXR9LHdhPW5ldyBuLk1hdHJpeDQsYmE9bmV3IG4uVmVjdG9yMyxNYT1uZXcgbi5RdWF0ZXJuaW9uLEVhPW5ldyBuLlZlY3RvcjMsU2E9bmV3IG4uUXVhdGVybmlvbixUYT1uZXcgbi5WZWN0b3IzLENhPVAuY3JlYXRlQ29udGV4dChudWxsKSxQYT1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxtYXRlcmlhbDp0PW4uTWVzaExhbWJlcnRNYXRlcmlhbCx0ZXh0dXJlOnI9XCJodHRwczovL3Jhd2Nkbi5naXRoYWNrLmNvbS9wbW5kcnMvZHJlaS1hc3NldHMvOTIyNWE5ZjFmYmQ0NDlkOTQxMTEyNWMyZjQxOWI4NDNkMDMwOGM5Zi9jbG91ZC5wbmdcIixyYW5nZTpvLGxpbWl0Omk9MjAwLC4uLnN9LGwpPT57dmFyIGMsdTtjb25zdCBkPVAudXNlTWVtbygoKCk9PmNsYXNzIGV4dGVuZHMgdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCk7Y29uc3QgZT1wYXJzZUludChuLlJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZyxcIlwiKSk+PTE1ND9cIm9wYXF1ZV9mcmFnbWVudFwiOlwib3V0cHV0X2ZyYWdtZW50XCI7dGhpcy5vbkJlZm9yZUNvbXBpbGU9dD0+e3QudmVydGV4U2hhZGVyPVwiYXR0cmlidXRlIGZsb2F0IG9wYWNpdHk7XFxuICAgICAgICAgICAgICAgdmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4gICAgICAgICAgICAgIFwiK3QudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cIixcIiNpbmNsdWRlIDxmb2dfdmVydGV4PlxcbiAgICAgICAgICAgICAgICAgdk9wYWNpdHkgPSBvcGFjaXR5O1xcbiAgICAgICAgICAgICAgICBcIiksdC5mcmFnbWVudFNoYWRlcj1cInZhcnlpbmcgZmxvYXQgdk9wYWNpdHk7XFxuICAgICAgICAgICAgICBcIit0LmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoYCNpbmNsdWRlIDwke2V9PmAsYCNpbmNsdWRlIDwke2V9PlxcbiAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSAqIHZPcGFjaXR5KTtcXG4gICAgICAgICAgICAgICAgYCl9fX0pLFt0XSk7YS5leHRlbmQoe0Nsb3VkTWF0ZXJpYWw6ZH0pO2NvbnN0IG09UC51c2VSZWYobnVsbCksZj1QLnVzZVJlZihbXSkscD1QLnVzZU1lbW8oKCgpPT5uZXcgRmxvYXQzMkFycmF5KEFycmF5LmZyb20oe2xlbmd0aDppfSwoKCk9PjEpKSkpLFtpXSksaD1QLnVzZU1lbW8oKCgpPT5uZXcgRmxvYXQzMkFycmF5KEFycmF5LmZyb20oe2xlbmd0aDppfSwoKCk9PlsxLDEsMV0pKS5mbGF0KCkpKSxbaV0pLHg9VGUocik7bGV0IHksdj0wLGc9MDtjb25zdCB6PW5ldyBuLlF1YXRlcm5pb24sdz1uZXcgbi5WZWN0b3IzKDAsMCwxKSxiPW5ldyBuLlZlY3RvcjM7YS51c2VGcmFtZSgoKGUsdCk9Pntmb3Iodj1lLmNsb2NrLmdldEVsYXBzZWRUaW1lKCksd2EuY29weShtLmN1cnJlbnQubWF0cml4V29ybGQpLmludmVydCgpLGUuY2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZShFYSxTYSxUYSksZz0wO2c8Zi5jdXJyZW50Lmxlbmd0aDtnKyspeT1mLmN1cnJlbnRbZ10seS5yZWYuY3VycmVudC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoYmEsTWEsVGEpLGJhLmFkZChiLmNvcHkoeS5wb3NpdGlvbikuYXBwbHlRdWF0ZXJuaW9uKE1hKS5tdWx0aXBseShUYSkpLE1hLmNvcHkoU2EpLm11bHRpcGx5KHouc2V0RnJvbUF4aXNBbmdsZSh3LHkucm90YXRpb24rPXQqeS5yb3RhdGlvbkZhY3RvcikpLFRhLm11bHRpcGx5U2NhbGFyKHkudm9sdW1lKygxK01hdGguc2luKHYqeS5kZW5zaXR5Knkuc3BlZWQpKS8yKnkuZ3Jvd3RoKSx5Lm1hdHJpeC5jb21wb3NlKGJhLE1hLFRhKS5wcmVtdWx0aXBseSh3YSkseS5kaXN0PWJhLmRpc3RhbmNlVG8oRWEpO2ZvcihmLmN1cnJlbnQuc29ydCgoKGUsdCk9PnQuZGlzdC1lLmRpc3QpKSxnPTA7ZzxmLmN1cnJlbnQubGVuZ3RoO2crKyl5PWYuY3VycmVudFtnXSxwW2ddPXkub3BhY2l0eSooeS5kaXN0PHkuZmFkZS0xP3kuZGlzdC95LmZhZGU6MSksbS5jdXJyZW50LnNldE1hdHJpeEF0KGcseS5tYXRyaXgpLG0uY3VycmVudC5zZXRDb2xvckF0KGcseS5jb2xvcik7bS5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMub3BhY2l0eS5uZWVkc1VwZGF0ZT0hMCxtLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGU9ITAsbS5jdXJyZW50Lmluc3RhbmNlQ29sb3ImJihtLmN1cnJlbnQuaW5zdGFuY2VDb2xvci5uZWVkc1VwZGF0ZT0hMCl9KSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgZT1NYXRoLm1pbihpLHZvaWQgMCE9PW8/bzppLGYuY3VycmVudC5sZW5ndGgpO20uY3VycmVudC5jb3VudD1lLHphKG0uY3VycmVudC5pbnN0YW5jZU1hdHJpeCx7b2Zmc2V0OjAsY291bnQ6MTYqZX0pLG0uY3VycmVudC5pbnN0YW5jZUNvbG9yJiZ6YShtLmN1cnJlbnQuaW5zdGFuY2VDb2xvcix7b2Zmc2V0OjAsY291bnQ6MyplfSksemEobS5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMub3BhY2l0eSx7b2Zmc2V0OjAsY291bnQ6ZX0pfSkpO2xldCBNPVtudWxsIT09KGM9eC5pbWFnZS53aWR0aCkmJnZvaWQgMCE9PWM/YzoxLG51bGwhPT0odT14LmltYWdlLmhlaWdodCkmJnZvaWQgMCE9PXU/dToxXSxFPU1hdGgubWF4KE1bMF0sTVsxXSk7cmV0dXJuIE09W01bMF0vRSxNWzFdL0VdLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsQy5kZWZhdWx0KHtyZWY6bH0scyksUC5jcmVhdGVFbGVtZW50KENhLlByb3ZpZGVyLHt2YWx1ZTpmfSxlLFAuY3JlYXRlRWxlbWVudChcImluc3RhbmNlZE1lc2hcIix7bWF0cml4QXV0b1VwZGF0ZTohMSxyZWY6bSxhcmdzOltudWxsLG51bGwsaV19LFAuY3JlYXRlRWxlbWVudChcImluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZVwiLHt1c2FnZTpuLkR5bmFtaWNEcmF3VXNhZ2UsYXR0YWNoOlwiaW5zdGFuY2VDb2xvclwiLGFyZ3M6W2gsM119KSxQLmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIse2FyZ3M6Wy4uLk1dfSxQLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIix7dXNhZ2U6bi5EeW5hbWljRHJhd1VzYWdlLGF0dGFjaDpcImF0dHJpYnV0ZXMtb3BhY2l0eVwiLGFyZ3M6W3AsMV19KSksUC5jcmVhdGVFbGVtZW50KFwiY2xvdWRNYXRlcmlhbFwiLHtrZXk6dC5uYW1lLG1hcDp4LHRyYW5zcGFyZW50OiEwLGRlcHRoV3JpdGU6ITF9KSkpKX0pKSxSYT1QLmZvcndhcmRSZWYoKCh7b3BhY2l0eTplPTEsc3BlZWQ6dD0wLGJvdW5kczpyPVs1LDEsMV0sc2VnbWVudHM6bz0yMCxjb2xvcjppPVwiI2ZmZmZmZlwiLGZhZGU6cz0xMCx2b2x1bWU6bD02LHNtYWxsZXN0Vm9sdW1lOmM9LjI1LGRpc3RyaWJ1dGU6dT1udWxsLGdyb3d0aDpkPTQsY29uY2VudHJhdGU6bT1cImluc2lkZVwiLHNlZWQ6Zj1NYXRoLnJhbmRvbSgpLC4uLnB9LGgpPT57ZnVuY3Rpb24geCgpe2NvbnN0IGU9MWU0Kk1hdGguc2luKGYrKyk7cmV0dXJuIGUtTWF0aC5mbG9vcihlKX1jb25zdCB5PVAudXNlQ29udGV4dChDYSksdj1QLnVzZVJlZihudWxsKSxbZ109UC51c2VTdGF0ZSgoKCk9PmIudjQoKSkpLHo9UC51c2VNZW1vKCgoKT0+Wy4uLm5ldyBBcnJheShvKV0ubWFwKCgoZSx0KT0+KHtzZWdtZW50czpvLGJvdW5kczpuZXcgbi5WZWN0b3IzKDEsMSwxKSxwb3NpdGlvbjpuZXcgbi5WZWN0b3IzLHV1aWQ6ZyxpbmRleDp0LHJlZjp2LGRpc3Q6MCxtYXRyaXg6bmV3IG4uTWF0cml4NCxjb2xvcjpuZXcgbi5Db2xvcixyb3RhdGlvbjp0KihNYXRoLlBJL28pfSkpKSksW28sZ10pO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pnt6LmZvckVhY2goKChuLGYpPT57dmFyIHA7YS5hcHBseVByb3BzKG4se3ZvbHVtZTpsLGNvbG9yOmksc3BlZWQ6dCxncm93dGg6ZCxvcGFjaXR5OmUsZmFkZTpzLGJvdW5kczpyLGRlbnNpdHk6TWF0aC5tYXgoLjUseCgpKSxyb3RhdGlvbkZhY3RvcjpNYXRoLm1heCguMiwuNSp4KCkpKnR9KTtjb25zdCBoPW51bGw9PXU/dm9pZCAwOnUobixmKTsoaHx8bz4xKSYmbi5wb3NpdGlvbi5jb3B5KG4uYm91bmRzKS5tdWx0aXBseShudWxsIT09KHA9bnVsbD09aD92b2lkIDA6aC5wb2ludCkmJnZvaWQgMCE9PXA/cDp7eDoyKngoKS0xLHk6Mip4KCktMSx6OjIqeCgpLTF9KTtjb25zdCB5PU1hdGguYWJzKG4ucG9zaXRpb24ueCksdj1NYXRoLmFicyhuLnBvc2l0aW9uLnkpLGc9TWF0aC5hYnMobi5wb3NpdGlvbi56KSx6PU1hdGgubWF4KHksdixnKTtuLmxlbmd0aD0xLHk9PT16JiYobi5sZW5ndGgtPXkvbi5ib3VuZHMueCksdj09PXomJihuLmxlbmd0aC09di9uLmJvdW5kcy55KSxnPT09eiYmKG4ubGVuZ3RoLT1nL24uYm91bmRzLnopLG4udm9sdW1lPSh2b2lkIDAhPT0obnVsbD09aD92b2lkIDA6aC52b2x1bWUpP2gudm9sdW1lOk1hdGgubWF4KE1hdGgubWF4KDAsYyksXCJyYW5kb21cIj09PW0/eCgpOlwiaW5zaWRlXCI9PT1tP24ubGVuZ3RoOjEtbi5sZW5ndGgpKSpsfSkpfSksW20scixzLGksZSxkLGwsZixvLHRdKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCBlPXo7cmV0dXJuIHkuY3VycmVudD1bLi4ueS5jdXJyZW50LC4uLmVdLCgpPT57eS5jdXJyZW50PXkuY3VycmVudC5maWx0ZXIoKGU9PmUudXVpZCE9PWcpKX19KSxbel0pLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShoLCgoKT0+di5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjp2fSxwKSl9KSksRGE9UC5mb3J3YXJkUmVmKCgoZSx0KT0+UC51c2VDb250ZXh0KENhKT9QLmNyZWF0ZUVsZW1lbnQoUmEsQy5kZWZhdWx0KHtyZWY6dH0sZSkpOlAuY3JlYXRlRWxlbWVudChQYSxudWxsLFAuY3JlYXRlRWxlbWVudChSYSxDLmRlZmF1bHQoe3JlZjp0fSxlKSkpKSksRmE9RWUoe3RpbWU6MCxwaXhlbFJhdGlvOjF9LFwiIHVuaWZvcm0gZmxvYXQgcGl4ZWxSYXRpbztcXG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xcbiAgICBhdHRyaWJ1dGUgZmxvYXQgc2l6ZTsgIFxcbiAgICBhdHRyaWJ1dGUgZmxvYXQgc3BlZWQ7ICBcXG4gICAgYXR0cmlidXRlIGZsb2F0IG9wYWNpdHk7XFxuICAgIGF0dHJpYnV0ZSB2ZWMzIG5vaXNlO1xcbiAgICBhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG4gICAgdmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4gICAgdmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIHZlYzQgbW9kZWxQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG4gICAgICBtb2RlbFBvc2l0aW9uLnkgKz0gc2luKHRpbWUgKiBzcGVlZCArIG1vZGVsUG9zaXRpb24ueCAqIG5vaXNlLnggKiAxMDAuMCkgKiAwLjI7XFxuICAgICAgbW9kZWxQb3NpdGlvbi56ICs9IGNvcyh0aW1lICogc3BlZWQgKyBtb2RlbFBvc2l0aW9uLnggKiBub2lzZS55ICogMTAwLjApICogMC4yO1xcbiAgICAgIG1vZGVsUG9zaXRpb24ueCArPSBjb3ModGltZSAqIHNwZWVkICsgbW9kZWxQb3NpdGlvbi54ICogbm9pc2UueiAqIDEwMC4wKSAqIDAuMjtcXG4gICAgICB2ZWM0IHZpZXdQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiBtb2RlbFBvc2l0aW9uO1xcbiAgICAgIHZlYzQgcHJvamVjdGlvblBvc3Rpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld1Bvc2l0aW9uO1xcbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvblBvc3Rpb247XFxuICAgICAgZ2xfUG9pbnRTaXplID0gc2l6ZSAqIDI1LiAqIHBpeGVsUmF0aW87XFxuICAgICAgZ2xfUG9pbnRTaXplICo9ICgxLjAgLyAtIHZpZXdQb3NpdGlvbi56KTtcXG4gICAgICB2Q29sb3IgPSBjb2xvcjtcXG4gICAgICB2T3BhY2l0eSA9IG9wYWNpdHk7XFxuICAgIH1cIixgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuICAgIHZhcnlpbmcgZmxvYXQgdk9wYWNpdHk7XFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBmbG9hdCBkaXN0YW5jZVRvQ2VudGVyID0gZGlzdGFuY2UoZ2xfUG9pbnRDb29yZCwgdmVjMigwLjUpKTtcXG4gICAgICBmbG9hdCBzdHJlbmd0aCA9IDAuMDUgLyBkaXN0YW5jZVRvQ2VudGVyIC0gMC4xO1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yLCBzdHJlbmd0aCAqIHZPcGFjaXR5KTtcXG4gICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuICAgICAgI2luY2x1ZGUgPCR7Q2U+PTE1ND9cImNvbG9yc3BhY2VfZnJhZ21lbnRcIjpcImVuY29kaW5nc19mcmFnbWVudFwifT5cXG4gICAgfWApLGthPWU9PmUmJmUuY29uc3RydWN0b3I9PT1GbG9hdDMyQXJyYXksX2E9ZT0+ZSBpbnN0YW5jZW9mIEQuVmVjdG9yMnx8ZSBpbnN0YW5jZW9mIEQuVmVjdG9yM3x8ZSBpbnN0YW5jZW9mIEQuVmVjdG9yNCxBYT1lPT5BcnJheS5pc0FycmF5KGUpP2U6X2EoZSk/ZS50b0FycmF5KCk6W2UsZSxlXTtmdW5jdGlvbiBMYShlLHQscil7cmV0dXJuIFAudXNlTWVtbygoKCk9PntpZih2b2lkIDAhPT10KXtpZihrYSh0KSlyZXR1cm4gdDtpZih0IGluc3RhbmNlb2YgRC5Db2xvcil7Y29uc3Qgcj1BcnJheS5mcm9tKHtsZW5ndGg6MyplfSwoKCk9PihlPT5bZS5yLGUuZyxlLmJdKSh0KSkpLmZsYXQoKTtyZXR1cm4gRmxvYXQzMkFycmF5LmZyb20ocil9aWYoX2EodCl8fEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IHI9QXJyYXkuZnJvbSh7bGVuZ3RoOjMqZX0sKCgpPT5BYSh0KSkpLmZsYXQoKTtyZXR1cm4gRmxvYXQzMkFycmF5LmZyb20ocil9cmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6ZX0sKCgpPT50KSl9cmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6ZX0scil9KSxbdF0pfWNvbnN0IEJhPVAuZm9yd2FyZFJlZigoKHtub2lzZTplPTEsY291bnQ6dD0xMDAsc3BlZWQ6cj0xLG9wYWNpdHk6bj0xLHNjYWxlOm89MSxzaXplOmksY29sb3I6cyxjaGlsZHJlbjpsLC4uLmN9LHUpPT57UC51c2VNZW1vKCgoKT0+YS5leHRlbmQoe1NwYXJrbGVzSW1wbE1hdGVyaWFsOkZhfSkpLFtdKTtjb25zdCBkPVAudXNlUmVmKG51bGwpLG09YS51c2VUaHJlZSgoZT0+ZS52aWV3cG9ydC5kcHIpKSxmPUFhKG8pLHA9UC51c2VNZW1vKCgoKT0+RmxvYXQzMkFycmF5LmZyb20oQXJyYXkuZnJvbSh7bGVuZ3RoOnR9LCgoKT0+Zi5tYXAoRC5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKSkpLmZsYXQoKSkpLFt0LC4uLmZdKSxoPUxhKHQsaSxNYXRoLnJhbmRvbSkseD1MYSh0LG4pLHk9TGEodCxyKSx2PUxhKDMqdCxlKSxnPUxhKHZvaWQgMD09PXM/Myp0OnQsa2Eocyk/czpuZXcgRC5Db2xvcihzKSwoKCk9PjEpKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+e2QuY3VycmVudCYmZC5jdXJyZW50Lm1hdGVyaWFsJiYoZC5jdXJyZW50Lm1hdGVyaWFsLnRpbWU9ZS5jbG9jay5lbGFwc2VkVGltZSl9KSksUC51c2VJbXBlcmF0aXZlSGFuZGxlKHUsKCgpPT5kLmN1cnJlbnQpLFtdKSxQLmNyZWF0ZUVsZW1lbnQoXCJwb2ludHNcIixDLmRlZmF1bHQoe2tleTpgcGFydGljbGUtJHt0fS0ke0pTT04uc3RyaW5naWZ5KG8pfWB9LGMse3JlZjpkfSksUC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIixudWxsLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsYXJnczpbcCwzXX0pLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXNpemVcIixhcmdzOltoLDFdfSksUC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtb3BhY2l0eVwiLGFyZ3M6W3gsMV19KSxQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1zcGVlZFwiLGFyZ3M6W3ksMV19KSxQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1jb2xvclwiLGFyZ3M6W2csM119KSxQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1ub2lzZVwiLGFyZ3M6W3YsM119KSksbHx8UC5jcmVhdGVFbGVtZW50KFwic3BhcmtsZXNJbXBsTWF0ZXJpYWxcIix7dHJhbnNwYXJlbnQ6ITAscGl4ZWxSYXRpbzptLGRlcHRoV3JpdGU6ITF9KSl9KSk7Y29uc3QgVWE9e3VuaWZvcm1zOntzdHJva2VPcGFjaXR5OjEsZmlsbE9wYWNpdHk6LjI1LGZpbGxNaXg6MCx0aGlja25lc3M6LjA1LGNvbG9yQmFja2ZhY2VzOiExLGRhc2hJbnZlcnQ6ITAsZGFzaDohMSxkYXNoUmVwZWF0czo0LGRhc2hMZW5ndGg6LjUsc3F1ZWV6ZTohMSxzcXVlZXplTWluOi4yLHNxdWVlemVNYXg6MSxzdHJva2U6bmV3IEQuQ29sb3IoXCIjZmYwMDAwXCIpLGJhY2tmYWNlU3Ryb2tlOm5ldyBELkNvbG9yKFwiIzAwMDBmZlwiKSxmaWxsOm5ldyBELkNvbG9yKFwiIzAwZmYwMFwiKX0sdmVydGV4OlwiXFxuXFx0ICBhdHRyaWJ1dGUgdmVjMyBiYXJ5Y2VudHJpYztcXG5cXHRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdl9lZGdlc19CYXJ5Y2VudHJpYztcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdl9lZGdlc19Qb3NpdGlvbjtcXG5cXG5cXHRcXHR2b2lkIGluaXRXaXJlZnJhbWUoKSB7XFxuXFx0XFx0XFx0dl9lZGdlc19CYXJ5Y2VudHJpYyA9IGJhcnljZW50cmljO1xcblxcdFxcdFxcdHZfZWRnZXNfUG9zaXRpb24gPSBwb3NpdGlvbi54eXo7XFxuXFx0XFx0fVxcblxcdCAgXCIsZnJhZ21lbnQ6XCJcXG5cXHRcXHQjaWZuZGVmIFBJXFxuXFx0ICBcXHQjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NVxcblxcdFxcdCNlbmRpZlxcbiAgXFxuXFx0ICB2YXJ5aW5nIHZlYzMgdl9lZGdlc19CYXJ5Y2VudHJpYztcXG5cXHQgIHZhcnlpbmcgdmVjMyB2X2VkZ2VzX1Bvc2l0aW9uO1xcbiAgXFxuXFx0ICB1bmlmb3JtIGZsb2F0IHN0cm9rZU9wYWNpdHk7XFxuXFx0ICB1bmlmb3JtIGZsb2F0IGZpbGxPcGFjaXR5O1xcblxcdCAgdW5pZm9ybSBmbG9hdCBmaWxsTWl4O1xcblxcdCAgdW5pZm9ybSBmbG9hdCB0aGlja25lc3M7XFxuXFx0ICB1bmlmb3JtIGJvb2wgY29sb3JCYWNrZmFjZXM7XFxuICBcXG5cXHQgIC8vIERhc2hcXG5cXHQgIHVuaWZvcm0gYm9vbCBkYXNoSW52ZXJ0O1xcblxcdCAgdW5pZm9ybSBib29sIGRhc2g7XFxuXFx0ICB1bmlmb3JtIGJvb2wgZGFzaE9ubHk7XFxuXFx0ICB1bmlmb3JtIGZsb2F0IGRhc2hSZXBlYXRzO1xcblxcdCAgdW5pZm9ybSBmbG9hdCBkYXNoTGVuZ3RoO1xcbiAgXFxuXFx0ICAvLyBTcXVlZXplXFxuXFx0ICB1bmlmb3JtIGJvb2wgc3F1ZWV6ZTtcXG5cXHQgIHVuaWZvcm0gZmxvYXQgc3F1ZWV6ZU1pbjtcXG5cXHQgIHVuaWZvcm0gZmxvYXQgc3F1ZWV6ZU1heDtcXG4gIFxcblxcdCAgLy8gQ29sb3JzXFxuXFx0ICB1bmlmb3JtIHZlYzMgc3Ryb2tlO1xcblxcdCAgdW5pZm9ybSB2ZWMzIGJhY2tmYWNlU3Ryb2tlO1xcblxcdCAgdW5pZm9ybSB2ZWMzIGZpbGw7XFxuICBcXG5cXHQgIC8vIFRoaXMgaXMgbGlrZVxcblxcdCAgZmxvYXQgd2lyZWZyYW1lX2Fhc3RlcChmbG9hdCB0aHJlc2hvbGQsIGZsb2F0IGRpc3QpIHtcXG5cXHRcXHQgIGZsb2F0IGFmd2lkdGggPSBmd2lkdGgoZGlzdCkgKiAwLjU7XFxuXFx0XFx0ICByZXR1cm4gc21vb3Roc3RlcCh0aHJlc2hvbGQgLSBhZndpZHRoLCB0aHJlc2hvbGQgKyBhZndpZHRoLCBkaXN0KTtcXG5cXHQgIH1cXG4gIFxcblxcdCAgZmxvYXQgd2lyZWZyYW1lX21hcChmbG9hdCB2YWx1ZSwgZmxvYXQgbWluMSwgZmxvYXQgbWF4MSwgZmxvYXQgbWluMiwgZmxvYXQgbWF4Mikge1xcblxcdFxcdCAgcmV0dXJuIG1pbjIgKyAodmFsdWUgLSBtaW4xKSAqIChtYXgyIC0gbWluMikgLyAobWF4MSAtIG1pbjEpO1xcblxcdCAgfVxcbiAgXFxuXFx0ICBmbG9hdCBnZXRXaXJlZnJhbWUoKSB7XFxuXFx0XFx0XFx0dmVjMyBiYXJ5Y2VudHJpYyA9IHZfZWRnZXNfQmFyeWNlbnRyaWM7XFxuXFx0XFx0XFxuXFx0XFx0XFx0Ly8gRGlzdGFuY2UgZnJvbSBjZW50ZXIgb2YgZWFjaCB0cmlhbmdsZSB0byBpdHMgZWRnZXMuXFxuXFx0XFx0XFx0ZmxvYXQgZCA9IG1pbihtaW4oYmFyeWNlbnRyaWMueCwgYmFyeWNlbnRyaWMueSksIGJhcnljZW50cmljLnopO1xcblxcblxcdFxcdFxcdC8vIGZvciBkYXNoZWQgcmVuZGVyaW5nLCB3ZSBjYW4gdXNlIHRoaXMgdG8gZ2V0IHRoZSAwIC4uIDEgdmFsdWUgb2YgdGhlIGxpbmUgbGVuZ3RoXFxuXFx0XFx0XFx0ZmxvYXQgcG9zaXRpb25BbG9uZyA9IG1heChiYXJ5Y2VudHJpYy54LCBiYXJ5Y2VudHJpYy55KTtcXG5cXHRcXHRcXHRpZiAoYmFyeWNlbnRyaWMueSA8IGJhcnljZW50cmljLnggJiYgYmFyeWNlbnRyaWMueSA8IGJhcnljZW50cmljLnopIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbkFsb25nID0gMS4wIC0gcG9zaXRpb25BbG9uZztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlXFxuXFx0XFx0XFx0ZmxvYXQgY29tcHV0ZWRUaGlja25lc3MgPSB3aXJlZnJhbWVfbWFwKHRoaWNrbmVzcywgMC4wLCAxLjAsIDAuMCwgMC4zNCk7XFxuXFxuXFx0XFx0XFx0Ly8gaWYgd2Ugd2FudCB0byBzaHJpbmsgdGhlIHRoaWNrbmVzcyB0b3dhcmQgdGhlIGNlbnRlciBvZiB0aGUgbGluZSBzZWdtZW50XFxuXFx0XFx0XFx0aWYgKHNxdWVlemUpIHtcXG5cXHRcXHRcXHRcXHRjb21wdXRlZFRoaWNrbmVzcyAqPSBtaXgoc3F1ZWV6ZU1pbiwgc3F1ZWV6ZU1heCwgKDEuMCAtIHNpbihwb3NpdGlvbkFsb25nICogUEkpKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENyZWF0ZSBkYXNoIHBhdHRlcm5cXG5cXHRcXHRcXHRpZiAoZGFzaCkge1xcblxcdFxcdFxcdFxcdC8vIGhlcmUgd2Ugb2Zmc2V0IHRoZSBzdHJva2UgcG9zaXRpb24gZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXRcXG5cXHRcXHRcXHRcXHQvLyBzaG91bGQgb3ZlcmxhcCBvciBub3RcXG5cXHRcXHRcXHRcXHRmbG9hdCBvZmZzZXQgPSAxLjAgLyBkYXNoUmVwZWF0cyAqIGRhc2hMZW5ndGggLyAyLjA7XFxuXFx0XFx0XFx0XFx0aWYgKCFkYXNoSW52ZXJ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0ICs9IDEuMCAvIGRhc2hSZXBlYXRzIC8gMi4wO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiB3ZSBzaG91bGQgYW5pbWF0ZSB0aGUgZGFzaCBvciBub3RcXG5cXHRcXHRcXHRcXHQvLyBpZiAoZGFzaEFuaW1hdGUpIHtcXG5cXHRcXHRcXHRcXHQvLyBcXHRvZmZzZXQgKz0gdGltZSAqIDAuMjI7XFxuXFx0XFx0XFx0XFx0Ly8gfVxcblxcblxcdFxcdFxcdFxcdC8vIGNyZWF0ZSB0aGUgcmVwZWF0aW5nIGRhc2ggcGF0dGVyblxcblxcdFxcdFxcdFxcdGZsb2F0IHBhdHRlcm4gPSBmcmFjdCgocG9zaXRpb25BbG9uZyArIG9mZnNldCkgKiBkYXNoUmVwZWF0cyk7XFxuXFx0XFx0XFx0XFx0Y29tcHV0ZWRUaGlja25lc3MgKj0gMS4wIC0gd2lyZWZyYW1lX2Fhc3RlcChkYXNoTGVuZ3RoLCBwYXR0ZXJuKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSB0aGUgYW50aS1hbGlhc2VkIHN0cm9rZSBlZGdlICBcXG5cXHRcXHRcXHRmbG9hdCBlZGdlID0gMS4wIC0gd2lyZWZyYW1lX2Fhc3RlcChjb21wdXRlZFRoaWNrbmVzcywgZCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVkZ2U7XFxuXFx0ICB9XFxuXFx0ICBcIn0sSWE9RWUoVWEudW5pZm9ybXMsVWEudmVydGV4K1wiXFxuICBcXHR2b2lkIG1haW4oKSB7XFxuXFx0XFx0aW5pdFdpcmVmcmFtZSgpO1xcblxcdFxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFx0fVxcbiAgXCIsVWEuZnJhZ21lbnQrXCJcXG4gIHZvaWQgbWFpbiAoKSB7XFxuXFx0XFx0Ly8gQ29tcHV0ZSBjb2xvclxcblxcblxcdFxcdGZsb2F0IGVkZ2UgPSBnZXRXaXJlZnJhbWUoKTtcXG5cXHRcXHR2ZWM0IGNvbG9yU3Ryb2tlID0gdmVjNChzdHJva2UsIGVkZ2UpO1xcblxcblxcdFxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0XFx0Y29sb3JTdHJva2UucmdiID0gYmFja2ZhY2VTdHJva2U7XFxuXFx0XFx0I2VuZGlmXFxuICAgIFxcblxcdFxcdHZlYzQgY29sb3JGaWxsID0gdmVjNChmaWxsLCBmaWxsT3BhY2l0eSk7XFxuXFx0XFx0dmVjNCBvdXRDb2xvciA9IG1peChjb2xvckZpbGwsIGNvbG9yU3Ryb2tlLCBlZGdlICogc3Ryb2tlT3BhY2l0eSk7XFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gb3V0Q29sb3I7XFxuXFx0fVxcbiAgXCIpO2Z1bmN0aW9uIFZhKGUpe3JldHVybiB2b2lkIDAhPT0obnVsbD09ZT92b2lkIDA6ZS5jdXJyZW50KX1mdW5jdGlvbiBPYShlKXtyZXR1cm5cIldpcmVmcmFtZUdlb21ldHJ5XCI9PT1lLnR5cGV9ZnVuY3Rpb24gTmEoZSl7Y29uc3QgdD1udWxsIT0ocj1lKSYmci5jdXJyZW50P2UuY3VycmVudDplO3ZhciByO2lmKGZ1bmN0aW9uKGUpe3JldHVybiEobnVsbD09ZXx8IWUuaXNCdWZmZXJHZW9tZXRyeSl9KHQpKXJldHVybiB0O3tpZihPYSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJXaXJlZnJhbWU6IFdpcmVmcmFtZUdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWQuXCIpO2NvbnN0IGU9dC5wYXJlbnQ7aWYoZnVuY3Rpb24oZSl7cmV0dXJuIShudWxsPT1lfHwhZS5nZW9tZXRyeSl9KGUpKXtpZihPYShlLmdlb21ldHJ5KSl0aHJvdyBuZXcgRXJyb3IoXCJXaXJlZnJhbWU6IFdpcmVmcmFtZUdlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWQuXCIpO3JldHVybiBlLmdlb21ldHJ5fX19ZnVuY3Rpb24gamEoZSx0KXtpZihlLmluZGV4KXtjb25zb2xlLndhcm4oXCJXaXJlZnJhbWU6IFJlcXVpcmVzIG5vbi1pbmRleGVkIGdlb21ldHJ5LCBjb252ZXJ0aW5nIHRvIG5vbi1pbmRleGVkIGdlb21ldHJ5LlwiKTtjb25zdCB0PWUudG9Ob25JbmRleGVkKCk7ZS5jb3B5KHQpLGUuc2V0SW5kZXgobnVsbCl9Y29uc3Qgcj1mdW5jdGlvbihlLHQpe2NvbnN0IHI9ZS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKS5jb3VudCxuPVtdO2ZvcihsZXQgZT0wO2U8cjtlKyspe2NvbnN0IHI9dD8xOjA7ZSUyPT0wP24ucHVzaCgwLDAsMSwwLDEsMCwxLDAscik6bi5wdXNoKDAsMSwwLDAsMCwxLDEsMCxyKX1yZXR1cm4gbmV3IEQuQnVmZmVyQXR0cmlidXRlKEZsb2F0MzJBcnJheS5mcm9tKG4pLDMpfShlLHQpO2Uuc2V0QXR0cmlidXRlKFwiYmFyeWNlbnRyaWNcIixyKX1mdW5jdGlvbiBXYSh7Z2VvbWV0cnk6ZSxzaW1wbGlmeTp0PSExLC4uLnJ9KXthLmV4dGVuZCh7TWVzaFdpcmVmcmFtZU1hdGVyaWFsOklhfSk7Y29uc3RbbixvXT1QLnVzZVN0YXRlKG51bGwpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2NvbnN0IHI9TmEoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiV2lyZWZyYW1lOiBnZW9tZXRyeSBwcm9wIG11c3QgYmUgYSBCdWZmZXJHZW9tZXRyeSBvciBhIHJlZiB0byBhIEJ1ZmZlckdlb21ldHJ5LlwiKTtqYShyLHQpLFZhKGUpJiZvKHIpfSksW3QsZV0pO2NvbnN0IGk9VmEoZSk/bjplO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGkmJlAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7Z2VvbWV0cnk6aX0sUC5jcmVhdGVFbGVtZW50KFwibWVzaFdpcmVmcmFtZU1hdGVyaWFsXCIsQy5kZWZhdWx0KHthdHRhY2g6XCJtYXRlcmlhbFwiLHRyYW5zcGFyZW50OiEwLHNpZGU6RC5Eb3VibGVTaWRlLHBvbHlnb25PZmZzZXQ6ITAscG9seWdvbk9mZnNldEZhY3RvcjotNH0scix7ZXh0ZW5zaW9uczp7ZGVyaXZhdGl2ZXM6ITAsZnJhZ0RlcHRoOiExLGRyYXdCdWZmZXJzOiExLHNoYWRlclRleHR1cmVMT0Q6ITF9fSkpKSl9ZnVuY3Rpb24gR2Eoe3NpbXBsaWZ5OmU9ITEsLi4udH0pe2NvbnN0IHI9UC51c2VSZWYobnVsbCksbj1QLnVzZU1lbW8oKCgpPT5mdW5jdGlvbigpe2NvbnN0IGU9e307Zm9yKGNvbnN0IHQgaW4gVWEudW5pZm9ybXMpZVt0XT17dmFsdWU6VWEudW5pZm9ybXNbdF19O3JldHVybiBlfSgpKSxbVWEudW5pZm9ybXNdKTtyZXR1cm4gZnVuY3Rpb24oZSx0KXtQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLmZpbGxPcGFjaXR5LnZhbHVlPW51bGwhPT0ocj10LmZpbGxPcGFjaXR5KSYmdm9pZCAwIT09cj9yOmUuZmlsbE9wYWNpdHkudmFsdWV9KSxbdC5maWxsT3BhY2l0eV0pLFAudXNlRWZmZWN0KCgoKT0+e3ZhciByO2UuZmlsbE1peC52YWx1ZT1udWxsIT09KHI9dC5maWxsTWl4KSYmdm9pZCAwIT09cj9yOmUuZmlsbE1peC52YWx1ZX0pLFt0LmZpbGxNaXhdKSxQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLnN0cm9rZU9wYWNpdHkudmFsdWU9bnVsbCE9PShyPXQuc3Ryb2tlT3BhY2l0eSkmJnZvaWQgMCE9PXI/cjplLnN0cm9rZU9wYWNpdHkudmFsdWV9KSxbdC5zdHJva2VPcGFjaXR5XSksUC51c2VFZmZlY3QoKCgpPT57dmFyIHI7ZS50aGlja25lc3MudmFsdWU9bnVsbCE9PShyPXQudGhpY2tuZXNzKSYmdm9pZCAwIT09cj9yOmUudGhpY2tuZXNzLnZhbHVlfSksW3QudGhpY2tuZXNzXSksUC51c2VFZmZlY3QoKCgpPT57ZS5jb2xvckJhY2tmYWNlcy52YWx1ZT0hIXQuY29sb3JCYWNrZmFjZXN9KSxbdC5jb2xvckJhY2tmYWNlc10pLFAudXNlRWZmZWN0KCgoKT0+e2UuZGFzaC52YWx1ZT0hIXQuZGFzaH0pLFt0LmRhc2hdKSxQLnVzZUVmZmVjdCgoKCk9PntlLmRhc2hJbnZlcnQudmFsdWU9ISF0LmRhc2hJbnZlcnR9KSxbdC5kYXNoSW52ZXJ0XSksUC51c2VFZmZlY3QoKCgpPT57dmFyIHI7ZS5kYXNoUmVwZWF0cy52YWx1ZT1udWxsIT09KHI9dC5kYXNoUmVwZWF0cykmJnZvaWQgMCE9PXI/cjplLmRhc2hSZXBlYXRzLnZhbHVlfSksW3QuZGFzaFJlcGVhdHNdKSxQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLmRhc2hMZW5ndGgudmFsdWU9bnVsbCE9PShyPXQuZGFzaExlbmd0aCkmJnZvaWQgMCE9PXI/cjplLmRhc2hMZW5ndGgudmFsdWV9KSxbdC5kYXNoTGVuZ3RoXSksUC51c2VFZmZlY3QoKCgpPT57ZS5zcXVlZXplLnZhbHVlPSEhdC5zcXVlZXplfSksW3Quc3F1ZWV6ZV0pLFAudXNlRWZmZWN0KCgoKT0+e3ZhciByO2Uuc3F1ZWV6ZU1pbi52YWx1ZT1udWxsIT09KHI9dC5zcXVlZXplTWluKSYmdm9pZCAwIT09cj9yOmUuc3F1ZWV6ZU1pbi52YWx1ZX0pLFt0LnNxdWVlemVNaW5dKSxQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgcjtlLnNxdWVlemVNYXgudmFsdWU9bnVsbCE9PShyPXQuc3F1ZWV6ZU1heCkmJnZvaWQgMCE9PXI/cjplLnNxdWVlemVNYXgudmFsdWV9KSxbdC5zcXVlZXplTWF4XSksUC51c2VFZmZlY3QoKCgpPT57ZS5zdHJva2UudmFsdWU9dC5zdHJva2U/bmV3IEQuQ29sb3IodC5zdHJva2UpOmUuc3Ryb2tlLnZhbHVlfSksW3Quc3Ryb2tlXSksUC51c2VFZmZlY3QoKCgpPT57ZS5maWxsLnZhbHVlPXQuZmlsbD9uZXcgRC5Db2xvcih0LmZpbGwpOmUuZmlsbC52YWx1ZX0pLFt0LmZpbGxdKSxQLnVzZUVmZmVjdCgoKCk9PntlLmJhY2tmYWNlU3Ryb2tlLnZhbHVlPXQuYmFja2ZhY2VTdHJva2U/bmV3IEQuQ29sb3IodC5iYWNrZmFjZVN0cm9rZSk6ZS5iYWNrZmFjZVN0cm9rZS52YWx1ZX0pLFt0LmJhY2tmYWNlU3Ryb2tlXSl9KG4sdCksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgdD1OYShyKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJXaXJlZnJhbWU6IE11c3QgYmUgYSBjaGlsZCBvZiBhIE1lc2gsIExpbmUgb3IgUG9pbnRzIG9iamVjdCBvciBzcGVjaWZ5IGEgZ2VvbWV0cnkgcHJvcC5cIik7Y29uc3Qgbj10LmNsb25lKCk7cmV0dXJuIGphKHQsZSksKCk9Pnt0LmNvcHkobiksbi5kaXNwb3NlKCl9fSksW2VdKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCBlPXIuY3VycmVudC5wYXJlbnQsdD1lLm1hdGVyaWFsLmNsb25lKCk7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7ZS5vbkJlZm9yZUNvbXBpbGU9ZT0+e2UudW5pZm9ybXM9ey4uLmUudW5pZm9ybXMsLi4udH0sZS52ZXJ0ZXhTaGFkZXI9ZS52ZXJ0ZXhTaGFkZXIucmVwbGFjZShcInZvaWQgbWFpbigpIHtcIixgXFxuXFx0XFx0ICAke1VhLnZlcnRleH1cXG5cXHRcXHQgIHZvaWQgbWFpbigpIHtcXG5cXHRcXHRcXHRpbml0V2lyZWZyYW1lKCk7XFxuXFx0XFx0YCksZS5mcmFnbWVudFNoYWRlcj1lLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXCJ2b2lkIG1haW4oKSB7XCIsYFxcblxcdFxcdCAgJHtVYS5mcmFnbWVudH1cXG5cXHRcXHQgIHZvaWQgbWFpbigpIHtcXG5cXHRcXHRgKSxlLmZyYWdtZW50U2hhZGVyPWUuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cIixcIlxcblxcdFxcdCAgI2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdFxcdFxcdCAgZmxvYXQgZWRnZSA9IGdldFdpcmVmcmFtZSgpO1xcblxcdFxcdCAgdmVjNCBjb2xvclN0cm9rZSA9IHZlYzQoc3Ryb2tlLCBlZGdlKTtcXG5cXHRcXHQgICNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0XFx0Y29sb3JTdHJva2UucmdiID0gYmFja2ZhY2VTdHJva2U7XFxuXFx0XFx0ICAjZW5kaWZcXG5cXHRcXHQgIHZlYzQgY29sb3JGaWxsID0gdmVjNChtaXgoZGlmZnVzZUNvbG9yLnJnYiwgZmlsbCwgZmlsbE1peCksIG1peChkaWZmdXNlQ29sb3IuYSwgZmlsbE9wYWNpdHksIGZpbGxNaXgpKTtcXG5cXHRcXHQgIHZlYzQgb3V0Q29sb3IgPSBtaXgoY29sb3JGaWxsLCBjb2xvclN0cm9rZSwgZWRnZSAqIHN0cm9rZU9wYWNpdHkpO1xcblxcblxcdFxcdCAgZGlmZnVzZUNvbG9yLnJnYiA9IG91dENvbG9yLnJnYjtcXG5cXHRcXHQgIGRpZmZ1c2VDb2xvci5hICo9IG91dENvbG9yLmE7XFxuXFx0XFx0XCIpfSxlLnNpZGU9RC5Eb3VibGVTaWRlLGUudHJhbnNwYXJlbnQ9ITB9KGUubWF0ZXJpYWwsbiksKCk9PntlLm1hdGVyaWFsLmRpc3Bvc2UoKSxlLm1hdGVyaWFsPXR9fSksW10pLFAuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIse3JlZjpyfSl9Y29uc3QgSGE9bmV3IEQuTWF0cml4NCwkYT1uZXcgRC5SYXkscWE9bmV3IEQuU3BoZXJlLFhhPW5ldyBELlZlY3RvcjM7Y2xhc3MgWmEgZXh0ZW5kcyBELkdyb3Vwe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnNpemU9MCx0aGlzLmNvbG9yPW5ldyBELkNvbG9yKFwid2hpdGVcIiksdGhpcy5pbnN0YW5jZT17Y3VycmVudDp2b2lkIDB9LHRoaXMuaW5zdGFuY2VLZXk9e2N1cnJlbnQ6dm9pZCAwfX1nZXQgZ2VvbWV0cnkoKXt2YXIgZTtyZXR1cm4gbnVsbD09KGU9dGhpcy5pbnN0YW5jZS5jdXJyZW50KT92b2lkIDA6ZS5nZW9tZXRyeX1yYXljYXN0KGUsdCl7dmFyIHIsbjtjb25zdCBhPXRoaXMuaW5zdGFuY2UuY3VycmVudDtpZighYXx8IWEuZ2VvbWV0cnkpcmV0dXJuO2NvbnN0IG89YS51c2VyRGF0YS5pbnN0YW5jZXMuaW5kZXhPZih0aGlzLmluc3RhbmNlS2V5KTtpZigtMT09PW98fG8+YS5nZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQpcmV0dXJuO2NvbnN0IGk9bnVsbCE9PShyPW51bGw9PShuPWUucGFyYW1zLlBvaW50cyk/dm9pZCAwOm4udGhyZXNob2xkKSYmdm9pZCAwIT09cj9yOjE7aWYocWEuc2V0KHRoaXMuZ2V0V29ybGRQb3NpdGlvbihYYSksaSksITE9PT1lLnJheS5pbnRlcnNlY3RzU3BoZXJlKHFhKSlyZXR1cm47SGEuY29weShhLm1hdHJpeFdvcmxkKS5pbnZlcnQoKSwkYS5jb3B5KGUucmF5KS5hcHBseU1hdHJpeDQoSGEpO2NvbnN0IHM9aS8oKHRoaXMuc2NhbGUueCt0aGlzLnNjYWxlLnkrdGhpcy5zY2FsZS56KS8zKSxsPXMqcyxjPSRhLmRpc3RhbmNlU3FUb1BvaW50KHRoaXMucG9zaXRpb24pO2lmKGM8bCl7Y29uc3Qgcj1uZXcgRC5WZWN0b3IzOyRhLmNsb3Nlc3RQb2ludFRvUG9pbnQodGhpcy5wb3NpdGlvbixyKSxyLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtjb25zdCBuPWUucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHIpO2lmKG48ZS5uZWFyfHxuPmUuZmFyKXJldHVybjt0LnB1c2goe2Rpc3RhbmNlOm4sZGlzdGFuY2VUb1JheTpNYXRoLnNxcnQoYykscG9pbnQ6cixpbmRleDpvLGZhY2U6bnVsbCxvYmplY3Q6dGhpc30pfX19bGV0IFlhLFFhO2NvbnN0IEthPVAuY3JlYXRlQ29udGV4dChudWxsKSxKYT1uZXcgRC5NYXRyaXg0LGVvPW5ldyBELlZlY3RvcjMsdG89UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUscmFuZ2U6dCxsaW1pdDpyPTFlMywuLi5ufSxvKT0+e2NvbnN0IGk9UC51c2VSZWYobnVsbCksW3MsbF09UC51c2VTdGF0ZShbXSksW1tjLHUsZF1dPVAudXNlU3RhdGUoKCgpPT5bbmV3IEZsb2F0MzJBcnJheSgzKnIpLEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6MypyfSwoKCk9PjEpKSxGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOnJ9LCgoKT0+MSkpXSkpO1AudXNlRWZmZWN0KCgoKT0+e2kuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlPSEwfSkpLGEudXNlRnJhbWUoKCgpPT57Zm9yKGkuY3VycmVudC51cGRhdGVNYXRyaXgoKSxpLmN1cnJlbnQudXBkYXRlTWF0cml4V29ybGQoKSxKYS5jb3B5KGkuY3VycmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksaS5jdXJyZW50Lmdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudD1NYXRoLm1pbihyLHZvaWQgMCE9PXQ/dDpyLHMubGVuZ3RoKSxZYT0wO1lhPHMubGVuZ3RoO1lhKyspUWE9c1tZYV0uY3VycmVudCxRYS5nZXRXb3JsZFBvc2l0aW9uKGVvKS5hcHBseU1hdHJpeDQoSmEpLGVvLnRvQXJyYXkoYywzKllhKSxpLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZT0hMCxRYS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwLFFhLmNvbG9yLnRvQXJyYXkodSwzKllhKSxpLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZT0hMCxkLnNldChbUWEuc2l6ZV0sWWEpLGkuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNpemUubmVlZHNVcGRhdGU9ITB9KSk7Y29uc3QgbT1QLnVzZU1lbW8oKCgpPT4oe2dldFBhcmVudDooKT0+aSxzdWJzY3JpYmU6ZT0+KGwoKHQ9PlsuLi50LGVdKSksKCk9PmwoKHQ9PnQuZmlsdGVyKCh0PT50LmN1cnJlbnQhPT1lLmN1cnJlbnQpKSkpKX0pKSxbXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLEMuZGVmYXVsdCh7dXNlckRhdGE6e2luc3RhbmNlczpzfSxtYXRyaXhBdXRvVXBkYXRlOiExLHJlZjprLmRlZmF1bHQoW28saV0pLHJheWNhc3Q6KCk9Pm51bGx9LG4pLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1wb3NpdGlvblwiLGNvdW50OmMubGVuZ3RoLzMsYXJyYXk6YyxpdGVtU2l6ZTozLHVzYWdlOkQuRHluYW1pY0RyYXdVc2FnZX0pLFAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLWNvbG9yXCIsY291bnQ6dS5sZW5ndGgvMyxhcnJheTp1LGl0ZW1TaXplOjMsdXNhZ2U6RC5EeW5hbWljRHJhd1VzYWdlfSksUC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtc2l6ZVwiLGNvdW50OmQubGVuZ3RoLGFycmF5OmQsaXRlbVNpemU6MSx1c2FnZTpELkR5bmFtaWNEcmF3VXNhZ2V9KSksUC5jcmVhdGVFbGVtZW50KEthLlByb3ZpZGVyLHt2YWx1ZTptfSxlKSl9KSkscm89UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsLi4udH0scik9PntQLnVzZU1lbW8oKCgpPT5hLmV4dGVuZCh7UG9zaXRpb25Qb2ludDpaYX0pKSxbXSk7Y29uc3Qgbj1QLnVzZVJlZigpLHtzdWJzY3JpYmU6byxnZXRQYXJlbnQ6aX09UC51c2VDb250ZXh0KEthKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT5vKG4pKSxbXSksUC5jcmVhdGVFbGVtZW50KFwicG9zaXRpb25Qb2ludFwiLEMuZGVmYXVsdCh7aW5zdGFuY2U6aSgpLGluc3RhbmNlS2V5Om4scmVmOmsuZGVmYXVsdChbcixuXSl9LHQpLGUpfSkpLG5vPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHBvc2l0aW9uczp0LGNvbG9yczpyLHNpemVzOm4sc3RyaWRlOm89MywuLi5pfSxzKT0+e2NvbnN0IGw9UC51c2VSZWYobnVsbCk7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57Y29uc3QgZT1sLmN1cnJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlcztlLnBvc2l0aW9uLm5lZWRzVXBkYXRlPSEwLHImJihlLmNvbG9yLm5lZWRzVXBkYXRlPSEwKSxuJiYoZS5zaXplLm5lZWRzVXBkYXRlPSEwKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJwb2ludHNcIixDLmRlZmF1bHQoe3JlZjprLmRlZmF1bHQoW3MsbF0pfSxpKSxQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLG51bGwsUC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIse2F0dGFjaDpcImF0dHJpYnV0ZXMtcG9zaXRpb25cIixjb3VudDp0Lmxlbmd0aC9vLGFycmF5OnQsaXRlbVNpemU6byx1c2FnZTpELkR5bmFtaWNEcmF3VXNhZ2V9KSxyJiZQLmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiYXR0cmlidXRlcy1jb2xvclwiLGNvdW50OnIubGVuZ3RoL28sYXJyYXk6cixpdGVtU2l6ZTozLHVzYWdlOkQuRHluYW1pY0RyYXdVc2FnZX0pLG4mJlAuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJhdHRyaWJ1dGVzLXNpemVcIixjb3VudDpuLmxlbmd0aC9vLGFycmF5Om4saXRlbVNpemU6MSx1c2FnZTpELkR5bmFtaWNEcmF3VXNhZ2V9KSksZSl9KSksYW89UC5mb3J3YXJkUmVmKCgoZSx0KT0+ZS5wb3NpdGlvbnMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXk/UC5jcmVhdGVFbGVtZW50KG5vLEMuZGVmYXVsdCh7fSxlLHtyZWY6dH0pKTpQLmNyZWF0ZUVsZW1lbnQodG8sQy5kZWZhdWx0KHt9LGUse3JlZjp0fSkpKSksb289bmV3IEQuTWF0cml4NCxpbz1uZXcgRC5NYXRyaXg0LHNvPVtdLGxvPW5ldyBELk1lc2g7Y2xhc3MgY28gZXh0ZW5kcyBELkdyb3Vwe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLmNvbG9yPW5ldyBELkNvbG9yKFwid2hpdGVcIiksdGhpcy5pbnN0YW5jZT17Y3VycmVudDp2b2lkIDB9LHRoaXMuaW5zdGFuY2VLZXk9e2N1cnJlbnQ6dm9pZCAwfX1nZXQgZ2VvbWV0cnkoKXt2YXIgZTtyZXR1cm4gbnVsbD09KGU9dGhpcy5pbnN0YW5jZS5jdXJyZW50KT92b2lkIDA6ZS5nZW9tZXRyeX1yYXljYXN0KGUsdCl7Y29uc3Qgcj10aGlzLmluc3RhbmNlLmN1cnJlbnQ7aWYoIXIpcmV0dXJuO2lmKCFyLmdlb21ldHJ5fHwhci5tYXRlcmlhbClyZXR1cm47bG8uZ2VvbWV0cnk9ci5nZW9tZXRyeTtjb25zdCBuPXIubWF0cml4V29ybGQsYT1yLnVzZXJEYXRhLmluc3RhbmNlcy5pbmRleE9mKHRoaXMuaW5zdGFuY2VLZXkpO2lmKCEoLTE9PT1hfHxhPnIuY291bnQpKXtyLmdldE1hdHJpeEF0KGEsb28pLGlvLm11bHRpcGx5TWF0cmljZXMobixvbyksbG8ubWF0cml4V29ybGQ9aW8sci5tYXRlcmlhbCBpbnN0YW5jZW9mIEQuTWF0ZXJpYWw/bG8ubWF0ZXJpYWwuc2lkZT1yLm1hdGVyaWFsLnNpZGU6bG8ubWF0ZXJpYWwuc2lkZT1yLm1hdGVyaWFsWzBdLnNpZGUsbG8ucmF5Y2FzdChlLHNvKTtmb3IobGV0IGU9MCxyPXNvLmxlbmd0aDtlPHI7ZSsrKXtjb25zdCByPXNvW2VdO3IuaW5zdGFuY2VJZD1hLHIub2JqZWN0PXRoaXMsdC5wdXNoKHIpfXNvLmxlbmd0aD0wfX19Y29uc3QgdW89UC5jcmVhdGVDb250ZXh0KG51bGwpLG1vPW5ldyBELk1hdHJpeDQsZm89bmV3IEQuTWF0cml4NCxwbz1uZXcgRC5NYXRyaXg0LGhvPW5ldyBELlZlY3RvcjMseG89bmV3IEQuUXVhdGVybmlvbix5bz1uZXcgRC5WZWN0b3IzLHZvPVAuZm9yd2FyZFJlZigoKHtjb250ZXh0OmUsY2hpbGRyZW46dCwuLi5yfSxuKT0+e1AudXNlTWVtbygoKCk9PmEuZXh0ZW5kKHtQb3NpdGlvbk1lc2g6Y299KSksW10pO2NvbnN0IG89UC51c2VSZWYoKSx7c3Vic2NyaWJlOmksZ2V0UGFyZW50OnN9PVAudXNlQ29udGV4dChlfHx1byk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+aShvKSksW10pLFAuY3JlYXRlRWxlbWVudChcInBvc2l0aW9uTWVzaFwiLEMuZGVmYXVsdCh7aW5zdGFuY2U6cygpLGluc3RhbmNlS2V5Om8scmVmOmsuZGVmYXVsdChbbixvXSl9LHIpLHQpfSkpLGdvPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLHJhbmdlOnQsbGltaXQ6cj0xZTMsZnJhbWVzOm49MS8wLC4uLm99LGkpPT57Y29uc3Rbe2NvbnRleHQ6cyxpbnN0YW5jZTpsfV09UC51c2VTdGF0ZSgoKCk9Pntjb25zdCBlPVAuY3JlYXRlQ29udGV4dChudWxsKTtyZXR1cm57Y29udGV4dDplLGluc3RhbmNlOlAuZm9yd2FyZFJlZigoKHQscik9PlAuY3JlYXRlRWxlbWVudCh2byxDLmRlZmF1bHQoe2NvbnRleHQ6ZX0sdCx7cmVmOnJ9KSkpKX19KSksYz1QLnVzZVJlZihudWxsKSxbdSxkXT1QLnVzZVN0YXRlKFtdKSxbW20sZl1dPVAudXNlU3RhdGUoKCgpPT57Y29uc3QgZT1uZXcgRmxvYXQzMkFycmF5KDE2KnIpO2ZvcihsZXQgdD0wO3Q8cjt0KyspcG8uaWRlbnRpdHkoKS50b0FycmF5KGUsMTYqdCk7cmV0dXJuW2UsbmV3IEZsb2F0MzJBcnJheShbLi4ubmV3IEFycmF5KDMqcildLm1hcCgoKCk9PjEpKSldfSkpO1AudXNlRWZmZWN0KCgoKT0+e2MuY3VycmVudC5pbnN0YW5jZU1hdHJpeC5uZWVkc1VwZGF0ZT0hMH0pKTtsZXQgcD0wLGg9MDthLnVzZUZyYW1lKCgoKT0+e2lmKG49PT0xLzB8fHA8bil7Yy5jdXJyZW50LnVwZGF0ZU1hdHJpeCgpLGMuY3VycmVudC51cGRhdGVNYXRyaXhXb3JsZCgpLG1vLmNvcHkoYy5jdXJyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKSxoPU1hdGgubWluKHIsdm9pZCAwIT09dD90OnIsdS5sZW5ndGgpLGMuY3VycmVudC5jb3VudD1oLHphKGMuY3VycmVudC5pbnN0YW5jZU1hdHJpeCx7b2Zmc2V0OjAsY291bnQ6MTYqaH0pLHphKGMuY3VycmVudC5pbnN0YW5jZUNvbG9yLHtvZmZzZXQ6MCxjb3VudDozKmh9KTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7Y29uc3QgdD11W2VdLmN1cnJlbnQ7dC5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoaG8seG8seW8pLGZvLmNvbXBvc2UoaG8seG8seW8pLnByZW11bHRpcGx5KG1vKSxmby50b0FycmF5KG0sMTYqZSksYy5jdXJyZW50Lmluc3RhbmNlTWF0cml4Lm5lZWRzVXBkYXRlPSEwLHQuY29sb3IudG9BcnJheShmLDMqZSksYy5jdXJyZW50Lmluc3RhbmNlQ29sb3IubmVlZHNVcGRhdGU9ITB9cCsrfX0pKTtjb25zdCB4PVAudXNlTWVtbygoKCk9Pih7Z2V0UGFyZW50OigpPT5jLHN1YnNjcmliZTplPT4oZCgodD0+Wy4uLnQsZV0pKSwoKT0+ZCgodD0+dC5maWx0ZXIoKHQ9PnQuY3VycmVudCE9PWUuY3VycmVudCkpKSkpfSkpLFtdKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiaW5zdGFuY2VkTWVzaFwiLEMuZGVmYXVsdCh7dXNlckRhdGE6e2luc3RhbmNlczp1fSxtYXRyaXhBdXRvVXBkYXRlOiExLHJlZjprLmRlZmF1bHQoW2ksY10pLGFyZ3M6W251bGwsbnVsbCwwXSxyYXljYXN0OigpPT5udWxsfSxvKSxQLmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIix7YXR0YWNoOlwiaW5zdGFuY2VNYXRyaXhcIixjb3VudDptLmxlbmd0aC8xNixhcnJheTptLGl0ZW1TaXplOjE2LHVzYWdlOkQuRHluYW1pY0RyYXdVc2FnZX0pLFAuY3JlYXRlRWxlbWVudChcImluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZVwiLHthdHRhY2g6XCJpbnN0YW5jZUNvbG9yXCIsY291bnQ6Zi5sZW5ndGgvMyxhcnJheTpmLGl0ZW1TaXplOjMsdXNhZ2U6RC5EeW5hbWljRHJhd1VzYWdlfSksXCJmdW5jdGlvblwiPT10eXBlb2YgZT9QLmNyZWF0ZUVsZW1lbnQocy5Qcm92aWRlcix7dmFsdWU6eH0sZShsKSk6UC5jcmVhdGVFbGVtZW50KHVvLlByb3ZpZGVyLHt2YWx1ZTp4fSxlKSl9KSksem89UC5mb3J3YXJkUmVmKChmdW5jdGlvbih7bWVzaGVzOmUsY2hpbGRyZW46dCwuLi5yfSxuKXtjb25zdCBhPUFycmF5LmlzQXJyYXkoZSk7aWYoIWEpZm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMoZSkpZVt0XS5pc01lc2h8fGRlbGV0ZSBlW3RdO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6bn0sUC5jcmVhdGVFbGVtZW50KFYuZGVmYXVsdCx7Y29tcG9uZW50czooYT9lOk9iamVjdC52YWx1ZXMoZSkpLm1hcCgoKHtnZW9tZXRyeTplLG1hdGVyaWFsOnR9KT0+UC5jcmVhdGVFbGVtZW50KGdvLEMuZGVmYXVsdCh7a2V5OmUudXVpZCxnZW9tZXRyeTplLG1hdGVyaWFsOnR9LHIpKSkpfSwocj0+YT90KC4uLnIpOnQoT2JqZWN0LmtleXMoZSkuZmlsdGVyKCh0PT5lW3RdLmlzTWVzaCkpLnJlZHVjZSgoKGUsdCxuKT0+KHsuLi5lLFt0XTpyW25dfSkpLHt9KSkpKSl9KSksd289UC5jcmVhdGVDb250ZXh0KG51bGwpLGJvPVAuZm9yd2FyZFJlZigoKGUsdCk9PntQLnVzZU1lbW8oKCgpPT5hLmV4dGVuZCh7U2VnbWVudE9iamVjdDpNb30pKSxbXSk7Y29uc3R7bGltaXQ6cj0xZTMsbGluZVdpZHRoOm49MSxjaGlsZHJlbjpvLC4uLml9PWUsW3MsbF09UC51c2VTdGF0ZShbXSksW2NdPVAudXNlU3RhdGUoKCgpPT5uZXcgZC5MaW5lMikpLFt1XT1QLnVzZVN0YXRlKCgoKT0+bmV3IGQuTGluZU1hdGVyaWFsKSksW21dPVAudXNlU3RhdGUoKCgpPT5uZXcgZC5MaW5lU2VnbWVudHNHZW9tZXRyeSkpLFtmXT1QLnVzZVN0YXRlKCgoKT0+bmV3IEQuVmVjdG9yMig1MTIsNTEyKSkpLFtwXT1QLnVzZVN0YXRlKCgoKT0+QXJyYXkoNipyKS5maWxsKDApKSksW2hdPVAudXNlU3RhdGUoKCgpPT5BcnJheSg2KnIpLmZpbGwoMCkpKSx4PVAudXNlTWVtbygoKCk9Pih7c3Vic2NyaWJlOmU9PihsKCh0PT5bLi4udCxlXSkpLCgpPT5sKCh0PT50LmZpbHRlcigodD0+dC5jdXJyZW50IT09ZS5jdXJyZW50KSkpKSl9KSksW10pO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e2ZvcihsZXQgdD0wO3Q8cjt0Kyspe3ZhciBlO2NvbnN0IHI9bnVsbD09KGU9c1t0XSk/dm9pZCAwOmUuY3VycmVudDtyJiYocFs2KnQrMF09ci5zdGFydC54LHBbNip0KzFdPXIuc3RhcnQueSxwWzYqdCsyXT1yLnN0YXJ0LnoscFs2KnQrM109ci5lbmQueCxwWzYqdCs0XT1yLmVuZC55LHBbNip0KzVdPXIuZW5kLnosaFs2KnQrMF09ci5jb2xvci5yLGhbNip0KzFdPXIuY29sb3IuZyxoWzYqdCsyXT1yLmNvbG9yLmIsaFs2KnQrM109ci5jb2xvci5yLGhbNip0KzRdPXIuY29sb3IuZyxoWzYqdCs1XT1yLmNvbG9yLmIpfW0uc2V0Q29sb3JzKGgpLG0uc2V0UG9zaXRpb25zKHApLGMuY29tcHV0ZUxpbmVEaXN0YW5jZXMoKX0pKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIix7b2JqZWN0OmMscmVmOnR9LFAuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLHtvYmplY3Q6bSxhdHRhY2g6XCJnZW9tZXRyeVwifSksUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtvYmplY3Q6dSxhdHRhY2g6XCJtYXRlcmlhbFwiLHZlcnRleENvbG9yczohMCxyZXNvbHV0aW9uOmYsbGluZXdpZHRoOm59LGkpKSxQLmNyZWF0ZUVsZW1lbnQod28uUHJvdmlkZXIse3ZhbHVlOnh9LG8pKX0pKTtjbGFzcyBNb3tjb25zdHJ1Y3Rvcigpe3RoaXMuY29sb3I9bmV3IEQuQ29sb3IoXCJ3aGl0ZVwiKSx0aGlzLnN0YXJ0PW5ldyBELlZlY3RvcjMoMCwwLDApLHRoaXMuZW5kPW5ldyBELlZlY3RvcjMoMCwwLDApfX1jb25zdCBFbz1lPT5lIGluc3RhbmNlb2YgRC5WZWN0b3IzP2U6bmV3IEQuVmVjdG9yMyguLi5cIm51bWJlclwiPT10eXBlb2YgZT9bZSxlLGVdOmUpLFNvPVAuZm9yd2FyZFJlZigoKHtjb2xvcjplLHN0YXJ0OnQsZW5kOnJ9LG4pPT57Y29uc3QgYT1QLnVzZUNvbnRleHQod28pO2lmKCFhKXRocm93XCJTZWdtZW50IG11c3QgdXNlZCBpbnNpZGUgU2VnbWVudHMgY29tcG9uZW50LlwiO2NvbnN0IG89UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+YS5zdWJzY3JpYmUobykpLFtdKSxQLmNyZWF0ZUVsZW1lbnQoXCJzZWdtZW50T2JqZWN0XCIse3JlZjprLmRlZmF1bHQoW28sbl0pLGNvbG9yOmUsc3RhcnQ6RW8odCksZW5kOkVvKHIpfSl9KSksVG89UC5mb3J3YXJkUmVmKCgoe2NoaWxkcmVuOmUsaHlzdGVyZXNpczp0PTAsZGlzdGFuY2VzOnIsLi4ubn0sbyk9Pntjb25zdCBpPVAudXNlUmVmKG51bGwpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdHtjdXJyZW50OmV9PWk7ZS5sZXZlbHMubGVuZ3RoPTAsZS5jaGlsZHJlbi5mb3JFYWNoKCgobixhKT0+ZS5sZXZlbHMucHVzaCh7b2JqZWN0Om4saHlzdGVyZXNpczp0LGRpc3RhbmNlOnJbYV19KSkpfSkpLGEudXNlRnJhbWUoKGU9Pnt2YXIgdDtyZXR1cm4gbnVsbD09KHQ9aS5jdXJyZW50KT92b2lkIDA6dC51cGRhdGUoZS5jYW1lcmEpfSkpLFAuY3JlYXRlRWxlbWVudChcImxPRFwiLEMuZGVmYXVsdCh7cmVmOmsuZGVmYXVsdChbaSxvXSl9LG4pLGUpfSkpO2NvbnN0IENvPW5ldyBuLk1hdHJpeDQsUG89bmV3IG4uUmF5LFJvPW5ldyBuLlNwaGVyZSxEbz1uZXcgbi5WZWN0b3IzO2NvbnN0IEZvPXQuY3JlYXRlQ29udGV4dChudWxsKTtjb25zdCBrbz1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxjb21wdXRlOnQsd2lkdGg6cixoZWlnaHQ6bixzYW1wbGVzOm89OCxyZW5kZXJQcmlvcml0eTppPTAsZXZlbnRQcmlvcml0eTpzPTAsZnJhbWVzOmw9MS8wLHN0ZW5jaWxCdWZmZXI6Yz0hMSxkZXB0aEJ1ZmZlcjp1PSEwLGdlbmVyYXRlTWlwbWFwczpkPSExLC4uLm19LGYpPT57Y29uc3R7c2l6ZTpwLHZpZXdwb3J0Omh9PWEudXNlVGhyZWUoKSx4PW50KChyfHxwLndpZHRoKSpoLmRwciwobnx8cC5oZWlnaHQpKmguZHByLHtzYW1wbGVzOm8sc3RlbmNpbEJ1ZmZlcjpjLGRlcHRoQnVmZmVyOnUsZ2VuZXJhdGVNaXBtYXBzOmR9KSxbeV09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELlNjZW5lKSksdj1QLnVzZUNhbGxiYWNrKCgoZSx0LHIpPT57dmFyIG4sYTtsZXQgbz1udWxsPT0obj14LnRleHR1cmUpP3ZvaWQgMDpuLl9fcjNmLnBhcmVudDtmb3IoO28mJiEobyBpbnN0YW5jZW9mIEQuT2JqZWN0M0QpOylvPW8uX19yM2YucGFyZW50O2lmKCFvKXJldHVybiExO3IucmF5Y2FzdGVyLmNhbWVyYXx8ci5ldmVudHMuY29tcHV0ZShlLHIsbnVsbD09KGE9ci5wcmV2aW91c1Jvb3QpP3ZvaWQgMDphLmdldFN0YXRlKCkpO2NvbnN0W2ldPXIucmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdChvKTtpZighaSlyZXR1cm4hMTtjb25zdCBzPWkudXY7aWYoIXMpcmV0dXJuITE7dC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIuc2V0KDIqcy54LTEsMipzLnktMSksdC5jYW1lcmEpfSksW10pO3JldHVybiBQLnVzZUltcGVyYXRpdmVIYW5kbGUoZiwoKCk9PngudGV4dHVyZSksW3hdKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGEuY3JlYXRlUG9ydGFsKFAuY3JlYXRlRWxlbWVudChfbyx7cmVuZGVyUHJpb3JpdHk6aSxmcmFtZXM6bCxmYm86eH0sZSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtvblBvaW50ZXJPdmVyOigpPT5udWxsfSkpLHkse2V2ZW50czp7Y29tcHV0ZTp0fHx2LHByaW9yaXR5OnN9fSksUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtvYmplY3Q6eC50ZXh0dXJlfSxtKSkpfSkpO2Z1bmN0aW9uIF9vKHtmcmFtZXM6ZSxyZW5kZXJQcmlvcml0eTp0LGNoaWxkcmVuOnIsZmJvOm59KXtsZXQgbyxpPTA7cmV0dXJuIGEudXNlRnJhbWUoKHQ9PnsoZT09PTEvMHx8aTxlKSYmKG89dC5nbC5hdXRvQ2xlYXIsdC5nbC5hdXRvQ2xlYXI9ITAsdC5nbC5zZXRSZW5kZXJUYXJnZXQobiksdC5nbC5yZW5kZXIodC5zY2VuZSx0LmNhbWVyYSksdC5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksdC5nbC5hdXRvQ2xlYXI9byxpKyspfSksdCksUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxyKX1jb25zdCBBbz1QLmZvcndhcmRSZWYoKCh7Y2hpbGRyZW46ZSxjb21wdXRlOnQscmVuZGVyUHJpb3JpdHk6cj0tMSxldmVudFByaW9yaXR5Om49MCxmcmFtZXM6bz0xLzAsc3RlbmNpbEJ1ZmZlcjppPSExLGRlcHRoQnVmZmVyOnM9ITAsZ2VuZXJhdGVNaXBtYXBzOmw9ITEscmVzb2x1dGlvbjpjPTg5NixuZWFyOnU9LjEsZmFyOmQ9MWUzLGZsaXA6bT0hMSxwb3NpdGlvbjpmLHJvdGF0aW9uOnAsc2NhbGU6aCxxdWF0ZXJuaW9uOngsbWF0cml4OnksbWF0cml4QXV0b1VwZGF0ZTp2LC4uLmd9LHopPT57Y29uc3R7c2l6ZTp3LHZpZXdwb3J0OmJ9PWEudXNlVGhyZWUoKSxNPVAudXNlUmVmKG51bGwpLEU9UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IEQuV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KE1hdGgubWF4KChjfHx3LndpZHRoKSpiLmRwciwoY3x8dy5oZWlnaHQpKmIuZHByKSx7c3RlbmNpbEJ1ZmZlcjppLGRlcHRoQnVmZmVyOnMsZ2VuZXJhdGVNaXBtYXBzOmx9KTtyZXR1cm4gZS50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZT0hbSxlLnRleHR1cmUuZmxpcFk9ITAsZS50ZXh0dXJlLnR5cGU9RC5IYWxmRmxvYXRUeXBlLGV9KSxbYyxtXSk7UC51c2VFZmZlY3QoKCgpPT4oKT0+RS5kaXNwb3NlKCkpLFtFXSk7Y29uc3RbU109UC51c2VTdGF0ZSgoKCk9Pm5ldyBELlNjZW5lKSk7cmV0dXJuIFAudXNlSW1wZXJhdGl2ZUhhbmRsZSh6LCgoKT0+KHtzY2VuZTpTLGZibzpFLGNhbWVyYTpNLmN1cnJlbnR9KSksW0VdKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLGEuY3JlYXRlUG9ydGFsKFAuY3JlYXRlRWxlbWVudChMbyx7cmVuZGVyUHJpb3JpdHk6cixmcmFtZXM6byxjYW1lcmE6TX0sZSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtvblBvaW50ZXJPdmVyOigpPT5udWxsfSkpLFMse2V2ZW50czp7Y29tcHV0ZTp0LHByaW9yaXR5Om59fSksUC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsQy5kZWZhdWx0KHtvYmplY3Q6RS50ZXh0dXJlfSxnKSksUC5jcmVhdGVFbGVtZW50KFwiY3ViZUNhbWVyYVwiLHtyZWY6TSxhcmdzOlt1LGQsRV0scG9zaXRpb246Zixyb3RhdGlvbjpwLHNjYWxlOmgscXVhdGVybmlvbjp4LG1hdHJpeDp5LG1hdHJpeEF1dG9VcGRhdGU6dn0pKX0pKTtmdW5jdGlvbiBMbyh7ZnJhbWVzOmUscmVuZGVyUHJpb3JpdHk6dCxjaGlsZHJlbjpyLGNhbWVyYTpufSl7bGV0IG89MDtyZXR1cm4gYS51c2VGcmFtZSgodD0+eyhlPT09MS8wfHxvPGUpJiYobi5jdXJyZW50LnVwZGF0ZSh0LmdsLHQuc2NlbmUpLG8rKyl9KSx0KSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLHIpfWNvbnN0IEJvPVAuZm9yd2FyZFJlZigoKHtpZDplPTEsY29sb3JXcml0ZTp0PSExLGRlcHRoV3JpdGU6cj0hMSwuLi5ufSxhKT0+e2NvbnN0IG89UC51c2VSZWYobnVsbCksaT1QLnVzZU1lbW8oKCgpPT4oe2NvbG9yV3JpdGU6dCxkZXB0aFdyaXRlOnIsc3RlbmNpbFdyaXRlOiEwLHN0ZW5jaWxSZWY6ZSxzdGVuY2lsRnVuYzpELkFsd2F5c1N0ZW5jaWxGdW5jLHN0ZW5jaWxGYWlsOkQuUmVwbGFjZVN0ZW5jaWxPcCxzdGVuY2lsWkZhaWw6RC5SZXBsYWNlU3RlbmNpbE9wLHN0ZW5jaWxaUGFzczpELlJlcGxhY2VTdGVuY2lsT3B9KSksW2UsdCxyXSk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e09iamVjdC5hc3NpZ24oby5jdXJyZW50Lm1hdGVyaWFsLGkpfSkpLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShhLCgoKT0+by5jdXJyZW50KSxbXSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLEMuZGVmYXVsdCh7cmVmOm8scmVuZGVyT3JkZXI6LWV9LG4pKX0pKTtmdW5jdGlvbiBVbyh7YXBpOmV9KXtjb25zdCB0PW5ldyBELlZlY3RvcjMscj1uZXcgRC5RdWF0ZXJuaW9uLG49bmV3IEQuVmVjdG9yMyxvPW5ldyBELkV1bGVyKDAsTWF0aC5QSSwwKTtyZXR1cm4gYS51c2VGcmFtZSgoYT0+e2EuY2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSh0LHIsbiksZS5jdXJyZW50LmNhbWVyYS5wb3NpdGlvbi5jb3B5KHQpLGUuY3VycmVudC5jYW1lcmEucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIobykucHJlbXVsdGlwbHkocil9KSksbnVsbH1jb25zdCBJbz1FZSh7Ymx1cjowLG1hcDpudWxsLHNkZjpudWxsLGJsZW5kOjAsc2l6ZTowLHJlc29sdXRpb246bmV3IEQuVmVjdG9yMn0sXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgIHZvaWQgbWFpbigpIHtcXG4gICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuICAgICB2VXYgPSB1djtcXG4gICB9XCIsYHVuaWZvcm0gc2FtcGxlcjJEIHNkZjtcXG4gICB1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuICAgdW5pZm9ybSBmbG9hdCBibHVyO1xcbiAgIHVuaWZvcm0gZmxvYXQgc2l6ZTtcXG4gICB1bmlmb3JtIGZsb2F0IHRpbWU7XFxuICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XFxuICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICB2b2lkIG1haW4oKSB7XFxuICAgICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbi54eTtcXG4gICAgIHZlYzQgdCA9IHRleHR1cmUyRChtYXAsIHV2KTtcXG4gICAgIGZsb2F0IGsgPSBibHVyO1xcbiAgICAgZmxvYXQgZCA9IHRleHR1cmUyRChzZGYsIHZVdikuci9zaXplO1xcbiAgICAgZmxvYXQgYWxwaGEgPSAxLjAgLSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjbGFtcChkL2sgKyAxLjAsIDAuMCwgMS4wKSk7XFxuICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHQucmdiLCBibHVyID09IDAuMCA/IHQuYSA6IHQuYSAqIGFscGhhKTtcXG4gICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgICNpbmNsdWRlIDwke0NlPj0xNTQ/XCJjb2xvcnNwYWNlX2ZyYWdtZW50XCI6XCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XFxuICAgfWApLFZvPVAuZm9yd2FyZFJlZigoKHtjaGlsZHJlbjplLGV2ZW50czp0LGJsdXI6cj0wLGV2ZW50UHJpb3JpdHk6bj0wLHJlbmRlclByaW9yaXR5Om89MCx3b3JsZFVuaXRzOmk9ITEscmVzb2x1dGlvbjpzPTUxMiwuLi5sfSxjKT0+e2EuZXh0ZW5kKHtQb3J0YWxNYXRlcmlhbEltcGw6SW99KTtjb25zdCB1PVAudXNlUmVmKG51bGwpLHtzY2VuZTpkLGdsOm0sc2l6ZTpmLHZpZXdwb3J0OnAsc2V0RXZlbnRzOmh9PWEudXNlVGhyZWUoKSx4PW50KHMscyksW3ksdl09UC51c2VTdGF0ZSgwKTthLnVzZUZyYW1lKCgoKT0+e2NvbnN0IGU9dS5jdXJyZW50LmJsZW5kPjA/TWF0aC5tYXgoMSxvKTowO3khPT1lJiZ2KGUpfSkpLFAudXNlRWZmZWN0KCgoKT0+e3ZvaWQgMCE9PXQmJmgoe2VuYWJsZWQ6IXR9KX0pLFt0XSk7Y29uc3RbZyx6XT1QLnVzZVN0YXRlKCEwKSx3PXdyKHopO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3ZhciBlO3cuY3VycmVudD1udWxsPT0oZT11LmN1cnJlbnQpP3ZvaWQgMDplLl9fcjNmLnBhcmVudH0pLFtdKSxQLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZih3LmN1cnJlbnQmJnImJm51bGw9PT11LmN1cnJlbnQuc2RmKXtjb25zdCBlPW5ldyBELk1lc2gody5jdXJyZW50Lmdlb21ldHJ5LG5ldyBELk1lc2hCYXNpY01hdGVyaWFsKSx0PShuZXcgRC5Cb3gzKS5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGUuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbikscj1uZXcgRC5PcnRob2dyYXBoaWNDYW1lcmEodC5taW4ueCooMSsyL3MpLHQubWF4LngqKDErMi9zKSx0Lm1heC55KigxKzIvcyksdC5taW4ueSooMSsyL3MpLC4xLDFlMyk7ci5wb3NpdGlvbi5zZXQoMCwwLDEpLHIubG9va0F0KDAsMCwwKSxtLnNldFJlbmRlclRhcmdldCh4KSxtLnJlbmRlcihlLHIpO2NvbnN0IG49Tm8ocyxzLG0pKHgudGV4dHVyZSksYT1uZXcgRmxvYXQzMkFycmF5KHMqcyk7bS5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKG4sMCwwLHMscyxhKTtsZXQgbz0xLzA7Zm9yKGxldCBlPTA7ZTxhLmxlbmd0aDtlKyspYVtlXTxvJiYobz1hW2VdKTtvPS1vLHUuY3VycmVudC5zaXplPW8sdS5jdXJyZW50LnNkZj1uLnRleHR1cmUsbS5zZXRSZW5kZXJUYXJnZXQobnVsbCl9fSksW3Mscl0pLFAudXNlSW1wZXJhdGl2ZUhhbmRsZShjLCgoKT0+dS5jdXJyZW50KSk7Y29uc3QgYj1QLnVzZUNhbGxiYWNrKCgoZSx0LHIpPT57dmFyIG47aWYoIXcuY3VycmVudClyZXR1cm4hMTtpZih0LnBvaW50ZXIuc2V0KGUub2Zmc2V0WC90LnNpemUud2lkdGgqMi0xLC1lLm9mZnNldFkvdC5zaXplLmhlaWdodCoyKzEpLHQucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodC5wb2ludGVyLHQuY2FtZXJhKSwwPT09KG51bGw9PShuPXUuY3VycmVudCk/dm9pZCAwOm4uYmxlbmQpKXtjb25zdFtlXT10LnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qody5jdXJyZW50KTtpZighZSlyZXR1cm4gdC5yYXljYXN0ZXIuY2FtZXJhPXZvaWQgMCwhMX19KSxbXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcInBvcnRhbE1hdGVyaWFsSW1wbFwiLEMuZGVmYXVsdCh7cmVmOnUsYmx1cjpyLGJsZW5kOjAscmVzb2x1dGlvbjpbZi53aWR0aCpwLmRwcixmLmhlaWdodCpwLmRwcl0sYXR0YWNoOlwibWF0ZXJpYWxcIn0sbCksUC5jcmVhdGVFbGVtZW50KGtvLHthdHRhY2g6XCJtYXBcIixmcmFtZXM6Zz8xLzA6MCxldmVudFByaW9yaXR5Om4scmVuZGVyUHJpb3JpdHk6byxjb21wdXRlOmJ9LGUsUC5jcmVhdGVFbGVtZW50KE9vLHtldmVudHM6dCxyb290U2NlbmU6ZCxwcmlvcml0eTp5LG1hdGVyaWFsOnUsd29ybGRVbml0czppfSkpKX0pKTtmdW5jdGlvbiBPbyh7ZXZlbnRzOmUscm9vdFNjZW5lOnQsbWF0ZXJpYWw6cixwcmlvcml0eTpuLHdvcmxkVW5pdHM6b30pe2NvbnN0IGk9YS51c2VUaHJlZSgoZT0+ZS5zY2VuZSkpLHM9YS51c2VUaHJlZSgoZT0+ZS5zZXRFdmVudHMpKSxsPW50KCksYz1udCgpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2kubWF0cml4QXV0b1VwZGF0ZT0hMX0pLFtdKSxQLnVzZUVmZmVjdCgoKCk9Pnt2b2lkIDAhPT1lJiZzKHtlbmFibGVkOmV9KX0pLFtlXSk7Y29uc3RbdSxtXT1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT17dmFsdWU6MH07cmV0dXJuW25ldyBkLkZ1bGxTY3JlZW5RdWFkKG5ldyBELlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp7YTp7dmFsdWU6bC50ZXh0dXJlfSxiOnt2YWx1ZTpjLnRleHR1cmV9LGJsZW5kOmV9LHZlcnRleFNoYWRlcjpcIlxcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgdlV2ID0gdXY7XFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6YFxcbiAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBhO1xcbiAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBiO1xcbiAgICAgICAgICB1bmlmb3JtIGZsb2F0IGJsZW5kO1xcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgIHZlYzQgdGEgPSB0ZXh0dXJlMkQoYSwgdlV2KTtcXG4gICAgICAgICAgICB2ZWM0IHRiID0gdGV4dHVyZTJEKGIsIHZVdik7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KHRiLCB0YSwgYmxlbmQpO1xcbiAgICAgICAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG4gICAgICAgICAgICAjaW5jbHVkZSA8JHtDZT49MTU0P1wiY29sb3JzcGFjZV9mcmFnbWVudFwiOlwiZW5jb2RpbmdzX2ZyYWdtZW50XCJ9PlxcbiAgICAgICAgICB9YH0pKSxlXX0pLFtdKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+e3ZhciBhO2xldCBzPW51bGw9PXJ8fG51bGw9PShhPXIuY3VycmVudCk/dm9pZCAwOmEuX19yM2YucGFyZW50O2lmKHMpe3ZhciBkLGYscCxoO2lmKG8paS5tYXRyaXhXb3JsZC5pZGVudGl0eSgpO2Vsc2UgbiYmMT09PShudWxsPT0oZD1yLmN1cnJlbnQpP3ZvaWQgMDpkLmJsZW5kKSYmcy51cGRhdGVXb3JsZE1hdHJpeCghMCwhMSksaS5tYXRyaXhXb3JsZC5jb3B5KHMubWF0cml4V29ybGQpO2lmKG4pKG51bGw9PShmPXIuY3VycmVudCk/dm9pZCAwOmYuYmxlbmQpPjAmJihudWxsPT0ocD1yLmN1cnJlbnQpP3ZvaWQgMDpwLmJsZW5kKTwxPyhtLnZhbHVlPXIuY3VycmVudC5ibGVuZCxlLmdsLnNldFJlbmRlclRhcmdldChsKSxlLmdsLnJlbmRlcihpLGUuY2FtZXJhKSxlLmdsLnNldFJlbmRlclRhcmdldChjKSxlLmdsLnJlbmRlcih0LGUuY2FtZXJhKSxlLmdsLnNldFJlbmRlclRhcmdldChudWxsKSx1LnJlbmRlcihlLmdsKSk6MT09PShudWxsPT0oaD1yLmN1cnJlbnQpP3ZvaWQgMDpoLmJsZW5kKSYmZS5nbC5yZW5kZXIoaSxlLmNhbWVyYSl9fSksbiksUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCl9Y29uc3QgTm89KGUsdCxyKT0+e2xldCBuPW5ldyBELldlYkdMUmVuZGVyVGFyZ2V0KGUsdCx7bWluRmlsdGVyOkQuTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLG1hZ0ZpbHRlcjpELkxpbmVhckZpbHRlcix0eXBlOkQuRmxvYXRUeXBlLGZvcm1hdDpELlJlZEZvcm1hdCxnZW5lcmF0ZU1pcG1hcHM6ITB9KSxhPW5ldyBELldlYkdMUmVuZGVyVGFyZ2V0KGUsdCx7bWluRmlsdGVyOkQuTmVhcmVzdEZpbHRlcixtYWdGaWx0ZXI6RC5OZWFyZXN0RmlsdGVyfSksbz1uZXcgRC5XZWJHTFJlbmRlclRhcmdldChlLHQse21pbkZpbHRlcjpELk5lYXJlc3RGaWx0ZXIsbWFnRmlsdGVyOkQuTmVhcmVzdEZpbHRlcn0pLGk9bmV3IEQuV2ViR0xSZW5kZXJUYXJnZXQoZSx0LHttaW5GaWx0ZXI6RC5OZWFyZXN0RmlsdGVyLG1hZ0ZpbHRlcjpELk5lYXJlc3RGaWx0ZXJ9KSxzPW5ldyBELldlYkdMUmVuZGVyVGFyZ2V0KGUsdCx7bWluRmlsdGVyOkQuTmVhcmVzdEZpbHRlcixtYWdGaWx0ZXI6RC5OZWFyZXN0RmlsdGVyfSksbD1uZXcgRC5XZWJHTFJlbmRlclRhcmdldChlLHQse21pbkZpbHRlcjpELk5lYXJlc3RGaWx0ZXIsbWFnRmlsdGVyOkQuTmVhcmVzdEZpbHRlcix0eXBlOkQuRmxvYXRUeXBlLGZvcm1hdDpELlJlZEZvcm1hdH0pLGM9bmV3IEQuV2ViR0xSZW5kZXJUYXJnZXQoZSx0LHttaW5GaWx0ZXI6RC5OZWFyZXN0RmlsdGVyLG1hZ0ZpbHRlcjpELk5lYXJlc3RGaWx0ZXIsdHlwZTpELkZsb2F0VHlwZSxmb3JtYXQ6RC5SZWRGb3JtYXR9KTtjb25zdCB1PW5ldyBkLkZ1bGxTY3JlZW5RdWFkKG5ldyBELlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp7dGV4Ont2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgfVwiLGZyYWdtZW50U2hhZGVyOlwiXFxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7XFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgI2luY2x1ZGUgPHBhY2tpbmc+XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHBhY2sySGFsZlRvUkdCQSh2VXYgKiAocm91bmQodGV4dHVyZTJEKHRleCwgdlV2KS54KSkpO1xcbiAgICAgICAgfVwifSkpLG09bmV3IGQuRnVsbFNjcmVlblF1YWQobmV3IEQuU2hhZGVyTWF0ZXJpYWwoe3VuaWZvcm1zOnt0ZXg6e3ZhbHVlOm51bGx9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6XCJcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKHZVdiAqICgxLjAgLSByb3VuZCh0ZXh0dXJlMkQodGV4LCB2VXYpLngpKSk7XFxuICAgICAgICB9XCJ9KSksZj1uZXcgZC5GdWxsU2NyZWVuUXVhZChuZXcgRC5TaGFkZXJNYXRlcmlhbCh7dW5pZm9ybXM6e3RleDp7dmFsdWU6bnVsbH0sb2Zmc2V0Ont2YWx1ZTowfSxsZXZlbDp7dmFsdWU6MH0sbWF4U3RlcHM6e3ZhbHVlOjB9fSx2ZXJ0ZXhTaGFkZXI6XCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZVdiA9IHV2O1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuICAgICAgICB9XCIsZnJhZ21lbnRTaGFkZXI6YFxcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgb2Zmc2V0O1xcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBsZXZlbDtcXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgbWF4U3RlcHM7XFxuICAgICAgICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZmxvYXQgY2xvc2VzdERpc3QgPSA5OTk5OTk5Ljk7XFxuICAgICAgICAgIHZlYzIgY2xvc2VzdFBvcyA9IHZlYzIoMC4wKTtcXG4gICAgICAgICAgZm9yIChmbG9hdCB4ID0gLTEuMDsgeCA8PSAxLjA7IHggKz0gMS4wKSB7XFxuICAgICAgICAgICAgZm9yIChmbG9hdCB5ID0gLTEuMDsgeSA8PSAxLjA7IHkgKz0gMS4wKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHZvZmZzZXQgPSB2VXY7XFxuICAgICAgICAgICAgICB2b2Zmc2V0ICs9IHZlYzIoeCwgeSkgKiB2ZWMyKCR7MS9lfSwgJHsxL3R9KSAqIG9mZnNldDtcXG4gICAgICAgICAgICAgIHZlYzIgcG9zID0gdW5wYWNrUkdCQVRvMkhhbGYodGV4dHVyZTJEKHRleCwgdm9mZnNldCkpO1xcbiAgICAgICAgICAgICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHBvcy54eSwgdlV2KTtcXG4gICAgICAgICAgICAgIGlmKHBvcy54ICE9IDAuMCAmJiBwb3MueSAhPSAwLjAgJiYgZGlzdCA8IGNsb3Nlc3REaXN0KSB7XFxuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gZGlzdDtcXG4gICAgICAgICAgICAgICAgY2xvc2VzdFBvcyA9IHBvcztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gcGFjazJIYWxmVG9SR0JBKGNsb3Nlc3RQb3MpO1xcbiAgICAgICAgfWB9KSkscD1uZXcgZC5GdWxsU2NyZWVuUXVhZChuZXcgRC5TaGFkZXJNYXRlcmlhbCh7dW5pZm9ybXM6e3RleDp7dmFsdWU6bnVsbH0sc2l6ZTp7dmFsdWU6bmV3IEQuVmVjdG9yMihlLHQpfX0sdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgfVwiLGZyYWdtZW50U2hhZGVyOlwiXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHNpemU7XFxuICAgICAgICAjaW5jbHVkZSA8cGFja2luZz5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChkaXN0YW5jZShzaXplICogdW5wYWNrUkdCQVRvMkhhbGYodGV4dHVyZTJEKHRleCwgdlV2KSksIHNpemUgKiB2VXYpLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICAgIH1cIn0pKSxoPW5ldyBkLkZ1bGxTY3JlZW5RdWFkKG5ldyBELlNoYWRlck1hdGVyaWFsKHt1bmlmb3Jtczp7aW5zaWRlOnt2YWx1ZTpjLnRleHR1cmV9LG91dHNpZGU6e3ZhbHVlOmwudGV4dHVyZX0sdGV4Ont2YWx1ZTpudWxsfX0sdmVydGV4U2hhZGVyOlwiXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICB2VXYgPSB1djtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiAgICAgICAgfVwiLGZyYWdtZW50U2hhZGVyOlwiXFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgaW5zaWRlO1xcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgb3V0c2lkZTtcXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDtcXG4gICAgICAgICNpbmNsdWRlIDxwYWNraW5nPlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBmbG9hdCBpID0gdGV4dHVyZTJEKGluc2lkZSwgdlV2KS54O1xcbiAgICAgICAgICBmbG9hdCBvID10ZXh0dXJlMkQob3V0c2lkZSwgdlV2KS54O1xcbiAgICAgICAgICBpZiAodGV4dHVyZTJEKHRleCwgdlV2KS54ID09IDAuMCkge1xcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobywgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgtaSwgMC4wLCAwLjAsIDAuMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cIn0pKTtyZXR1cm4gZD0+e2xldCB4PW47ZC5taW5GaWx0ZXI9RC5OZWFyZXN0RmlsdGVyLGQubWFnRmlsdGVyPUQuTmVhcmVzdEZpbHRlcix1Lm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT1kLHIuc2V0UmVuZGVyVGFyZ2V0KGEpLHUucmVuZGVyKHIpO2NvbnN0IHk9TWF0aC5jZWlsKE1hdGgubG9nKE1hdGgubWF4KGUsdCkpL01hdGgubG9nKDIpKTtsZXQgdj1hLGc9bnVsbDtmb3IobGV0IGU9MDtlPHk7ZSsrKXtjb25zdCB0PU1hdGgucG93KDIseS1lLTEpO2c9dj09PWE/aTphLGYubWF0ZXJpYWwudW5pZm9ybXMubGV2ZWwudmFsdWU9ZSxmLm1hdGVyaWFsLnVuaWZvcm1zLm1heFN0ZXBzLnZhbHVlPXksZi5tYXRlcmlhbC51bmlmb3Jtcy5vZmZzZXQudmFsdWU9dCxmLm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT12LnRleHR1cmUsci5zZXRSZW5kZXJUYXJnZXQoZyksZi5yZW5kZXIociksdj1nfXIuc2V0UmVuZGVyVGFyZ2V0KGwpLHAubWF0ZXJpYWwudW5pZm9ybXMudGV4LnZhbHVlPWcudGV4dHVyZSxwLnJlbmRlcihyKSxtLm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT1kLHIuc2V0UmVuZGVyVGFyZ2V0KG8pLG0ucmVuZGVyKHIpLHY9bztmb3IobGV0IGU9MDtlPHk7ZSsrKXtjb25zdCB0PU1hdGgucG93KDIseS1lLTEpO2c9dj09PW8/czpvLGYubWF0ZXJpYWwudW5pZm9ybXMubGV2ZWwudmFsdWU9ZSxmLm1hdGVyaWFsLnVuaWZvcm1zLm1heFN0ZXBzLnZhbHVlPXksZi5tYXRlcmlhbC51bmlmb3Jtcy5vZmZzZXQudmFsdWU9dCxmLm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT12LnRleHR1cmUsci5zZXRSZW5kZXJUYXJnZXQoZyksZi5yZW5kZXIociksdj1nfXJldHVybiByLnNldFJlbmRlclRhcmdldChjKSxwLm1hdGVyaWFsLnVuaWZvcm1zLnRleC52YWx1ZT1nLnRleHR1cmUscC5yZW5kZXIociksci5zZXRSZW5kZXJUYXJnZXQoeCksaC5tYXRlcmlhbC51bmlmb3Jtcy50ZXgudmFsdWU9ZCxoLnJlbmRlcihyKSxyLnNldFJlbmRlclRhcmdldChudWxsKSx4fX0sam89bmV3IEQuQ29sb3I7ZnVuY3Rpb24gV28oZSl7cmV0dXJuXCJ0b3BcImluIGV9ZnVuY3Rpb24gR28oe2NhbnZhc1NpemU6ZSxzY2VuZTp0LGluZGV4OnIsY2hpbGRyZW46bixmcmFtZXM6byxyZWN0OmksdHJhY2s6c30pe2NvbnN0IGw9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSxjPWEudXNlVGhyZWUoKGU9PmUuY2FtZXJhKSksdT1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSksZD1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpO2xldCBtPTA7cmV0dXJuIGEudXNlRnJhbWUoKHI9Pnt2YXIgYSxsOyhvPT09MS8wfHxtPD1vKSYmKGkuY3VycmVudD1udWxsPT0oYT1zLmN1cnJlbnQpP3ZvaWQgMDphLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG0rKyk7aWYoaS5jdXJyZW50KXtjb25zdHtwb3NpdGlvbjp7bGVmdDphLGJvdHRvbTpvLHdpZHRoOnMsaGVpZ2h0OmR9LGlzT2Zmc2NyZWVuOm19PWZ1bmN0aW9uKGUsdCl7Y29uc3R7cmlnaHQ6cix0b3A6bixsZWZ0OmEsYm90dG9tOm8sd2lkdGg6aSxoZWlnaHQ6c309dCxsPXQuYm90dG9tPDB8fG4+ZS5oZWlnaHR8fHI8MHx8dC5sZWZ0PmUud2lkdGg7aWYoV28oZSkpe2NvbnN0IHQ9ZS50b3ArZS5oZWlnaHQtbztyZXR1cm57cG9zaXRpb246e3dpZHRoOmksaGVpZ2h0OnMsbGVmdDphLWUubGVmdCx0b3A6bixib3R0b206dCxyaWdodDpyfSxpc09mZnNjcmVlbjpsfX1yZXR1cm57cG9zaXRpb246e3dpZHRoOmksaGVpZ2h0OnMsdG9wOm4sbGVmdDphLGJvdHRvbTplLmhlaWdodC1vLHJpZ2h0OnJ9LGlzT2Zmc2NyZWVuOmx9fShlLGkuY3VycmVudCksZj1zL2Q7KGw9YykmJmwuaXNPcnRob2dyYXBoaWNDYW1lcmE/Yy5sZWZ0PT09cy8tMiYmYy5yaWdodD09PXMvMiYmYy50b3A9PT1kLzImJmMuYm90dG9tPT09ZC8tMnx8KE9iamVjdC5hc3NpZ24oYyx7bGVmdDpzLy0yLHJpZ2h0OnMvMix0b3A6ZC8yLGJvdHRvbTpkLy0yfSksYy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkpOmMuYXNwZWN0IT09ZiYmKGMuYXNwZWN0PWYsYy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkpLHIuZ2wuc2V0Vmlld3BvcnQoYSxvLHMsZCksci5nbC5zZXRTY2lzc29yKGEsbyxzLGQpLHIuZ2wuc2V0U2Npc3NvclRlc3QoITApLG0/KHIuZ2wuZ2V0Q2xlYXJDb2xvcihqbyksci5nbC5zZXRDbGVhckNvbG9yKGpvLHIuZ2wuZ2V0Q2xlYXJBbHBoYSgpKSxyLmdsLmNsZWFyKCEwLCEwKSk6ci5nbC5yZW5kZXIobj91OnQsYyksci5nbC5zZXRTY2lzc29yVGVzdCghMCl9fSksciksUC51c2VFZmZlY3QoKCgpPT57Y29uc3QgZT1sKCkuZXZlbnRzLmNvbm5lY3RlZDtyZXR1cm4gZCh7Y29ubmVjdGVkOnMuY3VycmVudH0pLCgpPT5kKHtjb25uZWN0ZWQ6ZX0pfSksW10pLFAudXNlRWZmZWN0KCgoKT0+e1dvKGUpfHxjb25zb2xlLndhcm4oXCJEZXRlY3RlZCBAcmVhY3QtdGhyZWUvZmliZXIgY2FudmFzIHNpemUgZG9lcyBub3QgaW5jbHVkZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi4gPFZpZXcgLz4gbWF5IG5vdCB3b3JrIGFzIGV4cGVjdGVkLiBVcGdyYWRlIHRvIEByZWFjdC10aHJlZS9maWJlciBeOC4xLjAgZm9yIHN1cHBvcnQuXFxuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2RyZWkvaXNzdWVzLzk0NFwiKX0pLFtdKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLG4pfWNvbnN0IEhvPVAuY3JlYXRlQ29udGV4dChudWxsKSwkbz1uZXcgRC5WZWN0b3IzLHFvPW5ldyBELlZlY3RvcjMsWG89bmV3IEQuVmVjdG9yMygwLDEsMCksWm89bmV3IEQuTWF0cml4NCxZbz0oe2RpcmVjdGlvbjplLGF4aXM6dH0pPT57Y29uc3R7dHJhbnNsYXRpb246cix0cmFuc2xhdGlvbkxpbWl0czpuLGFubm90YXRpb25zOm8sYW5ub3RhdGlvbnNDbGFzczppLGRlcHRoVGVzdDpzLHNjYWxlOmwsbGluZVdpZHRoOmMsZml4ZWQ6dSxheGlzQ29sb3JzOmQsaG92ZXJlZENvbG9yOm0sb3BhY2l0eTpmLG9uRHJhZ1N0YXJ0OnAsb25EcmFnOmgsb25EcmFnRW5kOngsdXNlckRhdGE6eX09UC51c2VDb250ZXh0KEhvKSx2PWEudXNlVGhyZWUoKGU9PmUuY29udHJvbHMpKSxnPVAudXNlUmVmKG51bGwpLHo9UC51c2VSZWYobnVsbCksdz1QLnVzZVJlZihudWxsKSxiPVAudXNlUmVmKDApLFtNLEVdPVAudXNlU3RhdGUoITEpLFM9UC51c2VDYWxsYmFjaygobj0+e28mJihnLmN1cnJlbnQuaW5uZXJUZXh0PWAke3IuY3VycmVudFt0XS50b0ZpeGVkKDIpfWAsZy5jdXJyZW50LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKSxuLnN0b3BQcm9wYWdhdGlvbigpO2NvbnN0IGE9KG5ldyBELk1hdHJpeDQpLmV4dHJhY3RSb3RhdGlvbih6LmN1cnJlbnQubWF0cml4V29ybGQpLGk9bi5wb2ludC5jbG9uZSgpLHM9KG5ldyBELlZlY3RvcjMpLnNldEZyb21NYXRyaXhQb3NpdGlvbih6LmN1cnJlbnQubWF0cml4V29ybGQpLGw9ZS5jbG9uZSgpLmFwcGx5TWF0cml4NChhKS5ub3JtYWxpemUoKTt3LmN1cnJlbnQ9e2NsaWNrUG9pbnQ6aSxkaXI6bH0sYi5jdXJyZW50PXIuY3VycmVudFt0XSxwKHtjb21wb25lbnQ6XCJBcnJvd1wiLGF4aXM6dCxvcmlnaW46cyxkaXJlY3Rpb25zOltsXX0pLHYmJih2LmVuYWJsZWQ9ITEpLG4udGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKG4ucG9pbnRlcklkKX0pLFtvLGUsdixwLHIsdF0pLFQ9UC51c2VDYWxsYmFjaygoZT0+e2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksTXx8RSghMCksdy5jdXJyZW50KXtjb25zdHtjbGlja1BvaW50OmEsZGlyOml9PXcuY3VycmVudCxbcyxsXT0obnVsbD09bj92b2lkIDA6blt0XSl8fFt2b2lkIDAsdm9pZCAwXTtsZXQgYz0oKGUsdCxyLG4pPT57Y29uc3QgYT10LmRvdCh0KSxvPXQuZG90KGUpLXQuZG90KHIpLGk9dC5kb3Qobik7cmV0dXJuIDA9PT1pPy1vL2E6KCRvLmNvcHkobikubXVsdGlwbHlTY2FsYXIoYS9pKS5zdWIodCkscW8uY29weShuKS5tdWx0aXBseVNjYWxhcihvL2kpLmFkZChyKS5zdWIoZSksLSRvLmRvdChxbykvJG8uZG90KCRvKSl9KShhLGksZS5yYXkub3JpZ2luLGUucmF5LmRpcmVjdGlvbik7dm9pZCAwIT09cyYmKGM9TWF0aC5tYXgoYyxzLWIuY3VycmVudCkpLHZvaWQgMCE9PWwmJihjPU1hdGgubWluKGMsbC1iLmN1cnJlbnQpKSxyLmN1cnJlbnRbdF09Yi5jdXJyZW50K2MsbyYmKGcuY3VycmVudC5pbm5lclRleHQ9YCR7ci5jdXJyZW50W3RdLnRvRml4ZWQoMil9YCksWm8ubWFrZVRyYW5zbGF0aW9uKGkueCpjLGkueSpjLGkueipjKSxoKFpvKX19KSxbbyxoLE0scixuLHRdKSxDPVAudXNlQ2FsbGJhY2soKGU9PntvJiYoZy5jdXJyZW50LnN0eWxlLmRpc3BsYXk9XCJub25lXCIpLGUuc3RvcFByb3BhZ2F0aW9uKCksdy5jdXJyZW50PW51bGwseCgpLHYmJih2LmVuYWJsZWQ9ITApLGUudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCl9KSxbbyx2LHhdKSxSPVAudXNlQ2FsbGJhY2soKGU9PntlLnN0b3BQcm9wYWdhdGlvbigpLEUoITEpfSksW10pLHtjeWxpbmRlckxlbmd0aDpGLGNvbmVXaWR0aDprLGNvbmVMZW5ndGg6XyxtYXRyaXhMOkF9PVAudXNlTWVtbygoKCk9Pntjb25zdCB0PXU/Yy9sKjEuNjpsLzIwLHI9dT8uMjpsLzUsbj11PzEtcjpsLXIsYT0obmV3IEQuUXVhdGVybmlvbikuc2V0RnJvbVVuaXRWZWN0b3JzKFhvLGUuY2xvbmUoKS5ub3JtYWxpemUoKSk7cmV0dXJue2N5bGluZGVyTGVuZ3RoOm4sY29uZVdpZHRoOnQsY29uZUxlbmd0aDpyLG1hdHJpeEw6KG5ldyBELk1hdHJpeDQpLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGEpfX0pLFtlLGwsYyx1XSksTD1NP206ZFt0XTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnp9LFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse21hdHJpeDpBLG1hdHJpeEF1dG9VcGRhdGU6ITEsb25Qb2ludGVyRG93bjpTLG9uUG9pbnRlck1vdmU6VCxvblBvaW50ZXJVcDpDLG9uUG9pbnRlck91dDpSfSxvJiZQLmNyZWF0ZUVsZW1lbnQoWSx7cG9zaXRpb246WzAsLV8sMF19LFAuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7ZGlzcGxheTpcIm5vbmVcIixiYWNrZ3JvdW5kOlwiIzE1MTUyMFwiLGNvbG9yOlwid2hpdGVcIixwYWRkaW5nOlwiNnB4IDhweFwiLGJvcmRlclJhZGl1czo3LHdoaXRlU3BhY2U6XCJub3dyYXBcIn0sY2xhc3NOYW1lOmkscmVmOmd9KSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHt2aXNpYmxlOiExLHBvc2l0aW9uOlswLChGK18pLzIsMF0sdXNlckRhdGE6eX0sUC5jcmVhdGVFbGVtZW50KFwiY3lsaW5kZXJHZW9tZXRyeVwiLHthcmdzOlsxLjQqaywxLjQqayxGK18sOCwxXX0pKSxQLmNyZWF0ZUVsZW1lbnQodWUse3RyYW5zcGFyZW50OiEwLHJheWNhc3Q6KCk9Pm51bGwsZGVwdGhUZXN0OnMscG9pbnRzOlswLDAsMCwwLEYsMF0sbGluZVdpZHRoOmMsY29sb3I6TCxvcGFjaXR5OmYscG9seWdvbk9mZnNldDohMCxyZW5kZXJPcmRlcjoxLHBvbHlnb25PZmZzZXRGYWN0b3I6LTEwLGZvZzohMX0pLFAuY3JlYXRlRWxlbWVudChcIm1lc2hcIix7cmF5Y2FzdDooKT0+bnVsbCxwb3NpdGlvbjpbMCxGK18vMiwwXSxyZW5kZXJPcmRlcjo1MDB9LFAuY3JlYXRlRWxlbWVudChcImNvbmVHZW9tZXRyeVwiLHthcmdzOltrLF8sMjQsMV19KSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxkZXB0aFRlc3Q6cyxjb2xvcjpMLG9wYWNpdHk6Zixwb2x5Z29uT2Zmc2V0OiEwLHBvbHlnb25PZmZzZXRGYWN0b3I6LTEwLGZvZzohMX0pKSkpfSxRbz1uZXcgRC5SYXksS289bmV3IEQuVmVjdG9yMyxKbz1uZXcgRC5NYXRyaXg0LGVpPSh7ZGlyMTplLGRpcjI6dCxheGlzOnJ9KT0+e2NvbnN0e3RyYW5zbGF0aW9uOm4sdHJhbnNsYXRpb25MaW1pdHM6byxhbm5vdGF0aW9uczppLGFubm90YXRpb25zQ2xhc3M6cyxkZXB0aFRlc3Q6bCxzY2FsZTpjLGxpbmVXaWR0aDp1LGZpeGVkOmQsYXhpc0NvbG9yczptLGhvdmVyZWRDb2xvcjpmLG9wYWNpdHk6cCxvbkRyYWdTdGFydDpoLG9uRHJhZzp4LG9uRHJhZ0VuZDp5LHVzZXJEYXRhOnZ9PVAudXNlQ29udGV4dChIbyksZz1hLnVzZVRocmVlKChlPT5lLmNvbnRyb2xzKSksej1QLnVzZVJlZihudWxsKSx3PVAudXNlUmVmKG51bGwpLGI9UC51c2VSZWYobnVsbCksTT1QLnVzZVJlZigwKSxFPVAudXNlUmVmKDApLFtTLFRdPVAudXNlU3RhdGUoITEpLEM9UC51c2VDYWxsYmFjaygoZT0+e2kmJih6LmN1cnJlbnQuaW5uZXJUZXh0PWAke24uY3VycmVudFsocisxKSUzXS50b0ZpeGVkKDIpfSwgJHtuLmN1cnJlbnRbKHIrMiklM10udG9GaXhlZCgyKX1gLHouY3VycmVudC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIiksZS5zdG9wUHJvcGFnYXRpb24oKTtjb25zdCB0PWUucG9pbnQuY2xvbmUoKSxhPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4UG9zaXRpb24ody5jdXJyZW50Lm1hdHJpeFdvcmxkKSxvPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwwKS5ub3JtYWxpemUoKSxzPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwxKS5ub3JtYWxpemUoKSxsPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHcuY3VycmVudC5tYXRyaXhXb3JsZCwyKS5ub3JtYWxpemUoKSxjPShuZXcgRC5QbGFuZSkuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQobCxhKTtiLmN1cnJlbnQ9e2NsaWNrUG9pbnQ6dCxlMTpvLGUyOnMscGxhbmU6Y30sTS5jdXJyZW50PW4uY3VycmVudFsocisxKSUzXSxFLmN1cnJlbnQ9bi5jdXJyZW50WyhyKzIpJTNdLGgoe2NvbXBvbmVudDpcIlNsaWRlclwiLGF4aXM6cixvcmlnaW46YSxkaXJlY3Rpb25zOltvLHMsbF19KSxnJiYoZy5lbmFibGVkPSExKSxlLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCl9KSxbaSxnLGgscl0pLFI9UC51c2VDYWxsYmFjaygoZT0+e2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksU3x8VCghMCksYi5jdXJyZW50KXtjb25zdHtjbGlja1BvaW50OnQsZTE6YSxlMjpzLHBsYW5lOmx9PWIuY3VycmVudCxbYyx1XT0obnVsbD09bz92b2lkIDA6b1socisxKSUzXSl8fFt2b2lkIDAsdm9pZCAwXSxbZCxtXT0obnVsbD09bz92b2lkIDA6b1socisyKSUzXSl8fFt2b2lkIDAsdm9pZCAwXTtRby5jb3B5KGUucmF5KSxRby5pbnRlcnNlY3RQbGFuZShsLEtvKSxRby5kaXJlY3Rpb24ubmVnYXRlKCksUW8uaW50ZXJzZWN0UGxhbmUobCxLbyksS28uc3ViKHQpO2xldFtmLHBdPSgoZSx0LHIpPT57Y29uc3Qgbj1NYXRoLmFicyhlLngpPj1NYXRoLmFicyhlLnkpJiZNYXRoLmFicyhlLngpPj1NYXRoLmFicyhlLnopPzA6TWF0aC5hYnMoZS55KT49TWF0aC5hYnMoZS54KSYmTWF0aC5hYnMoZS55KT49TWF0aC5hYnMoZS56KT8xOjIsYT1bMCwxLDJdLnNvcnQoKChlLHIpPT5NYXRoLmFicyh0LmdldENvbXBvbmVudChyKSktTWF0aC5hYnModC5nZXRDb21wb25lbnQoZSkpKSksbz1uPT09YVswXT9hWzFdOmFbMF0saT1lLmdldENvbXBvbmVudChuKSxzPWUuZ2V0Q29tcG9uZW50KG8pLGw9dC5nZXRDb21wb25lbnQobiksYz10LmdldENvbXBvbmVudChvKSx1PXIuZ2V0Q29tcG9uZW50KG4pLGQ9KHIuZ2V0Q29tcG9uZW50KG8pLXUqKHMvaSkpLyhjLWwqKHMvaSkpO3JldHVyblsodS1kKmwpL2ksZF19KShhLHMsS28pO3ZvaWQgMCE9PWMmJihmPU1hdGgubWF4KGYsYy1NLmN1cnJlbnQpKSx2b2lkIDAhPT11JiYoZj1NYXRoLm1pbihmLHUtTS5jdXJyZW50KSksdm9pZCAwIT09ZCYmKHA9TWF0aC5tYXgocCxkLUUuY3VycmVudCkpLHZvaWQgMCE9PW0mJihwPU1hdGgubWluKHAsbS1FLmN1cnJlbnQpKSxuLmN1cnJlbnRbKHIrMSklM109TS5jdXJyZW50K2Ysbi5jdXJyZW50WyhyKzIpJTNdPUUuY3VycmVudCtwLGkmJih6LmN1cnJlbnQuaW5uZXJUZXh0PWAke24uY3VycmVudFsocisxKSUzXS50b0ZpeGVkKDIpfSwgJHtuLmN1cnJlbnRbKHIrMiklM10udG9GaXhlZCgyKX1gKSxKby5tYWtlVHJhbnNsYXRpb24oZiphLngrcCpzLngsZiphLnkrcCpzLnksZiphLnorcCpzLnopLHgoSm8pfX0pLFtpLHgsUyxuLG8scl0pLEY9UC51c2VDYWxsYmFjaygoZT0+e2kmJih6LmN1cnJlbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIiksZS5zdG9wUHJvcGFnYXRpb24oKSxiLmN1cnJlbnQ9bnVsbCx5KCksZyYmKGcuZW5hYmxlZD0hMCksZS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKX0pLFtpLGcseV0pLGs9UC51c2VDYWxsYmFjaygoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksVCghMSl9KSxbXSksXz1QLnVzZU1lbW8oKCgpPT57Y29uc3Qgcj1lLmNsb25lKCkubm9ybWFsaXplKCksbj10LmNsb25lKCkubm9ybWFsaXplKCk7cmV0dXJuKG5ldyBELk1hdHJpeDQpLm1ha2VCYXNpcyhyLG4sci5jbG9uZSgpLmNyb3NzKG4pKX0pLFtlLHRdKSxBPWQ/MS83OmMvNyxMPWQ/LjIyNTouMjI1KmMsQj1TP2Y6bVtyXSxVPVAudXNlTWVtbygoKCk9PltuZXcgRC5WZWN0b3IzKDAsMCwwKSxuZXcgRC5WZWN0b3IzKDAsTCwwKSxuZXcgRC5WZWN0b3IzKEwsTCwwKSxuZXcgRC5WZWN0b3IzKEwsMCwwKSxuZXcgRC5WZWN0b3IzKDAsMCwwKV0pLFtMXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjp3LG1hdHJpeDpfLG1hdHJpeEF1dG9VcGRhdGU6ITF9LGkmJlAuY3JlYXRlRWxlbWVudChZLHtwb3NpdGlvbjpbMCwwLDBdfSxQLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJub25lXCIsYmFja2dyb3VuZDpcIiMxNTE1MjBcIixjb2xvcjpcIndoaXRlXCIscGFkZGluZzpcIjZweCA4cHhcIixib3JkZXJSYWRpdXM6Nyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9LGNsYXNzTmFtZTpzLHJlZjp6fSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3Bvc2l0aW9uOlsxLjcqQSwxLjcqQSwwXX0sUC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLHt2aXNpYmxlOiEwLG9uUG9pbnRlckRvd246QyxvblBvaW50ZXJNb3ZlOlIsb25Qb2ludGVyVXA6RixvblBvaW50ZXJPdXQ6ayxzY2FsZTpMLHVzZXJEYXRhOnZ9LFAuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIixudWxsKSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoQmFzaWNNYXRlcmlhbFwiLHt0cmFuc3BhcmVudDohMCxkZXB0aFRlc3Q6bCxjb2xvcjpCLHBvbHlnb25PZmZzZXQ6ITAscG9seWdvbk9mZnNldEZhY3RvcjotMTAsc2lkZTpELkRvdWJsZVNpZGUsZm9nOiExfSkpLFAuY3JlYXRlRWxlbWVudCh1ZSx7cG9zaXRpb246Wy1MLzIsLUwvMiwwXSx0cmFuc3BhcmVudDohMCxkZXB0aFRlc3Q6bCxwb2ludHM6VSxsaW5lV2lkdGg6dSxjb2xvcjpCLG9wYWNpdHk6cCxwb2x5Z29uT2Zmc2V0OiEwLHBvbHlnb25PZmZzZXRGYWN0b3I6LTEwLHVzZXJEYXRhOnYsZm9nOiExfSkpKX0sdGk9bmV3IEQuVmVjdG9yMyxyaT1uZXcgRC5WZWN0b3IzLG5pPWU9PjE4MCplL01hdGguUEksYWk9ZT0+e2xldCB0PSgoZSx0KT0+e2xldCByPU1hdGguZmxvb3IoZS90KTtyZXR1cm4gcj1yPDA/cisxOnIsZS1yKnR9KShlLDIqTWF0aC5QSSk7cmV0dXJuIE1hdGguYWJzKHQpPDFlLTY/MDoodDwwJiYodCs9MipNYXRoLlBJKSx0KX0sb2k9bmV3IEQuTWF0cml4NCxpaT1uZXcgRC5WZWN0b3IzLHNpPW5ldyBELlJheSxsaT1uZXcgRC5WZWN0b3IzLGNpPSh7ZGlyMTplLGRpcjI6dCxheGlzOnJ9KT0+e2NvbnN0e3JvdGF0aW9uTGltaXRzOm4sYW5ub3RhdGlvbnM6byxhbm5vdGF0aW9uc0NsYXNzOmksZGVwdGhUZXN0OnMsc2NhbGU6bCxsaW5lV2lkdGg6YyxmaXhlZDp1LGF4aXNDb2xvcnM6ZCxob3ZlcmVkQ29sb3I6bSxvcGFjaXR5OmYsb25EcmFnU3RhcnQ6cCxvbkRyYWc6aCxvbkRyYWdFbmQ6eCx1c2VyRGF0YTp5fT1QLnVzZUNvbnRleHQoSG8pLHY9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLGc9UC51c2VSZWYobnVsbCksej1QLnVzZVJlZihudWxsKSx3PVAudXNlUmVmKDApLGI9UC51c2VSZWYoMCksTT1QLnVzZVJlZihudWxsKSxbRSxTXT1QLnVzZVN0YXRlKCExKSxUPVAudXNlQ2FsbGJhY2soKGU9PntvJiYoZy5jdXJyZW50LmlubmVyVGV4dD1gJHtuaShiLmN1cnJlbnQpLnRvRml4ZWQoMCl9wrpgLGcuY3VycmVudC5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIiksZS5zdG9wUHJvcGFnYXRpb24oKTtjb25zdCB0PWUucG9pbnQuY2xvbmUoKSxuPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oei5jdXJyZW50Lm1hdHJpeFdvcmxkKSxhPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHouY3VycmVudC5tYXRyaXhXb3JsZCwwKS5ub3JtYWxpemUoKSxpPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHouY3VycmVudC5tYXRyaXhXb3JsZCwxKS5ub3JtYWxpemUoKSxzPShuZXcgRC5WZWN0b3IzKS5zZXRGcm9tTWF0cml4Q29sdW1uKHouY3VycmVudC5tYXRyaXhXb3JsZCwyKS5ub3JtYWxpemUoKSxsPShuZXcgRC5QbGFuZSkuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQocyxuKTtNLmN1cnJlbnQ9e2NsaWNrUG9pbnQ6dCxvcmlnaW46bixlMTphLGUyOmksbm9ybWFsOnMscGxhbmU6bH0scCh7Y29tcG9uZW50OlwiUm90YXRvclwiLGF4aXM6cixvcmlnaW46bixkaXJlY3Rpb25zOlthLGksc119KSx2JiYodi5lbmFibGVkPSExKSxlLnRhcmdldC5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCl9KSxbbyx2LHAscl0pLEM9UC51c2VDYWxsYmFjaygoZT0+e2lmKGUuc3RvcFByb3BhZ2F0aW9uKCksRXx8UyghMCksTS5jdXJyZW50KXtjb25zdHtjbGlja1BvaW50OnQsb3JpZ2luOmEsZTE6aSxlMjpzLG5vcm1hbDpsLHBsYW5lOmN9PU0uY3VycmVudCxbdSxkXT0obnVsbD09bj92b2lkIDA6bltyXSl8fFt2b2lkIDAsdm9pZCAwXTtzaS5jb3B5KGUucmF5KSxzaS5pbnRlcnNlY3RQbGFuZShjLGxpKSxzaS5kaXJlY3Rpb24ubmVnYXRlKCksc2kuaW50ZXJzZWN0UGxhbmUoYyxsaSk7bGV0IG09KChlLHQscixuLGEpPT57dGkuY29weShlKS5zdWIocikscmkuY29weSh0KS5zdWIocik7Y29uc3Qgbz1uLmRvdChuKSxpPWEuZG90KGEpLHM9dGkuZG90KG4pL28sbD10aS5kb3QoYSkvaSxjPXJpLmRvdChuKS9vLHU9cmkuZG90KGEpL2ksZD1NYXRoLmF0YW4yKGwscyk7cmV0dXJuIE1hdGguYXRhbjIodSxjKS1kfSkodCxsaSxhLGkscyksZj1uaShtKTtlLnNoaWZ0S2V5JiYoZj0xMCpNYXRoLnJvdW5kKGYvMTApLG09KGU9PmUqTWF0aC5QSS8xODApKGYpKSx2b2lkIDAhPT11JiZ2b2lkIDAhPT1kJiZkLXU8MipNYXRoLlBJPyhtPWFpKG0pLG09bT5NYXRoLlBJP20tMipNYXRoLlBJOm0sbT1PLmRlZmF1bHQobSx1LXcuY3VycmVudCxkLXcuY3VycmVudCksYi5jdXJyZW50PXcuY3VycmVudCttKTooYi5jdXJyZW50PWFpKHcuY3VycmVudCttKSxiLmN1cnJlbnQ9Yi5jdXJyZW50Pk1hdGguUEk/Yi5jdXJyZW50LTIqTWF0aC5QSTpiLmN1cnJlbnQpLG8mJihmPW5pKGIuY3VycmVudCksZy5jdXJyZW50LmlubmVyVGV4dD1gJHtmLnRvRml4ZWQoMCl9wrpgKSxvaS5tYWtlUm90YXRpb25BeGlzKGwsbSksaWkuY29weShhKS5hcHBseU1hdHJpeDQob2kpLnN1YihhKS5uZWdhdGUoKSxvaS5zZXRQb3NpdGlvbihpaSksaChvaSl9fSksW28saCxFLG4scl0pLFI9UC51c2VDYWxsYmFjaygoZT0+e28mJihnLmN1cnJlbnQuc3R5bGUuZGlzcGxheT1cIm5vbmVcIiksZS5zdG9wUHJvcGFnYXRpb24oKSx3LmN1cnJlbnQ9Yi5jdXJyZW50LE0uY3VycmVudD1udWxsLHgoKSx2JiYodi5lbmFibGVkPSEwKSxlLnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpfSksW28sdix4XSksRj1QLnVzZUNhbGxiYWNrKChlPT57ZS5zdG9wUHJvcGFnYXRpb24oKSxTKCExKX0pLFtdKSxrPVAudXNlTWVtbygoKCk9Pntjb25zdCByPWUuY2xvbmUoKS5ub3JtYWxpemUoKSxuPXQuY2xvbmUoKS5ub3JtYWxpemUoKTtyZXR1cm4obmV3IEQuTWF0cml4NCkubWFrZUJhc2lzKHIsbixyLmNsb25lKCkuY3Jvc3MobikpfSksW2UsdF0pLF89dT8uNjU6LjY1KmwsQT1QLnVzZU1lbW8oKCgpPT57Y29uc3QgZT1bXTtmb3IobGV0IHQ9MDt0PD0zMjt0Kyspe2NvbnN0IHI9dCooTWF0aC5QSS8yKS8zMjtlLnB1c2gobmV3IEQuVmVjdG9yMyhNYXRoLmNvcyhyKSpfLE1hdGguc2luKHIpKl8sMCkpfXJldHVybiBlfSksW19dKTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7cmVmOnosb25Qb2ludGVyRG93bjpULG9uUG9pbnRlck1vdmU6QyxvblBvaW50ZXJVcDpSLG9uUG9pbnRlck91dDpGLG1hdHJpeDprLG1hdHJpeEF1dG9VcGRhdGU6ITF9LG8mJlAuY3JlYXRlRWxlbWVudChZLHtwb3NpdGlvbjpbXyxfLDBdfSxQLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7c3R5bGU6e2Rpc3BsYXk6XCJub25lXCIsYmFja2dyb3VuZDpcIiMxNTE1MjBcIixjb2xvcjpcIndoaXRlXCIscGFkZGluZzpcIjZweCA4cHhcIixib3JkZXJSYWRpdXM6Nyx3aGl0ZVNwYWNlOlwibm93cmFwXCJ9LGNsYXNzTmFtZTppLHJlZjpnfSkpLFAuY3JlYXRlRWxlbWVudCh1ZSx7cG9pbnRzOkEsbGluZVdpZHRoOjQqYyx2aXNpYmxlOiExLHVzZXJEYXRhOnl9KSxQLmNyZWF0ZUVsZW1lbnQodWUse3RyYW5zcGFyZW50OiEwLHJheWNhc3Q6KCk9Pm51bGwsZGVwdGhUZXN0OnMscG9pbnRzOkEsbGluZVdpZHRoOmMsY29sb3I6RT9tOmRbcl0sb3BhY2l0eTpmLHBvbHlnb25PZmZzZXQ6ITAscG9seWdvbk9mZnNldEZhY3RvcjotMTAsZm9nOiExfSkpfSx1aT1uZXcgRC5WZWN0b3IzLGRpPW5ldyBELlZlY3RvcjMsbWk9bmV3IEQuVmVjdG9yMyxmaT0oZSx0LHIsbj0xKT0+e2NvbnN0IGE9dWkuc2V0KGUueC9yLndpZHRoKjItMSwtZS55L3IuaGVpZ2h0KjIrMSxuKTtyZXR1cm4gYS51bnByb2plY3QodCksYX0scGk9KGUsdCxyLG4pPT57Y29uc3QgYT0oKGUsdCxyKT0+e2NvbnN0IG49ci53aWR0aC8yLGE9ci5oZWlnaHQvMjt0LnVwZGF0ZU1hdHJpeFdvcmxkKCExKTtjb25zdCBvPWUucHJvamVjdCh0KTtyZXR1cm4gby54PW8ueCpuK24sby55PS1vLnkqYSthLG99KShtaS5jb3B5KGUpLHIsbik7bGV0IG89MDtmb3IobGV0IGk9MDtpPDI7KytpKXtjb25zdCBzPWRpLmNvcHkoYSkuc2V0Q29tcG9uZW50KGksYS5nZXRDb21wb25lbnQoaSkrdCksbD1maShzLHIsbixzLnopO289TWF0aC5tYXgobyxlLmRpc3RhbmNlVG8obCkpfXJldHVybiBvfSxoaT1uZXcgRC5NYXRyaXg0LHhpPW5ldyBELk1hdHJpeDQseWk9bmV3IEQuTWF0cml4NCx2aT1uZXcgRC5NYXRyaXg0LGdpPW5ldyBELk1hdHJpeDQsemk9bmV3IEQuTWF0cml4NCx3aT1uZXcgRC5NYXRyaXg0LGJpPW5ldyBELk1hdHJpeDQsTWk9bmV3IEQuQm94MyxFaT1uZXcgRC5Cb3gzLFNpPW5ldyBELlZlY3RvcjMsVGk9bmV3IEQuVmVjdG9yMyxDaT1uZXcgRC5WZWN0b3IzLFBpPW5ldyBELlZlY3RvcjMsUmk9bmV3IEQuVmVjdG9yMygxLDAsMCksRGk9bmV3IEQuVmVjdG9yMygwLDEsMCksRmk9bmV3IEQuVmVjdG9yMygwLDAsMSksa2k9UC5mb3J3YXJkUmVmKCgoe21hdHJpeDplLG9uRHJhZ1N0YXJ0OnQsb25EcmFnOnIsb25EcmFnRW5kOm4sYXV0b1RyYW5zZm9ybTpvPSEwLGFuY2hvcjppLGRpc2FibGVBeGVzOnM9ITEsZGlzYWJsZVNsaWRlcnM6bD0hMSxkaXNhYmxlUm90YXRpb25zOmM9ITEsYWN0aXZlQXhlczp1PVshMCwhMCwhMF0sb2Zmc2V0OmQ9WzAsMCwwXSxyb3RhdGlvbjptPVswLDAsMF0sc2NhbGU6Zj0xLGxpbmVXaWR0aDpwPTQsZml4ZWQ6aD0hMSx0cmFuc2xhdGlvbkxpbWl0czp4LHJvdGF0aW9uTGltaXRzOnksZGVwdGhUZXN0OnY9ITAsYXhpc0NvbG9yczpnPVtcIiNmZjIwNjBcIixcIiMyMGRmODBcIixcIiMyMDgwZmZcIl0saG92ZXJlZENvbG9yOno9XCIjZmZmZjQwXCIsYW5ub3RhdGlvbnM6dz0hMSxhbm5vdGF0aW9uc0NsYXNzOmIsb3BhY2l0eTpNPTEsdmlzaWJsZTpFPSEwLHVzZXJEYXRhOlMsY2hpbGRyZW46VCwuLi5SfSxGKT0+e2NvbnN0IGs9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksXz1QLnVzZVJlZihudWxsKSxBPVAudXNlUmVmKG51bGwpLEw9UC51c2VSZWYobnVsbCksQj1QLnVzZVJlZihudWxsKSxVPVAudXNlUmVmKFswLDAsMF0pO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2kmJihCLmN1cnJlbnQudXBkYXRlV29ybGRNYXRyaXgoITAsITApLHZpLmNvcHkoQi5jdXJyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKSxNaS5tYWtlRW1wdHkoKSxCLmN1cnJlbnQudHJhdmVyc2UoKGU9PntlLmdlb21ldHJ5JiYoZS5nZW9tZXRyeS5ib3VuZGluZ0JveHx8ZS5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKSx6aS5jb3B5KGUubWF0cml4V29ybGQpLnByZW11bHRpcGx5KHZpKSxFaS5jb3B5KGUuZ2VvbWV0cnkuYm91bmRpbmdCb3gpLEVpLmFwcGx5TWF0cml4NCh6aSksTWkudW5pb24oRWkpKX0pKSxTaS5jb3B5KE1pLm1heCkuYWRkKE1pLm1pbikubXVsdGlwbHlTY2FsYXIoLjUpLFRpLmNvcHkoTWkubWF4KS5zdWIoTWkubWluKS5tdWx0aXBseVNjYWxhciguNSksQ2kuY29weShUaSkubXVsdGlwbHkobmV3IEQuVmVjdG9yMyguLi5pKSkuYWRkKFNpKSxQaS5zZXQoLi4uZCkuYWRkKENpKSxMLmN1cnJlbnQucG9zaXRpb24uY29weShQaSksaygpKX0pKTtjb25zdCBJPVAudXNlTWVtbygoKCk9Pih7b25EcmFnU3RhcnQ6ZT0+e2hpLmNvcHkoQS5jdXJyZW50Lm1hdHJpeCkseGkuY29weShBLmN1cnJlbnQubWF0cml4V29ybGQpLHQmJnQoZSksaygpfSxvbkRyYWc6ZT0+e3lpLmNvcHkoXy5jdXJyZW50Lm1hdHJpeFdvcmxkKSx2aS5jb3B5KHlpKS5pbnZlcnQoKSxnaS5jb3B5KHhpKS5wcmVtdWx0aXBseShlKSx6aS5jb3B5KGdpKS5wcmVtdWx0aXBseSh2aSksd2kuY29weShoaSkuaW52ZXJ0KCksYmkuY29weSh6aSkubXVsdGlwbHkod2kpLG8mJkEuY3VycmVudC5tYXRyaXguY29weSh6aSksciYmcih6aSxiaSxnaSxlKSxrKCl9LG9uRHJhZ0VuZDooKT0+e24mJm4oKSxrKCl9LHRyYW5zbGF0aW9uOlUsdHJhbnNsYXRpb25MaW1pdHM6eCxyb3RhdGlvbkxpbWl0czp5LGF4aXNDb2xvcnM6Zyxob3ZlcmVkQ29sb3I6eixvcGFjaXR5Ok0sc2NhbGU6ZixsaW5lV2lkdGg6cCxmaXhlZDpoLGRlcHRoVGVzdDp2LHVzZXJEYXRhOlMsYW5ub3RhdGlvbnM6dyxhbm5vdGF0aW9uc0NsYXNzOmJ9KSksW3QscixuLFUseCx5LHYsZixwLGgsLi4uZyx6LE0sUyxvLHcsYl0pLFY9bmV3IEQuVmVjdG9yMztyZXR1cm4gYS51c2VGcmFtZSgoZT0+e2lmKGgpe2NvbnN0IGE9cGkoTC5jdXJyZW50LmdldFdvcmxkUG9zaXRpb24oViksZixlLmNhbWVyYSxlLnNpemUpO3ZhciB0LHIsbjtpZihMLmN1cnJlbnQpKG51bGw9PSh0PUwuY3VycmVudCk/dm9pZCAwOnQuc2NhbGUueCk9PT1hJiYobnVsbD09KHI9TC5jdXJyZW50KT92b2lkIDA6ci5zY2FsZS55KT09PWEmJihudWxsPT0obj1MLmN1cnJlbnQpP3ZvaWQgMDpuLnNjYWxlLnopPT09YXx8KEwuY3VycmVudC5zY2FsZS5zZXRTY2FsYXIoYSksZS5pbnZhbGlkYXRlKCkpfX0pKSxQLnVzZUltcGVyYXRpdmVIYW5kbGUoRiwoKCk9PkEuY3VycmVudCksW10pLFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2UmJmUgaW5zdGFuY2VvZiBELk1hdHJpeDQmJihBLmN1cnJlbnQubWF0cml4PWUpfSksW2VdKSxQLmNyZWF0ZUVsZW1lbnQoSG8uUHJvdmlkZXIse3ZhbHVlOkl9LFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpffSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLEMuZGVmYXVsdCh7cmVmOkEsbWF0cml4OmUsbWF0cml4QXV0b1VwZGF0ZTohMX0sUiksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIix7dmlzaWJsZTpFLHJlZjpMLHBvc2l0aW9uOmQscm90YXRpb246bX0sIXMmJnVbMF0mJlAuY3JlYXRlRWxlbWVudChZbyx7YXhpczowLGRpcmVjdGlvbjpSaX0pLCFzJiZ1WzFdJiZQLmNyZWF0ZUVsZW1lbnQoWW8se2F4aXM6MSxkaXJlY3Rpb246RGl9KSwhcyYmdVsyXSYmUC5jcmVhdGVFbGVtZW50KFlvLHtheGlzOjIsZGlyZWN0aW9uOkZpfSksIWwmJnVbMF0mJnVbMV0mJlAuY3JlYXRlRWxlbWVudChlaSx7YXhpczoyLGRpcjE6UmksZGlyMjpEaX0pLCFsJiZ1WzBdJiZ1WzJdJiZQLmNyZWF0ZUVsZW1lbnQoZWkse2F4aXM6MSxkaXIxOkZpLGRpcjI6Uml9KSwhbCYmdVsyXSYmdVsxXSYmUC5jcmVhdGVFbGVtZW50KGVpLHtheGlzOjAsZGlyMTpEaSxkaXIyOkZpfSksIWMmJnVbMF0mJnVbMV0mJlAuY3JlYXRlRWxlbWVudChjaSx7YXhpczoyLGRpcjE6UmksZGlyMjpEaX0pLCFjJiZ1WzBdJiZ1WzJdJiZQLmNyZWF0ZUVsZW1lbnQoY2kse2F4aXM6MSxkaXIxOkZpLGRpcjI6Uml9KSwhYyYmdVsyXSYmdVsxXSYmUC5jcmVhdGVFbGVtZW50KGNpLHtheGlzOjAsZGlyMTpEaSxkaXIyOkZpfSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjpCfSxUKSkpKX0pKTtleHBvcnRzLkFjY3VtdWxhdGl2ZVNoYWRvd3M9JG4sZXhwb3J0cy5BZGFwdGl2ZURwcj1mdW5jdGlvbih7cGl4ZWxhdGVkOmV9KXtjb25zdCB0PWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxyPWEudXNlVGhyZWUoKGU9PmUuaW50ZXJuYWwuYWN0aXZlKSksbj1hLnVzZVRocmVlKChlPT5lLnBlcmZvcm1hbmNlLmN1cnJlbnQpKSxvPWEudXNlVGhyZWUoKGU9PmUudmlld3BvcnQuaW5pdGlhbERwcikpLGk9YS51c2VUaHJlZSgoZT0+ZS5zZXREcHIpKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57Y29uc3Qgbj10LmRvbUVsZW1lbnQ7cmV0dXJuKCk9PntyJiZpKG8pLGUmJm4mJihuLnN0eWxlLmltYWdlUmVuZGVyaW5nPVwiYXV0b1wiKX19KSxbXSksUC51c2VFZmZlY3QoKCgpPT57aShuKm8pLGUmJnQuZG9tRWxlbWVudCYmKHQuZG9tRWxlbWVudC5zdHlsZS5pbWFnZVJlbmRlcmluZz0xPT09bj9cImF1dG9cIjpcInBpeGVsYXRlZFwiKX0pLFtuXSksbnVsbH0sZXhwb3J0cy5BZGFwdGl2ZUV2ZW50cz1mdW5jdGlvbigpe2NvbnN0IGU9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSx0PWEudXNlVGhyZWUoKGU9PmUuc2V0RXZlbnRzKSkscj1hLnVzZVRocmVlKChlPT5lLnBlcmZvcm1hbmNlLmN1cnJlbnQpKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57Y29uc3Qgcj1lKCkuZXZlbnRzLmVuYWJsZWQ7cmV0dXJuKCk9PnQoe2VuYWJsZWQ6cn0pfSksW10pLFAudXNlRWZmZWN0KCgoKT0+dCh7ZW5hYmxlZDoxPT09cn0pKSxbcl0pLG51bGx9LGV4cG9ydHMuQXJjYmFsbENvbnRyb2xzPW10LGV4cG9ydHMuQXNjaWlSZW5kZXJlcj1mdW5jdGlvbih7cmVuZGVySW5kZXg6ZT0xLGJnQ29sb3I6dD1cImJsYWNrXCIsZmdDb2xvcjpyPVwid2hpdGVcIixjaGFyYWN0ZXJzOm49XCIgLjotKyo9JUAjXCIsaW52ZXJ0Om89ITAsY29sb3I6aT0hMSxyZXNvbHV0aW9uOnM9LjE1fSl7Y29uc3R7c2l6ZTpsLGdsOmMsc2NlbmU6dSxjYW1lcmE6bX09YS51c2VUaHJlZSgpLGY9UC51c2VNZW1vKCgoKT0+e2NvbnN0IGU9bmV3IGQuQXNjaWlFZmZlY3QoYyxuLHtpbnZlcnQ6byxjb2xvcjppLHJlc29sdXRpb246c30pO3JldHVybiBlLmRvbUVsZW1lbnQuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGUuZG9tRWxlbWVudC5zdHlsZS50b3A9XCIwcHhcIixlLmRvbUVsZW1lbnQuc3R5bGUubGVmdD1cIjBweFwiLGUuZG9tRWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiLGV9KSxbbixvLGksc10pO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9PntmLmRvbUVsZW1lbnQuc3R5bGUuY29sb3I9cixmLmRvbUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yPXR9KSxbcix0XSksUC51c2VFZmZlY3QoKCgpPT4oYy5kb21FbGVtZW50LnN0eWxlLm9wYWNpdHk9XCIwXCIsYy5kb21FbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZi5kb21FbGVtZW50KSwoKT0+e2MuZG9tRWxlbWVudC5zdHlsZS5vcGFjaXR5PVwiMVwiLGMuZG9tRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGYuZG9tRWxlbWVudCl9KSksW2ZdKSxQLnVzZUVmZmVjdCgoKCk9PntmLnNldFNpemUobC53aWR0aCxsLmhlaWdodCl9KSxbZixsXSksYS51c2VGcmFtZSgoZT0+e2YucmVuZGVyKHUsbSl9KSxlKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsKX0sZXhwb3J0cy5CQkFuY2hvcj0oe2FuY2hvcjplLC4uLnR9KT0+e2NvbnN0IHI9UC51c2VSZWYobnVsbCksbj1QLnVzZVJlZihudWxsKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57dmFyIGU7bnVsbCE9KGU9ci5jdXJyZW50KSYmbnVsbCE9KGU9ZS5wYXJlbnQpJiZlLnBhcmVudCYmKG4uY3VycmVudD1yLmN1cnJlbnQucGFyZW50LHIuY3VycmVudC5wYXJlbnQucGFyZW50LmFkZChyLmN1cnJlbnQpKX0pLFtdKSxhLnVzZUZyYW1lKCgoKT0+e24uY3VycmVudCYmKFRyLnNldEZyb21PYmplY3Qobi5jdXJyZW50KSxUci5nZXRTaXplKENyKSxyLmN1cnJlbnQucG9zaXRpb24uc2V0KG4uY3VycmVudC5wb3NpdGlvbi54K0NyLngqKEFycmF5LmlzQXJyYXkoZSk/ZVswXTplLngpLzIsbi5jdXJyZW50LnBvc2l0aW9uLnkrQ3IueSooQXJyYXkuaXNBcnJheShlKT9lWzFdOmUueSkvMixuLmN1cnJlbnQucG9zaXRpb24ueitDci56KihBcnJheS5pc0FycmF5KGUpP2VbMl06ZS56KS8yKSl9KSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjpyfSx0KSl9LGV4cG9ydHMuQmFja2Ryb3A9ZnVuY3Rpb24oe2NoaWxkcmVuOmUsZmxvb3I6dD0uMjUsc2VnbWVudHM6cj0yMCxyZWNlaXZlU2hhZG93Om4sLi4uYX0pe2NvbnN0IG89UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2xldCBlPTA7Y29uc3Qgbj1yL3IvMixhPW8uY3VycmVudC5hdHRyaWJ1dGVzLnBvc2l0aW9uO2ZvcihsZXQgbz0wO288cisxO28rKylmb3IobGV0IGk9MDtpPHIrMTtpKyspYS5zZXRYWVooZSsrLG8vci1uKygwPT09bz8tdDowKSxpL3ItbixRbihvL3IpKTthLm5lZWRzVXBkYXRlPSEwLG8uY3VycmVudC5jb21wdXRlVmVydGV4Tm9ybWFscygpfSksW3IsdF0pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsYSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIse3JlY2VpdmVTaGFkb3c6bixyb3RhdGlvbjpbLU1hdGguUEkvMiwwLE1hdGguUEkvMl19LFAuY3JlYXRlRWxlbWVudChcInBsYW5lR2VvbWV0cnlcIix7cmVmOm8sYXJnczpbMSwxLHIscl19KSxlKSl9LGV4cG9ydHMuQmFrZVNoYWRvd3M9ZnVuY3Rpb24oKXtjb25zdCBlPWEudXNlVGhyZWUoKGU9PmUuZ2wpKTtyZXR1cm4gdC51c2VFZmZlY3QoKCgpPT4oZS5zaGFkb3dNYXAuYXV0b1VwZGF0ZT0hMSxlLnNoYWRvd01hcC5uZWVkc1VwZGF0ZT0hMCwoKT0+e2Uuc2hhZG93TWFwLmF1dG9VcGRhdGU9ZS5zaGFkb3dNYXAubmVlZHNVcGRhdGU9ITB9KSksW2Uuc2hhZG93TWFwXSksbnVsbH0sZXhwb3J0cy5CaWxsYm9hcmQ9bGUsZXhwb3J0cy5Cb3VuZHM9UG4sZXhwb3J0cy5Cb3g9S3IsZXhwb3J0cy5Cdmg9enIsZXhwb3J0cy5DYW1lcmFDb250cm9scz14dCxleHBvcnRzLkNhbWVyYVNoYWtlPURuLGV4cG9ydHMuQ2Fwc3VsZT14bixleHBvcnRzLkNhdG11bGxSb21MaW5lPXBlLGV4cG9ydHMuQ2F1c3RpY3M9YWEsZXhwb3J0cy5DZW50ZXI9RHIsZXhwb3J0cy5DaXJjbGU9SnIsZXhwb3J0cy5DbG9uZT1PZSxleHBvcnRzLkNsb3VkPURhLGV4cG9ydHMuQ2xvdWRJbnN0YW5jZT1SYSxleHBvcnRzLkNsb3Vkcz1QYSxleHBvcnRzLkNvbXB1dGVkQXR0cmlidXRlPSh7Y29tcHV0ZTplLG5hbWU6dCwuLi5yfSk9Pntjb25zdFthXT1QLnVzZVN0YXRlKCgoKT0+bmV3IG4uQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoMCksMSkpKSxvPVAudXNlUmVmKG51bGwpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9PntpZihvLmN1cnJlbnQpe3ZhciB0O2NvbnN0IHI9bnVsbCE9PSh0PW8uY3VycmVudC5wYXJlbnQpJiZ2b2lkIDAhPT10P3Q6by5jdXJyZW50Ll9fcjNmLnBhcmVudCxuPWUocik7by5jdXJyZW50LmNvcHkobil9fSksW2VdKSxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIixDLmRlZmF1bHQoe3JlZjpvLG9iamVjdDphLGF0dGFjaDpgYXR0cmlidXRlcy0ke3R9YH0scikpfSxleHBvcnRzLkNvbmU9ZW4sZXhwb3J0cy5Db250YWN0U2hhZG93cz1XbixleHBvcnRzLkN1YmVDYW1lcmE9ZnVuY3Rpb24oe2NoaWxkcmVuOmUsZnJhbWVzOnQ9MS8wLHJlc29sdXRpb246cixuZWFyOm4sZmFyOm8sZW52TWFwOmksZm9nOnMsLi4ubH0pe2NvbnN0IGM9UC51c2VSZWYobnVsbCkse2Zibzp1LGNhbWVyYTpkLHVwZGF0ZTptfT1pdCh7cmVzb2x1dGlvbjpyLG5lYXI6bixmYXI6byxlbnZNYXA6aSxmb2c6c30pO2xldCBmPTA7cmV0dXJuIGEudXNlRnJhbWUoKCgpPT57Yy5jdXJyZW50JiYodD09PTEvMHx8Zjx0KSYmKGMuY3VycmVudC52aXNpYmxlPSExLG0oKSxjLmN1cnJlbnQudmlzaWJsZT0hMCxmKyspfSkpLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsbCxQLmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIix7b2JqZWN0OmR9KSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtyZWY6Y30sZSh1LnRleHR1cmUpKSl9LGV4cG9ydHMuQ3ViaWNCZXppZXJMaW5lPWZlLGV4cG9ydHMuQ3VydmVNb2RpZmllcj1fcixleHBvcnRzLkN5Y2xlUmF5Y2FzdD1mdW5jdGlvbih7b25DaGFuZ2VkOmUscG9ydGFsOnQscHJldmVudERlZmF1bHQ6cj0hMCxzY3JvbGw6bj0hMCxrZXlDb2RlOm89OX0pe2NvbnN0IGk9UC51c2VSZWYoMCkscz1hLnVzZVRocmVlKChlPT5lLnNldEV2ZW50cykpLGw9YS51c2VUaHJlZSgoZT0+ZS5nZXQpKSxjPWEudXNlVGhyZWUoKGU9PmUuZ2wpKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57dmFyIGE7bGV0IHUsZD1bXTtjb25zdCBtPWwoKS5ldmVudHMuZmlsdGVyLGY9bnVsbCE9PShhPW51bGw9PXQ/dm9pZCAwOnQuY3VycmVudCkmJnZvaWQgMCE9PWE/YTpjLmRvbUVsZW1lbnQucGFyZW50Tm9kZSxwPSgpPT5mJiZlJiZlKGQsTWF0aC5yb3VuZChpLmN1cnJlbnQpJWQubGVuZ3RoKTtzKHtmaWx0ZXI6KGUsdCk9PntsZXQgcj1bLi4uZV07ci5sZW5ndGg9PT1kLmxlbmd0aCYmZC5ldmVyeSgoZT0+ci5tYXAoKGU9PmUub2JqZWN0LnV1aWQpKS5pbmNsdWRlcyhlLm9iamVjdC51dWlkKSkpfHwoaS5jdXJyZW50PTAsZD1yLHAoKSksbSYmKHI9bShyLHQpKTtmb3IobGV0IGU9MDtlPE1hdGgucm91bmQoaS5jdXJyZW50KSVyLmxlbmd0aDtlKyspe2NvbnN0IGU9ci5zaGlmdCgpO3I9Wy4uLnIsZV19cmV0dXJuIHJ9fSk7Y29uc3QgaD1lPT57dmFyIHQscjtpLmN1cnJlbnQ9ZShpLmN1cnJlbnQpLG51bGw9PSh0PWwoKS5ldmVudHMuaGFuZGxlcnMpfHx0Lm9uUG9pbnRlckNhbmNlbCh2b2lkIDApLG51bGw9PShyPWwoKS5ldmVudHMuaGFuZGxlcnMpfHxyLm9uUG9pbnRlck1vdmUodSkscCgpfSx4PWU9PnsoZS5rZXlDb2RlfHxlLndoaWNoKT09PW8mJihyJiZlLnByZXZlbnREZWZhdWx0KCksZC5sZW5ndGg+MSYmaCgoZT0+ZSsxKSkpfSx5PWU9PntyJiZlLnByZXZlbnREZWZhdWx0KCk7bGV0IHQ9MDtlfHwoZT13aW5kb3cuZXZlbnQpLGUud2hlZWxEZWx0YT90PWUud2hlZWxEZWx0YS8xMjA6ZS5kZXRhaWwmJih0PS1lLmRldGFpbC8zKSxkLmxlbmd0aD4xJiZoKChlPT5NYXRoLmFicyhlLXQpKSl9LHY9ZT0+dT1lO3JldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIix2LHtwYXNzaXZlOiEwfSksbiYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIseSksdm9pZCAwIT09byYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix4KSwoKT0+e3Moe2ZpbHRlcjptfSksdm9pZCAwIT09byYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix4KSxuJiZkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIix5KSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIix2KX19KSxbYyxsLHMscixuLG9dKSxudWxsfSxleHBvcnRzLkN5bGluZGVyPXRuLGV4cG9ydHMuRGVjYWw9JGUsZXhwb3J0cy5EZXRhaWxlZD1UbyxleHBvcnRzLkRldmljZU9yaWVudGF0aW9uQ29udHJvbHM9c3QsZXhwb3J0cy5Eb2RlY2FoZWRyb249Zm4sZXhwb3J0cy5FZGdlcz1fZSxleHBvcnRzLkVmZmVjdHM9YmUsZXhwb3J0cy5FbnZpcm9ubWVudD1qbixleHBvcnRzLkVudmlyb25tZW50Q3ViZT1WbixleHBvcnRzLkVudmlyb25tZW50TWFwPUluLGV4cG9ydHMuRW52aXJvbm1lbnRQb3J0YWw9T24sZXhwb3J0cy5FeGFtcGxlPUZyLGV4cG9ydHMuRXh0cnVkZT1wbixleHBvcnRzLkZhY2VDb250cm9scz1EdCxleHBvcnRzLkZhY2VMYW5kbWFya2VyPWZ1bmN0aW9uKHtiYXNlUGF0aDplPVN0LmJhc2VQYXRoLG9wdGlvbnM6cj1TdC5vcHRpb25zLGNoaWxkcmVuOm59KXtjb25zdCBhPUpTT04uc3RyaW5naWZ5KHIpLG89Zi5zdXNwZW5kKChhc3luYygpPT57Y29uc3R7RmlsZXNldFJlc29sdmVyOnQsRmFjZUxhbmRtYXJrZXI6bn09YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gVChyZXF1aXJlKFwiQG1lZGlhcGlwZS90YXNrcy12aXNpb25cIikpfSkpLGE9YXdhaXQgdC5mb3JWaXNpb25UYXNrcyhlKTtyZXR1cm4gbi5jcmVhdGVGcm9tT3B0aW9ucyhhLHIpfSksW2UsYV0pO3JldHVybiB0LnVzZUVmZmVjdCgoKCk9PigpPT57bnVsbD09b3x8by5jbG9zZSgpLGYuY2xlYXIoW2UsYV0pfSksW28sZSxhXSksUC5jcmVhdGVFbGVtZW50KEV0LlByb3ZpZGVyLHt2YWx1ZTpvfSxuKX0sZXhwb3J0cy5GYWNlTGFuZG1hcmtlckRlZmF1bHRzPVN0LGV4cG9ydHMuRmFjZW1lc2g9enQsZXhwb3J0cy5GYWNlbWVzaERhdGFzPU10LGV4cG9ydHMuRmFjZW1lc2hFeWU9YnQsZXhwb3J0cy5GYWNlbWVzaEV5ZURlZmF1bHRzPXd0LGV4cG9ydHMuRmlyc3RQZXJzb25Db250cm9scz1odCxleHBvcnRzLkZpc2hleWU9ZnVuY3Rpb24oe3JlbmRlclByaW9yaXR5OmU9MSx6b29tOnQ9MCxzZWdtZW50czpyPTY0LGNoaWxkcmVuOm4scmVzb2x1dGlvbjpvPTg5NiwuLi5pfSl7Y29uc3Qgcz1QLnVzZVJlZihudWxsKSxsPVAudXNlUmVmKG51bGwpLHt3aWR0aDpjLGhlaWdodDp1fT1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxbZF09UC51c2VTdGF0ZSgoKCk9Pm5ldyBELk9ydGhvZ3JhcGhpY0NhbWVyYSkpO1AudXNlTGF5b3V0RWZmZWN0KCgoKT0+e2QucG9zaXRpb24uc2V0KDAsMCwxMDApLGQuem9vbT0xMDAsZC5sZWZ0PWMvLTIsZC5yaWdodD1jLzIsZC50b3A9dS8yLGQuYm90dG9tPXUvLTIsZC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9KSxbYyx1XSk7Y29uc3QgbT1NYXRoLnNxcnQoYypjK3UqdSkvMTAwKiguNSt0LzIpLGY9bmV3IEQuVmVjdG9yMyxwPW5ldyBELlNwaGVyZShuZXcgRC5WZWN0b3IzLG0pLGg9bmV3IEQuTWF0cml4Myx4PVAudXNlQ2FsbGJhY2soKChlLHQscik9Pnt0LnBvaW50ZXIuc2V0KGUub2Zmc2V0WC90LnNpemUud2lkdGgqMi0xLC1lLm9mZnNldFkvdC5zaXplLmhlaWdodCoyKzEpLHQucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEodC5wb2ludGVyLGQpLHQucmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RTcGhlcmUocCxmKSYmKGYubm9ybWFsaXplKCksaC5nZXROb3JtYWxNYXRyaXgobC5jdXJyZW50LmNhbWVyYS5tYXRyaXhXb3JsZCksbC5jdXJyZW50LmNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHQucmF5Y2FzdGVyLnJheS5vcmlnaW4pLHQucmF5Y2FzdGVyLnJheS5kaXJlY3Rpb24uc2V0KDAsMCwxKS5yZWZsZWN0KGYpLHQucmF5Y2FzdGVyLnJheS5kaXJlY3Rpb24ueCo9LTEsdC5yYXljYXN0ZXIucmF5LmRpcmVjdGlvbi5hcHBseU5vcm1hbE1hdHJpeChoKS5tdWx0aXBseVNjYWxhcigtMSkpfSksW10pO3JldHVybiBhLnVzZUZyYW1lKCh0PT57ZSYmdC5nbC5yZW5kZXIocy5jdXJyZW50LGQpfSksZSksUC5jcmVhdGVFbGVtZW50KFAuRnJhZ21lbnQsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZWY6c30saSx7c2NhbGU6bX0pLFAuY3JlYXRlRWxlbWVudChcInNwaGVyZUdlb21ldHJ5XCIse2FyZ3M6WzEscixyXX0pLFAuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIsbnVsbCxQLmNyZWF0ZUVsZW1lbnQoQW8se2NvbXB1dGU6eCxhdHRhY2g6XCJlbnZNYXBcIixmbGlwOiEwLHJlc29sdXRpb246byxyZWY6bH0sbixQLmNyZWF0ZUVsZW1lbnQoVW8se2FwaTpsfSkpKSkpfSxleHBvcnRzLkZsb2F0PUZuLGV4cG9ydHMuRmx5Q29udHJvbHM9bHQsZXhwb3J0cy5HaXptb0hlbHBlcj0oe2FsaWdubWVudDplPVwiYm90dG9tLXJpZ2h0XCIsbWFyZ2luOnQ9WzgwLDgwXSxyZW5kZXJQcmlvcml0eTpyPTEsb25VcGRhdGU6byxvblRhcmdldDppLGNoaWxkcmVuOnN9KT0+e2NvbnN0IGw9YS51c2VUaHJlZSgoZT0+ZS5zaXplKSksYz1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpLHU9YS51c2VUaHJlZSgoZT0+ZS5jb250cm9scykpLGQ9YS51c2VUaHJlZSgoZT0+ZS5pbnZhbGlkYXRlKSksbT1QLnVzZVJlZihudWxsKSxmPVAudXNlUmVmKG51bGwpLHA9UC51c2VSZWYoITEpLGg9UC51c2VSZWYoMCkseD1QLnVzZVJlZihuZXcgbi5WZWN0b3IzKDAsMCwwKSkseT1QLnVzZVJlZihuZXcgbi5WZWN0b3IzKDAsMCwwKSk7UC51c2VFZmZlY3QoKCgpPT57eS5jdXJyZW50LmNvcHkoYy51cCl9KSxbY10pO2NvbnN0IHY9UC51c2VDYWxsYmFjaygoZT0+e3AuY3VycmVudD0hMCwodXx8aSkmJih4LmN1cnJlbnQ9KG51bGw9PXU/dm9pZCAwOnUudGFyZ2V0KXx8KG51bGw9PWk/dm9pZCAwOmkoKSkpLGguY3VycmVudD1jLnBvc2l0aW9uLmRpc3RhbmNlVG8oWHQpLCR0LmNvcHkoYy5xdWF0ZXJuaW9uKSxadC5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKGguY3VycmVudCkuYWRkKFh0KSxHdC5sb29rQXQoWnQpLEd0LnVwLmNvcHkoYy51cCkscXQuY29weShHdC5xdWF0ZXJuaW9uKSxkKCl9KSxbdSxjLGksZF0pO2EudXNlRnJhbWUoKChlLHQpPT57aWYoZi5jdXJyZW50JiZtLmN1cnJlbnQpe3ZhciByO2lmKHAuY3VycmVudClpZigkdC5hbmdsZVRvKHF0KTwuMDEpcC5jdXJyZW50PSExLFwibWluUG9sYXJBbmdsZVwiaW4gdSYmYy51cC5jb3B5KHkuY3VycmVudCk7ZWxzZXtjb25zdCBlPXQqV3Q7JHQucm90YXRlVG93YXJkcyhxdCxlKSxjLnBvc2l0aW9uLnNldCgwLDAsMSkuYXBwbHlRdWF0ZXJuaW9uKCR0KS5tdWx0aXBseVNjYWxhcihoLmN1cnJlbnQpLmFkZCh4LmN1cnJlbnQpLGMudXAuc2V0KDAsMSwwKS5hcHBseVF1YXRlcm5pb24oJHQpLm5vcm1hbGl6ZSgpLGMucXVhdGVybmlvbi5jb3B5KCR0KSxvP28oKTp1JiZ1LnVwZGF0ZSgpLGQoKX1IdC5jb3B5KGMubWF0cml4KS5pbnZlcnQoKSxudWxsPT0ocj1tLmN1cnJlbnQpfHxyLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KEh0KX19KSk7Y29uc3QgZz1QLnVzZU1lbW8oKCgpPT4oe3R3ZWVuQ2FtZXJhOnZ9KSksW3ZdKSxbeix3XT10LGI9ZS5lbmRzV2l0aChcIi1jZW50ZXJcIik/MDplLmVuZHNXaXRoKFwiLWxlZnRcIik/LWwud2lkdGgvMit6Omwud2lkdGgvMi16LE09ZS5zdGFydHNXaXRoKFwiY2VudGVyLVwiKT8wOmUuc3RhcnRzV2l0aChcInRvcC1cIik/bC5oZWlnaHQvMi13Oi1sLmhlaWdodC8yK3c7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChPdCx7cmVuZGVyUHJpb3JpdHk6cn0sUC5jcmVhdGVFbGVtZW50KE50LlByb3ZpZGVyLHt2YWx1ZTpnfSxQLmNyZWF0ZUVsZW1lbnQoYXQse21ha2VEZWZhdWx0OiEwLHJlZjpmLHBvc2l0aW9uOlswLDAsMjAwXX0pLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse3JlZjptLHBvc2l0aW9uOltiLE0sMF19LHMpKSl9LGV4cG9ydHMuR2l6bW9WaWV3Y3ViZT1lPT5QLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtzY2FsZTpbNjAsNjAsNjBdfSxQLmNyZWF0ZUVsZW1lbnQoc3IsZSksYXIubWFwKCgodCxyKT0+UC5jcmVhdGVFbGVtZW50KGxyLEMuZGVmYXVsdCh7a2V5OnIscG9zaXRpb246dCxkaW1lbnNpb25zOm9yW3JdfSxlKSkpKSxyci5tYXAoKCh0LHIpPT5QLmNyZWF0ZUVsZW1lbnQobHIsQy5kZWZhdWx0KHtrZXk6cixwb3NpdGlvbjp0LGRpbWVuc2lvbnM6bnJ9LGUpKSkpKSxleHBvcnRzLkdpem1vVmlld3BvcnQ9KHtoaWRlTmVnYXRpdmVBeGVzOmUsaGlkZUF4aXNIZWFkczp0LGRpc2FibGVkOnIsZm9udDpuPVwiMThweCBJbnRlciB2YXIsIEFyaWFsLCBzYW5zLXNlcmlmXCIsYXhpc0NvbG9yczphPVtcIiNmZjIwNjBcIixcIiMyMGRmODBcIixcIiMyMDgwZmZcIl0sYXhpc0hlYWRTY2FsZTpvPTEsYXhpc1NjYWxlOmksbGFiZWxzOnM9W1wiWFwiLFwiWVwiLFwiWlwiXSxsYWJlbENvbG9yOmw9XCIjMDAwXCIsb25DbGljazpjLC4uLnV9KT0+e2NvbnN0W2QsbSxmXT1hLHt0d2VlbkNhbWVyYTpwfT1qdCgpLGg9e2ZvbnQ6bixkaXNhYmxlZDpyLGxhYmVsQ29sb3I6bCxvbkNsaWNrOmMsYXhpc0hlYWRTY2FsZTpvLG9uUG9pbnRlckRvd246cj92b2lkIDA6ZT0+e3AoZS5vYmplY3QucG9zaXRpb24pLGUuc3RvcFByb3BhZ2F0aW9uKCl9fTtyZXR1cm4gUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3NjYWxlOjQwfSx1KSxQLmNyZWF0ZUVsZW1lbnQoY3Ise2NvbG9yOmQscm90YXRpb246WzAsMCwwXSxzY2FsZTppfSksUC5jcmVhdGVFbGVtZW50KGNyLHtjb2xvcjptLHJvdGF0aW9uOlswLDAsTWF0aC5QSS8yXSxzY2FsZTppfSksUC5jcmVhdGVFbGVtZW50KGNyLHtjb2xvcjpmLHJvdGF0aW9uOlswLC1NYXRoLlBJLzIsMF0sc2NhbGU6aX0pLCF0JiZQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudCh1cixDLmRlZmF1bHQoe2FyY1N0eWxlOmQscG9zaXRpb246WzEsMCwwXSxsYWJlbDpzWzBdfSxoKSksUC5jcmVhdGVFbGVtZW50KHVyLEMuZGVmYXVsdCh7YXJjU3R5bGU6bSxwb3NpdGlvbjpbMCwxLDBdLGxhYmVsOnNbMV19LGgpKSxQLmNyZWF0ZUVsZW1lbnQodXIsQy5kZWZhdWx0KHthcmNTdHlsZTpmLHBvc2l0aW9uOlswLDAsMV0sbGFiZWw6c1syXX0saCkpLCFlJiZQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudCh1cixDLmRlZmF1bHQoe2FyY1N0eWxlOmQscG9zaXRpb246Wy0xLDAsMF19LGgpKSxQLmNyZWF0ZUVsZW1lbnQodXIsQy5kZWZhdWx0KHthcmNTdHlsZTptLHBvc2l0aW9uOlswLC0xLDBdfSxoKSksUC5jcmVhdGVFbGVtZW50KHVyLEMuZGVmYXVsdCh7YXJjU3R5bGU6Zixwb3NpdGlvbjpbMCwwLC0xXX0saCkpKSkpfSxleHBvcnRzLkdsdGY9S2UsZXhwb3J0cy5HcmFkaWVudFRleHR1cmU9ZnVuY3Rpb24oe3N0b3BzOmUsY29sb3JzOnQsc2l6ZTpyPTEwMjQsd2lkdGg6bj0xNix0eXBlOm89TWUuTGluZWFyLGlubmVyQ2lyY2xlUmFkaXVzOmk9MCxvdXRlckNpcmNsZVJhZGl1czpzPVwiYXV0b1wiLC4uLmx9KXtjb25zdCBjPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSx1PVAudXNlTWVtbygoKCk9Pntjb25zdCBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksbD1hLmdldENvbnRleHQoXCIyZFwiKTtsZXQgYztpZihhLndpZHRoPW4sYS5oZWlnaHQ9cixvPT09TWUuTGluZWFyKWM9bC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLDAsMCxyKTtlbHNle2NvbnN0IGU9YS53aWR0aC8yLHQ9YS5oZWlnaHQvMixyPVwiYXV0b1wiIT09cz9NYXRoLmFicyhOdW1iZXIocykpOk1hdGguc3FydChlKioyK3QqKjIpO2M9bC5jcmVhdGVSYWRpYWxHcmFkaWVudChlLHQsTWF0aC5hYnMoaSksZSx0LHIpfWxldCB1PWUubGVuZ3RoO2Zvcig7dS0tOyljLmFkZENvbG9yU3RvcChlW3VdLHRbdV0pO3JldHVybiBsLnNhdmUoKSxsLmZpbGxTdHlsZT1jLGwuZmlsbFJlY3QoMCwwLG4sciksbC5yZXN0b3JlKCksYX0pLFtlXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChcImNhbnZhc1RleHR1cmVcIixDLmRlZmF1bHQoe2NvbG9yU3BhY2U6Yy5vdXRwdXRDb2xvclNwYWNlLGFyZ3M6W3VdLGF0dGFjaDpcIm1hcFwifSxsKSl9LGV4cG9ydHMuR3JhZGllbnRUeXBlPU1lLGV4cG9ydHMuR3JpZD1tcixleHBvcnRzLkh0bWw9WSxleHBvcnRzLkh1ZD1PdCxleHBvcnRzLkljb3NhaGVkcm9uPWRuLGV4cG9ydHMuSW1hZ2U9a2UsZXhwb3J0cy5JbnN0YW5jZT12byxleHBvcnRzLkluc3RhbmNlcz1nbyxleHBvcnRzLklzT2JqZWN0PVNlLGV4cG9ydHMuS2V5Ym9hcmRDb250cm9scz1mdW5jdGlvbih7bWFwOmUsY2hpbGRyZW46dCxvbkNoYW5nZTpyLGRvbUVsZW1lbnQ6bn0pe2NvbnN0IGE9ZS5tYXAoKGU9PmUubmFtZStlLmtleXMpKS5qb2luKFwiLVwiKSxvPVAudXNlTWVtbygoKCk9PkYuZGVmYXVsdCh1LnN1YnNjcmliZVdpdGhTZWxlY3RvcigoKCk9PmUucmVkdWNlKCgoZSx0KT0+KHsuLi5lLFt0Lm5hbWVdOiExfSkpLHt9KSkpKSksW2FdKSxpPVAudXNlTWVtbygoKCk9PltvLnN1YnNjcmliZSxvLmdldFN0YXRlLG9dKSxbYV0pLHM9by5zZXRTdGF0ZTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT57Y29uc3QgdD1lLm1hcCgoKHtuYW1lOmUsa2V5czp0LHVwOm59KT0+KHtrZXlzOnQsdXA6bixmbjp0PT57cyh7W2VdOnR9KSxyJiZyKGUsdCxpWzFdKCkpfX0pKSkucmVkdWNlKCgoZSx7a2V5czp0LGZuOnIsdXA6bj0hMH0pPT4odC5mb3JFYWNoKCh0PT5lW3RdPXtmbjpyLHByZXNzZWQ6ITEsdXA6bn0pKSxlKSkse30pLGE9KHtrZXk6ZSxjb2RlOnJ9KT0+e2NvbnN0IG49dFtlXXx8dFtyXTtpZighbilyZXR1cm47Y29uc3R7Zm46YSxwcmVzc2VkOm8sdXA6aX09bjtuLnByZXNzZWQ9ITAsIWkmJm98fGEoITApfSxvPSh7a2V5OmUsY29kZTpyfSk9Pntjb25zdCBuPXRbZV18fHRbcl07aWYoIW4pcmV0dXJuO2NvbnN0e2ZuOmEsdXA6b309bjtuLnByZXNzZWQ9ITEsbyYmYSghMSl9LGw9bnx8d2luZG93O3JldHVybiBsLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsYSx7cGFzc2l2ZTohMH0pLGwuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbyx7cGFzc2l2ZTohMH0pLCgpPT57bC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGEpLGwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsbyl9fSksW24sYV0pLFAuY3JlYXRlRWxlbWVudChpZS5Qcm92aWRlcix7dmFsdWU6aSxjaGlsZHJlbjp0fSl9LGV4cG9ydHMuTGF0aGU9aG4sZXhwb3J0cy5MaWdodGZvcm1lcj1wYSxleHBvcnRzLkxpbmU9dWUsZXhwb3J0cy5Mb2FkZXI9ZnVuY3Rpb24oe2NvbnRhaW5lclN0eWxlczplLGlubmVyU3R5bGVzOnQsYmFyU3R5bGVzOnIsZGF0YVN0eWxlczpuLGRhdGFJbnRlcnBvbGF0aW9uOmE9Sixpbml0aWFsU3RhdGU6bz0oZT0+ZSl9KXtjb25zdHthY3RpdmU6aSxwcm9ncmVzczpzfT1LKCksbD1QLnVzZVJlZigwKSxjPVAudXNlUmVmKDApLHU9UC51c2VSZWYobnVsbCksW2QsbV09UC51c2VTdGF0ZShvKGkpKTtQLnVzZUVmZmVjdCgoKCk9PntsZXQgZTtyZXR1cm4gaSE9PWQmJihlPXNldFRpbWVvdXQoKCgpPT5tKGkpKSwzMDApKSwoKT0+Y2xlYXJUaW1lb3V0KGUpfSksW2QsaV0pO2NvbnN0IGY9UC51c2VDYWxsYmFjaygoKCk9Pnt1LmN1cnJlbnQmJihsLmN1cnJlbnQrPShzLWwuY3VycmVudCkvMiwobC5jdXJyZW50Pi45NSpzfHwxMDA9PT1zKSYmKGwuY3VycmVudD1zKSx1LmN1cnJlbnQuaW5uZXJUZXh0PWEobC5jdXJyZW50KSxsLmN1cnJlbnQ8cyYmKGMuY3VycmVudD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZikpKX0pLFthLHNdKTtyZXR1cm4gUC51c2VFZmZlY3QoKCgpPT4oZigpLCgpPT5jYW5jZWxBbmltYXRpb25GcmFtZShjLmN1cnJlbnQpKSksW2ZdKSxkP1AuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTp7Li4uZWUuY29udGFpbmVyLG9wYWNpdHk6aT8xOjAsLi4uZX19LFAuY3JlYXRlRWxlbWVudChcImRpdlwiLG51bGwsUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOnsuLi5lZS5pbm5lciwuLi50fX0sUC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3N0eWxlOnsuLi5lZS5iYXIsdHJhbnNmb3JtOmBzY2FsZVgoJHtzLzEwMH0pYCwuLi5yfX0pLFAuY3JlYXRlRWxlbWVudChcInNwYW5cIix7cmVmOnUsc3R5bGU6ey4uLmVlLmRhdGEsLi4ubn19KSkpKTpudWxsfSxleHBvcnRzLk1hcENvbnRyb2xzPWN0LGV4cG9ydHMuTWFyY2hpbmdDdWJlPVdlLGV4cG9ydHMuTWFyY2hpbmdDdWJlcz1qZSxleHBvcnRzLk1hcmNoaW5nUGxhbmU9R2UsZXhwb3J0cy5NYXNrPUJvLGV4cG9ydHMuTWVyZ2VkPXpvLGV4cG9ydHMuTWVzaERpc2NhcmRNYXRlcmlhbD0kcixleHBvcnRzLk1lc2hEaXN0b3J0TWF0ZXJpYWw9THIsZXhwb3J0cy5NZXNoUG9ydGFsTWF0ZXJpYWw9Vm8sZXhwb3J0cy5NZXNoUmVmbGVjdG9yTWF0ZXJpYWw9TnIsZXhwb3J0cy5NZXNoUmVmcmFjdGlvbk1hdGVyaWFsPWZ1bmN0aW9uKHthYmVycmF0aW9uU3RyZW5ndGg6ZT0wLGZhc3RDaHJvbWE6cj0hMCxlbnZNYXA6biwuLi5vfSl7YS5leHRlbmQoe01lc2hSZWZyYWN0aW9uTWF0ZXJpYWw6anJ9KTtjb25zdCBpPXQudXNlUmVmKCkse3NpemU6c309YS51c2VUaHJlZSgpLGw9dC51c2VNZW1vKCgoKT0+e3ZhciB0LGE7Y29uc3Qgbz17fSxpPShzPW4pJiZzLmlzQ3ViZVRleHR1cmU7dmFyIHM7Y29uc3QgbD0obnVsbCE9PSh0PWk/bnVsbD09KGE9bi5pbWFnZVswXSk/dm9pZCAwOmEud2lkdGg6bi5pbWFnZS53aWR0aCkmJnZvaWQgMCE9PXQ/dDoxMDI0KS80LGM9TWF0aC5mbG9vcihNYXRoLmxvZzIobCkpLHU9TWF0aC5wb3coMixjKSxkPTMqTWF0aC5tYXgodSwxMTIpLG09NCp1O3JldHVybiBpJiYoby5FTlZNQVBfVFlQRV9DVUJFTT1cIlwiKSxvLkNVQkVVVl9URVhFTF9XSURUSD1cIlwiKzEvZCxvLkNVQkVVVl9URVhFTF9IRUlHSFQ9XCJcIisxL20sby5DVUJFVVZfTUFYX01JUD1gJHtjfS4wYCxlPjAmJihvLkNIUk9NQVRJQ19BQkVSUkFUSU9OUz1cIlwiKSxyJiYoby5GQVNUX0NIUk9NQT1cIlwiKSxvfSksW2Uscl0pO3JldHVybiB0LnVzZUxheW91dEVmZmVjdCgoKCk9Pnt2YXIgZTtjb25zdCB0PW51bGw9PShlPWkuY3VycmVudCl8fG51bGw9PShlPWUuX19yM2YpfHxudWxsPT0oZT1lLnBhcmVudCk/dm9pZCAwOmUuZ2VvbWV0cnk7dCYmKGkuY3VycmVudC5idmg9bmV3IHcuTWVzaEJWSFVuaWZvcm1TdHJ1Y3QsaS5jdXJyZW50LmJ2aC51cGRhdGVGcm9tKG5ldyB3Lk1lc2hCVkgodC5jbG9uZSgpLnRvTm9uSW5kZXhlZCgpLHtsYXp5R2VuZXJhdGlvbjohMSxzdHJhdGVneTp3LlNBSH0pKSl9KSxbXSksYS51c2VGcmFtZSgoKHtjYW1lcmE6ZX0pPT57aS5jdXJyZW50LnZpZXdNYXRyaXhJbnZlcnNlPWUubWF0cml4V29ybGQsaS5jdXJyZW50LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlPWUucHJvamVjdGlvbk1hdHJpeEludmVyc2V9KSksUC5jcmVhdGVFbGVtZW50KFwibWVzaFJlZnJhY3Rpb25NYXRlcmlhbFwiLEMuZGVmYXVsdCh7a2V5OkpTT04uc3RyaW5naWZ5KGwpLGRlZmluZXM6bCxyZWY6aSxyZXNvbHV0aW9uOltzLndpZHRoLHMuaGVpZ2h0XSxhYmVycmF0aW9uU3RyZW5ndGg6ZSxlbnZNYXA6bn0sbykpfSxleHBvcnRzLk1lc2hUcmFuc21pc3Npb25NYXRlcmlhbD1IcixleHBvcnRzLk1lc2hXb2JibGVNYXRlcmlhbD1VcixleHBvcnRzLk1vdGlvblBhdGhDb250cm9scz1JdCxleHBvcnRzLk9jdGFoZWRyb249bW4sZXhwb3J0cy5PcmJpdENvbnRyb2xzPXV0LGV4cG9ydHMuT3J0aG9ncmFwaGljQ2FtZXJhPWF0LGV4cG9ydHMuT3V0bGluZXM9ZnVuY3Rpb24oe2NvbG9yOmU9XCJibGFja1wiLG9wYWNpdHk6dD0xLHRyYW5zcGFyZW50OnI9ITEsc2NyZWVuc3BhY2U6bj0hMSx0b25lTWFwcGVkOm89ITAscG9seWdvbk9mZnNldDppPSExLHBvbHlnb25PZmZzZXRGYWN0b3I6cz0wLHJlbmRlck9yZGVyOmw9MCx0aGlja25lc3M6Yz0uMDUsYW5nbGU6dT1NYXRoLlBJLC4uLm19KXtjb25zdCBmPVAudXNlUmVmKCksW3BdPVAudXNlU3RhdGUoKCgpPT5uZXcgQWUoe3NpZGU6RC5CYWNrU2lkZX0pKSkse2dsOmh9PWEudXNlVGhyZWUoKSx4PWguZ2V0RHJhd2luZ0J1ZmZlclNpemUobmV3IEQuVmVjdG9yMik7UC51c2VNZW1vKCgoKT0+YS5leHRlbmQoe091dGxpbmVzTWF0ZXJpYWw6QWV9KSksW10pO2NvbnN0IHk9UC51c2VSZWYoMCksdj1QLnVzZVJlZigpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCBlPWYuY3VycmVudDtpZighZSlyZXR1cm47Y29uc3QgdD1lLnBhcmVudDtpZih0JiZ0Lmdlb21ldHJ5JiYoeS5jdXJyZW50IT09dXx8di5jdXJyZW50IT09dC5nZW9tZXRyeSkpe3kuY3VycmVudD11LHYuY3VycmVudD10Lmdlb21ldHJ5O2xldCByPWUuY2hpbGRyZW5bMF07ciYmKHUmJnIuZ2VvbWV0cnkuZGlzcG9zZSgpLGUucmVtb3ZlKHIpKSx0LnNrZWxldG9uPyhyPW5ldyBELlNraW5uZWRNZXNoLHIubWF0ZXJpYWw9cCxyLmJpbmQodC5za2VsZXRvbix0LmJpbmRNYXRyaXgpLGUuYWRkKHIpKTp0LmlzSW5zdGFuY2VkTWVzaD8ocj1uZXcgRC5JbnN0YW5jZWRNZXNoKHQuZ2VvbWV0cnkscCx0LmNvdW50KSxyLmluc3RhbmNlTWF0cml4PXQuaW5zdGFuY2VNYXRyaXgsZS5hZGQocikpOihyPW5ldyBELk1lc2gsci5tYXRlcmlhbD1wLGUuYWRkKHIpKSxyLmdlb21ldHJ5PXU/ZC50b0NyZWFzZWROb3JtYWxzKHQuZ2VvbWV0cnksdSk6dC5nZW9tZXRyeX19KSksUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgdT1mLmN1cnJlbnQ7aWYoIXUpcmV0dXJuO2NvbnN0IGQ9dS5jaGlsZHJlblswXTtkJiYoZC5yZW5kZXJPcmRlcj1sLGEuYXBwbHlQcm9wcyhkLm1hdGVyaWFsLHt0cmFuc3BhcmVudDpyLHRoaWNrbmVzczpjLGNvbG9yOmUsb3BhY2l0eTp0LHNpemU6eCxzY3JlZW5zcGFjZTpuLHRvbmVNYXBwZWQ6byxwb2x5Z29uT2Zmc2V0OmkscG9seWdvbk9mZnNldEZhY3RvcjpzfSkpfSkpLFAudXNlRWZmZWN0KCgoKT0+KCk9Pntjb25zdCBlPWYuY3VycmVudDtpZighZSlyZXR1cm47Y29uc3QgdD1lLmNoaWxkcmVuWzBdO3QmJih1JiZ0Lmdlb21ldHJ5LmRpc3Bvc2UoKSxlLnJlbW92ZSh0KSl9KSxbXSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjpmfSxtKSl9LGV4cG9ydHMuUGVyZm9ybWFuY2VNb25pdG9yPWZ1bmN0aW9uKHtpdGVyYXRpb25zOmU9MTAsbXM6cj0yNTAsdGhyZXNob2xkOm49Ljc1LHN0ZXA6bz0uMSxmYWN0b3I6aT0uNSxmbGlwZmxvcHM6cz0xLzAsYm91bmRzOmw9KGU9PmU+MTAwP1s2MCwxMDBdOls0MCw2MF0pLG9uSW5jbGluZTpjLG9uRGVjbGluZTp1LG9uQ2hhbmdlOmQsb25GYWxsYmFjazptLGNoaWxkcmVuOmZ9KXtjb25zdCBwPU1hdGgucG93KDEwLDApLFtoLHhdPXQudXNlU3RhdGUoKCgpPT4oe2ZwczowLGluZGV4OjAsZmFjdG9yOmksZmxpcHBlZDowLHJlZnJlc2hyYXRlOjAsZmFsbGJhY2s6ITEsZnJhbWVzOltdLGF2ZXJhZ2VzOltdLHN1YnNjcmlwdGlvbnM6bmV3IE1hcCxzdWJzY3JpYmU6ZT0+e2NvbnN0IHQ9U3ltYm9sKCk7cmV0dXJuIGguc3Vic2NyaXB0aW9ucy5zZXQodCxlLmN1cnJlbnQpLCgpPT57aC5zdWJzY3JpcHRpb25zLmRlbGV0ZSh0KX19fSkpKTtsZXQgeT0wO3JldHVybiBhLnVzZUZyYW1lKCgoKT0+e2NvbnN0e2ZyYW1lczp0LGF2ZXJhZ2VzOmF9PWg7aWYoIWguZmFsbGJhY2smJmEubGVuZ3RoPGUpe3QucHVzaChwZXJmb3JtYW5jZS5ub3coKSk7Y29uc3QgaT10W3QubGVuZ3RoLTFdLXRbMF07aWYoaT49cil7aWYoaC5mcHM9TWF0aC5yb3VuZCh0Lmxlbmd0aC9pKjFlMypwKS9wLGgucmVmcmVzaHJhdGU9TWF0aC5tYXgoaC5yZWZyZXNocmF0ZSxoLmZwcyksYVtoLmluZGV4KyslZV09aC5mcHMsYS5sZW5ndGg9PT1lKXtjb25zdFt0LHJdPWwoaC5yZWZyZXNocmF0ZSksaT1hLmZpbHRlcigoZT0+ZT49cikpLGY9YS5maWx0ZXIoKGU9PmU8dCkpO2kubGVuZ3RoPmUqbiYmKGguZmFjdG9yPU1hdGgubWluKDEsaC5mYWN0b3IrbyksaC5mbGlwcGVkKyssYyYmYyhoKSxoLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoZT0+ZS5vbkluY2xpbmUmJmUub25JbmNsaW5lKGgpKSkpLGYubGVuZ3RoPmUqbiYmKGguZmFjdG9yPU1hdGgubWF4KDAsaC5mYWN0b3ItbyksaC5mbGlwcGVkKyssdSYmdShoKSxoLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoZT0+ZS5vbkRlY2xpbmUmJmUub25EZWNsaW5lKGgpKSkpLHkhPT1oLmZhY3RvciYmKHk9aC5mYWN0b3IsZCYmZChoKSxoLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoZT0+ZS5vbkNoYW5nZSYmZS5vbkNoYW5nZShoKSkpKSxoLmZsaXBwZWQ+cyYmIWguZmFsbGJhY2smJihoLmZhbGxiYWNrPSEwLG0mJm0oaCksaC5zdWJzY3JpcHRpb25zLmZvckVhY2goKGU9PmUub25GYWxsYmFjayYmZS5vbkZhbGxiYWNrKGgpKSkpLGguYXZlcmFnZXM9W119aC5mcmFtZXM9W119fX0pKSxQLmNyZWF0ZUVsZW1lbnQoRm8uUHJvdmlkZXIse3ZhbHVlOmh9LGYpfSxleHBvcnRzLlBlcnNwZWN0aXZlQ2FtZXJhPW90LGV4cG9ydHMuUGl2b3RDb250cm9scz1raSxleHBvcnRzLlBsYW5lPW5uLGV4cG9ydHMuUG9pbnQ9cm8sZXhwb3J0cy5Qb2ludE1hdGVyaWFsPVpyLGV4cG9ydHMuUG9pbnRNYXRlcmlhbEltcGw9WHIsZXhwb3J0cy5Qb2ludGVyTG9ja0NvbnRyb2xzPXB0LGV4cG9ydHMuUG9pbnRzPWFvLGV4cG9ydHMuUG9pbnRzQnVmZmVyPW5vLGV4cG9ydHMuUG9seWhlZHJvbj11bixleHBvcnRzLlBvc2l0aW9uUG9pbnQ9WmEsZXhwb3J0cy5Qb3NpdGlvbmFsQXVkaW89aGUsZXhwb3J0cy5QcmVsb2FkPWZ1bmN0aW9uKHthbGw6ZSxzY2VuZTp0LGNhbWVyYTpyfSl7Y29uc3Qgbz1hLnVzZVRocmVlKCgoe2dsOmV9KT0+ZSkpLGk9YS51c2VUaHJlZSgoKHtjYW1lcmE6ZX0pPT5lKSkscz1hLnVzZVRocmVlKCgoe3NjZW5lOmV9KT0+ZSkpO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9Pntjb25zdCBhPVtdO2UmJih0fHxzKS50cmF2ZXJzZSgoZT0+eyExPT09ZS52aXNpYmxlJiYoYS5wdXNoKGUpLGUudmlzaWJsZT0hMCl9KSksby5jb21waWxlKHR8fHMscnx8aSk7Y29uc3QgbD1uZXcgbi5XZWJHTEN1YmVSZW5kZXJUYXJnZXQoMTI4KTtuZXcgbi5DdWJlQ2FtZXJhKC4wMSwxZTUsbCkudXBkYXRlKG8sdHx8cyksbC5kaXNwb3NlKCksYS5mb3JFYWNoKChlPT5lLnZpc2libGU9ITEpKX0pLFtdKSxudWxsfSxleHBvcnRzLlByZXNlbnRhdGlvbkNvbnRyb2xzPWZ1bmN0aW9uKHtlbmFibGVkOmU9ITAsc25hcDp0LGdsb2JhbDpyLGRvbUVsZW1lbnQ6byxjdXJzb3I6aT0hMCxjaGlsZHJlbjpzLHNwZWVkOnU9MSxyb3RhdGlvbjpkPVswLDAsMF0sem9vbTptPTEscG9sYXI6Zj1bMCxNYXRoLlBJLzJdLGF6aW11dGg6cD1bLTEvMCwxLzBdLGNvbmZpZzpoPXttYXNzOjEsdGVuc2lvbjoxNzAsZnJpY3Rpb246MjZ9fSl7Y29uc3QgeD1hLnVzZVRocmVlKChlPT5lLmV2ZW50cykpLHk9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLHY9b3x8eC5jb25uZWN0ZWR8fHkuZG9tRWxlbWVudCx7c2l6ZTpnfT1hLnVzZVRocmVlKCksej1QLnVzZU1lbW8oKCgpPT5bZFswXStmWzBdLGRbMF0rZlsxXV0pLFtkWzBdLGZbMF0sZlsxXV0pLHc9UC51c2VNZW1vKCgoKT0+W2RbMV0rcFswXSxkWzFdK3BbMV1dKSxbZFsxXSxwWzBdLHBbMV1dKSxiPVAudXNlTWVtbygoKCk9PltuLk1hdGhVdGlscy5jbGFtcChkWzBdLC4uLnopLG4uTWF0aFV0aWxzLmNsYW1wKGRbMV0sLi4udyksZFsyXV0pLFtkWzBdLGRbMV0sZFsyXSx6LHddKSxbTSxFXT1sLnVzZVNwcmluZygoKCk9Pih7c2NhbGU6MSxyb3RhdGlvbjpiLGNvbmZpZzpofSkpKTtQLnVzZUVmZmVjdCgoKCk9PntFLnN0YXJ0KHtzY2FsZToxLHJvdGF0aW9uOmIsY29uZmlnOmh9KX0pLFtiXSksUC51c2VFZmZlY3QoKCgpPT57aWYociYmaSYmZSlyZXR1cm4gdi5zdHlsZS5jdXJzb3I9XCJncmFiXCIseS5kb21FbGVtZW50LnN0eWxlLmN1cnNvcj1cIlwiLCgpPT57di5zdHlsZS5jdXJzb3I9XCJkZWZhdWx0XCIseS5kb21FbGVtZW50LnN0eWxlLmN1cnNvcj1cImRlZmF1bHRcIn19KSxbcixpLHYsZV0pO2NvbnN0IFM9Yy51c2VHZXN0dXJlKHtvbkhvdmVyOih7bGFzdDp0fSk9PntpJiYhciYmZSYmKHYuc3R5bGUuY3Vyc29yPXQ/XCJhdXRvXCI6XCJncmFiXCIpfSxvbkRyYWc6KHtkb3duOnIsZGVsdGE6W2Esb10sbWVtbzpbcyxsXT1NLnJvdGF0aW9uLmFuaW1hdGlvbi50b3x8Yn0pPT57aWYoIWUpcmV0dXJuW28sYV07aSYmKHYuc3R5bGUuY3Vyc29yPXI/XCJncmFiYmluZ1wiOlwiZ3JhYlwiKSxhPW4uTWF0aFV0aWxzLmNsYW1wKGwrYS9nLndpZHRoKk1hdGguUEkqdSwuLi53KSxvPW4uTWF0aFV0aWxzLmNsYW1wKHMrby9nLmhlaWdodCpNYXRoLlBJKnUsLi4ueik7Y29uc3QgYz10JiYhciYmXCJib29sZWFuXCIhPXR5cGVvZiB0P3Q6aDtyZXR1cm4gRS5zdGFydCh7c2NhbGU6ciYmbz56WzFdLzI/bToxLHJvdGF0aW9uOnQmJiFyP2I6W28sYSwwXSxjb25maWc6ZT0+XCJzY2FsZVwiPT09ZT97Li4uYyxmcmljdGlvbjozKmMuZnJpY3Rpb259OmN9KSxbbyxhXX19LHt0YXJnZXQ6cj92OnZvaWQgMH0pO3JldHVybiBQLmNyZWF0ZUVsZW1lbnQobC5hLmdyb3VwLEMuZGVmYXVsdCh7fSxudWxsPT1TP3ZvaWQgMDpTKCksTSkscyl9LGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyTGluZT1tZSxleHBvcnRzLlJhbmRvbWl6ZWRMaWdodD1xbixleHBvcnRzLlJlZmxlY3Rvcj1vYSxleHBvcnRzLlJlbmRlckN1YmVUZXh0dXJlPUFvLGV4cG9ydHMuUmVuZGVyVGV4dHVyZT1rbyxleHBvcnRzLlJlc2l6ZT1ibixleHBvcnRzLlJpbmc9Y24sZXhwb3J0cy5Sb3VuZGVkQm94PWduLGV4cG9ydHMuU2FtcGxlcj1mdW5jdGlvbih7Y2hpbGRyZW46ZSx3ZWlnaHQ6dCx0cmFuc2Zvcm06cixpbnN0YW5jZXM6bixtZXNoOmEsY291bnQ6bz0xNiwuLi5pfSl7Y29uc3Qgcz1QLnVzZVJlZihudWxsKSxsPVAudXNlUmVmKG51bGwpLGM9UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlTGF5b3V0RWZmZWN0KCgoKT0+e3ZhciBlLHQ7bC5jdXJyZW50PW51bGwhPT0oZT1udWxsPT1uP3ZvaWQgMDpuLmN1cnJlbnQpJiZ2b2lkIDAhPT1lP2U6cy5jdXJyZW50LmNoaWxkcmVuLmZpbmQoKGU9PmUuaGFzT3duUHJvcGVydHkoXCJpbnN0YW5jZU1hdHJpeFwiKSkpLGMuY3VycmVudD1udWxsIT09KHQ9bnVsbD09YT92b2lkIDA6YS5jdXJyZW50KSYmdm9pZCAwIT09dD90OnMuY3VycmVudC5jaGlsZHJlbi5maW5kKChlPT5cIk1lc2hcIj09PWUudHlwZSkpfSksW2UsbnVsbD09YT92b2lkIDA6YS5jdXJyZW50LG51bGw9PW4/dm9pZCAwOm4uY3VycmVudF0pLFZlKGMsbyxyLHQsbCksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjpzfSxpKSxlKX0sZXhwb3J0cy5TY3JlZW5RdWFkPXduLGV4cG9ydHMuU2NyZWVuU3BhY2U9Y2UsZXhwb3J0cy5TY3JvbGw9b2UsZXhwb3J0cy5TY3JvbGxDb250cm9scz1mdW5jdGlvbih7ZXBzOmU9MWUtNSxlbmFibGVkOnQ9ITAsaW5maW5pdGU6cixob3Jpem9udGFsOm4scGFnZXM6bz0xLGRpc3RhbmNlOmk9MSxkYW1waW5nOmw9LjI1LG1heFNwZWVkOmM9MS8wLHN0eWxlOnU9e30sY2hpbGRyZW46ZH0pe2NvbnN0e2dldDptLHNldEV2ZW50czpmLGdsOnAsc2l6ZTpoLGludmFsaWRhdGU6eCxldmVudHM6eX09YS51c2VUaHJlZSgpLFt2XT1QLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLFtnXT1QLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLFt6XT1QLnVzZVN0YXRlKCgoKT0+ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkpLHc9cC5kb21FbGVtZW50LnBhcmVudE5vZGUsYj1QLnVzZVJlZigwKSxNPVAudXNlTWVtbygoKCk9Pntjb25zdCB0PXtlbDp2LGVwczplLGZpbGw6ZyxmaXhlZDp6LGhvcml6b250YWw6bixkYW1waW5nOmwsb2Zmc2V0OjAsZGVsdGE6MCxzY3JvbGw6YixwYWdlczpvLHJhbmdlKGUsdCxyPTApe2NvbnN0IG49ZS1yLGE9bit0KzIqcjtyZXR1cm4gdGhpcy5vZmZzZXQ8bj8wOnRoaXMub2Zmc2V0PmE/MToodGhpcy5vZmZzZXQtbikvKGEtbil9LGN1cnZlKGUsdCxyPTApe3JldHVybiBNYXRoLnNpbih0aGlzLnJhbmdlKGUsdCxyKSpNYXRoLlBJKX0sdmlzaWJsZShlLHQscj0wKXtjb25zdCBuPWUtcixhPW4rdCsyKnI7cmV0dXJuIHRoaXMub2Zmc2V0Pj1uJiZ0aGlzLm9mZnNldDw9YX19O3JldHVybiB0fSksW2UsbCxuLG9dKTtQLnVzZUVmZmVjdCgoKCk9Pnt2LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix2LnN0eWxlLndpZHRoPVwiMTAwJVwiLHYuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHYuc3R5bGVbbj9cIm92ZXJmbG93WFwiOlwib3ZlcmZsb3dZXCJdPVwiYXV0b1wiLHYuc3R5bGVbbj9cIm92ZXJmbG93WVwiOlwib3ZlcmZsb3dYXCJdPVwiaGlkZGVuXCIsdi5zdHlsZS50b3A9XCIwcHhcIix2LnN0eWxlLmxlZnQ9XCIwcHhcIjtmb3IoY29uc3QgZSBpbiB1KXYuc3R5bGVbZV09dVtlXTt6LnN0eWxlLnBvc2l0aW9uPVwic3RpY2t5XCIsei5zdHlsZS50b3A9XCIwcHhcIix6LnN0eWxlLmxlZnQ9XCIwcHhcIix6LnN0eWxlLndpZHRoPVwiMTAwJVwiLHouc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHouc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix2LmFwcGVuZENoaWxkKHopLGcuc3R5bGUuaGVpZ2h0PW4/XCIxMDAlXCI6byppKjEwMCtcIiVcIixnLnN0eWxlLndpZHRoPW4/byppKjEwMCtcIiVcIjpcIjEwMCVcIixnLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsdi5hcHBlbmRDaGlsZChnKSx3LmFwcGVuZENoaWxkKHYpLHZbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0xO2NvbnN0IGU9eS5jb25uZWN0ZWR8fHAuZG9tRWxlbWVudDtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT5udWxsPT15LmNvbm5lY3Q/dm9pZCAwOnkuY29ubmVjdCh2KSkpO2NvbnN0IHQ9bSgpLmV2ZW50cy5jb21wdXRlO3JldHVybiBmKHtjb21wdXRlKGUsdCl7Y29uc3R7bGVmdDpyLHRvcDpufT13LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGE9ZS5jbGllbnRYLXIsbz1lLmNsaWVudFktbjt0LnBvaW50ZXIuc2V0KGEvdC5zaXplLndpZHRoKjItMSwtby90LnNpemUuaGVpZ2h0KjIrMSksdC5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0LnBvaW50ZXIsdC5jYW1lcmEpfX0pLCgpPT57dy5yZW1vdmVDaGlsZCh2KSxmKHtjb21wdXRlOnR9KSxudWxsPT15LmNvbm5lY3R8fHkuY29ubmVjdChlKX19KSxbbyxpLG4sdixnLHosd10pLFAudXNlRWZmZWN0KCgoKT0+e2lmKHkuY29ubmVjdGVkPT09dil7Y29uc3QgZT1oW24/XCJ3aWR0aFwiOlwiaGVpZ2h0XCJdLGE9dltuP1wic2Nyb2xsV2lkdGhcIjpcInNjcm9sbEhlaWdodFwiXSxvPWEtZTtsZXQgaT0wLHM9ITAsbD0hMDtjb25zdCBjPSgpPT57aWYodCYmIWwmJih4KCksaT12W24/XCJzY3JvbGxMZWZ0XCI6XCJzY3JvbGxUb3BcIl0sYi5jdXJyZW50PWkvbyxyKSl7aWYoIXMpaWYoaT49byl7Y29uc3QgZT0xLU0ub2Zmc2V0O3Zbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT0xLGIuY3VycmVudD1NLm9mZnNldD0tZSxzPSEwfWVsc2UgaWYoaTw9MCl7Y29uc3QgZT0xK00ub2Zmc2V0O3Zbbj9cInNjcm9sbExlZnRcIjpcInNjcm9sbFRvcFwiXT1hLGIuY3VycmVudD1NLm9mZnNldD1lLHM9ITB9cyYmc2V0VGltZW91dCgoKCk9PnM9ITEpLDQwKX19O3YuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLGMse3Bhc3NpdmU6ITB9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCgpPT5sPSExKSk7Y29uc3QgdT1lPT52LnNjcm9sbExlZnQrPWUuZGVsdGFZLzI7cmV0dXJuIG4mJnYuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsdSx7cGFzc2l2ZTohMH0pLCgpPT57di5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsYyksbiYmdi5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIix1KX19fSksW3YseSxoLHIsTSx4LG4sdF0pO2xldCBFPTA7cmV0dXJuIGEudXNlRnJhbWUoKCh0LHIpPT57RT1NLm9mZnNldCxzLmVhc2luZy5kYW1wKE0sXCJvZmZzZXRcIixiLmN1cnJlbnQsbCxyLGMsdm9pZCAwLGUpLHMuZWFzaW5nLmRhbXAoTSxcImRlbHRhXCIsTWF0aC5hYnMoRS1NLm9mZnNldCksbCxyLGMsdm9pZCAwLGUpLE0uZGVsdGE+ZSYmeCgpfSkpLFAuY3JlYXRlRWxlbWVudCh0ZS5Qcm92aWRlcix7dmFsdWU6TX0sZCl9LGV4cG9ydHMuU2VnbWVudD1TbyxleHBvcnRzLlNlZ21lbnRPYmplY3Q9TW8sZXhwb3J0cy5TZWdtZW50cz1ibyxleHBvcnRzLlNlbGVjdD1mdW5jdGlvbih7Ym94OmUsbXVsdGlwbGU6dCxjaGlsZHJlbjpyLG9uQ2hhbmdlOm4sb25DaGFuZ2VQb2ludGVyVXA6byxib3JkZXI6aT1cIjFweCBzb2xpZCAjNTVhYWZmXCIsYmFja2dyb3VuZENvbG9yOnM9XCJyZ2JhKDc1LCAxNjAsIDI1NSwgMC4xKVwiLGZpbHRlcjpsPShlPT5lKSwuLi5jfSl7Y29uc3RbdSxtXT1QLnVzZVN0YXRlKCExKSx7c2V0RXZlbnRzOmYsY2FtZXJhOnAscmF5Y2FzdGVyOmgsZ2w6eCxjb250cm9sczp5LHNpemU6dixnZXQ6Z309YS51c2VUaHJlZSgpLFt6LHddPVAudXNlU3RhdGUoITEpLFtiLE1dPVAudXNlUmVkdWNlcigoKGUse29iamVjdDp0LHNoaWZ0OnJ9KT0+dm9pZCAwPT09dD9bXTpBcnJheS5pc0FycmF5KHQpP3Q6cj9lLmluY2x1ZGVzKHQpP2UuZmlsdGVyKChlPT5lIT09dCkpOlt0LC4uLmVdOmVbMF09PT10P1tdOlt0XSksW10pO1AudXNlRWZmZWN0KCgoKT0+e3U/bnVsbD09bnx8bihiKTpudWxsPT1vfHxvKGIpfSksW2IsdV0pO2NvbnN0IEU9UC51c2VDYWxsYmFjaygoZT0+e2Uuc3RvcFByb3BhZ2F0aW9uKCksTSh7b2JqZWN0OmwoW2Uub2JqZWN0XSlbMF0sc2hpZnQ6dCYmZS5zaGlmdEtleX0pfSksW10pLFM9UC51c2VDYWxsYmFjaygoZT0+IXomJk0oe30pKSxbel0pLFQ9UC51c2VSZWYobnVsbCk7cmV0dXJuIFAudXNlRWZmZWN0KCgoKT0+e2lmKCFlfHwhdClyZXR1cm47Y29uc3Qgcj1uZXcgZC5TZWxlY3Rpb25Cb3gocCxULmN1cnJlbnQpLG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtuLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsbi5zdHlsZS5ib3JkZXI9aSxuLnN0eWxlLmJhY2tncm91bmRDb2xvcj1zLG4uc3R5bGUucG9zaXRpb249XCJmaXhlZFwiO2NvbnN0IGE9bmV3IEQuVmVjdG9yMixvPW5ldyBELlZlY3RvcjIsYz1uZXcgRC5WZWN0b3IyLHU9ZygpLmV2ZW50cy5lbmFibGVkLGg9bnVsbD09eT92b2lkIDA6eS5lbmFibGVkO2xldCB6PSExO2Z1bmN0aW9uIHcoZSx0KXtjb25zdHtvZmZzZXRYOnIsb2Zmc2V0WTpufT1lLHt3aWR0aDphLGhlaWdodDpvfT12O3Quc2V0KHIvYSoyLTEsLW4vbyoyKzEpfWZ1bmN0aW9uIGIoZSl7ZS5zaGlmdEtleSYmKCFmdW5jdGlvbihlKXt2YXIgdDt5JiYoeS5lbmFibGVkPSExKSxmKHtlbmFibGVkOiExfSksbSh6PSEwKSxudWxsPT0odD14LmRvbUVsZW1lbnQucGFyZW50RWxlbWVudCl8fHQuYXBwZW5kQ2hpbGQobiksbi5zdHlsZS5sZWZ0PWAke2UuY2xpZW50WH1weGAsbi5zdHlsZS50b3A9YCR7ZS5jbGllbnRZfXB4YCxuLnN0eWxlLndpZHRoPVwiMHB4XCIsbi5zdHlsZS5oZWlnaHQ9XCIwcHhcIixhLng9ZS5jbGllbnRYLGEueT1lLmNsaWVudFl9KGUpLHcoZSxyLnN0YXJ0UG9pbnQpKX1sZXQgRT1bXTtmdW5jdGlvbiBTKGUpe2lmKHopeyFmdW5jdGlvbihlKXtjLng9TWF0aC5tYXgoYS54LGUuY2xpZW50WCksYy55PU1hdGgubWF4KGEueSxlLmNsaWVudFkpLG8ueD1NYXRoLm1pbihhLngsZS5jbGllbnRYKSxvLnk9TWF0aC5taW4oYS55LGUuY2xpZW50WSksbi5zdHlsZS5sZWZ0PWAke28ueH1weGAsbi5zdHlsZS50b3A9YCR7by55fXB4YCxuLnN0eWxlLndpZHRoPWMueC1vLngrXCJweFwiLG4uc3R5bGUuaGVpZ2h0PWMueS1vLnkrXCJweFwifShlKSx3KGUsci5lbmRQb2ludCk7Y29uc3QgdD1yLnNlbGVjdCgpLnNvcnQoKGU9PmUudXVpZCkpLmZpbHRlcigoZT0+ZS5pc01lc2gpKTtfLmRlZmF1bHQodCxFKXx8KEU9dCxNKHtvYmplY3Q6bCh0KX0pKX19ZnVuY3Rpb24gQyhlKXt2YXIgdDt6JiZ6JiYoeSYmKHkuZW5hYmxlZD1oKSxmKHtlbmFibGVkOnV9KSxtKHo9ITEpLG51bGw9PSh0PW4ucGFyZW50RWxlbWVudCl8fHQucmVtb3ZlQ2hpbGQobikpfXJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIixiLHtwYXNzaXZlOiEwfSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsUyx7cGFzc2l2ZTohMCxjYXB0dXJlOiEwfSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLEMse3Bhc3NpdmU6ITB9KSwoKT0+e2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLGIpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLFMpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIixDKX19KSxbdi53aWR0aCx2LmhlaWdodCxoLHAseSx4XSksUC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIixDLmRlZmF1bHQoe3JlZjpULG9uQ2xpY2s6RSxvblBvaW50ZXJPdmVyOigpPT53KCEwKSxvblBvaW50ZXJPdXQ6KCk9PncoITEpLG9uUG9pbnRlck1pc3NlZDpTfSxjKSxQLmNyZWF0ZUVsZW1lbnQoc2UuUHJvdmlkZXIse3ZhbHVlOmJ9LHIpKX0sZXhwb3J0cy5TaGFkb3c9S24sZXhwb3J0cy5TaGFkb3dBbHBoYT1mdW5jdGlvbih7b3BhY2l0eTplLGFscGhhTWFwOnR9KXtjb25zdCByPVAudXNlUmVmKG51bGwpLG49UC51c2VSZWYobnVsbCksbz1QLnVzZVJlZih7dmFsdWU6MX0pLGk9UC51c2VSZWYoe3ZhbHVlOm51bGx9KSxzPVAudXNlUmVmKHt2YWx1ZTohMX0pO3JldHVybiBQLnVzZUxheW91dEVmZmVjdCgoKCk9PntyLmN1cnJlbnQub25CZWZvcmVDb21waWxlPW4uY3VycmVudC5vbkJlZm9yZUNvbXBpbGU9ZT0+e2NvbnN0IHQ9ZS5mcmFnbWVudFNoYWRlci5pbmRleE9mKFwidm9pZCBtYWluXCIpO2xldCByLG49XCJcIixhPXQ7Zm9yKDtcIlxcblwiIT09ciYmYTx0KzEwMDspcj1lLmZyYWdtZW50U2hhZGVyLmNoYXJBdChhKSxuKz1yLGErKztuPW4udHJpbSgpLGUudmVydGV4U2hhZGVyPWUudmVydGV4U2hhZGVyLnJlcGxhY2UoXCJ2b2lkIG1haW4oKSB7XCIsXCJcXG4gICAgICAgIHZhcnlpbmcgdmVjMiBjdXN0b21fdlV2O1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBjdXN0b21fdlV2ID0gdXY7XFxuICAgICAgICAgIFxcbiAgICAgICAgXCIpLGUuZnJhZ21lbnRTaGFkZXI9ZS5mcmFnbWVudFNoYWRlci5yZXBsYWNlKG4sXCJcXG4gICAgICAgICAgdW5pZm9ybSBmbG9hdCB1U2hhZG93T3BhY2l0eTtcXG4gICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdUFscGhhTWFwO1xcbiAgICAgICAgICB1bmlmb3JtIGJvb2wgdUhhc0FscGhhTWFwO1xcblxcbiAgICAgICAgICB2YXJ5aW5nIHZlYzIgY3VzdG9tX3ZVdjtcXG4gIFxcbiAgICAgICAgICBmbG9hdCBiYXllckRpdGhlcjJ4MiggdmVjMiB2ICkge1xcbiAgICAgICAgICAgIHJldHVybiBtb2QoIDMuMCAqIHYueSArIDIuMCAqIHYueCwgNC4wICk7XFxuICAgICAgICAgIH1cXG4gICAgXFxuICAgICAgICAgIGZsb2F0IGJheWVyRGl0aGVyNHg0KCB2ZWMyIHYgKSB7XFxuICAgICAgICAgICAgdmVjMiBQMSA9IG1vZCggdiwgMi4wICk7XFxuICAgICAgICAgICAgdmVjMiBQMiA9IG1vZCggZmxvb3IoIDAuNSAgKiB2ICksIDIuMCApO1xcbiAgICAgICAgICAgIHJldHVybiA0LjAgKiBiYXllckRpdGhlcjJ4MiggUDEgKSArIGJheWVyRGl0aGVyMngyKCBQMiApO1xcbiAgICAgICAgICB9XFxuICBcXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgIGZsb2F0IGFscGhhID0gXFxuICAgICAgICAgICAgICB1SGFzQWxwaGFNYXAgPyBcXG4gICAgICAgICAgICAgICAgdVNoYWRvd09wYWNpdHkgKiB0ZXh0dXJlMkQodUFscGhhTWFwLCBjdXN0b21fdlV2KS54XFxuICAgICAgICAgICAgICA6IHVTaGFkb3dPcGFjaXR5O1xcblxcbiAgICAgICAgICAgIGlmKCAoIGJheWVyRGl0aGVyNHg0KCBmbG9vciggbW9kKCBnbF9GcmFnQ29vcmQueHksIDQuMCApICkgKSApIC8gMTYuMCA+PSBhbHBoYSApIGRpc2NhcmQ7XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIFwiKSxlLnVuaWZvcm1zLnVTaGFkb3dPcGFjaXR5PW8uY3VycmVudCxlLnVuaWZvcm1zLnVBbHBoYU1hcD1pLmN1cnJlbnQsZS51bmlmb3Jtcy51SGFzQWxwaGFNYXA9cy5jdXJyZW50fX0pLFtdKSxhLnVzZUZyYW1lKCgoKT0+e3ZhciBuO2NvbnN0IGE9bnVsbD09KG49ci5jdXJyZW50Ll9fcjNmKT92b2lkIDA6bi5wYXJlbnQ7aWYoYSl7Y29uc3Qgcj1hLm1hdGVyaWFsO3ImJihvLmN1cnJlbnQudmFsdWU9bnVsbCE9ZT9lOnIub3BhY2l0eSwhMT09PXQ/KGkuY3VycmVudC52YWx1ZT1udWxsLHMuY3VycmVudC52YWx1ZT0hMSk6KGkuY3VycmVudC52YWx1ZT10fHxyLmFscGhhTWFwLHMuY3VycmVudC52YWx1ZT0hIWkuY3VycmVudC52YWx1ZSkpfX0pKSxQLmNyZWF0ZUVsZW1lbnQoUC5GcmFnbWVudCxudWxsLFAuY3JlYXRlRWxlbWVudChcIm1lc2hEZXB0aE1hdGVyaWFsXCIse3JlZjpyLGF0dGFjaDpcImN1c3RvbURlcHRoTWF0ZXJpYWxcIixkZXB0aFBhY2tpbmc6RC5SR0JBRGVwdGhQYWNraW5nfSksUC5jcmVhdGVFbGVtZW50KFwibWVzaERpc3RhbmNlTWF0ZXJpYWxcIix7cmVmOm4sYXR0YWNoOlwiY3VzdG9tRGlzdGFuY2VNYXRlcmlhbFwifSkpfSxleHBvcnRzLlNoYXBlPXluLGV4cG9ydHMuU2t5PXhhLGV4cG9ydHMuU29mdFNoYWRvd3M9ZnVuY3Rpb24oe2ZvY3VzOmU9MCxzYW1wbGVzOnQ9MTAsc2l6ZTpyPTI1fSl7Y29uc3Qgbj1hLnVzZVRocmVlKChlPT5lLmdsKSksbz1hLnVzZVRocmVlKChlPT5lLnNjZW5lKSksaT1hLnVzZVRocmVlKChlPT5lLmNhbWVyYSkpO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBhPUQuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ7cmV0dXJuIEQuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ9RC5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudC5yZXBsYWNlKFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXCIrKCh7Zm9jdXM6ZT0wLHNpemU6dD0yNSxzYW1wbGVzOnI9MTB9PXt9KT0+YFxcbiNkZWZpbmUgUEVOVU1CUkFfRklMVEVSX1NJWkUgZmxvYXQoJHt0fSlcXG4jZGVmaW5lIFJHQl9OT0lTRV9GVU5DVElPTih1dikgKHJhbmRSR0IodXYpKVxcbnZlYzMgcmFuZFJHQih2ZWMyIHV2KSB7XFxuICByZXR1cm4gdmVjMyhcXG4gICAgZnJhY3Qoc2luKGRvdCh1diwgdmVjMigxMi43NTYxMywgMzguMTIxMjMpKSkgKiAxMzIzNC43NjU3NSksXFxuICAgIGZyYWN0KHNpbihkb3QodXYsIHZlYzIoMTkuNDU1MzEsIDU4LjQ2NTQ3KSkpICogNDM2NzguMjM0MzEpLFxcbiAgICBmcmFjdChzaW4oZG90KHV2LCB2ZWMyKDIzLjY3ODE3LCA3OC4yMzEyMSkpKSAqIDkzNTY3LjIzNDIzKVxcbiAgKTtcXG59XFxuXFxudmVjMyBsb3dQYXNzUmFuZFJHQih2ZWMyIHV2KSB7XFxuICAvLyAzeDMgY29udm9sdXRpb24gKGF2ZXJhZ2UpXFxuICAvLyBjYW4gYmUgaW1wbGVtZW50ZWQgYXMgc2VwYXJhYmxlIHdpdGggYW4gZXh0cmEgYnVmZmVyIGZvciBhIHRvdGFsIG9mIDYgc2FtcGxlcyBpbnN0ZWFkIG9mIDlcXG4gIHZlYzMgcmVzdWx0ID0gdmVjMygwKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKC0xLjAsICsxLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCAwLjAsICsxLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsIC0xLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsICAwLjApKTtcXG4gIHJlc3VsdCArPSBSR0JfTk9JU0VfRlVOQ1RJT04odXYgKyB2ZWMyKCsxLjAsICsxLjApKTtcXG4gIHJlc3VsdCAqPSAwLjExMTExMTExMTsgLy8gMS4wIC8gOS4wXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cXG52ZWMzIGhpZ2hQYXNzUmFuZFJHQih2ZWMyIHV2KSB7XFxuICAvLyBieSBzdWJ0cmFjdGluZyB0aGUgbG93LXBhc3Mgc2lnbmFsIGZyb20gdGhlIG9yaWdpbmFsIHNpZ25hbCwgd2UncmUgYmVpbmcgbGVmdCB3aXRoIHRoZSBoaWdoLXBhc3Mgc2lnbmFsXFxuICAvLyBocCh4KSA9IHggLSBscCh4KVxcbiAgcmV0dXJuIFJHQl9OT0lTRV9GVU5DVElPTih1dikgLSBsb3dQYXNzUmFuZFJHQih1dikgKyAwLjU7XFxufVxcblxcblxcbnZlYzIgdm9nZWxEaXNrU2FtcGxlKGludCBzYW1wbGVJbmRleCwgaW50IHNhbXBsZUNvdW50LCBmbG9hdCBhbmdsZSkge1xcbiAgY29uc3QgZmxvYXQgZ29sZGVuQW5nbGUgPSAyLjM5OTk2M2Y7IC8vIHJhZGlhbnNcXG4gIGZsb2F0IHIgPSBzcXJ0KGZsb2F0KHNhbXBsZUluZGV4KSArIDAuNWYpIC8gc3FydChmbG9hdChzYW1wbGVDb3VudCkpO1xcbiAgZmxvYXQgdGhldGEgPSBmbG9hdChzYW1wbGVJbmRleCkgKiBnb2xkZW5BbmdsZSArIGFuZ2xlO1xcbiAgZmxvYXQgc2luZSA9IHNpbih0aGV0YSk7XFxuICBmbG9hdCBjb3NpbmUgPSBjb3ModGhldGEpO1xcbiAgcmV0dXJuIHZlYzIoY29zaW5lLCBzaW5lKSAqIHI7XFxufVxcbmZsb2F0IHBlbnVtYnJhU2l6ZSggY29uc3QgaW4gZmxvYXQgelJlY2VpdmVyLCBjb25zdCBpbiBmbG9hdCB6QmxvY2tlciApIHsgLy8gUGFyYWxsZWwgcGxhbmUgZXN0aW1hdGlvblxcbiAgcmV0dXJuICh6UmVjZWl2ZXIgLSB6QmxvY2tlcikgLyB6QmxvY2tlcjtcXG59XFxuZmxvYXQgZmluZEJsb2NrZXIoc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSwgZmxvYXQgYW5nbGUpIHtcXG4gIGZsb2F0IHRleGVsU2l6ZSA9IDEuMCAvIGZsb2F0KHRleHR1cmVTaXplKHNoYWRvd01hcCwgMCkueCk7XFxuICBmbG9hdCBibG9ja2VyRGVwdGhTdW0gPSBmbG9hdCgke2V9KTtcXG4gIGZsb2F0IGJsb2NrZXJzID0gMC4wO1xcblxcbiAgaW50IGogPSAwO1xcbiAgdmVjMiBvZmZzZXQgPSB2ZWMyKDAuKTtcXG4gIGZsb2F0IGRlcHRoID0gMC47XFxuXFxuICAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuICBmb3IoaW50IGkgPSAwOyBpIDwgJHtyfTsgaSArKykge1xcbiAgICBvZmZzZXQgPSAodm9nZWxEaXNrU2FtcGxlKGosICR7cn0sIGFuZ2xlKSAqIHRleGVsU2l6ZSkgKiAyLjAgKiBQRU5VTUJSQV9GSUxURVJfU0laRTtcXG4gICAgZGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXAsIHV2ICsgb2Zmc2V0KSk7XFxuICAgIGlmIChkZXB0aCA8IGNvbXBhcmUpIHtcXG4gICAgICBibG9ja2VyRGVwdGhTdW0gKz0gZGVwdGg7XFxuICAgICAgYmxvY2tlcnMrKztcXG4gICAgfVxcbiAgICBqKys7XFxuICB9XFxuICAjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcbiAgaWYgKGJsb2NrZXJzID4gMC4wKSB7XFxuICAgIHJldHVybiBibG9ja2VyRGVwdGhTdW0gLyBibG9ja2VycztcXG4gIH1cXG4gIHJldHVybiAtMS4wO1xcbn1cXG5cXG4gICAgICAgIFxcbmZsb2F0IHZvZ2VsRmlsdGVyKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgdXYsIGZsb2F0IHpSZWNlaXZlciwgZmxvYXQgZmlsdGVyUmFkaXVzLCBmbG9hdCBhbmdsZSkge1xcbiAgZmxvYXQgdGV4ZWxTaXplID0gMS4wIC8gZmxvYXQodGV4dHVyZVNpemUoc2hhZG93TWFwLCAwKS54KTtcXG4gIGZsb2F0IHNoYWRvdyA9IDAuMGY7XFxuICBpbnQgaiA9IDA7XFxuICB2ZWMyIHZvZ2VsU2FtcGxlID0gdmVjMigwLjApO1xcbiAgdmVjMiBvZmZzZXQgPSB2ZWMyKDAuMCk7XFxuICAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuICBmb3IgKGludCBpID0gMDsgaSA8ICR7cn07IGkrKykge1xcbiAgICB2b2dlbFNhbXBsZSA9IHZvZ2VsRGlza1NhbXBsZShqLCAke3J9LCBhbmdsZSkgKiB0ZXhlbFNpemU7XFxuICAgIG9mZnNldCA9IHZvZ2VsU2FtcGxlICogKDEuMCArIGZpbHRlclJhZGl1cyAqIGZsb2F0KCR7dH0pKTtcXG4gICAgc2hhZG93ICs9IHN0ZXAoIHpSZWNlaXZlciwgdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwLCB1diArIG9mZnNldCApICkgKTtcXG4gICAgaisrO1xcbiAgfVxcbiAgI3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4gIHJldHVybiBzaGFkb3cgKiAxLjAgLyAke3J9LjA7XFxufVxcblxcbmZsb2F0IFBDU1MgKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzQgY29vcmRzKSB7XFxuICB2ZWMyIHV2ID0gY29vcmRzLnh5O1xcbiAgZmxvYXQgelJlY2VpdmVyID0gY29vcmRzLno7IC8vIEFzc3VtZWQgdG8gYmUgZXllLXNwYWNlIHogaW4gdGhpcyBjb2RlXFxuICBmbG9hdCBhbmdsZSA9IGhpZ2hQYXNzUmFuZFJHQihnbF9GcmFnQ29vcmQueHkpLnIgKiBQSTI7XFxuICBmbG9hdCBhdmdCbG9ja2VyRGVwdGggPSBmaW5kQmxvY2tlcihzaGFkb3dNYXAsIHV2LCB6UmVjZWl2ZXIsIGFuZ2xlKTtcXG4gIGlmIChhdmdCbG9ja2VyRGVwdGggPT0gLTEuMCkge1xcbiAgICByZXR1cm4gMS4wO1xcbiAgfVxcbiAgZmxvYXQgcGVudW1icmFSYXRpbyA9IHBlbnVtYnJhU2l6ZSh6UmVjZWl2ZXIsIGF2Z0Jsb2NrZXJEZXB0aCk7XFxuICByZXR1cm4gdm9nZWxGaWx0ZXIoc2hhZG93TWFwLCB1diwgelJlY2VpdmVyLCAxLjI1ICogcGVudW1icmFSYXRpbywgYW5nbGUpO1xcbn1gKSh7c2l6ZTpyLHNhbXBsZXM6dCxmb2N1czplfSkpLnJlcGxhY2UoXCIjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcIixcIlxcbnJldHVybiBQQ1NTKHNoYWRvd01hcCwgc2hhZG93Q29vcmQpO1xcbiNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVwiKSxZcihuLG8saSksKCk9PntELlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PWEsWXIobixvLGkpfX0pLFtlLHIsdF0pLG51bGx9LGV4cG9ydHMuU3BhcmtsZXM9QmEsZXhwb3J0cy5TcGhlcmU9cm4sZXhwb3J0cy5TcGxhdD1mdW5jdGlvbih7c3JjOmUsdG9uZU1hcHBlZDp0PSExLGFscGhhVGVzdDpyPTAsYWxwaGFIYXNoOm49ITEsY2h1bmtTaXplOm89MjVlMywuLi5pfSl7YS5leHRlbmQoe1NwbGF0TWF0ZXJpYWw6SmV9KTtjb25zdCBzPVAudXNlUmVmKG51bGwpLGw9YS51c2VUaHJlZSgoZT0+ZS5nbCkpLGM9YS51c2VUaHJlZSgoZT0+ZS5jYW1lcmEpKSx1PWEudXNlTG9hZGVyKHR0LGUsKGU9PntlLmdsPWwsZS5jaHVua1NpemU9b30pKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT51LmNvbm5lY3Qocy5jdXJyZW50KSksW2VdKSxhLnVzZUZyYW1lKCgoKT0+dS51cGRhdGUocy5jdXJyZW50LGMsbikpKSxQLmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsQy5kZWZhdWx0KHtyZWY6cyxmcnVzdHVtQ3VsbGVkOiExfSxpKSxQLmNyZWF0ZUVsZW1lbnQoXCJzcGxhdE1hdGVyaWFsXCIse2tleTpgJHtlfS8ke3J9LyR7bn0ke0plLmtleX1gLHRyYW5zcGFyZW50OiFuLGRlcHRoVGVzdDohMCxhbHBoYVRlc3Q6bj8wOnIsY2VudGVyQW5kU2NhbGVUZXh0dXJlOnUuY2VudGVyQW5kU2NhbGVUZXh0dXJlLGNvdkFuZENvbG9yVGV4dHVyZTp1LmNvdkFuZENvbG9yVGV4dHVyZSxkZXB0aFdyaXRlOiEhbnx8cj4wLGJsZW5kaW5nOm4/RC5Ob3JtYWxCbGVuZGluZzpELkN1c3RvbUJsZW5kaW5nLGJsZW5kU3JjQWxwaGE6RC5PbmVGYWN0b3IsYWxwaGFIYXNoOiEhbix0b25lTWFwcGVkOnR9KSl9LGV4cG9ydHMuU3BvdExpZ2h0PWZhLGV4cG9ydHMuU3BvdExpZ2h0U2hhZG93PWZ1bmN0aW9uKGUpe3JldHVybiBlLnNoYWRlcj9QLmNyZWF0ZUVsZW1lbnQoZGEsZSk6UC5jcmVhdGVFbGVtZW50KG1hLGUpfSxleHBvcnRzLlNwcml0ZUFuaW1hdG9yPWtyLGV4cG9ydHMuU3RhZ2U9ZnVuY3Rpb24oe2NoaWxkcmVuOmUsY2VudGVyOnQsYWRqdXN0Q2FtZXJhOnI9ITAsaW50ZW5zaXR5Om49LjUsc2hhZG93czphPVwiY29udGFjdFwiLGVudmlyb25tZW50Om89XCJjaXR5XCIscHJlc2V0Omk9XCJyZW1icmFuZHRcIiwuLi5zfSl7dmFyIGwsYyx1LGQsbSxmLHAsaDtjb25zdCB4PVwic3RyaW5nXCI9PXR5cGVvZiBpP1puW2ldOmksW3tyYWRpdXM6eSxoZWlnaHQ6dn0sZ109UC51c2VTdGF0ZSh7cmFkaXVzOjAsd2lkdGg6MCxoZWlnaHQ6MCxkZXB0aDowfSksej1udWxsIT09KGw9bnVsbD09YT92b2lkIDA6YS5iaWFzKSYmdm9pZCAwIT09bD9sOi0xZS00LHc9bnVsbCE9PShjPW51bGw9PWE/dm9pZCAwOmEubm9ybWFsQmlhcykmJnZvaWQgMCE9PWM/YzowLGI9bnVsbCE9PSh1PW51bGw9PWE/dm9pZCAwOmEuc2l6ZSkmJnZvaWQgMCE9PXU/dToxMDI0LE09bnVsbCE9PShkPW51bGw9PWE/dm9pZCAwOmEub2Zmc2V0KSYmdm9pZCAwIT09ZD9kOjAsRT1cImNvbnRhY3RcIj09PWF8fFwiY29udGFjdFwiPT09KG51bGw9PWE/dm9pZCAwOmEudHlwZSksUz1cImFjY3VtdWxhdGl2ZVwiPT09YXx8XCJhY2N1bXVsYXRpdmVcIj09PShudWxsPT1hP3ZvaWQgMDphLnR5cGUpLFQ9ey4uLlwib2JqZWN0XCI9PXR5cGVvZiBhP2E6e319LFI9bz9cInN0cmluZ1wiPT10eXBlb2Ygbz97cHJlc2V0Om99Om86bnVsbCxEPVAudXNlQ2FsbGJhY2soKGU9Pntjb25zdHt3aWR0aDpyLGhlaWdodDpuLGRlcHRoOmEsYm91bmRpbmdTcGhlcmU6b309ZTtnKHtyYWRpdXM6by5yYWRpdXMsd2lkdGg6cixoZWlnaHQ6bixkZXB0aDphfSksbnVsbCE9dCYmdC5vbkNlbnRlcmVkJiZ0Lm9uQ2VudGVyZWQoZSl9KSxbXSk7cmV0dXJuIFAuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsUC5jcmVhdGVFbGVtZW50KFwiYW1iaWVudExpZ2h0XCIse2ludGVuc2l0eTpuLzN9KSxQLmNyZWF0ZUVsZW1lbnQoXCJzcG90TGlnaHRcIix7cGVudW1icmE6MSxwb3NpdGlvbjpbeC5tYWluWzBdKnkseC5tYWluWzFdKnkseC5tYWluWzJdKnldLGludGVuc2l0eToyKm4sY2FzdFNoYWRvdzohIWEsXCJzaGFkb3ctYmlhc1wiOnosXCJzaGFkb3ctbm9ybWFsQmlhc1wiOncsXCJzaGFkb3ctbWFwU2l6ZVwiOmJ9KSxQLmNyZWF0ZUVsZW1lbnQoXCJwb2ludExpZ2h0XCIse3Bvc2l0aW9uOlt4LmZpbGxbMF0qeSx4LmZpbGxbMV0qeSx4LmZpbGxbMl0qeV0saW50ZW5zaXR5Om59KSxQLmNyZWF0ZUVsZW1lbnQoUG4sQy5kZWZhdWx0KHtmaXQ6ISFyLGNsaXA6ISFyLG1hcmdpbjpOdW1iZXIociksb2JzZXJ2ZTohMH0scyksUC5jcmVhdGVFbGVtZW50KFluLHtyYWRpdXM6eSxhZGp1c3RDYW1lcmE6cn0pLFAuY3JlYXRlRWxlbWVudChEcixDLmRlZmF1bHQoe30sdCx7cG9zaXRpb246WzAsTS8yLDBdLG9uQ2VudGVyZWQ6RH0pLGUpKSxQLmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLHtwb3NpdGlvbjpbMCwtdi8yLU0vMiwwXX0sRSYmUC5jcmVhdGVFbGVtZW50KFduLEMuZGVmYXVsdCh7c2NhbGU6NCp5LGZhcjp5LGJsdXI6Mn0sVCkpLFMmJlAuY3JlYXRlRWxlbWVudCgkbixDLmRlZmF1bHQoe3RlbXBvcmFsOiEwLGZyYW1lczoxMDAsYWxwaGFUZXN0Oi45LHRvbmVNYXBwZWQ6ITAsc2NhbGU6NCp5fSxUKSxQLmNyZWF0ZUVsZW1lbnQocW4se2Ftb3VudDpudWxsIT09KG09VC5hbW91bnQpJiZ2b2lkIDAhPT1tP206OCxyYWRpdXM6bnVsbCE9PShmPVQucmFkaXVzKSYmdm9pZCAwIT09Zj9mOnksYW1iaWVudDpudWxsIT09KHA9VC5hbWJpZW50KSYmdm9pZCAwIT09cD9wOi41LGludGVuc2l0eTpudWxsIT09KGg9VC5pbnRlbnNpdHkpJiZ2b2lkIDAhPT1oP2g6MSxwb3NpdGlvbjpbeC5tYWluWzBdKnkseC5tYWluWzFdKnkseC5tYWluWzJdKnldLHNpemU6NCp5LGJpYXM6LXosbWFwU2l6ZTpifSkpKSxvJiZQLmNyZWF0ZUVsZW1lbnQoam4sUikpfSxleHBvcnRzLlN0YXJzPWdhLGV4cG9ydHMuU3RhdHM9ZnVuY3Rpb24oe3Nob3dQYW5lbDplPTAsY2xhc3NOYW1lOnQscGFyZW50OnJ9KXtjb25zdCBuPWZ1bmN0aW9uKGUsdD1bXSxyKXtjb25zdFtuLGFdPVAudXNlU3RhdGUoKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57Y29uc3QgdD1lKCk7cmV0dXJuIGEodCkseXIocix0KSwoKT0+eXIocixudWxsKX0pLHQpLG59KCgoKT0+bmV3IFUuZGVmYXVsdCksW10pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PntpZihuKXtjb25zdCBvPXImJnIuY3VycmVudHx8ZG9jdW1lbnQuYm9keTtuLnNob3dQYW5lbChlKSxudWxsPT1vfHxvLmFwcGVuZENoaWxkKG4uZG9tKSx0JiZuLmRvbS5jbGFzc0xpc3QuYWRkKC4uLnQuc3BsaXQoXCIgXCIpLmZpbHRlcigoZT0+ZSkpKTtjb25zdCBpPWEuYWRkRWZmZWN0KCgoKT0+bi5iZWdpbigpKSkscz1hLmFkZEFmdGVyRWZmZWN0KCgoKT0+bi5lbmQoKSkpO3JldHVybigpPT57bnVsbD09b3x8by5yZW1vdmVDaGlsZChuLmRvbSksaSgpLHMoKX19fSksW3Isbix0LGVdKSxudWxsfSxleHBvcnRzLlN0YXRzR2w9ZnVuY3Rpb24oe2NsYXNzTmFtZTplLHBhcmVudDp0LC4uLnJ9KXtjb25zdCBuPWEudXNlVGhyZWUoKGU9PmUuZ2wpKSxvPVAudXNlTWVtbygoKCk9Pntjb25zdCBlPW5ldyBJLmRlZmF1bHQoey4uLnJ9KTtyZXR1cm4gZS5pbml0KG4pLGV9KSxbbl0pO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9PntpZihvKXtjb25zdCByPXQmJnQuY3VycmVudHx8ZG9jdW1lbnQuYm9keTtudWxsPT1yfHxyLmFwcGVuZENoaWxkKG8uZG9tKSxlJiZvLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLmUuc3BsaXQoXCIgXCIpLmZpbHRlcigoZT0+ZSkpKTtjb25zdCBuPWEuYWRkQWZ0ZXJFZmZlY3QoKCgpPT5vLnVwZGF0ZSgpKSk7cmV0dXJuKCk9PntudWxsPT1yfHxyLnJlbW92ZUNoaWxkKG8uZG9tKSxuKCl9fX0pLFt0LG8sZV0pLG51bGx9LGV4cG9ydHMuU3ZnPXFlLGV4cG9ydHMuVGV0cmFoZWRyb249bG4sZXhwb3J0cy5UZXh0PXhlLGV4cG9ydHMuVGV4dDNEPXdlLGV4cG9ydHMuVG9ydXM9b24sZXhwb3J0cy5Ub3J1c0tub3Q9c24sZXhwb3J0cy5UcmFja2JhbGxDb250cm9scz1kdCxleHBvcnRzLlRyYWlsPUllLGV4cG9ydHMuVHJhbnNmb3JtQ29udHJvbHM9ZnQsZXhwb3J0cy5UdWJlPWFuLGV4cG9ydHMuVmlldz0oe3RyYWNrOmUsaW5kZXg6dD0xLGZyYW1lczpyPTEvMCxjaGlsZHJlbjpufSk9Pnt2YXIgbyxpO2NvbnN0IHM9UC51c2VSZWYobnVsbCkse3NpemU6bCxzY2VuZTpjfT1hLnVzZVRocmVlKCksW3VdPVAudXNlU3RhdGUoKCgpPT5uZXcgRC5TY2VuZSkpLGQ9UC51c2VDYWxsYmFjaygoKHQscik9PntpZihzLmN1cnJlbnQmJmUuY3VycmVudCYmdC50YXJnZXQ9PT1lLmN1cnJlbnQpe2NvbnN0e3dpZHRoOmUsaGVpZ2h0Om4sbGVmdDphLHRvcDpvfT1zLmN1cnJlbnQsaT10LmNsaWVudFgtYSxsPXQuY2xpZW50WS1vO3IucG9pbnRlci5zZXQoaS9lKjItMSwtbC9uKjIrMSksci5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShyLnBvaW50ZXIsci5jYW1lcmEpfX0pLFtzLGVdKSxbbSxmXT1QLnVzZVJlZHVjZXIoKCgpPT4hMCksITEpO3JldHVybiBQLnVzZUVmZmVjdCgoKCk9Pnt2YXIgdDtzLmN1cnJlbnQ9bnVsbD09KHQ9ZS5jdXJyZW50KT92b2lkIDA6dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxmKCl9KSxbZV0pLFAuY3JlYXRlRWxlbWVudChQLkZyYWdtZW50LG51bGwsbSYmYS5jcmVhdGVQb3J0YWwoUC5jcmVhdGVFbGVtZW50KEdvLHtjYW52YXNTaXplOmwsZnJhbWVzOnIsc2NlbmU6Yyx0cmFjazplLHJlY3Q6cyxpbmRleDp0fSxuLFAuY3JlYXRlRWxlbWVudChcImdyb3VwXCIse29uUG9pbnRlck92ZXI6KCk9Pm51bGx9KSksdSx7ZXZlbnRzOntjb21wdXRlOmQscHJpb3JpdHk6dH0sc2l6ZTp7d2lkdGg6bnVsbD09KG89cy5jdXJyZW50KT92b2lkIDA6by53aWR0aCxoZWlnaHQ6bnVsbD09KGk9cy5jdXJyZW50KT92b2lkIDA6aS5oZWlnaHR9fSkpfSxleHBvcnRzLldpcmVmcmFtZT1mdW5jdGlvbih7Z2VvbWV0cnk6ZSwuLi50fSl7cmV0dXJuIGU/UC5jcmVhdGVFbGVtZW50KFdhLEMuZGVmYXVsdCh7Z2VvbWV0cnk6ZX0sdCkpOlAuY3JlYXRlRWxlbWVudChHYSx0KX0sZXhwb3J0cy5hY2N1bXVsYXRpdmVDb250ZXh0PUduLGV4cG9ydHMuY2FsY1Bvc0Zyb21BbmdsZXM9aGEsZXhwb3J0cy5jYWxjdWxhdGVTY2FsZUZhY3Rvcj1waSxleHBvcnRzLmlzV2ViR0wyQXZhaWxhYmxlPSgpPT57dHJ5e3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7cmV0dXJuISghd2luZG93LldlYkdMMlJlbmRlcmluZ0NvbnRleHR8fCFlLmdldENvbnRleHQoXCJ3ZWJnbDJcIikpfWNhdGNoKGUpe3JldHVybiExfX0sZXhwb3J0cy5tZXNoQm91bmRzPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj10aGlzLmdlb21ldHJ5LG49dGhpcy5tYXRlcmlhbCxhPXRoaXMubWF0cml4V29ybGQ7dm9pZCAwIT09biYmKG51bGw9PT1yLmJvdW5kaW5nU3BoZXJlJiZyLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLFJvLmNvcHkoci5ib3VuZGluZ1NwaGVyZSksUm8uYXBwbHlNYXRyaXg0KGEpLCExIT09ZS5yYXkuaW50ZXJzZWN0c1NwaGVyZShSbykmJihDby5jb3B5KGEpLmludmVydCgpLFBvLmNvcHkoZS5yYXkpLmFwcGx5TWF0cml4NChDbyksbnVsbCE9PXIuYm91bmRpbmdCb3gmJm51bGw9PT1Qby5pbnRlcnNlY3RCb3goci5ib3VuZGluZ0JveCxEbyl8fHQucHVzaCh7ZGlzdGFuY2U6RG8uZGlzdGFuY2VUbyhlLnJheS5vcmlnaW4pLHBvaW50OkRvLmNsb25lKCksb2JqZWN0OnRoaXN9KSkpfSxleHBvcnRzLnNoYWRlck1hdGVyaWFsPUVlLGV4cG9ydHMudXNlQW5pbWF0aW9ucz1mdW5jdGlvbihlLHQpe2NvbnN0IHI9UC51c2VSZWYoKSxbb109UC51c2VTdGF0ZSgoKCk9PnQ/dCBpbnN0YW5jZW9mIG4uT2JqZWN0M0Q/e2N1cnJlbnQ6dH06dDpyKSksW2ldPVAudXNlU3RhdGUoKCgpPT5uZXcgbi5BbmltYXRpb25NaXhlcih2b2lkIDApKSk7UC51c2VMYXlvdXRFZmZlY3QoKCgpPT57dCYmKG8uY3VycmVudD10IGluc3RhbmNlb2Ygbi5PYmplY3QzRD90OnQuY3VycmVudCksaS5fcm9vdD1vLmN1cnJlbnR9KSk7Y29uc3Qgcz1QLnVzZVJlZih7fSksbD1QLnVzZU1lbW8oKCgpPT57Y29uc3QgdD17fTtyZXR1cm4gZS5mb3JFYWNoKChlPT5PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLm5hbWUse2VudW1lcmFibGU6ITAsZ2V0KCl7aWYoby5jdXJyZW50KXJldHVybiBzLmN1cnJlbnRbZS5uYW1lXXx8KHMuY3VycmVudFtlLm5hbWVdPWkuY2xpcEFjdGlvbihlLG8uY3VycmVudCkpfSxjb25maWd1cmFibGU6ITB9KSkpLHtyZWY6byxjbGlwczplLGFjdGlvbnM6dCxuYW1lczplLm1hcCgoZT0+ZS5uYW1lKSksbWl4ZXI6aX19KSxbZV0pO3JldHVybiBhLnVzZUZyYW1lKCgoZSx0KT0+aS51cGRhdGUodCkpKSxQLnVzZUVmZmVjdCgoKCk9Pntjb25zdCBlPW8uY3VycmVudDtyZXR1cm4oKT0+e3MuY3VycmVudD17fSxpLnN0b3BBbGxBY3Rpb24oKSxPYmplY3QudmFsdWVzKGwuYWN0aW9ucykuZm9yRWFjaCgodD0+e2UmJmkudW5jYWNoZUFjdGlvbih0LGUpfSkpfX0pLFtlXSksbH0sZXhwb3J0cy51c2VBc3BlY3Q9ZnVuY3Rpb24oZSx0LHI9MSl7Y29uc3Qgbj1hLnVzZVRocmVlKChlPT5lLnZpZXdwb3J0KSksbz10KihuLmFzcGVjdD5lL3Q/bi53aWR0aC9lOm4uaGVpZ2h0L3QpO3JldHVybltlKihuLmFzcGVjdD5lL3Q/bi53aWR0aC9lOm4uaGVpZ2h0L3QpKnIsbypyLDFdfSxleHBvcnRzLnVzZUJWSD1mdW5jdGlvbihlLHQpe3Q9e3N0cmF0ZWd5OncuU0FILHZlcmJvc2U6ITEsc2V0Qm91bmRpbmdCb3g6ITAsbWF4RGVwdGg6NDAsbWF4TGVhZlRyaXM6MTAsaW5kaXJlY3Q6ITEsLi4udH0sUC51c2VFZmZlY3QoKCgpPT57aWYoZS5jdXJyZW50KXtlLmN1cnJlbnQucmF5Y2FzdD13LmFjY2VsZXJhdGVkUmF5Y2FzdDtjb25zdCByPWUuY3VycmVudC5nZW9tZXRyeTtyZXR1cm4gci5jb21wdXRlQm91bmRzVHJlZT13LmNvbXB1dGVCb3VuZHNUcmVlLHIuZGlzcG9zZUJvdW5kc1RyZWU9dy5kaXNwb3NlQm91bmRzVHJlZSxyLmNvbXB1dGVCb3VuZHNUcmVlKHQpLCgpPT57ci5ib3VuZHNUcmVlJiZyLmRpc3Bvc2VCb3VuZHNUcmVlKCl9fX0pLFtlLEpTT04uc3RyaW5naWZ5KHQpXSl9LGV4cG9ydHMudXNlQm91bmRzPVJuLGV4cG9ydHMudXNlQm94UHJvamVjdGVkRW52PWZ1bmN0aW9uKGU9bmV3IEQuVmVjdG9yMyx0PW5ldyBELlZlY3RvcjMpe2NvbnN0W3JdPVAudXNlU3RhdGUoKCgpPT4oe3Bvc2l0aW9uOm5ldyBELlZlY3RvcjMsc2l6ZTpuZXcgRC5WZWN0b3IzfSkpKTthLmFwcGx5UHJvcHMocix7cG9zaXRpb246ZSxzaXplOnR9KTtjb25zdCBuPVAudXNlUmVmKG51bGwpLG89UC51c2VNZW1vKCgoKT0+KHtyZWY6bixvbkJlZm9yZUNvbXBpbGU6ZT0+ZnVuY3Rpb24oZSx0LHIpe2UuZGVmaW5lcy5CT1hfUFJPSkVDVEVEX0VOVl9NQVA9ITAsZS51bmlmb3Jtcy5lbnZNYXBQb3NpdGlvbj17dmFsdWU6dH0sZS51bmlmb3Jtcy5lbnZNYXBTaXplPXt2YWx1ZTpyfSxlLnZlcnRleFNoYWRlcj1gXFxuICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuICAke2UudmVydGV4U2hhZGVyLnJlcGxhY2UoXCIjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlwiLGJyKX1gLGUuZnJhZ21lbnRTaGFkZXI9YFxcbiAgICAke01yfVxcbiAgICAke2UuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcIiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cIixELlNoYWRlckNodW5rLmVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50KS5yZXBsYWNlKFwidmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1wiLGB2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuICAgICAgICAgJHtFcn1cXG4gICAgICAgICBgKS5yZXBsYWNlKFwicmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcIixgcmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG4gICAgICAgICAke1NyfVxcbiAgICAgICAgYCl9YH0oZSxyLnBvc2l0aW9uLHIuc2l6ZSksY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OigpPT5KU09OLnN0cmluZ2lmeShyLnBvc2l0aW9uLnRvQXJyYXkoKSkrSlNPTi5zdHJpbmdpZnkoci5zaXplLnRvQXJyYXkoKSl9KSksWy4uLnIucG9zaXRpb24udG9BcnJheSgpLC4uLnIuc2l6ZS50b0FycmF5KCldKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57bi5jdXJyZW50Lm5lZWRzVXBkYXRlPSEwfSksW3JdKSxvfSxleHBvcnRzLnVzZUNhbWVyYT1mdW5jdGlvbihlLHQpe2NvbnN0IHI9YS51c2VUaHJlZSgoZT0+ZS5wb2ludGVyKSksW29dPVAudXNlU3RhdGUoKCgpPT57Y29uc3Qgbz1uZXcgbi5SYXljYXN0ZXI7cmV0dXJuIHQmJmEuYXBwbHlQcm9wcyhvLHQse30pLGZ1bmN0aW9uKHQsYSl7by5zZXRGcm9tQ2FtZXJhKHIsZSBpbnN0YW5jZW9mIG4uQ2FtZXJhP2U6ZS5jdXJyZW50KTtjb25zdCBpPXRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnJheWNhc3QuYmluZCh0aGlzKTtpJiZpKG8sYSl9fSkpO3JldHVybiBvfSxleHBvcnRzLnVzZUNvbnRleHRCcmlkZ2U9ZnVuY3Rpb24oLi4uZSl7Y29uc3QgdD1QLnVzZVJlZihbXSk7cmV0dXJuIHQuY3VycmVudD1lLm1hcCgoZT0+UC51c2VDb250ZXh0KGUpKSksUC51c2VNZW1vKCgoKT0+KHtjaGlsZHJlbjpyfSk9PmUucmVkdWNlUmlnaHQoKChlLHIsbik9PlAuY3JlYXRlRWxlbWVudChyLlByb3ZpZGVyLHt2YWx1ZTp0LmN1cnJlbnRbbl0sY2hpbGRyZW46ZX0pKSxyKSksW10pfSxleHBvcnRzLnVzZUN1YmVDYW1lcmE9aXQsZXhwb3J0cy51c2VDdWJlVGV4dHVyZT1mcixleHBvcnRzLnVzZUN1cnNvcj1mdW5jdGlvbihlLHQ9XCJwb2ludGVyXCIscj1cImF1dG9cIixuPWRvY3VtZW50LmJvZHkpe1AudXNlRWZmZWN0KCgoKT0+e2lmKGUpcmV0dXJuIG4uc3R5bGUuY3Vyc29yPXQsKCk9PntuLnN0eWxlLmN1cnNvcj1yfX0pLFtlXSl9LGV4cG9ydHMudXNlRGVwdGhCdWZmZXI9ZnVuY3Rpb24oe3NpemU6ZT0yNTYsZnJhbWVzOnQ9MS8wfT17fSl7Y29uc3Qgcj1hLnVzZVRocmVlKChlPT5lLnZpZXdwb3J0LmRwcikpLHt3aWR0aDpvLGhlaWdodDppfT1hLnVzZVRocmVlKChlPT5lLnNpemUpKSxzPWV8fG8qcixsPWV8fGkqcixjPVAudXNlTWVtbygoKCk9Pntjb25zdCBlPW5ldyBuLkRlcHRoVGV4dHVyZShzLGwpO3JldHVybiBlLmZvcm1hdD1uLkRlcHRoRm9ybWF0LGUudHlwZT1uLlVuc2lnbmVkU2hvcnRUeXBlLHtkZXB0aFRleHR1cmU6ZX19KSxbcyxsXSk7bGV0IHU9MDtjb25zdCBkPW50KHMsbCxjKTtyZXR1cm4gYS51c2VGcmFtZSgoZT0+eyh0PT09MS8wfHx1PHQpJiYoZS5nbC5zZXRSZW5kZXJUYXJnZXQoZCksZS5nbC5yZW5kZXIoZS5zY2VuZSxlLmNhbWVyYSksZS5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCksdSsrKX0pKSxkLmRlcHRoVGV4dHVyZX0sZXhwb3J0cy51c2VEZXRlY3RHUFU9ZT0+Zi5zdXNwZW5kKCgoKT0+ei5nZXRHUFVUaWVyKGUpKSxbXCJ1c2VEZXRlY3RHUFVcIl0pLGV4cG9ydHMudXNlRW52aXJvbm1lbnQ9TG4sZXhwb3J0cy51c2VGQk89bnQsZXhwb3J0cy51c2VGQlg9cHIsZXhwb3J0cy51c2VGYWNlQ29udHJvbHM9RnQsZXhwb3J0cy51c2VGYWNlTGFuZG1hcmtlcj1UdCxleHBvcnRzLnVzZUZvbnQ9Z2UsZXhwb3J0cy51c2VHTFRGPVFlLGV4cG9ydHMudXNlR2l6bW9Db250ZXh0PWp0LGV4cG9ydHMudXNlSGVscGVyPXZyLGV4cG9ydHMudXNlSW50ZXJzZWN0PXdyLGV4cG9ydHMudXNlS1RYMj14cixleHBvcnRzLnVzZUtleWJvYXJkQ29udHJvbHM9ZnVuY3Rpb24oZSl7Y29uc3RbdCxyLG5dPVAudXNlQ29udGV4dChpZSk7cmV0dXJuIGU/bihlKTpbdCxyXX0sZXhwb3J0cy51c2VNYXNrPWZ1bmN0aW9uKGUsdD0hMSl7cmV0dXJue3N0ZW5jaWxXcml0ZTohMCxzdGVuY2lsUmVmOmUsc3RlbmNpbEZ1bmM6dD9ELk5vdEVxdWFsU3RlbmNpbEZ1bmM6RC5FcXVhbFN0ZW5jaWxGdW5jLHN0ZW5jaWxGYWlsOkQuS2VlcFN0ZW5jaWxPcCxzdGVuY2lsWkZhaWw6RC5LZWVwU3RlbmNpbE9wLHN0ZW5jaWxaUGFzczpELktlZXBTdGVuY2lsT3B9fSxleHBvcnRzLnVzZU1hdGNhcFRleHR1cmU9ZnVuY3Rpb24oZT0wLHQ9MTAyNCxyKXtjb25zdCBuPWYuc3VzcGVuZCgoKCk9PmZldGNoKFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3BtbmRycy9kcmVpLWFzc2V0c0BtYXN0ZXIvbWF0Y2Fwcy5qc29uXCIpLnRoZW4oKGU9PmUuanNvbigpKSkpLFtcIm1hdGNhcExpc3RcIl0pLGE9blswXSxvPVAudXNlTWVtbygoKCk9Pk9iamVjdC5rZXlzKG4pLmxlbmd0aCksW10pLGk9YCR7UC51c2VNZW1vKCgoKT0+XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpcIm51bWJlclwiPT10eXBlb2YgZT9uW2VdOm51bGwpLFtlXSl8fGF9JHtmdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSA2NDpyZXR1cm5cIi02NHB4XCI7Y2FzZSAxMjg6cmV0dXJuXCItMTI4cHhcIjtjYXNlIDI1NjpyZXR1cm5cIi0yNTZweFwiO2Nhc2UgNTEyOnJldHVyblwiLTUxMnB4XCI7ZGVmYXVsdDpyZXR1cm5cIlwifX0odCl9LnBuZ2Ascz1gaHR0cHM6Ly9yYXdjZG4uZ2l0aGFjay5jb20vZW1tZWxsZXBwaS9tYXRjYXBzLzliMzZjY2FhZjBhMjQ4ODFhMzkwNjJkMDU1NjZjOWU5MmJlNGFhMGQvJHt0fS8ke2l9YDtyZXR1cm5bVGUocyxyKSxzLG9dfSxleHBvcnRzLnVzZU1vdGlvbj1CdCxleHBvcnRzLnVzZU5vcm1hbFRleHR1cmU9ZnVuY3Rpb24oZT0wLHQ9e30scil7Y29uc3R7cmVwZWF0OmE9WzEsMV0sYW5pc290cm9weTpvPTEsb2Zmc2V0Omk9WzAsMF19PXQscz1mLnN1c3BlbmQoKCgpPT5mZXRjaChcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9wbW5kcnMvZHJlaS1hc3NldHNAbWFzdGVyL25vcm1hbHMvbm9ybWFscy5qc29uXCIpLnRoZW4oKGU9PmUuanNvbigpKSkpLFtcIm5vcm1hbHNMaXN0XCJdKSxsPVAudXNlTWVtbygoKCk9Pk9iamVjdC5rZXlzKHMpLmxlbmd0aCksW10pLGM9c1swXSx1PWBodHRwczovL3Jhd2Nkbi5naXRoYWNrLmNvbS9wbW5kcnMvZHJlaS1hc3NldHMvN2EzMTA0OTk3ZTE1NzZmODM0NzI4Mjk4MTViMDA4ODBkODhiMzJmYi9ub3JtYWxzLyR7c1tlXXx8Y31gLGQ9VGUodSxyKTtyZXR1cm4gUC51c2VMYXlvdXRFZmZlY3QoKCgpPT57ZCYmKGQud3JhcFM9ZC53cmFwVD1uLlJlcGVhdFdyYXBwaW5nLGQucmVwZWF0PW5ldyBuLlZlY3RvcjIoYVswXSxhWzFdKSxkLm9mZnNldD1uZXcgbi5WZWN0b3IyKGlbMF0saVsxXSksZC5hbmlzb3Ryb3B5PW8pfSksW2QsbyxhLGldKSxbZCx1LGxdfSxleHBvcnRzLnVzZVBlcmZvcm1hbmNlTW9uaXRvcj1mdW5jdGlvbih7b25JbmNsaW5lOmUsb25EZWNsaW5lOnIsb25DaGFuZ2U6bixvbkZhbGxiYWNrOmF9KXtjb25zdCBvPXQudXNlQ29udGV4dChGbyksaT10LnVzZVJlZih7b25JbmNsaW5lOmUsb25EZWNsaW5lOnIsb25DaGFuZ2U6bixvbkZhbGxiYWNrOmF9KTt0LnVzZUxheW91dEVmZmVjdCgoKCk9PntpLmN1cnJlbnQub25JbmNsaW5lPWUsaS5jdXJyZW50Lm9uRGVjbGluZT1yLGkuY3VycmVudC5vbkNoYW5nZT1uLGkuY3VycmVudC5vbkZhbGxiYWNrPWF9KSxbZSxyLG4sYV0pLHQudXNlTGF5b3V0RWZmZWN0KCgoKT0+by5zdWJzY3JpYmUoaSkpLFtvXSl9LGV4cG9ydHMudXNlUHJvZ3Jlc3M9SyxleHBvcnRzLnVzZVNjcm9sbD1yZSxleHBvcnRzLnVzZVNlbGVjdD1mdW5jdGlvbigpe3JldHVybiBQLnVzZUNvbnRleHQoc2UpfSxleHBvcnRzLnVzZVN1cmZhY2VTYW1wbGVyPVZlLGV4cG9ydHMudXNlVGV4dHVyZT1UZSxleHBvcnRzLnVzZVRyYWlsPVVlLGV4cG9ydHMudXNlVHJhaWxUZXh0dXJlPWZ1bmN0aW9uKGU9e30pe2NvbnN0e3NpemU6cixtYXhBZ2U6bixyYWRpdXM6byxpbnRlbnNpdHk6aSxpbnRlcnBvbGF0ZTpzLHNtb290aGluZzpsLG1pbkZvcmNlOmMsYmxlbmQ6dSxlYXNlOmR9PWUsbT10LnVzZU1lbW8oKCgpPT5uZXcgUnIoZSkpLFtyLG4sbyxpLHMsbCxjLHUsZF0pO2EudXNlRnJhbWUoKChlLHQpPT57bS51cGRhdGUodCl9KSk7Y29uc3QgZj10LnVzZUNhbGxiYWNrKChlPT5tLmFkZFRvdWNoKGUudXYpKSxbbV0pO3JldHVyblttLnRleHR1cmUsZl19LGV4cG9ydHMudXNlVmlkZW9UZXh0dXJlPXl0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nconst $node = Symbol.for('Animated:node');\nconst isAnimated = value => !!value && value[$node] === value;\nconst getAnimated = owner => owner && owner[$node];\nconst setAnimated = (owner, node) => shared.defineHidden(owner, $node, node);\nconst getPayload = owner => owner && owner[$node] && owner[$node].getPayload();\nclass Animated {\n  constructor() {\n    this.payload = void 0;\n    setAnimated(this, this);\n  }\n\n  getPayload() {\n    return this.payload || [];\n  }\n\n}\n\nclass AnimatedValue extends Animated {\n  constructor(_value) {\n    super();\n    this.done = true;\n    this.elapsedTime = void 0;\n    this.lastPosition = void 0;\n    this.lastVelocity = void 0;\n    this.v0 = void 0;\n    this.durationProgress = 0;\n    this._value = _value;\n\n    if (shared.is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n\n  getPayload() {\n    return [this];\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value, step) {\n    if (shared.is.num(value)) {\n      this.lastPosition = value;\n\n      if (step) {\n        value = Math.round(value / step) * step;\n\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n\n    if (this._value === value) {\n      return false;\n    }\n\n    this._value = value;\n    return true;\n  }\n\n  reset() {\n    const {\n      done\n    } = this;\n    this.done = false;\n\n    if (shared.is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done) this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n\n}\n\nclass AnimatedString extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = void 0;\n    this._toString = shared.createInterpolator({\n      output: [value, value]\n    });\n  }\n\n  static create(value) {\n    return new AnimatedString(value);\n  }\n\n  getValue() {\n    let value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n\n  setValue(value) {\n    if (shared.is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  reset(goal) {\n    if (goal) {\n      this._toString = shared.createInterpolator({\n        output: [this.getValue(), goal]\n      });\n    }\n\n    this._value = 0;\n    super.reset();\n  }\n\n}\n\nconst TreeContext = {\n  dependencies: null\n};\n\nclass AnimatedObject extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n\n  getValue(animated) {\n    const values = {};\n    shared.eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if (shared.hasFluidValue(source)) {\n        values[key] = shared.getFluidValue(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n\n  reset() {\n    if (this.payload) {\n      shared.each(this.payload, node => node.reset());\n    }\n  }\n\n  _makePayload(source) {\n    if (source) {\n      const payload = new Set();\n      shared.eachProp(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n\n  _addToPayload(source) {\n    if (TreeContext.dependencies && shared.hasFluidValue(source)) {\n      TreeContext.dependencies.add(source);\n    }\n\n    const payload = getPayload(source);\n\n    if (payload) {\n      shared.each(payload, node => this.add(node));\n    }\n  }\n\n}\n\nclass AnimatedArray extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n\n  getValue() {\n    return this.source.map(node => node.getValue());\n  }\n\n  setValue(source) {\n    const payload = this.getPayload();\n\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n\n}\n\nfunction makeAnimated(value) {\n  const nodeType = shared.isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : shared.is.arr(value) ? AnimatedArray : shared.isAnimatedString(value) ? AnimatedString : AnimatedValue;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst withAnimated = (Component, host) => {\n  const hasInstance = !shared.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return React.forwardRef((givenProps, givenRef) => {\n    const instanceRef = React.useRef(null);\n    const ref = hasInstance && React.useCallback(value => {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = shared.useForceUpdate();\n\n    const callback = () => {\n      const instance = instanceRef.current;\n\n      if (hasInstance && !instance) {\n        return;\n      }\n\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = React.useRef();\n    shared.useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer;\n      shared.each(deps, dep => shared.addFluidObserver(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          shared.each(observerRef.current.deps, dep => shared.removeFluidObserver(dep, observerRef.current));\n          shared.raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    React.useEffect(callback, []);\n    shared.useOnce(() => () => {\n      const observer = observerRef.current;\n      shared.each(observer.deps, dep => shared.removeFluidObserver(dep, observer));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return React__namespace.createElement(Component, _extends({}, usedProps, {\n      ref: ref\n    }));\n  });\n};\n\nclass PropsObserver {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      shared.raf.write(this.update);\n    }\n  }\n\n}\n\nfunction getAnimatedState(props, host) {\n  const dependencies = new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _extends({}, props, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\n\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (shared.is.fun(ref)) ref(value);else ref.current = value;\n  }\n\n  return value;\n}\n\nconst cacheKey = Symbol.for('AnimatedComponent');\nconst createHost = (components, {\n  applyAnimatedValues: _applyAnimatedValues = () => false,\n  createAnimatedStyle: _createAnimatedStyle = style => new AnimatedObject(style),\n  getComponentProps: _getComponentProps = props => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues: _applyAnimatedValues,\n    createAnimatedStyle: _createAnimatedStyle,\n    getComponentProps: _getComponentProps\n  };\n\n  const animated = Component => {\n    const displayName = getDisplayName(Component) || 'Anonymous';\n\n    if (shared.is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n\n  shared.eachProp(components, (Component, key) => {\n    if (shared.is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\n\nconst getDisplayName = arg => shared.is.str(arg) ? arg : arg && shared.is.str(arg.displayName) ? arg.displayName : shared.is.fun(arg) && arg.name || null;\n\nexports.Animated = Animated;\nexports.AnimatedArray = AnimatedArray;\nexports.AnimatedObject = AnimatedObject;\nexports.AnimatedString = AnimatedString;\nexports.AnimatedValue = AnimatedValue;\nexports.createHost = createHost;\nexports.getAnimated = getAnimated;\nexports.getAnimatedType = getAnimatedType;\nexports.getPayload = getPayload;\nexports.isAnimated = isAnimated;\nexports.setAnimated = setAnimated;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvYW5pbWF0ZWQvZGlzdC9yZWFjdC1zcHJpbmctYW5pbWF0ZWQuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGFBQWEsbUJBQU8sQ0FBQyxzSUFBc0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9hbmltYXRlZC9kaXN0L3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMuZGV2LmpzPzNmYjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2hhcmVkID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9zaGFyZWQnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcblxuY29uc3QgJG5vZGUgPSBTeW1ib2wuZm9yKCdBbmltYXRlZDpub2RlJyk7XG5jb25zdCBpc0FuaW1hdGVkID0gdmFsdWUgPT4gISF2YWx1ZSAmJiB2YWx1ZVskbm9kZV0gPT09IHZhbHVlO1xuY29uc3QgZ2V0QW5pbWF0ZWQgPSBvd25lciA9PiBvd25lciAmJiBvd25lclskbm9kZV07XG5jb25zdCBzZXRBbmltYXRlZCA9IChvd25lciwgbm9kZSkgPT4gc2hhcmVkLmRlZmluZUhpZGRlbihvd25lciwgJG5vZGUsIG5vZGUpO1xuY29uc3QgZ2V0UGF5bG9hZCA9IG93bmVyID0+IG93bmVyICYmIG93bmVyWyRub2RlXSAmJiBvd25lclskbm9kZV0uZ2V0UGF5bG9hZCgpO1xuY2xhc3MgQW5pbWF0ZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBheWxvYWQgPSB2b2lkIDA7XG4gICAgc2V0QW5pbWF0ZWQodGhpcywgdGhpcyk7XG4gIH1cblxuICBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLnBheWxvYWQgfHwgW107XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlZFZhbHVlIGV4dGVuZHMgQW5pbWF0ZWQge1xuICBjb25zdHJ1Y3RvcihfdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgdGhpcy5lbGFwc2VkVGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RWZWxvY2l0eSA9IHZvaWQgMDtcbiAgICB0aGlzLnYwID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG5cbiAgICBpZiAoc2hhcmVkLmlzLm51bSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5fdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZSwgc3RlcCkge1xuICAgIGlmIChzaGFyZWQuaXMubnVtKHZhbHVlKSkge1xuICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB2YWx1ZTtcblxuICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gc3RlcCkgKiBzdGVwO1xuXG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb25lXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG5cbiAgICBpZiAoc2hhcmVkLmlzLm51bSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgdGhpcy5kdXJhdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5fdmFsdWU7XG4gICAgICBpZiAoZG9uZSkgdGhpcy5sYXN0VmVsb2NpdHkgPSBudWxsO1xuICAgICAgdGhpcy52MCA9IG51bGw7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZWRTdHJpbmcgZXh0ZW5kcyBBbmltYXRlZFZhbHVlIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigwKTtcbiAgICB0aGlzLl9zdHJpbmcgPSBudWxsO1xuICAgIHRoaXMuX3RvU3RyaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuX3RvU3RyaW5nID0gc2hhcmVkLmNyZWF0ZUludGVycG9sYXRvcih7XG4gICAgICBvdXRwdXQ6IFt2YWx1ZSwgdmFsdWVdXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9zdHJpbmc7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzLl9zdHJpbmcgPSB0aGlzLl90b1N0cmluZyh0aGlzLl92YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHNoYXJlZC5pcy5zdHIodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gdGhpcy5fc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RyaW5nID0gdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdXBlci5zZXRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJlc2V0KGdvYWwpIHtcbiAgICBpZiAoZ29hbCkge1xuICAgICAgdGhpcy5fdG9TdHJpbmcgPSBzaGFyZWQuY3JlYXRlSW50ZXJwb2xhdG9yKHtcbiAgICAgICAgb3V0cHV0OiBbdGhpcy5nZXRWYWx1ZSgpLCBnb2FsXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gIH1cblxufVxuXG5jb25zdCBUcmVlQ29udGV4dCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBudWxsXG59O1xuXG5jbGFzcyBBbmltYXRlZE9iamVjdCBleHRlbmRzIEFuaW1hdGVkIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnNldFZhbHVlKHNvdXJjZSk7XG4gIH1cblxuICBnZXRWYWx1ZShhbmltYXRlZCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgIHNoYXJlZC5lYWNoUHJvcCh0aGlzLnNvdXJjZSwgKHNvdXJjZSwga2V5KSA9PiB7XG4gICAgICBpZiAoaXNBbmltYXRlZChzb3VyY2UpKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gc291cmNlLmdldFZhbHVlKGFuaW1hdGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcmVkLmhhc0ZsdWlkVmFsdWUoc291cmNlKSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNoYXJlZC5nZXRGbHVpZFZhbHVlKHNvdXJjZSk7XG4gICAgICB9IGVsc2UgaWYgKCFhbmltYXRlZCkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgc2V0VmFsdWUoc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5wYXlsb2FkID0gdGhpcy5fbWFrZVBheWxvYWQoc291cmNlKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnBheWxvYWQpIHtcbiAgICAgIHNoYXJlZC5lYWNoKHRoaXMucGF5bG9hZCwgbm9kZSA9PiBub2RlLnJlc2V0KCkpO1xuICAgIH1cbiAgfVxuXG4gIF9tYWtlUGF5bG9hZChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gbmV3IFNldCgpO1xuICAgICAgc2hhcmVkLmVhY2hQcm9wKHNvdXJjZSwgdGhpcy5fYWRkVG9QYXlsb2FkLCBwYXlsb2FkKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHBheWxvYWQpO1xuICAgIH1cbiAgfVxuXG4gIF9hZGRUb1BheWxvYWQoc291cmNlKSB7XG4gICAgaWYgKFRyZWVDb250ZXh0LmRlcGVuZGVuY2llcyAmJiBzaGFyZWQuaGFzRmx1aWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgICBUcmVlQ29udGV4dC5kZXBlbmRlbmNpZXMuYWRkKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGdldFBheWxvYWQoc291cmNlKTtcblxuICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICBzaGFyZWQuZWFjaChwYXlsb2FkLCBub2RlID0+IHRoaXMuYWRkKG5vZGUpKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBBbmltYXRlZEFycmF5IGV4dGVuZHMgQW5pbWF0ZWRPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkQXJyYXkoc291cmNlKTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5tYXAobm9kZSA9PiBub2RlLmdldFZhbHVlKCkpO1xuICB9XG5cbiAgc2V0VmFsdWUoc291cmNlKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuZ2V0UGF5bG9hZCgpO1xuXG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT0gcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkLm1hcCgobm9kZSwgaSkgPT4gbm9kZS5zZXRWYWx1ZShzb3VyY2VbaV0pKS5zb21lKEJvb2xlYW4pO1xuICAgIH1cblxuICAgIHN1cGVyLnNldFZhbHVlKHNvdXJjZS5tYXAobWFrZUFuaW1hdGVkKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBtYWtlQW5pbWF0ZWQodmFsdWUpIHtcbiAgY29uc3Qgbm9kZVR5cGUgPSBzaGFyZWQuaXNBbmltYXRlZFN0cmluZyh2YWx1ZSkgPyBBbmltYXRlZFN0cmluZyA6IEFuaW1hdGVkVmFsdWU7XG4gIHJldHVybiBub2RlVHlwZS5jcmVhdGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRlZFR5cGUodmFsdWUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldEFuaW1hdGVkKHZhbHVlKTtcbiAgcmV0dXJuIHBhcmVudE5vZGUgPyBwYXJlbnROb2RlLmNvbnN0cnVjdG9yIDogc2hhcmVkLmlzLmFycih2YWx1ZSkgPyBBbmltYXRlZEFycmF5IDogc2hhcmVkLmlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpID8gQW5pbWF0ZWRTdHJpbmcgOiBBbmltYXRlZFZhbHVlO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNvbnN0IHdpdGhBbmltYXRlZCA9IChDb21wb25lbnQsIGhvc3QpID0+IHtcbiAgY29uc3QgaGFzSW5zdGFuY2UgPSAhc2hhcmVkLmlzLmZ1bihDb21wb25lbnQpIHx8IENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZigoZ2l2ZW5Qcm9wcywgZ2l2ZW5SZWYpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCByZWYgPSBoYXNJbnN0YW5jZSAmJiBSZWFjdC51c2VDYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgICBpbnN0YW5jZVJlZi5jdXJyZW50ID0gdXBkYXRlUmVmKGdpdmVuUmVmLCB2YWx1ZSk7XG4gICAgfSwgW2dpdmVuUmVmXSk7XG4gICAgY29uc3QgW3Byb3BzLCBkZXBzXSA9IGdldEFuaW1hdGVkU3RhdGUoZ2l2ZW5Qcm9wcywgaG9zdCk7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSBzaGFyZWQudXNlRm9yY2VVcGRhdGUoKTtcblxuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoaGFzSW5zdGFuY2UgJiYgIWluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlkVXBkYXRlID0gaW5zdGFuY2UgPyBob3N0LmFwcGx5QW5pbWF0ZWRWYWx1ZXMoaW5zdGFuY2UsIHByb3BzLmdldFZhbHVlKHRydWUpKSA6IGZhbHNlO1xuXG4gICAgICBpZiAoZGlkVXBkYXRlID09PSBmYWxzZSkge1xuICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBQcm9wc09ic2VydmVyKGNhbGxiYWNrLCBkZXBzKTtcbiAgICBjb25zdCBvYnNlcnZlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBvYnNlcnZlcjtcbiAgICAgIHNoYXJlZC5lYWNoKGRlcHMsIGRlcCA9PiBzaGFyZWQuYWRkRmx1aWRPYnNlcnZlcihkZXAsIG9ic2VydmVyKSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIHNoYXJlZC5lYWNoKG9ic2VydmVyUmVmLmN1cnJlbnQuZGVwcywgZGVwID0+IHNoYXJlZC5yZW1vdmVGbHVpZE9ic2VydmVyKGRlcCwgb2JzZXJ2ZXJSZWYuY3VycmVudCkpO1xuICAgICAgICAgIHNoYXJlZC5yYWYuY2FuY2VsKG9ic2VydmVyUmVmLmN1cnJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoY2FsbGJhY2ssIFtdKTtcbiAgICBzaGFyZWQudXNlT25jZSgoKSA9PiAoKSA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG9ic2VydmVyUmVmLmN1cnJlbnQ7XG4gICAgICBzaGFyZWQuZWFjaChvYnNlcnZlci5kZXBzLCBkZXAgPT4gc2hhcmVkLnJlbW92ZUZsdWlkT2JzZXJ2ZXIoZGVwLCBvYnNlcnZlcikpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZWRQcm9wcyA9IGhvc3QuZ2V0Q29tcG9uZW50UHJvcHMocHJvcHMuZ2V0VmFsdWUoKSk7XG4gICAgcmV0dXJuIFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCB1c2VkUHJvcHMsIHtcbiAgICAgIHJlZjogcmVmXG4gICAgfSkpO1xuICB9KTtcbn07XG5cbmNsYXNzIFByb3BzT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3Rvcih1cGRhdGUsIGRlcHMpIHtcbiAgICB0aGlzLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB0aGlzLmRlcHMgPSBkZXBzO1xuICB9XG5cbiAgZXZlbnRPYnNlcnZlZChldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09ICdjaGFuZ2UnKSB7XG4gICAgICBzaGFyZWQucmFmLndyaXRlKHRoaXMudXBkYXRlKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRlZFN0YXRlKHByb3BzLCBob3N0KSB7XG4gIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgVHJlZUNvbnRleHQuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICBpZiAocHJvcHMuc3R5bGUpIHByb3BzID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgc3R5bGU6IGhvc3QuY3JlYXRlQW5pbWF0ZWRTdHlsZShwcm9wcy5zdHlsZSlcbiAgfSk7XG4gIHByb3BzID0gbmV3IEFuaW1hdGVkT2JqZWN0KHByb3BzKTtcbiAgVHJlZUNvbnRleHQuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgcmV0dXJuIFtwcm9wcywgZGVwZW5kZW5jaWVzXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKHJlZiwgdmFsdWUpIHtcbiAgaWYgKHJlZikge1xuICAgIGlmIChzaGFyZWQuaXMuZnVuKHJlZikpIHJlZih2YWx1ZSk7ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5jb25zdCBjYWNoZUtleSA9IFN5bWJvbC5mb3IoJ0FuaW1hdGVkQ29tcG9uZW50Jyk7XG5jb25zdCBjcmVhdGVIb3N0ID0gKGNvbXBvbmVudHMsIHtcbiAgYXBwbHlBbmltYXRlZFZhbHVlczogX2FwcGx5QW5pbWF0ZWRWYWx1ZXMgPSAoKSA9PiBmYWxzZSxcbiAgY3JlYXRlQW5pbWF0ZWRTdHlsZTogX2NyZWF0ZUFuaW1hdGVkU3R5bGUgPSBzdHlsZSA9PiBuZXcgQW5pbWF0ZWRPYmplY3Qoc3R5bGUpLFxuICBnZXRDb21wb25lbnRQcm9wczogX2dldENvbXBvbmVudFByb3BzID0gcHJvcHMgPT4gcHJvcHNcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBob3N0Q29uZmlnID0ge1xuICAgIGFwcGx5QW5pbWF0ZWRWYWx1ZXM6IF9hcHBseUFuaW1hdGVkVmFsdWVzLFxuICAgIGNyZWF0ZUFuaW1hdGVkU3R5bGU6IF9jcmVhdGVBbmltYXRlZFN0eWxlLFxuICAgIGdldENvbXBvbmVudFByb3BzOiBfZ2V0Q29tcG9uZW50UHJvcHNcbiAgfTtcblxuICBjb25zdCBhbmltYXRlZCA9IENvbXBvbmVudCA9PiB7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHx8ICdBbm9ueW1vdXMnO1xuXG4gICAgaWYgKHNoYXJlZC5pcy5zdHIoQ29tcG9uZW50KSkge1xuICAgICAgQ29tcG9uZW50ID0gYW5pbWF0ZWRbQ29tcG9uZW50XSB8fCAoYW5pbWF0ZWRbQ29tcG9uZW50XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50W2NhY2hlS2V5XSB8fCAoQ29tcG9uZW50W2NhY2hlS2V5XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9XG5cbiAgICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSBgQW5pbWF0ZWQoJHtkaXNwbGF5TmFtZX0pYDtcbiAgICByZXR1cm4gQ29tcG9uZW50O1xuICB9O1xuXG4gIHNoYXJlZC5lYWNoUHJvcChjb21wb25lbnRzLCAoQ29tcG9uZW50LCBrZXkpID0+IHtcbiAgICBpZiAoc2hhcmVkLmlzLmFycihjb21wb25lbnRzKSkge1xuICAgICAga2V5ID0gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBhbmltYXRlZFtrZXldID0gYW5pbWF0ZWQoQ29tcG9uZW50KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0ZWRcbiAgfTtcbn07XG5cbmNvbnN0IGdldERpc3BsYXlOYW1lID0gYXJnID0+IHNoYXJlZC5pcy5zdHIoYXJnKSA/IGFyZyA6IGFyZyAmJiBzaGFyZWQuaXMuc3RyKGFyZy5kaXNwbGF5TmFtZSkgPyBhcmcuZGlzcGxheU5hbWUgOiBzaGFyZWQuaXMuZnVuKGFyZykgJiYgYXJnLm5hbWUgfHwgbnVsbDtcblxuZXhwb3J0cy5BbmltYXRlZCA9IEFuaW1hdGVkO1xuZXhwb3J0cy5BbmltYXRlZEFycmF5ID0gQW5pbWF0ZWRBcnJheTtcbmV4cG9ydHMuQW5pbWF0ZWRPYmplY3QgPSBBbmltYXRlZE9iamVjdDtcbmV4cG9ydHMuQW5pbWF0ZWRTdHJpbmcgPSBBbmltYXRlZFN0cmluZztcbmV4cG9ydHMuQW5pbWF0ZWRWYWx1ZSA9IEFuaW1hdGVkVmFsdWU7XG5leHBvcnRzLmNyZWF0ZUhvc3QgPSBjcmVhdGVIb3N0O1xuZXhwb3J0cy5nZXRBbmltYXRlZCA9IGdldEFuaW1hdGVkO1xuZXhwb3J0cy5nZXRBbmltYXRlZFR5cGUgPSBnZXRBbmltYXRlZFR5cGU7XG5leHBvcnRzLmdldFBheWxvYWQgPSBnZXRQYXlsb2FkO1xuZXhwb3J0cy5pc0FuaW1hdGVkID0gaXNBbmltYXRlZDtcbmV4cG9ydHMuc2V0QW5pbWF0ZWQgPSBzZXRBbmltYXRlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js ***!
  \**************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-animated.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvYW5pbWF0ZWQvZGlzdC9yZWFjdC1zcHJpbmctYW5pbWF0ZWQuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxrTUFBOEQ7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL2FuaW1hdGVkL2Rpc3QvcmVhY3Qtc3ByaW5nLWFuaW1hdGVkLmNqcy5qcz84ODI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy1hbmltYXRlZC5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLWFuaW1hdGVkLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar animated$1 = __webpack_require__(/*! @react-spring/animated */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\");\nvar animated = __webpack_require__(/*! @react-spring/types/animated */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/types/animated.js\");\nvar interpolation = __webpack_require__(/*! @react-spring/types/interpolation */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/types/interpolation.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction callProp(value, ...args) {\n  return shared.is.fun(value) ? value(...args) : value;\n}\nconst matchProp = (value, key) => value === true || !!(key && value && (shared.is.fun(value) ? value(key) : shared.toArray(value).includes(key)));\nconst resolveProp = (prop, key) => shared.is.obj(prop) ? key && prop[key] : prop;\nconst getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : undefined;\n\nconst noopTransform = value => value;\n\nconst getDefaultProps = (props, transform = noopTransform) => {\n  let keys = DEFAULT_PROPS;\n\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n\n  const defaults = {};\n\n  for (const key of keys) {\n    const value = transform(props[key], key);\n\n    if (!shared.is.und(value)) {\n      defaults[key] = value;\n    }\n  }\n\n  return defaults;\n};\nconst DEFAULT_PROPS = ['config', 'onProps', 'onStart', 'onChange', 'onPause', 'onResume', 'onRest'];\nconst RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\n\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  shared.eachProp(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n\n  if (count) {\n    return forward;\n  }\n}\n\nfunction inferTo(props) {\n  const to = getForwardProps(props);\n\n  if (to) {\n    const out = {\n      to\n    };\n    shared.eachProp(props, (val, key) => key in to || (out[key] = val));\n    return out;\n  }\n\n  return _extends({}, props);\n}\nfunction computeGoal(value) {\n  value = shared.getFluidValue(value);\n  return shared.is.arr(value) ? value.map(computeGoal) : shared.isAnimatedString(value) ? shared.Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\nfunction hasProps(props) {\n  for (const _ in props) return true;\n\n  return false;\n}\nfunction isAsyncTo(to) {\n  return shared.is.fun(to) || shared.is.arr(to) && shared.is.obj(to[0]);\n}\nfunction detachRefs(ctrl, ref) {\n  var _ctrl$ref;\n\n  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);\n  ref == null ? void 0 : ref.delete(ctrl);\n}\nfunction replaceRef(ctrl, ref) {\n  if (ref && ctrl.ref !== ref) {\n    var _ctrl$ref2;\n\n    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\nfunction useChain(refs, timeSteps, timeFrame = 1000) {\n  shared.useIsomorphicLayoutEffect(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      shared.each(refs, (ref, i) => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay)) delay = prevDelay;else prevDelay = delay;\n          shared.each(controllers, ctrl => {\n            shared.each(ctrl.queue, props => {\n              const memoizedDelayProp = props.delay;\n\n              props.delay = key => delay + callProp(memoizedDelayProp || 0, key);\n            });\n          });\n          ref.start();\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      shared.each(refs, ref => {\n        const controllers = ref.current;\n\n        if (controllers.length) {\n          const queues = controllers.map(ctrl => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            shared.each(controllers, (ctrl, i) => shared.each(queues[i] || [], update => ctrl.queue.push(update)));\n            return Promise.all(ref.start());\n          });\n        }\n      });\n    }\n  });\n}\n\nconst config = {\n  default: {\n    tension: 170,\n    friction: 26\n  },\n  gentle: {\n    tension: 120,\n    friction: 14\n  },\n  wobbly: {\n    tension: 180,\n    friction: 12\n  },\n  stiff: {\n    tension: 210,\n    friction: 20\n  },\n  slow: {\n    tension: 280,\n    friction: 60\n  },\n  molasses: {\n    tension: 280,\n    friction: 120\n  }\n};\n\nconst defaults = _extends({}, config.default, {\n  mass: 1,\n  damping: 1,\n  easing: shared.easings.linear,\n  clamp: false\n});\n\nclass AnimationConfig {\n  constructor() {\n    this.tension = void 0;\n    this.friction = void 0;\n    this.frequency = void 0;\n    this.damping = void 0;\n    this.mass = void 0;\n    this.velocity = 0;\n    this.restVelocity = void 0;\n    this.precision = void 0;\n    this.progress = void 0;\n    this.duration = void 0;\n    this.easing = void 0;\n    this.clamp = void 0;\n    this.bounce = void 0;\n    this.decay = void 0;\n    this.round = void 0;\n    Object.assign(this, defaults);\n  }\n\n}\nfunction mergeConfig(config, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = _extends({}, defaultConfig);\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = _extends({}, defaultConfig, newConfig);\n  }\n\n  sanitizeConfig(config, newConfig);\n  Object.assign(config, newConfig);\n\n  for (const key in defaults) {\n    if (config[key] == null) {\n      config[key] = defaults[key];\n    }\n  }\n\n  let {\n    mass,\n    frequency,\n    damping\n  } = config;\n\n  if (!shared.is.und(frequency)) {\n    if (frequency < 0.01) frequency = 0.01;\n    if (damping < 0) damping = 0;\n    config.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n\n  return config;\n}\n\nfunction sanitizeConfig(config, props) {\n  if (!shared.is.und(props.decay)) {\n    config.duration = undefined;\n  } else {\n    const isTensionConfig = !shared.is.und(props.tension) || !shared.is.und(props.friction);\n\n    if (isTensionConfig || !shared.is.und(props.frequency) || !shared.is.und(props.damping) || !shared.is.und(props.mass)) {\n      config.duration = undefined;\n      config.decay = undefined;\n    }\n\n    if (isTensionConfig) {\n      config.frequency = undefined;\n    }\n  }\n}\n\nconst emptyArray = [];\nclass Animation {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.to = void 0;\n    this.from = void 0;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n\n}\n\nfunction scheduleProps(callId, {\n  key,\n  props,\n  defaultProps,\n  state,\n  actions\n}) {\n  return new Promise((resolve, reject) => {\n    var _props$cancel;\n\n    let delay;\n    let timeout;\n    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps == null ? void 0 : defaultProps.cancel, key);\n\n    if (cancel) {\n      onStart();\n    } else {\n      if (!shared.is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n\n      let pause = defaultProps == null ? void 0 : defaultProps.pause;\n\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n\n      delay = callProp(props.delay || 0, key);\n\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - shared.raf.now();\n    }\n\n    function onResume() {\n      if (delay > 0 && !shared.Globals.skipAnimation) {\n        state.delayed = true;\n        timeout = shared.raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n\n    function onStart() {\n      if (state.delayed) {\n        state.delayed = false;\n      }\n\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n\n      try {\n        actions.start(_extends({}, props, {\n          callId,\n          cancel\n        }), resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\nconst getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some(result => result.cancelled) ? getCancelledResult(target.get()) : results.every(result => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every(result => result.finished));\nconst getNoopResult = value => ({\n  value,\n  noop: true,\n  finished: true,\n  cancelled: false\n});\nconst getFinishedResult = (value, finished, cancelled = false) => ({\n  value,\n  finished,\n  cancelled\n});\nconst getCancelledResult = value => ({\n  value,\n  cancelled: true,\n  finished: false\n});\n\nfunction runAsync(to, props, state, target) {\n  const {\n    callId,\n    parentId,\n    onRest\n  } = props;\n  const {\n    asyncTo: prevTo,\n    promise: prevPromise\n  } = state;\n\n  if (!parentId && to === prevTo && !props.reset) {\n    return prevPromise;\n  }\n\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to;\n    const defaultProps = getDefaultProps(props, (value, key) => key === 'onRest' ? undefined : value);\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));\n\n    const bailIfEnded = bailSignal => {\n      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);\n\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      const skipAnimationSignal = new SkipAnimationSignal();\n      return (async () => {\n        if (shared.Globals.skipAnimation) {\n          stopAsync(state);\n          skipAnimationSignal.result = getFinishedResult(target, false);\n          bail(skipAnimationSignal);\n          throw skipAnimationSignal;\n        }\n\n        bailIfEnded(bailSignal);\n        const props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n          to: arg1\n        });\n        props.parentId = callId;\n        shared.eachProp(defaultProps, (value, key) => {\n          if (shared.is.und(props[key])) {\n            props[key] = value;\n          }\n        });\n        const result = await target.start(props);\n        bailIfEnded(bailSignal);\n\n        if (state.paused) {\n          await new Promise(resume => {\n            state.resumeQueue.add(resume);\n          });\n        }\n\n        return result;\n      })();\n    };\n\n    let result;\n\n    if (shared.Globals.skipAnimation) {\n      stopAsync(state);\n      return getFinishedResult(target, false);\n    }\n\n    try {\n      let animating;\n\n      if (shared.is.arr(to)) {\n        animating = (async queue => {\n          for (const props of queue) {\n            await animate(props);\n          }\n        })(to);\n      } else {\n        animating = Promise.resolve(to(animate, target.stop.bind(target)));\n      }\n\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target.get(), true, false);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else if (err instanceof SkipAnimationSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : undefined;\n        state.promise = parentId ? prevPromise : undefined;\n      }\n    }\n\n    if (shared.is.fun(onRest)) {\n      shared.raf.batchedUpdates(() => {\n        onRest(result, target, target.item);\n      });\n    }\n\n    return result;\n  })();\n}\nfunction stopAsync(state, cancelId) {\n  shared.flush(state.timeouts, t => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = undefined;\n  if (cancelId) state.cancelId = cancelId;\n}\nclass BailSignal extends Error {\n  constructor() {\n    super('An async animation has been interrupted. You see this error because you ' + 'forgot to use `await` or `.catch(...)` on its returned promise.');\n    this.result = void 0;\n  }\n\n}\nclass SkipAnimationSignal extends Error {\n  constructor() {\n    super('SkipAnimationSignal');\n    this.result = void 0;\n  }\n\n}\n\nconst isFrameValue = value => value instanceof FrameValue;\nlet nextId$1 = 1;\nclass FrameValue extends shared.FluidValue {\n  constructor(...args) {\n    super(...args);\n    this.id = nextId$1++;\n    this.key = void 0;\n    this._priority = 0;\n  }\n\n  get priority() {\n    return this._priority;\n  }\n\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n\n      this._onPriorityChange(priority);\n    }\n  }\n\n  get() {\n    const node = animated$1.getAnimated(this);\n    return node && node.getValue();\n  }\n\n  to(...args) {\n    return shared.Globals.to(this, args);\n  }\n\n  interpolate(...args) {\n    shared.deprecateInterpolate();\n    return shared.Globals.to(this, args);\n  }\n\n  toJSON() {\n    return this.get();\n  }\n\n  observerAdded(count) {\n    if (count == 1) this._attach();\n  }\n\n  observerRemoved(count) {\n    if (count == 0) this._detach();\n  }\n\n  _attach() {}\n\n  _detach() {}\n\n  _onChange(value, idle = false) {\n    shared.callFluidObservers(this, {\n      type: 'change',\n      parent: this,\n      value,\n      idle\n    });\n  }\n\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      shared.frameLoop.sort(this);\n    }\n\n    shared.callFluidObservers(this, {\n      type: 'priority',\n      parent: this,\n      priority\n    });\n  }\n\n}\n\nconst $P = Symbol.for('SpringPhase');\nconst HAS_ANIMATED = 1;\nconst IS_ANIMATING = 2;\nconst IS_PAUSED = 4;\nconst hasAnimated = target => (target[$P] & HAS_ANIMATED) > 0;\nconst isAnimating = target => (target[$P] & IS_ANIMATING) > 0;\nconst isPaused = target => (target[$P] & IS_PAUSED) > 0;\nconst setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\nconst setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\nclass SpringValue extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    this.key = void 0;\n    this.animation = new Animation();\n    this.queue = void 0;\n    this.defaultProps = {};\n    this._state = {\n      paused: false,\n      delayed: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._pendingCalls = new Set();\n    this._lastCallId = 0;\n    this._lastToId = 0;\n    this._memoizedDuration = 0;\n\n    if (!shared.is.und(arg1) || !shared.is.und(arg2)) {\n      const props = shared.is.obj(arg1) ? _extends({}, arg1) : _extends({}, arg2, {\n        from: arg1\n      });\n\n      if (shared.is.und(props.default)) {\n        props.default = true;\n      }\n\n      this.start(props);\n    }\n  }\n\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n\n  get goal() {\n    return shared.getFluidValue(this.animation.to);\n  }\n\n  get velocity() {\n    const node = animated$1.getAnimated(this);\n    return node instanceof animated$1.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map(node => node.lastVelocity || 0);\n  }\n\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n\n  get isAnimating() {\n    return isAnimating(this);\n  }\n\n  get isPaused() {\n    return isPaused(this);\n  }\n\n  get isDelayed() {\n    return this._state.delayed;\n  }\n\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let {\n      config,\n      toValues\n    } = anim;\n    const payload = animated$1.getPayload(anim.to);\n\n    if (!payload && shared.hasFluidValue(anim.to)) {\n      toValues = shared.toArray(shared.getFluidValue(anim.to));\n    }\n\n    anim.values.forEach((node, i) => {\n      if (node.done) return;\n      const to = node.constructor == animated$1.AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];\n      let finished = anim.immediate;\n      let position = to;\n\n      if (!finished) {\n        position = node.lastPosition;\n\n        if (config.tension <= 0) {\n          node.done = true;\n          return;\n        }\n\n        let elapsed = node.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node.v0 != null ? node.v0 : node.v0 = shared.is.arr(config.velocity) ? config.velocity[i] : config.velocity;\n        let velocity;\n        const precision = config.precision || (from == to ? 0.005 : Math.min(1, Math.abs(to - from) * 0.001));\n\n        if (!shared.is.und(config.duration)) {\n          let p = 1;\n\n          if (config.duration > 0) {\n            if (this._memoizedDuration !== config.duration) {\n              this._memoizedDuration = config.duration;\n\n              if (node.durationProgress > 0) {\n                node.elapsedTime = config.duration * node.durationProgress;\n                elapsed = node.elapsedTime += dt;\n              }\n            }\n\n            p = (config.progress || 0) + elapsed / this._memoizedDuration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n            node.durationProgress = p;\n          }\n\n          position = from + config.easing(p) * (to - from);\n          velocity = (position - node.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config.decay) {\n          const decay = config.decay === true ? 0.998 : config.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node.lastPosition - position) <= precision;\n          velocity = v0 * e;\n        } else {\n          velocity = node.lastVelocity == null ? v0 : node.lastVelocity;\n          const restVelocity = config.restVelocity || precision / 10;\n          const bounceFactor = config.clamp ? 0 : config.bounce;\n          const canBounce = !shared.is.und(bounceFactor);\n          const isGrowing = from == to ? node.v0 > 0 : from < to;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n\n            if (!isMoving) {\n              finished = Math.abs(to - position) <= precision;\n\n              if (finished) {\n                break;\n              }\n            }\n\n            if (canBounce) {\n              isBouncing = position == to || position > to == isGrowing;\n\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to;\n              }\n            }\n\n            const springForce = -config.tension * 0.000001 * (position - to);\n            const dampingForce = -config.friction * 0.001 * velocity;\n            const acceleration = (springForce + dampingForce) / config.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n\n        node.lastVelocity = velocity;\n\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n\n      if (finished) {\n        node.done = true;\n      } else {\n        idle = false;\n      }\n\n      if (node.setValue(position, config.round)) {\n        changed = true;\n      }\n    });\n    const node = animated$1.getAnimated(this);\n    const currVal = node.getValue();\n\n    if (idle) {\n      const finalVal = shared.getFluidValue(anim.to);\n\n      if ((currVal !== finalVal || changed) && !config.decay) {\n        node.setValue(finalVal);\n\n        this._onChange(finalVal);\n      } else if (changed && config.decay) {\n        this._onChange(currVal);\n      }\n\n      this._stop();\n    } else if (changed) {\n      this._onChange(currVal);\n    }\n  }\n\n  set(value) {\n    shared.raf.batchedUpdates(() => {\n      this._stop();\n\n      this._focus(value);\n\n      this._set(value);\n    });\n    return this;\n  }\n\n  pause() {\n    this._update({\n      pause: true\n    });\n  }\n\n  resume() {\n    this._update({\n      pause: false\n    });\n  }\n\n  finish() {\n    if (isAnimating(this)) {\n      const {\n        to,\n        config\n      } = this.animation;\n      shared.raf.batchedUpdates(() => {\n        this._onStart();\n\n        if (!config.decay) {\n          this._set(to, false);\n        }\n\n        this._stop();\n      });\n    }\n\n    return this;\n  }\n\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n\n  start(to, arg2) {\n    let queue;\n\n    if (!shared.is.und(to)) {\n      queue = [shared.is.obj(to) ? to : _extends({}, arg2, {\n        to\n      })];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n\n    return Promise.all(queue.map(props => {\n      const up = this._update(props);\n\n      return up;\n    })).then(results => getCombinedResult(this, results));\n  }\n\n  stop(cancel) {\n    const {\n      to\n    } = this.animation;\n\n    this._focus(this.get());\n\n    stopAsync(this._state, cancel && this._lastCallId);\n    shared.raf.batchedUpdates(() => this._stop(to, cancel));\n    return this;\n  }\n\n  reset() {\n    this._update({\n      reset: true\n    });\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      this._start();\n    } else if (event.type == 'priority') {\n      this.priority = event.priority + 1;\n    }\n  }\n\n  _prepareNode(props) {\n    const key = this.key || '';\n    let {\n      to,\n      from\n    } = props;\n    to = shared.is.obj(to) ? to[key] : to;\n\n    if (to == null || isAsyncTo(to)) {\n      to = undefined;\n    }\n\n    from = shared.is.obj(from) ? from[key] : from;\n\n    if (from == null) {\n      from = undefined;\n    }\n\n    const range = {\n      to,\n      from\n    };\n\n    if (!hasAnimated(this)) {\n      if (props.reverse) [to, from] = [from, to];\n      from = shared.getFluidValue(from);\n\n      if (!shared.is.und(from)) {\n        this._set(from);\n      } else if (!animated$1.getAnimated(this)) {\n        this._set(to);\n      }\n    }\n\n    return range;\n  }\n\n  _update(_ref, isLoop) {\n    let props = _extends({}, _ref);\n\n    const {\n      key,\n      defaultProps\n    } = this;\n    if (props.default) Object.assign(defaultProps, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));\n    mergeActiveFn(this, props, 'onProps');\n    sendEvent(this, 'onProps', props, this);\n\n    const range = this._prepareNode(props);\n\n    if (Object.isFrozen(this)) {\n      throw Error('Cannot animate a `SpringValue` object that is frozen. ' + 'Did you forget to pass your component to `animated(...)` before animating its props?');\n    }\n\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            shared.flushCalls(state.pauseQueue);\n            sendEvent(this, 'onPause', getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n\n            if (isAnimating(this)) {\n              this._resume();\n            }\n\n            shared.flushCalls(state.resumeQueue);\n            sendEvent(this, 'onResume', getFinishedResult(this, checkFinished(this, this.animation.to)), this);\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then(result => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n\n    const hasToProp = !shared.is.und(range.to);\n    const hasFromProp = !shared.is.und(range.from);\n\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n\n    const {\n      key,\n      defaultProps,\n      animation: anim\n    } = this;\n    const {\n      to: prevTo,\n      from: prevFrom\n    } = anim;\n    let {\n      to = prevTo,\n      from = prevFrom\n    } = range;\n\n    if (hasFromProp && !hasToProp && (!props.default || shared.is.und(to))) {\n      to = from;\n    }\n\n    if (props.reverse) [to, from] = [from, to];\n    const hasFromChanged = !shared.isEqual(from, prevFrom);\n\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n\n    from = shared.getFluidValue(from);\n    const hasToChanged = !shared.isEqual(to, prevTo);\n\n    if (hasToChanged) {\n      this._focus(to);\n    }\n\n    const hasAsyncTo = isAsyncTo(props.to);\n    const {\n      config\n    } = anim;\n    const {\n      decay,\n      velocity\n    } = config;\n\n    if (hasToProp || hasFromProp) {\n      config.velocity = 0;\n    }\n\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(config, callProp(props.config, key), props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0);\n    }\n\n    let node = animated$1.getAnimated(this);\n\n    if (!node || shared.is.und(to)) {\n      return resolve(getFinishedResult(this, true));\n    }\n\n    const reset = shared.is.und(props.reset) ? hasFromProp && !props.default : !shared.is.und(from) && matchProp(props.reset, key);\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to);\n    const isAnimatable = shared.is.num(goal) || shared.is.arr(goal) || shared.isAnimatedString(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n\n    if (hasToChanged) {\n      const nodeType = animated$1.getAnimatedType(to);\n\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`);\n      }\n    }\n\n    const goalType = node.constructor;\n    let started = shared.hasFluidValue(to);\n    let finished = false;\n\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n\n      if (hasToChanged || hasValueChanged) {\n        finished = shared.isEqual(computeGoal(value), goal);\n        started = !finished;\n      }\n\n      if (!shared.isEqual(anim.immediate, immediate) && !immediate || !shared.isEqual(config.decay, decay) || !shared.isEqual(config.velocity, velocity)) {\n        started = true;\n      }\n    }\n\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n\n    if (!hasAsyncTo) {\n      if (started || shared.hasFluidValue(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = shared.hasFluidValue(to) ? null : goalType == animated$1.AnimatedString ? [1] : shared.toArray(goal);\n      }\n\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n\n      if (started) {\n        const {\n          onRest\n        } = anim;\n        shared.each(ACTIVE_EVENTS, type => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        shared.flushCalls(this._pendingCalls, result);\n\n        this._pendingCalls.add(resolve);\n\n        if (anim.changed) shared.raf.batchedUpdates(() => {\n          anim.changed = !reset;\n          onRest == null ? void 0 : onRest(result, this);\n\n          if (reset) {\n            callProp(defaultProps.onRest, result);\n          } else {\n            anim.onStart == null ? void 0 : anim.onStart(result, this);\n          }\n        });\n      }\n    }\n\n    if (reset) {\n      this._set(value);\n    }\n\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(value));\n    }\n  }\n\n  _focus(value) {\n    const anim = this.animation;\n\n    if (value !== anim.to) {\n      if (shared.getFluidObservers(this)) {\n        this._detach();\n      }\n\n      anim.to = value;\n\n      if (shared.getFluidObservers(this)) {\n        this._attach();\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 0;\n    const {\n      to\n    } = this.animation;\n\n    if (shared.hasFluidValue(to)) {\n      shared.addFluidObserver(to, this);\n\n      if (isFrameValue(to)) {\n        priority = to.priority + 1;\n      }\n    }\n\n    this.priority = priority;\n  }\n\n  _detach() {\n    const {\n      to\n    } = this.animation;\n\n    if (shared.hasFluidValue(to)) {\n      shared.removeFluidObserver(to, this);\n    }\n  }\n\n  _set(arg, idle = true) {\n    const value = shared.getFluidValue(arg);\n\n    if (!shared.is.und(value)) {\n      const oldNode = animated$1.getAnimated(this);\n\n      if (!oldNode || !shared.isEqual(value, oldNode.getValue())) {\n        const nodeType = animated$1.getAnimatedType(value);\n\n        if (!oldNode || oldNode.constructor != nodeType) {\n          animated$1.setAnimated(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n\n        if (oldNode) {\n          shared.raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n\n    return animated$1.getAnimated(this);\n  }\n\n  _onStart() {\n    const anim = this.animation;\n\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(this, 'onStart', getFinishedResult(this, checkFinished(this, anim.to)), this);\n    }\n  }\n\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n\n      callProp(this.animation.onChange, value, this);\n    }\n\n    callProp(this.defaultProps.onChange, value, this);\n\n    super._onChange(value, idle);\n  }\n\n  _start() {\n    const anim = this.animation;\n    animated$1.getAnimated(this).reset(shared.getFluidValue(anim.to));\n\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map(node => node.lastPosition);\n    }\n\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n\n  _resume() {\n    if (shared.Globals.skipAnimation) {\n      this.finish();\n    } else {\n      shared.frameLoop.start(this);\n    }\n  }\n\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      shared.each(anim.values, node => {\n        node.done = true;\n      });\n\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = undefined;\n      }\n\n      shared.callFluidObservers(this, {\n        type: 'idle',\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));\n      shared.flushCalls(this._pendingCalls, result);\n\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, 'onRest', result, this);\n      }\n    }\n  }\n\n}\n\nfunction checkFinished(target, to) {\n  const goal = computeGoal(to);\n  const value = computeGoal(target.get());\n  return shared.isEqual(value, goal);\n}\n\nfunction createLoopUpdate(props, loop = props.loop, to = props.to) {\n  let loopRet = callProp(loop);\n\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate(_extends({}, props, {\n      loop,\n      default: false,\n      pause: undefined,\n      to: !reverse || isAsyncTo(to) ? to : undefined,\n      from: reset ? props.from : undefined,\n      reset\n    }, overrides));\n  }\n}\nfunction createUpdate(props) {\n  const {\n    to,\n    from\n  } = props = inferTo(props);\n  const keys = new Set();\n  if (shared.is.obj(to)) findDefined(to, keys);\n  if (shared.is.obj(from)) findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\nfunction declareUpdate(props) {\n  const update = createUpdate(props);\n\n  if (shared.is.und(update.default)) {\n    update.default = getDefaultProps(update);\n  }\n\n  return update;\n}\n\nfunction findDefined(values, keys) {\n  shared.eachProp(values, (value, key) => value != null && keys.add(key));\n}\n\nconst ACTIVE_EVENTS = ['onStart', 'onRest', 'onChange', 'onPause', 'onResume'];\n\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : undefined;\n}\n\nfunction sendEvent(target, type, ...args) {\n  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;\n\n  (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);\n  (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);\n}\n\nconst BATCHED_EVENTS = ['onStart', 'onChange', 'onRest'];\nlet nextId = 1;\nclass Controller {\n  constructor(props, flush) {\n    this.id = nextId++;\n    this.springs = {};\n    this.queue = [];\n    this.ref = void 0;\n    this._flush = void 0;\n    this._initialProps = void 0;\n    this._lastAsyncId = 0;\n    this._active = new Set();\n    this._changed = new Set();\n    this._started = false;\n    this._item = void 0;\n    this._state = {\n      paused: false,\n      pauseQueue: new Set(),\n      resumeQueue: new Set(),\n      timeouts: new Set()\n    };\n    this._events = {\n      onStart: new Map(),\n      onChange: new Map(),\n      onRest: new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n\n    if (flush) {\n      this._flush = flush;\n    }\n\n    if (props) {\n      this.start(_extends({\n        default: true\n      }, props));\n    }\n  }\n\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every(spring => {\n      return spring.idle && !spring.isDelayed && !spring.isPaused;\n    });\n  }\n\n  get item() {\n    return this._item;\n  }\n\n  set item(item) {\n    this._item = item;\n  }\n\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n\n      if (!shared.is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n\n    return this;\n  }\n\n  start(props) {\n    let {\n      queue\n    } = this;\n\n    if (props) {\n      queue = shared.toArray(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n\n    if (keys) {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each(spring => spring.stop(!!arg));\n    }\n\n    return this;\n  }\n\n  pause(keys) {\n    if (shared.is.und(keys)) {\n      this.start({\n        pause: true\n      });\n    } else {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].pause());\n    }\n\n    return this;\n  }\n\n  resume(keys) {\n    if (shared.is.und(keys)) {\n      this.start({\n        pause: false\n      });\n    } else {\n      const springs = this.springs;\n      shared.each(shared.toArray(keys), key => springs[key].resume());\n    }\n\n    return this;\n  }\n\n  each(iterator) {\n    shared.eachProp(this.springs, iterator);\n  }\n\n  _onFrame() {\n    const {\n      onStart,\n      onChange,\n      onRest\n    } = this._events;\n    const active = this._active.size > 0;\n    const changed = this._changed.size > 0;\n\n    if (active && !this._started || changed && !this._started) {\n      this._started = true;\n      shared.flush(onStart, ([onStart, result]) => {\n        result.value = this.get();\n        onStart(result, this, this._item);\n      });\n    }\n\n    const idle = !active && this._started;\n    const values = changed || idle && onRest.size ? this.get() : null;\n\n    if (changed && onChange.size) {\n      shared.flush(onChange, ([onChange, result]) => {\n        result.value = values;\n        onChange(result, this, this._item);\n      });\n    }\n\n    if (idle) {\n      this._started = false;\n      shared.flush(onRest, ([onRest, result]) => {\n        result.value = values;\n        onRest(result, this, this._item);\n      });\n    }\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      this._changed.add(event.parent);\n\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == 'idle') {\n      this._active.delete(event.parent);\n    } else return;\n\n    shared.raf.onFrame(this._onFrame);\n  }\n\n}\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map(props => flushUpdate(ctrl, props))).then(results => getCombinedResult(ctrl, results));\n}\nasync function flushUpdate(ctrl, props, isLoop) {\n  const {\n    keys,\n    to,\n    from,\n    loop,\n    onRest,\n    onResolve\n  } = props;\n  const defaults = shared.is.obj(props.default) && props.default;\n\n  if (loop) {\n    props.loop = false;\n  }\n\n  if (to === false) props.to = null;\n  if (from === false) props.from = null;\n  const asyncTo = shared.is.arr(to) || shared.is.fun(to) ? to : undefined;\n\n  if (asyncTo) {\n    props.to = undefined;\n    props.onRest = undefined;\n\n    if (defaults) {\n      defaults.onRest = undefined;\n    }\n  } else {\n    shared.each(BATCHED_EVENTS, key => {\n      const handler = props[key];\n\n      if (shared.is.fun(handler)) {\n        const queue = ctrl['_events'][key];\n\n        props[key] = ({\n          finished,\n          cancelled\n        }) => {\n          const result = queue.get(handler);\n\n          if (result) {\n            if (!finished) result.finished = false;\n            if (cancelled) result.cancelled = true;\n          } else {\n            queue.set(handler, {\n              value: null,\n              finished: finished || false,\n              cancelled: cancelled || false\n            });\n          }\n        };\n\n        if (defaults) {\n          defaults[key] = props[key];\n        }\n      }\n    });\n  }\n\n  const state = ctrl['_state'];\n\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    shared.flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n\n  const promises = (keys || Object.keys(ctrl.springs)).map(key => ctrl.springs[key].start(props));\n  const cancel = props.cancel === true || getDefaultProp(props, 'cancel') === true;\n\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(scheduleProps(++ctrl['_lastAsyncId'], {\n      props,\n      state,\n      actions: {\n        pause: shared.noop,\n        resume: shared.noop,\n\n        start(props, resolve) {\n          if (cancel) {\n            stopAsync(state, ctrl['_lastAsyncId']);\n            resolve(getCancelledResult(ctrl));\n          } else {\n            props.onRest = onRest;\n            resolve(runAsync(asyncTo, props, state, ctrl));\n          }\n        }\n\n      }\n    }));\n  }\n\n  if (state.paused) {\n    await new Promise(resume => {\n      state.resumeQueue.add(resume);\n    });\n  }\n\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to);\n\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n\n  if (onResolve) {\n    shared.raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));\n  }\n\n  return result;\n}\nfunction getSprings(ctrl, props) {\n  const springs = _extends({}, ctrl.springs);\n\n  if (props) {\n    shared.each(shared.toArray(props), props => {\n      if (shared.is.und(props.keys)) {\n        props = createUpdate(props);\n      }\n\n      if (!shared.is.obj(props.to)) {\n        props = _extends({}, props, {\n          to: undefined\n        });\n      }\n\n      prepareSprings(springs, props, key => {\n        return createSpring(key);\n      });\n    });\n  }\n\n  setSprings(ctrl, springs);\n  return springs;\n}\nfunction setSprings(ctrl, springs) {\n  shared.eachProp(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      shared.addFluidObserver(spring, ctrl);\n    }\n  });\n}\n\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n\n  if (observer) {\n    shared.addFluidObserver(spring, observer);\n  }\n\n  return spring;\n}\n\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    shared.each(props.keys, key => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring['_prepareNode'](props);\n    });\n  }\n}\n\nfunction prepareKeys(ctrl, queue) {\n  shared.each(queue, props => {\n    prepareSprings(ctrl.springs, props, key => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst _excluded$6 = [\"children\"];\nconst SpringContext = _ref => {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$6);\n\n  const inherited = React.useContext(ctx);\n  const pause = props.pause || !!inherited.pause,\n        immediate = props.immediate || !!inherited.immediate;\n  props = shared.useMemoOne(() => ({\n    pause,\n    immediate\n  }), [pause, immediate]);\n  const {\n    Provider\n  } = ctx;\n  return React__namespace.createElement(Provider, {\n    value: props\n  }, children);\n};\nconst ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\n\nfunction makeContext(target, init) {\n  Object.assign(target, React__namespace.createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\nconst SpringRef = () => {\n  const current = [];\n\n  const SpringRef = function SpringRef(props) {\n    shared.deprecateDirectCall();\n    const results = [];\n    shared.each(current, (ctrl, i) => {\n      if (shared.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = _getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  };\n\n  SpringRef.current = current;\n\n  SpringRef.add = function (ctrl) {\n    if (!current.includes(ctrl)) {\n      current.push(ctrl);\n    }\n  };\n\n  SpringRef.delete = function (ctrl) {\n    const i = current.indexOf(ctrl);\n    if (~i) current.splice(i, 1);\n  };\n\n  SpringRef.pause = function () {\n    shared.each(current, ctrl => ctrl.pause(...arguments));\n    return this;\n  };\n\n  SpringRef.resume = function () {\n    shared.each(current, ctrl => ctrl.resume(...arguments));\n    return this;\n  };\n\n  SpringRef.set = function (values) {\n    shared.each(current, ctrl => ctrl.set(values));\n  };\n\n  SpringRef.start = function (props) {\n    const results = [];\n    shared.each(current, (ctrl, i) => {\n      if (shared.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update = this._getProps(props, ctrl, i);\n\n        if (update) {\n          results.push(ctrl.start(update));\n        }\n      }\n    });\n    return results;\n  };\n\n  SpringRef.stop = function () {\n    shared.each(current, ctrl => ctrl.stop(...arguments));\n    return this;\n  };\n\n  SpringRef.update = function (props) {\n    shared.each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  };\n\n  const _getProps = function _getProps(arg, ctrl, index) {\n    return shared.is.fun(arg) ? arg(index, ctrl) : arg;\n  };\n\n  SpringRef._getProps = _getProps;\n  return SpringRef;\n};\n\nfunction useSprings(length, props, deps) {\n  const propsFn = shared.is.fun(props) && props;\n  if (propsFn && !deps) deps = [];\n  const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);\n  const layoutId = React.useRef(0);\n  const forceUpdate = shared.useForceUpdate();\n  const state = React.useMemo(() => ({\n    ctrls: [],\n    queue: [],\n\n    flush(ctrl, updates) {\n      const springs = getSprings(ctrl, updates);\n      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs).some(key => !ctrl.springs[key]);\n      return canFlushSync ? flushUpdateQueue(ctrl, updates) : new Promise(resolve => {\n        setSprings(ctrl, springs);\n        state.queue.push(() => {\n          resolve(flushUpdateQueue(ctrl, updates));\n        });\n        forceUpdate();\n      });\n    }\n\n  }), []);\n  const ctrls = React.useRef([...state.ctrls]);\n  const updates = [];\n  const prevLength = shared.usePrev(length) || 0;\n  React.useMemo(() => {\n    shared.each(ctrls.current.slice(length, prevLength), ctrl => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    ctrls.current.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  React.useMemo(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));\n      const update = propsFn ? propsFn(i, ctrl) : props[i];\n\n      if (update) {\n        updates[i] = declareUpdate(update);\n      }\n    }\n  }\n\n  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = React.useContext(SpringContext);\n  const prevContext = shared.usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  shared.useIsomorphicLayoutEffect(() => {\n    layoutId.current++;\n    state.ctrls = ctrls.current;\n    const {\n      queue\n    } = state;\n\n    if (queue.length) {\n      state.queue = [];\n      shared.each(queue, cb => cb());\n    }\n\n    shared.each(ctrls.current, (ctrl, i) => {\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      const update = updates[i];\n\n      if (update) {\n        replaceRef(ctrl, update.ref);\n\n        if (ctrl.ref) {\n          ctrl.queue.push(update);\n        } else {\n          ctrl.start(update);\n        }\n      }\n    });\n  });\n  shared.useOnce(() => () => {\n    shared.each(state.ctrls, ctrl => ctrl.stop(true));\n  });\n  const values = springs.map(x => _extends({}, x));\n  return ref ? [values, ref] : values;\n}\n\nfunction useSpring(props, deps) {\n  const isFn = shared.is.fun(props);\n  const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\nconst initSpringRef = () => SpringRef();\n\nconst useSpringRef = () => React.useState(initSpringRef)[0];\n\nconst useSpringValue = (initial, props) => {\n  const springValue = shared.useConstant(() => new SpringValue(initial, props));\n  shared.useOnce(() => () => {\n    springValue.stop();\n  });\n  return springValue;\n};\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = shared.is.fun(propsArg) && propsArg;\n  if (propsFn && !deps) deps = [];\n  let reverse = true;\n  let passedRef = undefined;\n  const result = useSprings(length, (i, ctrl) => {\n    const props = propsFn ? propsFn(i, ctrl) : propsArg;\n    passedRef = props.ref;\n    reverse = reverse && props.reverse;\n    return props;\n  }, deps || [{}]);\n  shared.useIsomorphicLayoutEffect(() => {\n    shared.each(result[1].current, (ctrl, i) => {\n      const parent = result[1].current[i + (reverse ? 1 : -1)];\n      replaceRef(ctrl, passedRef);\n\n      if (ctrl.ref) {\n        if (parent) {\n          ctrl.update({\n            to: parent.springs\n          });\n        }\n\n        return;\n      }\n\n      if (parent) {\n        ctrl.start({\n          to: parent.springs\n        });\n      } else {\n        ctrl.start();\n      }\n    });\n  }, deps);\n\n  if (propsFn || arguments.length == 3) {\n    var _passedRef;\n\n    const ref = (_passedRef = passedRef) != null ? _passedRef : result[1];\n\n    ref['_getProps'] = (propsArg, ctrl, i) => {\n      const props = shared.is.fun(propsArg) ? propsArg(i, ctrl) : propsArg;\n\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent) props.to = parent.springs;\n        return props;\n      }\n    };\n\n    return result;\n  }\n\n  return result[0];\n}\n\nlet TransitionPhase;\n\n(function (TransitionPhase) {\n  TransitionPhase[\"MOUNT\"] = \"mount\";\n  TransitionPhase[\"ENTER\"] = \"enter\";\n  TransitionPhase[\"UPDATE\"] = \"update\";\n  TransitionPhase[\"LEAVE\"] = \"leave\";\n})(TransitionPhase || (TransitionPhase = {}));\n\nfunction useTransition(data, props, deps) {\n  const propsFn = shared.is.fun(props) && props;\n  const {\n    reset,\n    sort,\n    trail = 0,\n    expires = true,\n    exitBeforeEnter = false,\n    onDestroyed,\n    ref: propsRef,\n    config: propsConfig\n  } = propsFn ? propsFn() : props;\n  const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);\n  const items = shared.toArray(data);\n  const transitions = [];\n  const usedTransitions = React.useRef(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  shared.useIsomorphicLayoutEffect(() => {\n    usedTransitions.current = transitions;\n  });\n  shared.useOnce(() => {\n    shared.each(transitions, t => {\n      ref == null ? void 0 : ref.add(t.ctrl);\n      t.ctrl.ref = ref;\n    });\n    return () => {\n      shared.each(usedTransitions.current, t => {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n\n        detachRefs(t.ctrl, ref);\n        t.ctrl.stop(true);\n      });\n    };\n  });\n  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  shared.useIsomorphicLayoutEffect(() => shared.each(expired, ({\n    ctrl,\n    item,\n    key\n  }) => {\n    detachRefs(ctrl, ref);\n    callProp(onDestroyed, item, key);\n  }));\n  const reused = [];\n  if (prevTransitions) shared.each(prevTransitions, (t, i) => {\n    if (t.expired) {\n      clearTimeout(t.expirationId);\n      expired.push(t);\n    } else {\n      i = reused[i] = keys.indexOf(t.key);\n      if (~i) transitions[i] = t;\n    }\n  });\n  shared.each(items, (item, i) => {\n    if (!transitions[i]) {\n      transitions[i] = {\n        key: keys[i],\n        item,\n        phase: TransitionPhase.MOUNT,\n        ctrl: new Controller()\n      };\n      transitions[i].ctrl.item = item;\n    }\n  });\n\n  if (reused.length) {\n    let i = -1;\n    const {\n      leave\n    } = propsFn ? propsFn() : props;\n    shared.each(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = _extends({}, t, {\n          item: items[keyIndex]\n        });\n      } else if (leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n\n  if (shared.is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n\n  let delay = -trail;\n  const forceUpdate = shared.useForceUpdate();\n  const defaultProps = getDefaultProps(props);\n  const changes = new Map();\n  const exitingTransitions = React.useRef(new Map());\n  const forceChange = React.useRef(false);\n  shared.each(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    const p = propsFn ? propsFn() : props;\n    let to;\n    let phase;\n    let propsDelay = callProp(p.delay || 0, key);\n\n    if (prevPhase == TransitionPhase.MOUNT) {\n      to = p.enter;\n      phase = TransitionPhase.ENTER;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n\n      if (prevPhase != TransitionPhase.LEAVE) {\n        if (isLeave) {\n          to = p.leave;\n          phase = TransitionPhase.LEAVE;\n        } else if (to = p.update) {\n          phase = TransitionPhase.UPDATE;\n        } else return;\n      } else if (!isLeave) {\n        to = p.enter;\n        phase = TransitionPhase.ENTER;\n      } else return;\n    }\n\n    to = callProp(to, t.item, i);\n    to = shared.is.obj(to) ? inferTo(to) : {\n      to\n    };\n\n    if (!to.config) {\n      const config = propsConfig || defaultProps.config;\n      to.config = callProp(config, t.item, i, phase);\n    }\n\n    delay += trail;\n\n    const payload = _extends({}, defaultProps, {\n      delay: propsDelay + delay,\n      ref: propsRef,\n      immediate: p.immediate,\n      reset: false\n    }, to);\n\n    if (phase == TransitionPhase.ENTER && shared.is.und(payload.from)) {\n      const _p = propsFn ? propsFn() : props;\n\n      const from = shared.is.und(_p.initial) || prevTransitions ? _p.from : _p.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n\n    const {\n      onResolve\n    } = payload;\n\n    payload.onResolve = result => {\n      callProp(onResolve, result);\n      const transitions = usedTransitions.current;\n      const t = transitions.find(t => t.key === key);\n      if (!t) return;\n\n      if (result.cancelled && t.phase != TransitionPhase.UPDATE) {\n        return;\n      }\n\n      if (t.ctrl.idle) {\n        const idle = transitions.every(t => t.ctrl.idle);\n\n        if (t.phase == TransitionPhase.LEAVE) {\n          const expiry = callProp(expires, t.item);\n\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t.expired = true;\n\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 0x7fffffff) t.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n\n        if (idle && transitions.some(t => t.expired)) {\n          exitingTransitions.current.delete(t);\n\n          if (exitBeforeEnter) {\n            forceChange.current = true;\n          }\n\n          forceUpdate();\n        }\n      }\n    };\n\n    const springs = getSprings(t.ctrl, payload);\n\n    if (phase === TransitionPhase.LEAVE && exitBeforeEnter) {\n      exitingTransitions.current.set(t, {\n        phase,\n        springs,\n        payload\n      });\n    } else {\n      changes.set(t, {\n        phase,\n        springs,\n        payload\n      });\n    }\n  });\n  const context = React.useContext(SpringContext);\n  const prevContext = shared.usePrev(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  shared.useIsomorphicLayoutEffect(() => {\n    if (hasContext) {\n      shared.each(transitions, t => {\n        t.ctrl.start({\n          default: context\n        });\n      });\n    }\n  }, [context]);\n  shared.each(changes, (_, t) => {\n    if (exitingTransitions.current.size) {\n      const ind = transitions.findIndex(state => state.key === t.key);\n      transitions.splice(ind, 1);\n    }\n  });\n  shared.useIsomorphicLayoutEffect(() => {\n    shared.each(exitingTransitions.current.size ? exitingTransitions.current : changes, ({\n      phase,\n      payload\n    }, t) => {\n      const {\n        ctrl\n      } = t;\n      t.phase = phase;\n      ref == null ? void 0 : ref.add(ctrl);\n\n      if (hasContext && phase == TransitionPhase.ENTER) {\n        ctrl.start({\n          default: context\n        });\n      }\n\n      if (payload) {\n        replaceRef(ctrl, payload.ref);\n\n        if ((ctrl.ref || ref) && !forceChange.current) {\n          ctrl.update(payload);\n        } else {\n          ctrl.start(payload);\n\n          if (forceChange.current) {\n            forceChange.current = false;\n          }\n        }\n      }\n    });\n  }, reset ? void 0 : deps);\n\n  const renderTransitions = render => React__namespace.createElement(React__namespace.Fragment, null, transitions.map((t, i) => {\n    const {\n      springs\n    } = changes.get(t) || t.ctrl;\n    const elem = render(_extends({}, springs), t.item, t, i);\n    return elem && elem.type ? React__namespace.createElement(elem.type, _extends({}, elem.props, {\n      key: shared.is.str(t.key) || shared.is.num(t.key) ? t.key : t.ctrl.id,\n      ref: elem.ref\n    })) : elem;\n  }));\n\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\nlet nextKey = 1;\n\nfunction getKeys(items, {\n  key,\n  keys = key\n}, prevTransitions) {\n  if (keys === null) {\n    const reused = new Set();\n    return items.map(item => {\n      const t = prevTransitions && prevTransitions.find(t => t.item === item && t.phase !== TransitionPhase.LEAVE && !reused.has(t));\n\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n\n      return nextKey++;\n    });\n  }\n\n  return shared.is.und(keys) ? items : shared.is.fun(keys) ? items.map(keys) : shared.toArray(keys);\n}\n\nconst _excluded$5 = [\"container\"];\nconst useScroll = (_ref = {}) => {\n  let {\n    container\n  } = _ref,\n      springOptions = _objectWithoutPropertiesLoose(_ref, _excluded$5);\n\n  const [scrollValues, api] = useSpring(() => _extends({\n    scrollX: 0,\n    scrollY: 0,\n    scrollXProgress: 0,\n    scrollYProgress: 0\n  }, springOptions), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const cleanupScroll = shared.onScroll(({\n      x,\n      y\n    }) => {\n      api.start({\n        scrollX: x.current,\n        scrollXProgress: x.progress,\n        scrollY: y.current,\n        scrollYProgress: y.progress\n      });\n    }, {\n      container: (container == null ? void 0 : container.current) || undefined\n    });\n    return () => {\n      shared.each(Object.values(scrollValues), value => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return scrollValues;\n};\n\nconst _excluded$4 = [\"container\"];\nconst useResize = _ref => {\n  let {\n    container\n  } = _ref,\n      springOptions = _objectWithoutPropertiesLoose(_ref, _excluded$4);\n\n  const [sizeValues, api] = useSpring(() => _extends({\n    width: 0,\n    height: 0\n  }, springOptions), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const cleanupScroll = shared.onResize(({\n      width,\n      height\n    }) => {\n      api.start({\n        width,\n        height,\n        immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0\n      });\n    }, {\n      container: (container == null ? void 0 : container.current) || undefined\n    });\n    return () => {\n      shared.each(Object.values(sizeValues), value => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return sizeValues;\n};\n\nconst _excluded$3 = [\"to\", \"from\"],\n      _excluded2 = [\"root\", \"once\", \"amount\"];\nconst defaultThresholdOptions = {\n  any: 0,\n  all: 1\n};\nfunction useInView(props, args) {\n  const [isInView, setIsInView] = React.useState(false);\n  const ref = React.useRef();\n  const propsFn = shared.is.fun(props) && props;\n  const springsProps = propsFn ? propsFn() : {};\n\n  const {\n    to = {},\n    from = {}\n  } = springsProps,\n        restSpringProps = _objectWithoutPropertiesLoose(springsProps, _excluded$3);\n\n  const intersectionArguments = propsFn ? args : props;\n  const [springs, api] = useSpring(() => _extends({\n    from\n  }, restSpringProps), []);\n  shared.useIsomorphicLayoutEffect(() => {\n    const element = ref.current;\n\n    const _ref = intersectionArguments != null ? intersectionArguments : {},\n          {\n      root,\n      once,\n      amount = 'any'\n    } = _ref,\n          restArgs = _objectWithoutPropertiesLoose(_ref, _excluded2);\n\n    if (!element || once && isInView || typeof IntersectionObserver === 'undefined') return;\n    const activeIntersections = new WeakMap();\n\n    const onEnter = () => {\n      if (to) {\n        api.start(to);\n      }\n\n      setIsInView(true);\n\n      const cleanup = () => {\n        if (from) {\n          api.start(from);\n        }\n\n        setIsInView(false);\n      };\n\n      return once ? undefined : cleanup;\n    };\n\n    const handleIntersection = entries => {\n      entries.forEach(entry => {\n        const onLeave = activeIntersections.get(entry.target);\n\n        if (entry.isIntersecting === Boolean(onLeave)) {\n          return;\n        }\n\n        if (entry.isIntersecting) {\n          const newOnLeave = onEnter();\n\n          if (shared.is.fun(newOnLeave)) {\n            activeIntersections.set(entry.target, newOnLeave);\n          } else {\n            observer.unobserve(entry.target);\n          }\n        } else if (onLeave) {\n          onLeave();\n          activeIntersections.delete(entry.target);\n        }\n      });\n    };\n\n    const observer = new IntersectionObserver(handleIntersection, _extends({\n      root: root && root.current || undefined,\n      threshold: typeof amount === 'number' || Array.isArray(amount) ? amount : defaultThresholdOptions[amount]\n    }, restArgs));\n    observer.observe(element);\n    return () => observer.unobserve(element);\n  }, [intersectionArguments]);\n\n  if (propsFn) {\n    return [ref, springs];\n  }\n\n  return [ref, isInView];\n}\n\nconst _excluded$2 = [\"children\"];\nfunction Spring(_ref) {\n  let {\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$2);\n\n  return children(useSpring(props));\n}\n\nconst _excluded$1 = [\"items\", \"children\"];\nfunction Trail(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return shared.is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\nconst _excluded = [\"items\", \"children\"];\nfunction Transition(_ref) {\n  let {\n    items,\n    children\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  return useTransition(items, props)(children);\n}\n\nclass Interpolation extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.key = void 0;\n    this.idle = true;\n    this.calc = void 0;\n    this._active = new Set();\n    this.source = source;\n    this.calc = shared.createInterpolator(...args);\n\n    const value = this._get();\n\n    const nodeType = animated$1.getAnimatedType(value);\n    animated$1.setAnimated(this, nodeType.create(value));\n  }\n\n  advance(_dt) {\n    const value = this._get();\n\n    const oldValue = this.get();\n\n    if (!shared.isEqual(value, oldValue)) {\n      animated$1.getAnimated(this).setValue(value);\n\n      this._onChange(value, this.idle);\n    }\n\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n\n  _get() {\n    const inputs = shared.is.arr(this.source) ? this.source.map(shared.getFluidValue) : shared.toArray(shared.getFluidValue(this.source));\n    return this.calc(...inputs);\n  }\n\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      shared.each(animated$1.getPayload(this), node => {\n        node.done = false;\n      });\n\n      if (shared.Globals.skipAnimation) {\n        shared.raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        shared.frameLoop.start(this);\n      }\n    }\n  }\n\n  _attach() {\n    let priority = 1;\n    shared.each(shared.toArray(this.source), source => {\n      if (shared.hasFluidValue(source)) {\n        shared.addFluidObserver(source, this);\n      }\n\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n\n    this._start();\n  }\n\n  _detach() {\n    shared.each(shared.toArray(this.source), source => {\n      if (shared.hasFluidValue(source)) {\n        shared.removeFluidObserver(source, this);\n      }\n    });\n\n    this._active.clear();\n\n    becomeIdle(this);\n  }\n\n  eventObserved(event) {\n    if (event.type == 'change') {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n\n        this._start();\n      }\n    } else if (event.type == 'idle') {\n      this._active.delete(event.parent);\n    } else if (event.type == 'priority') {\n      this.priority = shared.toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);\n    }\n  }\n\n}\n\nfunction isIdle(source) {\n  return source.idle !== false;\n}\n\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\n\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    shared.each(animated$1.getPayload(self), node => {\n      node.done = true;\n    });\n    shared.callFluidObservers(self, {\n      type: 'idle',\n      parent: self\n    });\n  }\n}\n\nconst to = (source, ...args) => new Interpolation(source, args);\nconst interpolate = (source, ...args) => (shared.deprecateInterpolate(), new Interpolation(source, args));\n\nshared.Globals.assign({\n  createStringInterpolator: shared.createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nconst update = shared.frameLoop.advance;\n\nObject.defineProperty(exports, \"Globals\", ({\n  enumerable: true,\n  get: function () { return shared.Globals; }\n}));\nObject.defineProperty(exports, \"createInterpolator\", ({\n  enumerable: true,\n  get: function () { return shared.createInterpolator; }\n}));\nObject.defineProperty(exports, \"easings\", ({\n  enumerable: true,\n  get: function () { return shared.easings; }\n}));\nObject.defineProperty(exports, \"useIsomorphicLayoutEffect\", ({\n  enumerable: true,\n  get: function () { return shared.useIsomorphicLayoutEffect; }\n}));\nObject.defineProperty(exports, \"useReducedMotion\", ({\n  enumerable: true,\n  get: function () { return shared.useReducedMotion; }\n}));\nexports.BailSignal = BailSignal;\nexports.Controller = Controller;\nexports.FrameValue = FrameValue;\nexports.Interpolation = Interpolation;\nexports.Spring = Spring;\nexports.SpringContext = SpringContext;\nexports.SpringRef = SpringRef;\nexports.SpringValue = SpringValue;\nexports.Trail = Trail;\nexports.Transition = Transition;\nexports.config = config;\nexports.inferTo = inferTo;\nexports.interpolate = interpolate;\nexports.to = to;\nexports.update = update;\nexports.useChain = useChain;\nexports.useInView = useInView;\nexports.useResize = useResize;\nexports.useScroll = useScroll;\nexports.useSpring = useSpring;\nexports.useSpringRef = useSpringRef;\nexports.useSpringValue = useSpringValue;\nexports.useSprings = useSprings;\nexports.useTrail = useTrail;\nexports.useTransition = useTransition;\nObject.keys(animated).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return animated[k]; }\n  });\n});\nObject.keys(interpolation).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return interpolation[k]; }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvY29yZS9kaXN0L3JlYWN0LXNwcmluZy1jb3JlLmNqcy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxhQUFhLG1CQUFPLENBQUMsc0lBQXNCO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyw0SUFBd0I7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHlIQUE4QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxtSUFBbUM7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELHFCQUFxQjtBQUMxRTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQyx1QkFBdUIsTUFBTSxjQUFjO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQ0FBbUM7QUFDbkMsb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsMkNBQTBDO0FBQzFDO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLHNEQUFxRDtBQUNyRDtBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRiwyQ0FBMEM7QUFDMUM7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0EscUJBQXFCO0FBQ3JCLENBQUMsRUFBQztBQUNGLG9EQUFtRDtBQUNuRDtBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsVUFBVTtBQUNWLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmRldi5qcz84YTZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ0ByZWFjdC1zcHJpbmcvc2hhcmVkJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFuaW1hdGVkJDEgPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL2FuaW1hdGVkJyk7XG52YXIgYW5pbWF0ZWQgPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL3R5cGVzL2FuaW1hdGVkJyk7XG52YXIgaW50ZXJwb2xhdGlvbiA9IHJlcXVpcmUoJ0ByZWFjdC1zcHJpbmcvdHlwZXMvaW50ZXJwb2xhdGlvbicpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2FsbFByb3AodmFsdWUsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHNoYXJlZC5pcy5mdW4odmFsdWUpID8gdmFsdWUoLi4uYXJncykgOiB2YWx1ZTtcbn1cbmNvbnN0IG1hdGNoUHJvcCA9ICh2YWx1ZSwga2V5KSA9PiB2YWx1ZSA9PT0gdHJ1ZSB8fCAhIShrZXkgJiYgdmFsdWUgJiYgKHNoYXJlZC5pcy5mdW4odmFsdWUpID8gdmFsdWUoa2V5KSA6IHNoYXJlZC50b0FycmF5KHZhbHVlKS5pbmNsdWRlcyhrZXkpKSk7XG5jb25zdCByZXNvbHZlUHJvcCA9IChwcm9wLCBrZXkpID0+IHNoYXJlZC5pcy5vYmoocHJvcCkgPyBrZXkgJiYgcHJvcFtrZXldIDogcHJvcDtcbmNvbnN0IGdldERlZmF1bHRQcm9wID0gKHByb3BzLCBrZXkpID0+IHByb3BzLmRlZmF1bHQgPT09IHRydWUgPyBwcm9wc1trZXldIDogcHJvcHMuZGVmYXVsdCA/IHByb3BzLmRlZmF1bHRba2V5XSA6IHVuZGVmaW5lZDtcblxuY29uc3Qgbm9vcFRyYW5zZm9ybSA9IHZhbHVlID0+IHZhbHVlO1xuXG5jb25zdCBnZXREZWZhdWx0UHJvcHMgPSAocHJvcHMsIHRyYW5zZm9ybSA9IG5vb3BUcmFuc2Zvcm0pID0+IHtcbiAgbGV0IGtleXMgPSBERUZBVUxUX1BST1BTO1xuXG4gIGlmIChwcm9wcy5kZWZhdWx0ICYmIHByb3BzLmRlZmF1bHQgIT09IHRydWUpIHtcbiAgICBwcm9wcyA9IHByb3BzLmRlZmF1bHQ7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtKHByb3BzW2tleV0sIGtleSk7XG5cbiAgICBpZiAoIXNoYXJlZC5pcy51bmQodmFsdWUpKSB7XG4gICAgICBkZWZhdWx0c1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRzO1xufTtcbmNvbnN0IERFRkFVTFRfUFJPUFMgPSBbJ2NvbmZpZycsICdvblByb3BzJywgJ29uU3RhcnQnLCAnb25DaGFuZ2UnLCAnb25QYXVzZScsICdvblJlc3VtZScsICdvblJlc3QnXTtcbmNvbnN0IFJFU0VSVkVEX1BST1BTID0ge1xuICBjb25maWc6IDEsXG4gIGZyb206IDEsXG4gIHRvOiAxLFxuICByZWY6IDEsXG4gIGxvb3A6IDEsXG4gIHJlc2V0OiAxLFxuICBwYXVzZTogMSxcbiAgY2FuY2VsOiAxLFxuICByZXZlcnNlOiAxLFxuICBpbW1lZGlhdGU6IDEsXG4gIGRlZmF1bHQ6IDEsXG4gIGRlbGF5OiAxLFxuICBvblByb3BzOiAxLFxuICBvblN0YXJ0OiAxLFxuICBvbkNoYW5nZTogMSxcbiAgb25QYXVzZTogMSxcbiAgb25SZXN1bWU6IDEsXG4gIG9uUmVzdDogMSxcbiAgb25SZXNvbHZlOiAxLFxuICBpdGVtczogMSxcbiAgdHJhaWw6IDEsXG4gIHNvcnQ6IDEsXG4gIGV4cGlyZXM6IDEsXG4gIGluaXRpYWw6IDEsXG4gIGVudGVyOiAxLFxuICB1cGRhdGU6IDEsXG4gIGxlYXZlOiAxLFxuICBjaGlsZHJlbjogMSxcbiAgb25EZXN0cm95ZWQ6IDEsXG4gIGtleXM6IDEsXG4gIGNhbGxJZDogMSxcbiAgcGFyZW50SWQ6IDFcbn07XG5cbmZ1bmN0aW9uIGdldEZvcndhcmRQcm9wcyhwcm9wcykge1xuICBjb25zdCBmb3J3YXJkID0ge307XG4gIGxldCBjb3VudCA9IDA7XG4gIHNoYXJlZC5lYWNoUHJvcChwcm9wcywgKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgaWYgKCFSRVNFUlZFRF9QUk9QU1twcm9wXSkge1xuICAgICAgZm9yd2FyZFtwcm9wXSA9IHZhbHVlO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCkge1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZmVyVG8ocHJvcHMpIHtcbiAgY29uc3QgdG8gPSBnZXRGb3J3YXJkUHJvcHMocHJvcHMpO1xuXG4gIGlmICh0bykge1xuICAgIGNvbnN0IG91dCA9IHtcbiAgICAgIHRvXG4gICAgfTtcbiAgICBzaGFyZWQuZWFjaFByb3AocHJvcHMsICh2YWwsIGtleSkgPT4ga2V5IGluIHRvIHx8IChvdXRba2V5XSA9IHZhbCkpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVHb2FsKHZhbHVlKSB7XG4gIHZhbHVlID0gc2hhcmVkLmdldEZsdWlkVmFsdWUodmFsdWUpO1xuICByZXR1cm4gc2hhcmVkLmlzLmFycih2YWx1ZSkgPyB2YWx1ZS5tYXAoY29tcHV0ZUdvYWwpIDogc2hhcmVkLmlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpID8gc2hhcmVkLkdsb2JhbHMuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yKHtcbiAgICByYW5nZTogWzAsIDFdLFxuICAgIG91dHB1dDogW3ZhbHVlLCB2YWx1ZV1cbiAgfSkoMSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhc1Byb3BzKHByb3BzKSB7XG4gIGZvciAoY29uc3QgXyBpbiBwcm9wcykgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNBc3luY1RvKHRvKSB7XG4gIHJldHVybiBzaGFyZWQuaXMuZnVuKHRvKSB8fCBzaGFyZWQuaXMuYXJyKHRvKSAmJiBzaGFyZWQuaXMub2JqKHRvWzBdKTtcbn1cbmZ1bmN0aW9uIGRldGFjaFJlZnMoY3RybCwgcmVmKSB7XG4gIHZhciBfY3RybCRyZWY7XG5cbiAgKF9jdHJsJHJlZiA9IGN0cmwucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2N0cmwkcmVmLmRlbGV0ZShjdHJsKTtcbiAgcmVmID09IG51bGwgPyB2b2lkIDAgOiByZWYuZGVsZXRlKGN0cmwpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVJlZihjdHJsLCByZWYpIHtcbiAgaWYgKHJlZiAmJiBjdHJsLnJlZiAhPT0gcmVmKSB7XG4gICAgdmFyIF9jdHJsJHJlZjI7XG5cbiAgICAoX2N0cmwkcmVmMiA9IGN0cmwucmVmKSA9PSBudWxsID8gdm9pZCAwIDogX2N0cmwkcmVmMi5kZWxldGUoY3RybCk7XG4gICAgcmVmLmFkZChjdHJsKTtcbiAgICBjdHJsLnJlZiA9IHJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDaGFpbihyZWZzLCB0aW1lU3RlcHMsIHRpbWVGcmFtZSA9IDEwMDApIHtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0aW1lU3RlcHMpIHtcbiAgICAgIGxldCBwcmV2RGVsYXkgPSAwO1xuICAgICAgc2hhcmVkLmVhY2gocmVmcywgKHJlZiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBjb250cm9sbGVycyA9IHJlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjb250cm9sbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBsZXQgZGVsYXkgPSB0aW1lRnJhbWUgKiB0aW1lU3RlcHNbaV07XG4gICAgICAgICAgaWYgKGlzTmFOKGRlbGF5KSkgZGVsYXkgPSBwcmV2RGVsYXk7ZWxzZSBwcmV2RGVsYXkgPSBkZWxheTtcbiAgICAgICAgICBzaGFyZWQuZWFjaChjb250cm9sbGVycywgY3RybCA9PiB7XG4gICAgICAgICAgICBzaGFyZWQuZWFjaChjdHJsLnF1ZXVlLCBwcm9wcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lbW9pemVkRGVsYXlQcm9wID0gcHJvcHMuZGVsYXk7XG5cbiAgICAgICAgICAgICAgcHJvcHMuZGVsYXkgPSBrZXkgPT4gZGVsYXkgKyBjYWxsUHJvcChtZW1vaXplZERlbGF5UHJvcCB8fCAwLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVmLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgc2hhcmVkLmVhY2gocmVmcywgcmVmID0+IHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlcnMgPSByZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoY29udHJvbGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcXVldWVzID0gY29udHJvbGxlcnMubWFwKGN0cmwgPT4ge1xuICAgICAgICAgICAgY29uc3QgcSA9IGN0cmwucXVldWU7XG4gICAgICAgICAgICBjdHJsLnF1ZXVlID0gW107XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwID0gcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHNoYXJlZC5lYWNoKGNvbnRyb2xsZXJzLCAoY3RybCwgaSkgPT4gc2hhcmVkLmVhY2gocXVldWVzW2ldIHx8IFtdLCB1cGRhdGUgPT4gY3RybC5xdWV1ZS5wdXNoKHVwZGF0ZSkpKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZWYuc3RhcnQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgZGVmYXVsdDoge1xuICAgIHRlbnNpb246IDE3MCxcbiAgICBmcmljdGlvbjogMjZcbiAgfSxcbiAgZ2VudGxlOiB7XG4gICAgdGVuc2lvbjogMTIwLFxuICAgIGZyaWN0aW9uOiAxNFxuICB9LFxuICB3b2JibHk6IHtcbiAgICB0ZW5zaW9uOiAxODAsXG4gICAgZnJpY3Rpb246IDEyXG4gIH0sXG4gIHN0aWZmOiB7XG4gICAgdGVuc2lvbjogMjEwLFxuICAgIGZyaWN0aW9uOiAyMFxuICB9LFxuICBzbG93OiB7XG4gICAgdGVuc2lvbjogMjgwLFxuICAgIGZyaWN0aW9uOiA2MFxuICB9LFxuICBtb2xhc3Nlczoge1xuICAgIHRlbnNpb246IDI4MCxcbiAgICBmcmljdGlvbjogMTIwXG4gIH1cbn07XG5cbmNvbnN0IGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGNvbmZpZy5kZWZhdWx0LCB7XG4gIG1hc3M6IDEsXG4gIGRhbXBpbmc6IDEsXG4gIGVhc2luZzogc2hhcmVkLmVhc2luZ3MubGluZWFyLFxuICBjbGFtcDogZmFsc2Vcbn0pO1xuXG5jbGFzcyBBbmltYXRpb25Db25maWcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRlbnNpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5mcmljdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmZyZXF1ZW5jeSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhbXBpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXNzID0gdm9pZCAwO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMucmVzdFZlbG9jaXR5ID0gdm9pZCAwO1xuICAgIHRoaXMucHJlY2lzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVhc2luZyA9IHZvaWQgMDtcbiAgICB0aGlzLmNsYW1wID0gdm9pZCAwO1xuICAgIHRoaXMuYm91bmNlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjYXkgPSB2b2lkIDA7XG4gICAgdGhpcy5yb3VuZCA9IHZvaWQgMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRzKTtcbiAgfVxuXG59XG5mdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcsIG5ld0NvbmZpZywgZGVmYXVsdENvbmZpZykge1xuICBpZiAoZGVmYXVsdENvbmZpZykge1xuICAgIGRlZmF1bHRDb25maWcgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdENvbmZpZyk7XG4gICAgc2FuaXRpemVDb25maWcoZGVmYXVsdENvbmZpZywgbmV3Q29uZmlnKTtcbiAgICBuZXdDb25maWcgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdENvbmZpZywgbmV3Q29uZmlnKTtcbiAgfVxuXG4gIHNhbml0aXplQ29uZmlnKGNvbmZpZywgbmV3Q29uZmlnKTtcbiAgT2JqZWN0LmFzc2lnbihjb25maWcsIG5ld0NvbmZpZyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoY29uZmlnW2tleV0gPT0gbnVsbCkge1xuICAgICAgY29uZmlnW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGxldCB7XG4gICAgbWFzcyxcbiAgICBmcmVxdWVuY3ksXG4gICAgZGFtcGluZ1xuICB9ID0gY29uZmlnO1xuXG4gIGlmICghc2hhcmVkLmlzLnVuZChmcmVxdWVuY3kpKSB7XG4gICAgaWYgKGZyZXF1ZW5jeSA8IDAuMDEpIGZyZXF1ZW5jeSA9IDAuMDE7XG4gICAgaWYgKGRhbXBpbmcgPCAwKSBkYW1waW5nID0gMDtcbiAgICBjb25maWcudGVuc2lvbiA9IE1hdGgucG93KDIgKiBNYXRoLlBJIC8gZnJlcXVlbmN5LCAyKSAqIG1hc3M7XG4gICAgY29uZmlnLmZyaWN0aW9uID0gNCAqIE1hdGguUEkgKiBkYW1waW5nICogbWFzcyAvIGZyZXF1ZW5jeTtcbiAgfVxuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplQ29uZmlnKGNvbmZpZywgcHJvcHMpIHtcbiAgaWYgKCFzaGFyZWQuaXMudW5kKHByb3BzLmRlY2F5KSkge1xuICAgIGNvbmZpZy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc1RlbnNpb25Db25maWcgPSAhc2hhcmVkLmlzLnVuZChwcm9wcy50ZW5zaW9uKSB8fCAhc2hhcmVkLmlzLnVuZChwcm9wcy5mcmljdGlvbik7XG5cbiAgICBpZiAoaXNUZW5zaW9uQ29uZmlnIHx8ICFzaGFyZWQuaXMudW5kKHByb3BzLmZyZXF1ZW5jeSkgfHwgIXNoYXJlZC5pcy51bmQocHJvcHMuZGFtcGluZykgfHwgIXNoYXJlZC5pcy51bmQocHJvcHMubWFzcykpIHtcbiAgICAgIGNvbmZpZy5kdXJhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbmZpZy5kZWNheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaXNUZW5zaW9uQ29uZmlnKSB7XG4gICAgICBjb25maWcuZnJlcXVlbmN5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlcyA9IGVtcHR5QXJyYXk7XG4gICAgdGhpcy50b1ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5mcm9tVmFsdWVzID0gZW1wdHlBcnJheTtcbiAgICB0aGlzLnRvID0gdm9pZCAwO1xuICAgIHRoaXMuZnJvbSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBBbmltYXRpb25Db25maWcoKTtcbiAgICB0aGlzLmltbWVkaWF0ZSA9IGZhbHNlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVQcm9wcyhjYWxsSWQsIHtcbiAga2V5LFxuICBwcm9wcyxcbiAgZGVmYXVsdFByb3BzLFxuICBzdGF0ZSxcbiAgYWN0aW9uc1xufSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBfcHJvcHMkY2FuY2VsO1xuXG4gICAgbGV0IGRlbGF5O1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGxldCBjYW5jZWwgPSBtYXRjaFByb3AoKF9wcm9wcyRjYW5jZWwgPSBwcm9wcy5jYW5jZWwpICE9IG51bGwgPyBfcHJvcHMkY2FuY2VsIDogZGVmYXVsdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0UHJvcHMuY2FuY2VsLCBrZXkpO1xuXG4gICAgaWYgKGNhbmNlbCkge1xuICAgICAgb25TdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNoYXJlZC5pcy51bmQocHJvcHMucGF1c2UpKSB7XG4gICAgICAgIHN0YXRlLnBhdXNlZCA9IG1hdGNoUHJvcChwcm9wcy5wYXVzZSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdXNlID0gZGVmYXVsdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0UHJvcHMucGF1c2U7XG5cbiAgICAgIGlmIChwYXVzZSAhPT0gdHJ1ZSkge1xuICAgICAgICBwYXVzZSA9IHN0YXRlLnBhdXNlZCB8fCBtYXRjaFByb3AocGF1c2UsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGF5ID0gY2FsbFByb3AocHJvcHMuZGVsYXkgfHwgMCwga2V5KTtcblxuICAgICAgaWYgKHBhdXNlKSB7XG4gICAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChvblJlc3VtZSk7XG4gICAgICAgIGFjdGlvbnMucGF1c2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnMucmVzdW1lKCk7XG4gICAgICAgIG9uUmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25QYXVzZSgpIHtcbiAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChvblJlc3VtZSk7XG4gICAgICBzdGF0ZS50aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG4gICAgICB0aW1lb3V0LmNhbmNlbCgpO1xuICAgICAgZGVsYXkgPSB0aW1lb3V0LnRpbWUgLSBzaGFyZWQucmFmLm5vdygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICAgICAgaWYgKGRlbGF5ID4gMCAmJiAhc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICBzdGF0ZS5kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgdGltZW91dCA9IHNoYXJlZC5yYWYuc2V0VGltZW91dChvblN0YXJ0LCBkZWxheSk7XG4gICAgICAgIHN0YXRlLnBhdXNlUXVldWUuYWRkKG9uUGF1c2UpO1xuICAgICAgICBzdGF0ZS50aW1lb3V0cy5hZGQodGltZW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgIGlmIChzdGF0ZS5kZWxheWVkKSB7XG4gICAgICAgIHN0YXRlLmRlbGF5ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUucGF1c2VRdWV1ZS5kZWxldGUob25QYXVzZSk7XG4gICAgICBzdGF0ZS50aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG5cbiAgICAgIGlmIChjYWxsSWQgPD0gKHN0YXRlLmNhbmNlbElkIHx8IDApKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGlvbnMuc3RhcnQoX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgY2FsbElkLFxuICAgICAgICAgIGNhbmNlbFxuICAgICAgICB9KSwgcmVzb2x2ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgZ2V0Q29tYmluZWRSZXN1bHQgPSAodGFyZ2V0LCByZXN1bHRzKSA9PiByZXN1bHRzLmxlbmd0aCA9PSAxID8gcmVzdWx0c1swXSA6IHJlc3VsdHMuc29tZShyZXN1bHQgPT4gcmVzdWx0LmNhbmNlbGxlZCkgPyBnZXRDYW5jZWxsZWRSZXN1bHQodGFyZ2V0LmdldCgpKSA6IHJlc3VsdHMuZXZlcnkocmVzdWx0ID0+IHJlc3VsdC5ub29wKSA/IGdldE5vb3BSZXN1bHQodGFyZ2V0LmdldCgpKSA6IGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldC5nZXQoKSwgcmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0LmZpbmlzaGVkKSk7XG5jb25zdCBnZXROb29wUmVzdWx0ID0gdmFsdWUgPT4gKHtcbiAgdmFsdWUsXG4gIG5vb3A6IHRydWUsXG4gIGZpbmlzaGVkOiB0cnVlLFxuICBjYW5jZWxsZWQ6IGZhbHNlXG59KTtcbmNvbnN0IGdldEZpbmlzaGVkUmVzdWx0ID0gKHZhbHVlLCBmaW5pc2hlZCwgY2FuY2VsbGVkID0gZmFsc2UpID0+ICh7XG4gIHZhbHVlLFxuICBmaW5pc2hlZCxcbiAgY2FuY2VsbGVkXG59KTtcbmNvbnN0IGdldENhbmNlbGxlZFJlc3VsdCA9IHZhbHVlID0+ICh7XG4gIHZhbHVlLFxuICBjYW5jZWxsZWQ6IHRydWUsXG4gIGZpbmlzaGVkOiBmYWxzZVxufSk7XG5cbmZ1bmN0aW9uIHJ1bkFzeW5jKHRvLCBwcm9wcywgc3RhdGUsIHRhcmdldCkge1xuICBjb25zdCB7XG4gICAgY2FsbElkLFxuICAgIHBhcmVudElkLFxuICAgIG9uUmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBhc3luY1RvOiBwcmV2VG8sXG4gICAgcHJvbWlzZTogcHJldlByb21pc2VcbiAgfSA9IHN0YXRlO1xuXG4gIGlmICghcGFyZW50SWQgJiYgdG8gPT09IHByZXZUbyAmJiAhcHJvcHMucmVzZXQpIHtcbiAgICByZXR1cm4gcHJldlByb21pc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGUucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgc3RhdGUuYXN5bmNJZCA9IGNhbGxJZDtcbiAgICBzdGF0ZS5hc3luY1RvID0gdG87XG4gICAgY29uc3QgZGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzKHByb3BzLCAodmFsdWUsIGtleSkgPT4ga2V5ID09PSAnb25SZXN0JyA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbiAgICBsZXQgcHJldmVudEJhaWw7XG4gICAgbGV0IGJhaWw7XG4gICAgY29uc3QgYmFpbFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiAocHJldmVudEJhaWwgPSByZXNvbHZlLCBiYWlsID0gcmVqZWN0KSk7XG5cbiAgICBjb25zdCBiYWlsSWZFbmRlZCA9IGJhaWxTaWduYWwgPT4ge1xuICAgICAgY29uc3QgYmFpbFJlc3VsdCA9IGNhbGxJZCA8PSAoc3RhdGUuY2FuY2VsSWQgfHwgMCkgJiYgZ2V0Q2FuY2VsbGVkUmVzdWx0KHRhcmdldCkgfHwgY2FsbElkICE9PSBzdGF0ZS5hc3luY0lkICYmIGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldCwgZmFsc2UpO1xuXG4gICAgICBpZiAoYmFpbFJlc3VsdCkge1xuICAgICAgICBiYWlsU2lnbmFsLnJlc3VsdCA9IGJhaWxSZXN1bHQ7XG4gICAgICAgIGJhaWwoYmFpbFNpZ25hbCk7XG4gICAgICAgIHRocm93IGJhaWxTaWduYWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgY29uc3QgYmFpbFNpZ25hbCA9IG5ldyBCYWlsU2lnbmFsKCk7XG4gICAgICBjb25zdCBza2lwQW5pbWF0aW9uU2lnbmFsID0gbmV3IFNraXBBbmltYXRpb25TaWduYWwoKTtcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICAgIHN0b3BBc3luYyhzdGF0ZSk7XG4gICAgICAgICAgc2tpcEFuaW1hdGlvblNpZ25hbC5yZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQsIGZhbHNlKTtcbiAgICAgICAgICBiYWlsKHNraXBBbmltYXRpb25TaWduYWwpO1xuICAgICAgICAgIHRocm93IHNraXBBbmltYXRpb25TaWduYWw7XG4gICAgICAgIH1cblxuICAgICAgICBiYWlsSWZFbmRlZChiYWlsU2lnbmFsKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMub2JqKGFyZzEpID8gX2V4dGVuZHMoe30sIGFyZzEpIDogX2V4dGVuZHMoe30sIGFyZzIsIHtcbiAgICAgICAgICB0bzogYXJnMVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvcHMucGFyZW50SWQgPSBjYWxsSWQ7XG4gICAgICAgIHNoYXJlZC5lYWNoUHJvcChkZWZhdWx0UHJvcHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHNoYXJlZC5pcy51bmQocHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0YXJnZXQuc3RhcnQocHJvcHMpO1xuICAgICAgICBiYWlsSWZFbmRlZChiYWlsU2lnbmFsKTtcblxuICAgICAgICBpZiAoc3RhdGUucGF1c2VkKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzdW1lID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChyZXN1bWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pKCk7XG4gICAgfTtcblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgc3RvcEFzeW5jKHN0YXRlKTtcbiAgICAgIHJldHVybiBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IGFuaW1hdGluZztcblxuICAgICAgaWYgKHNoYXJlZC5pcy5hcnIodG8pKSB7XG4gICAgICAgIGFuaW1hdGluZyA9IChhc3luYyBxdWV1ZSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wcyBvZiBxdWV1ZSkge1xuICAgICAgICAgICAgYXdhaXQgYW5pbWF0ZShwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmltYXRpbmcgPSBQcm9taXNlLnJlc29sdmUodG8oYW5pbWF0ZSwgdGFyZ2V0LnN0b3AuYmluZCh0YXJnZXQpKSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFthbmltYXRpbmcudGhlbihwcmV2ZW50QmFpbCksIGJhaWxQcm9taXNlXSk7XG4gICAgICByZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQuZ2V0KCksIHRydWUsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBCYWlsU2lnbmFsKSB7XG4gICAgICAgIHJlc3VsdCA9IGVyci5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIFNraXBBbmltYXRpb25TaWduYWwpIHtcbiAgICAgICAgcmVzdWx0ID0gZXJyLnJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNhbGxJZCA9PSBzdGF0ZS5hc3luY0lkKSB7XG4gICAgICAgIHN0YXRlLmFzeW5jSWQgPSBwYXJlbnRJZDtcbiAgICAgICAgc3RhdGUuYXN5bmNUbyA9IHBhcmVudElkID8gcHJldlRvIDogdW5kZWZpbmVkO1xuICAgICAgICBzdGF0ZS5wcm9taXNlID0gcGFyZW50SWQgPyBwcmV2UHJvbWlzZSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hhcmVkLmlzLmZ1bihvblJlc3QpKSB7XG4gICAgICBzaGFyZWQucmFmLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgb25SZXN0KHJlc3VsdCwgdGFyZ2V0LCB0YXJnZXQuaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gc3RvcEFzeW5jKHN0YXRlLCBjYW5jZWxJZCkge1xuICBzaGFyZWQuZmx1c2goc3RhdGUudGltZW91dHMsIHQgPT4gdC5jYW5jZWwoKSk7XG4gIHN0YXRlLnBhdXNlUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUucmVzdW1lUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUuYXN5bmNJZCA9IHN0YXRlLmFzeW5jVG8gPSBzdGF0ZS5wcm9taXNlID0gdW5kZWZpbmVkO1xuICBpZiAoY2FuY2VsSWQpIHN0YXRlLmNhbmNlbElkID0gY2FuY2VsSWQ7XG59XG5jbGFzcyBCYWlsU2lnbmFsIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignQW4gYXN5bmMgYW5pbWF0aW9uIGhhcyBiZWVuIGludGVycnVwdGVkLiBZb3Ugc2VlIHRoaXMgZXJyb3IgYmVjYXVzZSB5b3UgJyArICdmb3Jnb3QgdG8gdXNlIGBhd2FpdGAgb3IgYC5jYXRjaCguLi4pYCBvbiBpdHMgcmV0dXJuZWQgcHJvbWlzZS4nKTtcbiAgICB0aGlzLnJlc3VsdCA9IHZvaWQgMDtcbiAgfVxuXG59XG5jbGFzcyBTa2lwQW5pbWF0aW9uU2lnbmFsIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignU2tpcEFuaW1hdGlvblNpZ25hbCcpO1xuICAgIHRoaXMucmVzdWx0ID0gdm9pZCAwO1xuICB9XG5cbn1cblxuY29uc3QgaXNGcmFtZVZhbHVlID0gdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBGcmFtZVZhbHVlO1xubGV0IG5leHRJZCQxID0gMTtcbmNsYXNzIEZyYW1lVmFsdWUgZXh0ZW5kcyBzaGFyZWQuRmx1aWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmlkID0gbmV4dElkJDErKztcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLl9wcmlvcml0eSA9IDA7XG4gIH1cblxuICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaW9yaXR5O1xuICB9XG5cbiAgc2V0IHByaW9yaXR5KHByaW9yaXR5KSB7XG4gICAgaWYgKHRoaXMuX3ByaW9yaXR5ICE9IHByaW9yaXR5KSB7XG4gICAgICB0aGlzLl9wcmlvcml0eSA9IHByaW9yaXR5O1xuXG4gICAgICB0aGlzLl9vblByaW9yaXR5Q2hhbmdlKHByaW9yaXR5KTtcbiAgICB9XG4gIH1cblxuICBnZXQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgdG8oLi4uYXJncykge1xuICAgIHJldHVybiBzaGFyZWQuR2xvYmFscy50byh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIGludGVycG9sYXRlKC4uLmFyZ3MpIHtcbiAgICBzaGFyZWQuZGVwcmVjYXRlSW50ZXJwb2xhdGUoKTtcbiAgICByZXR1cm4gc2hhcmVkLkdsb2JhbHMudG8odGhpcywgYXJncyk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCk7XG4gIH1cblxuICBvYnNlcnZlckFkZGVkKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDEpIHRoaXMuX2F0dGFjaCgpO1xuICB9XG5cbiAgb2JzZXJ2ZXJSZW1vdmVkKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDApIHRoaXMuX2RldGFjaCgpO1xuICB9XG5cbiAgX2F0dGFjaCgpIHt9XG5cbiAgX2RldGFjaCgpIHt9XG5cbiAgX29uQ2hhbmdlKHZhbHVlLCBpZGxlID0gZmFsc2UpIHtcbiAgICBzaGFyZWQuY2FsbEZsdWlkT2JzZXJ2ZXJzKHRoaXMsIHtcbiAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgdmFsdWUsXG4gICAgICBpZGxlXG4gICAgfSk7XG4gIH1cblxuICBfb25Qcmlvcml0eUNoYW5nZShwcmlvcml0eSkge1xuICAgIGlmICghdGhpcy5pZGxlKSB7XG4gICAgICBzaGFyZWQuZnJhbWVMb29wLnNvcnQodGhpcyk7XG4gICAgfVxuXG4gICAgc2hhcmVkLmNhbGxGbHVpZE9ic2VydmVycyh0aGlzLCB7XG4gICAgICB0eXBlOiAncHJpb3JpdHknLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgcHJpb3JpdHlcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNvbnN0ICRQID0gU3ltYm9sLmZvcignU3ByaW5nUGhhc2UnKTtcbmNvbnN0IEhBU19BTklNQVRFRCA9IDE7XG5jb25zdCBJU19BTklNQVRJTkcgPSAyO1xuY29uc3QgSVNfUEFVU0VEID0gNDtcbmNvbnN0IGhhc0FuaW1hdGVkID0gdGFyZ2V0ID0+ICh0YXJnZXRbJFBdICYgSEFTX0FOSU1BVEVEKSA+IDA7XG5jb25zdCBpc0FuaW1hdGluZyA9IHRhcmdldCA9PiAodGFyZ2V0WyRQXSAmIElTX0FOSU1BVElORykgPiAwO1xuY29uc3QgaXNQYXVzZWQgPSB0YXJnZXQgPT4gKHRhcmdldFskUF0gJiBJU19QQVVTRUQpID4gMDtcbmNvbnN0IHNldEFjdGl2ZUJpdCA9ICh0YXJnZXQsIGFjdGl2ZSkgPT4gYWN0aXZlID8gdGFyZ2V0WyRQXSB8PSBJU19BTklNQVRJTkcgfCBIQVNfQU5JTUFURUQgOiB0YXJnZXRbJFBdICY9IH5JU19BTklNQVRJTkc7XG5jb25zdCBzZXRQYXVzZWRCaXQgPSAodGFyZ2V0LCBwYXVzZWQpID0+IHBhdXNlZCA/IHRhcmdldFskUF0gfD0gSVNfUEFVU0VEIDogdGFyZ2V0WyRQXSAmPSB+SVNfUEFVU0VEO1xuXG5jbGFzcyBTcHJpbmdWYWx1ZSBleHRlbmRzIEZyYW1lVmFsdWUge1xuICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oKTtcbiAgICB0aGlzLnF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdFByb3BzID0ge307XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgZGVsYXllZDogZmFsc2UsXG4gICAgICBwYXVzZVF1ZXVlOiBuZXcgU2V0KCksXG4gICAgICByZXN1bWVRdWV1ZTogbmV3IFNldCgpLFxuICAgICAgdGltZW91dHM6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2xhc3RDYWxsSWQgPSAwO1xuICAgIHRoaXMuX2xhc3RUb0lkID0gMDtcbiAgICB0aGlzLl9tZW1vaXplZER1cmF0aW9uID0gMDtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZChhcmcxKSB8fCAhc2hhcmVkLmlzLnVuZChhcmcyKSkge1xuICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMub2JqKGFyZzEpID8gX2V4dGVuZHMoe30sIGFyZzEpIDogX2V4dGVuZHMoe30sIGFyZzIsIHtcbiAgICAgICAgZnJvbTogYXJnMVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzLmRlZmF1bHQpKSB7XG4gICAgICAgIHByb3BzLmRlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0KHByb3BzKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIShpc0FuaW1hdGluZyh0aGlzKSB8fCB0aGlzLl9zdGF0ZS5hc3luY1RvKSB8fCBpc1BhdXNlZCh0aGlzKTtcbiAgfVxuXG4gIGdldCBnb2FsKCkge1xuICAgIHJldHVybiBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZSh0aGlzLmFuaW1hdGlvbi50byk7XG4gIH1cblxuICBnZXQgdmVsb2NpdHkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBhbmltYXRlZCQxLkFuaW1hdGVkVmFsdWUgPyBub2RlLmxhc3RWZWxvY2l0eSB8fCAwIDogbm9kZS5nZXRQYXlsb2FkKCkubWFwKG5vZGUgPT4gbm9kZS5sYXN0VmVsb2NpdHkgfHwgMCk7XG4gIH1cblxuICBnZXQgaGFzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIGhhc0FuaW1hdGVkKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGlzQW5pbWF0aW5nKCkge1xuICAgIHJldHVybiBpc0FuaW1hdGluZyh0aGlzKTtcbiAgfVxuXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gaXNQYXVzZWQodGhpcyk7XG4gIH1cblxuICBnZXQgaXNEZWxheWVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kZWxheWVkO1xuICB9XG5cbiAgYWR2YW5jZShkdCkge1xuICAgIGxldCBpZGxlID0gdHJ1ZTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICBsZXQge1xuICAgICAgY29uZmlnLFxuICAgICAgdG9WYWx1ZXNcbiAgICB9ID0gYW5pbTtcbiAgICBjb25zdCBwYXlsb2FkID0gYW5pbWF0ZWQkMS5nZXRQYXlsb2FkKGFuaW0udG8pO1xuXG4gICAgaWYgKCFwYXlsb2FkICYmIHNoYXJlZC5oYXNGbHVpZFZhbHVlKGFuaW0udG8pKSB7XG4gICAgICB0b1ZhbHVlcyA9IHNoYXJlZC50b0FycmF5KHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pKTtcbiAgICB9XG5cbiAgICBhbmltLnZhbHVlcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICBpZiAobm9kZS5kb25lKSByZXR1cm47XG4gICAgICBjb25zdCB0byA9IG5vZGUuY29uc3RydWN0b3IgPT0gYW5pbWF0ZWQkMS5BbmltYXRlZFN0cmluZyA/IDEgOiBwYXlsb2FkID8gcGF5bG9hZFtpXS5sYXN0UG9zaXRpb24gOiB0b1ZhbHVlc1tpXTtcbiAgICAgIGxldCBmaW5pc2hlZCA9IGFuaW0uaW1tZWRpYXRlO1xuICAgICAgbGV0IHBvc2l0aW9uID0gdG87XG5cbiAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub2RlLmxhc3RQb3NpdGlvbjtcblxuICAgICAgICBpZiAoY29uZmlnLnRlbnNpb24gPD0gMCkge1xuICAgICAgICAgIG5vZGUuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsYXBzZWQgPSBub2RlLmVsYXBzZWRUaW1lICs9IGR0O1xuICAgICAgICBjb25zdCBmcm9tID0gYW5pbS5mcm9tVmFsdWVzW2ldO1xuICAgICAgICBjb25zdCB2MCA9IG5vZGUudjAgIT0gbnVsbCA/IG5vZGUudjAgOiBub2RlLnYwID0gc2hhcmVkLmlzLmFycihjb25maWcudmVsb2NpdHkpID8gY29uZmlnLnZlbG9jaXR5W2ldIDogY29uZmlnLnZlbG9jaXR5O1xuICAgICAgICBsZXQgdmVsb2NpdHk7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGNvbmZpZy5wcmVjaXNpb24gfHwgKGZyb20gPT0gdG8gPyAwLjAwNSA6IE1hdGgubWluKDEsIE1hdGguYWJzKHRvIC0gZnJvbSkgKiAwLjAwMSkpO1xuXG4gICAgICAgIGlmICghc2hhcmVkLmlzLnVuZChjb25maWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgbGV0IHAgPSAxO1xuXG4gICAgICAgICAgaWYgKGNvbmZpZy5kdXJhdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZW1vaXplZER1cmF0aW9uICE9PSBjb25maWcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWVtb2l6ZWREdXJhdGlvbiA9IGNvbmZpZy5kdXJhdGlvbjtcblxuICAgICAgICAgICAgICBpZiAobm9kZS5kdXJhdGlvblByb2dyZXNzID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuZWxhcHNlZFRpbWUgPSBjb25maWcuZHVyYXRpb24gKiBub2RlLmR1cmF0aW9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgZWxhcHNlZCA9IG5vZGUuZWxhcHNlZFRpbWUgKz0gZHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IChjb25maWcucHJvZ3Jlc3MgfHwgMCkgKyBlbGFwc2VkIC8gdGhpcy5fbWVtb2l6ZWREdXJhdGlvbjtcbiAgICAgICAgICAgIHAgPSBwID4gMSA/IDEgOiBwIDwgMCA/IDAgOiBwO1xuICAgICAgICAgICAgbm9kZS5kdXJhdGlvblByb2dyZXNzID0gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IGZyb20gKyBjb25maWcuZWFzaW5nKHApICogKHRvIC0gZnJvbSk7XG4gICAgICAgICAgdmVsb2NpdHkgPSAocG9zaXRpb24gLSBub2RlLmxhc3RQb3NpdGlvbikgLyBkdDtcbiAgICAgICAgICBmaW5pc2hlZCA9IHAgPT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcuZGVjYXkpIHtcbiAgICAgICAgICBjb25zdCBkZWNheSA9IGNvbmZpZy5kZWNheSA9PT0gdHJ1ZSA/IDAuOTk4IDogY29uZmlnLmRlY2F5O1xuICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLmV4cCgtKDEgLSBkZWNheSkgKiBlbGFwc2VkKTtcbiAgICAgICAgICBwb3NpdGlvbiA9IGZyb20gKyB2MCAvICgxIC0gZGVjYXkpICogKDEgLSBlKTtcbiAgICAgICAgICBmaW5pc2hlZCA9IE1hdGguYWJzKG5vZGUubGFzdFBvc2l0aW9uIC0gcG9zaXRpb24pIDw9IHByZWNpc2lvbjtcbiAgICAgICAgICB2ZWxvY2l0eSA9IHYwICogZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IG5vZGUubGFzdFZlbG9jaXR5ID09IG51bGwgPyB2MCA6IG5vZGUubGFzdFZlbG9jaXR5O1xuICAgICAgICAgIGNvbnN0IHJlc3RWZWxvY2l0eSA9IGNvbmZpZy5yZXN0VmVsb2NpdHkgfHwgcHJlY2lzaW9uIC8gMTA7XG4gICAgICAgICAgY29uc3QgYm91bmNlRmFjdG9yID0gY29uZmlnLmNsYW1wID8gMCA6IGNvbmZpZy5ib3VuY2U7XG4gICAgICAgICAgY29uc3QgY2FuQm91bmNlID0gIXNoYXJlZC5pcy51bmQoYm91bmNlRmFjdG9yKTtcbiAgICAgICAgICBjb25zdCBpc0dyb3dpbmcgPSBmcm9tID09IHRvID8gbm9kZS52MCA+IDAgOiBmcm9tIDwgdG87XG4gICAgICAgICAgbGV0IGlzTW92aW5nO1xuICAgICAgICAgIGxldCBpc0JvdW5jaW5nID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IDE7XG4gICAgICAgICAgY29uc3QgbnVtU3RlcHMgPSBNYXRoLmNlaWwoZHQgLyBzdGVwKTtcblxuICAgICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbnVtU3RlcHM7ICsrbikge1xuICAgICAgICAgICAgaXNNb3ZpbmcgPSBNYXRoLmFicyh2ZWxvY2l0eSkgPiByZXN0VmVsb2NpdHk7XG5cbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSBNYXRoLmFicyh0byAtIHBvc2l0aW9uKSA8PSBwcmVjaXNpb247XG5cbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbkJvdW5jZSkge1xuICAgICAgICAgICAgICBpc0JvdW5jaW5nID0gcG9zaXRpb24gPT0gdG8gfHwgcG9zaXRpb24gPiB0byA9PSBpc0dyb3dpbmc7XG5cbiAgICAgICAgICAgICAgaWYgKGlzQm91bmNpbmcpIHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IC12ZWxvY2l0eSAqIGJvdW5jZUZhY3RvcjtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRvO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNwcmluZ0ZvcmNlID0gLWNvbmZpZy50ZW5zaW9uICogMC4wMDAwMDEgKiAocG9zaXRpb24gLSB0byk7XG4gICAgICAgICAgICBjb25zdCBkYW1waW5nRm9yY2UgPSAtY29uZmlnLmZyaWN0aW9uICogMC4wMDEgKiB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IChzcHJpbmdGb3JjZSArIGRhbXBpbmdGb3JjZSkgLyBjb25maWcubWFzcztcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkgKyBhY2NlbGVyYXRpb24gKiBzdGVwO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiArIHZlbG9jaXR5ICogc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmxhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4ocG9zaXRpb24pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBHb3QgTmFOIHdoaWxlIGFuaW1hdGluZzpgLCB0aGlzKTtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBheWxvYWQgJiYgIXBheWxvYWRbaV0uZG9uZSkge1xuICAgICAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkbGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuc2V0VmFsdWUocG9zaXRpb24sIGNvbmZpZy5yb3VuZCkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgY29uc3QgY3VyclZhbCA9IG5vZGUuZ2V0VmFsdWUoKTtcblxuICAgIGlmIChpZGxlKSB7XG4gICAgICBjb25zdCBmaW5hbFZhbCA9IHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pO1xuXG4gICAgICBpZiAoKGN1cnJWYWwgIT09IGZpbmFsVmFsIHx8IGNoYW5nZWQpICYmICFjb25maWcuZGVjYXkpIHtcbiAgICAgICAgbm9kZS5zZXRWYWx1ZShmaW5hbFZhbCk7XG5cbiAgICAgICAgdGhpcy5fb25DaGFuZ2UoZmluYWxWYWwpO1xuICAgICAgfSBlbHNlIGlmIChjaGFuZ2VkICYmIGNvbmZpZy5kZWNheSkge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZShjdXJyVmFsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25DaGFuZ2UoY3VyclZhbCk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHZhbHVlKSB7XG4gICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICB0aGlzLl9zdG9wKCk7XG5cbiAgICAgIHRoaXMuX2ZvY3VzKHZhbHVlKTtcblxuICAgICAgdGhpcy5fc2V0KHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh7XG4gICAgICBwYXVzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh7XG4gICAgICBwYXVzZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGZpbmlzaCgpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG8sXG4gICAgICAgIGNvbmZpZ1xuICAgICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3RhcnQoKTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5kZWNheSkge1xuICAgICAgICAgIHRoaXMuX3NldCh0bywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGUocHJvcHMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWUgfHwgKHRoaXMucXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydCh0bywgYXJnMikge1xuICAgIGxldCBxdWV1ZTtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZCh0bykpIHtcbiAgICAgIHF1ZXVlID0gW3NoYXJlZC5pcy5vYmoodG8pID8gdG8gOiBfZXh0ZW5kcyh7fSwgYXJnMiwge1xuICAgICAgICB0b1xuICAgICAgfSldO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZSA9IHRoaXMucXVldWUgfHwgW107XG4gICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXVlLm1hcChwcm9wcyA9PiB7XG4gICAgICBjb25zdCB1cCA9IHRoaXMuX3VwZGF0ZShwcm9wcyk7XG5cbiAgICAgIHJldHVybiB1cDtcbiAgICB9KSkudGhlbihyZXN1bHRzID0+IGdldENvbWJpbmVkUmVzdWx0KHRoaXMsIHJlc3VsdHMpKTtcbiAgfVxuXG4gIHN0b3AoY2FuY2VsKSB7XG4gICAgY29uc3Qge1xuICAgICAgdG9cbiAgICB9ID0gdGhpcy5hbmltYXRpb247XG5cbiAgICB0aGlzLl9mb2N1cyh0aGlzLmdldCgpKTtcblxuICAgIHN0b3BBc3luYyh0aGlzLl9zdGF0ZSwgY2FuY2VsICYmIHRoaXMuX2xhc3RDYWxsSWQpO1xuICAgIHNoYXJlZC5yYWYuYmF0Y2hlZFVwZGF0ZXMoKCkgPT4gdGhpcy5fc3RvcCh0bywgY2FuY2VsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoe1xuICAgICAgcmVzZXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSAnY2hhbmdlJykge1xuICAgICAgdGhpcy5fc3RhcnQoKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gJ3ByaW9yaXR5Jykge1xuICAgICAgdGhpcy5wcmlvcml0eSA9IGV2ZW50LnByaW9yaXR5ICsgMTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZU5vZGUocHJvcHMpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleSB8fCAnJztcbiAgICBsZXQge1xuICAgICAgdG8sXG4gICAgICBmcm9tXG4gICAgfSA9IHByb3BzO1xuICAgIHRvID0gc2hhcmVkLmlzLm9iaih0bykgPyB0b1trZXldIDogdG87XG5cbiAgICBpZiAodG8gPT0gbnVsbCB8fCBpc0FzeW5jVG8odG8pKSB7XG4gICAgICB0byA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmcm9tID0gc2hhcmVkLmlzLm9iaihmcm9tKSA/IGZyb21ba2V5XSA6IGZyb207XG5cbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgdG8sXG4gICAgICBmcm9tXG4gICAgfTtcblxuICAgIGlmICghaGFzQW5pbWF0ZWQodGhpcykpIHtcbiAgICAgIGlmIChwcm9wcy5yZXZlcnNlKSBbdG8sIGZyb21dID0gW2Zyb20sIHRvXTtcbiAgICAgIGZyb20gPSBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZShmcm9tKTtcblxuICAgICAgaWYgKCFzaGFyZWQuaXMudW5kKGZyb20pKSB7XG4gICAgICAgIHRoaXMuX3NldChmcm9tKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcykpIHtcbiAgICAgICAgdGhpcy5fc2V0KHRvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBfdXBkYXRlKF9yZWYsIGlzTG9vcCkge1xuICAgIGxldCBwcm9wcyA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIGRlZmF1bHRQcm9wc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChwcm9wcy5kZWZhdWx0KSBPYmplY3QuYXNzaWduKGRlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKHByb3BzLCAodmFsdWUsIHByb3ApID0+IC9eb24vLnRlc3QocHJvcCkgPyByZXNvbHZlUHJvcCh2YWx1ZSwga2V5KSA6IHZhbHVlKSk7XG4gICAgbWVyZ2VBY3RpdmVGbih0aGlzLCBwcm9wcywgJ29uUHJvcHMnKTtcbiAgICBzZW5kRXZlbnQodGhpcywgJ29uUHJvcHMnLCBwcm9wcywgdGhpcyk7XG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMuX3ByZXBhcmVOb2RlKHByb3BzKTtcblxuICAgIGlmIChPYmplY3QuaXNGcm96ZW4odGhpcykpIHtcbiAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgYW5pbWF0ZSBhIGBTcHJpbmdWYWx1ZWAgb2JqZWN0IHRoYXQgaXMgZnJvemVuLiAnICsgJ0RpZCB5b3UgZm9yZ2V0IHRvIHBhc3MgeW91ciBjb21wb25lbnQgdG8gYGFuaW1hdGVkKC4uLilgIGJlZm9yZSBhbmltYXRpbmcgaXRzIHByb3BzPycpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHNjaGVkdWxlUHJvcHMoKyt0aGlzLl9sYXN0Q2FsbElkLCB7XG4gICAgICBrZXksXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBwYXVzZTogKCkgPT4ge1xuICAgICAgICAgIGlmICghaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgICAgIHNldFBhdXNlZEJpdCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHNoYXJlZC5mbHVzaENhbGxzKHN0YXRlLnBhdXNlUXVldWUpO1xuICAgICAgICAgICAgc2VuZEV2ZW50KHRoaXMsICdvblBhdXNlJywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCB0aGlzLmFuaW1hdGlvbi50bykpLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VtZTogKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1BhdXNlZCh0aGlzKSkge1xuICAgICAgICAgICAgc2V0UGF1c2VkQml0KHRoaXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKGlzQW5pbWF0aW5nKHRoaXMpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3VtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGFyZWQuZmx1c2hDYWxscyhzdGF0ZS5yZXN1bWVRdWV1ZSk7XG4gICAgICAgICAgICBzZW5kRXZlbnQodGhpcywgJ29uUmVzdW1lJywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCB0aGlzLmFuaW1hdGlvbi50bykpLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiB0aGlzLl9tZXJnZS5iaW5kKHRoaXMsIHJhbmdlKVxuICAgICAgfVxuICAgIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChwcm9wcy5sb29wICYmIHJlc3VsdC5maW5pc2hlZCAmJiAhKGlzTG9vcCAmJiByZXN1bHQubm9vcCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFByb3BzID0gY3JlYXRlTG9vcFVwZGF0ZShwcm9wcyk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobmV4dFByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG5cbiAgX21lcmdlKHJhbmdlLCBwcm9wcywgcmVzb2x2ZSkge1xuICAgIGlmIChwcm9wcy5jYW5jZWwpIHtcbiAgICAgIHRoaXMuc3RvcCh0cnVlKTtcbiAgICAgIHJldHVybiByZXNvbHZlKGdldENhbmNlbGxlZFJlc3VsdCh0aGlzKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzVG9Qcm9wID0gIXNoYXJlZC5pcy51bmQocmFuZ2UudG8pO1xuICAgIGNvbnN0IGhhc0Zyb21Qcm9wID0gIXNoYXJlZC5pcy51bmQocmFuZ2UuZnJvbSk7XG5cbiAgICBpZiAoaGFzVG9Qcm9wIHx8IGhhc0Zyb21Qcm9wKSB7XG4gICAgICBpZiAocHJvcHMuY2FsbElkID4gdGhpcy5fbGFzdFRvSWQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRvSWQgPSBwcm9wcy5jYWxsSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRDYW5jZWxsZWRSZXN1bHQodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIGFuaW1hdGlvbjogYW5pbVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvOiBwcmV2VG8sXG4gICAgICBmcm9tOiBwcmV2RnJvbVxuICAgIH0gPSBhbmltO1xuICAgIGxldCB7XG4gICAgICB0byA9IHByZXZUbyxcbiAgICAgIGZyb20gPSBwcmV2RnJvbVxuICAgIH0gPSByYW5nZTtcblxuICAgIGlmIChoYXNGcm9tUHJvcCAmJiAhaGFzVG9Qcm9wICYmICghcHJvcHMuZGVmYXVsdCB8fCBzaGFyZWQuaXMudW5kKHRvKSkpIHtcbiAgICAgIHRvID0gZnJvbTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMucmV2ZXJzZSkgW3RvLCBmcm9tXSA9IFtmcm9tLCB0b107XG4gICAgY29uc3QgaGFzRnJvbUNoYW5nZWQgPSAhc2hhcmVkLmlzRXF1YWwoZnJvbSwgcHJldkZyb20pO1xuXG4gICAgaWYgKGhhc0Zyb21DaGFuZ2VkKSB7XG4gICAgICBhbmltLmZyb20gPSBmcm9tO1xuICAgIH1cblxuICAgIGZyb20gPSBzaGFyZWQuZ2V0Rmx1aWRWYWx1ZShmcm9tKTtcbiAgICBjb25zdCBoYXNUb0NoYW5nZWQgPSAhc2hhcmVkLmlzRXF1YWwodG8sIHByZXZUbyk7XG5cbiAgICBpZiAoaGFzVG9DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9mb2N1cyh0byk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQXN5bmNUbyA9IGlzQXN5bmNUbyhwcm9wcy50byk7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnXG4gICAgfSA9IGFuaW07XG4gICAgY29uc3Qge1xuICAgICAgZGVjYXksXG4gICAgICB2ZWxvY2l0eVxuICAgIH0gPSBjb25maWc7XG5cbiAgICBpZiAoaGFzVG9Qcm9wIHx8IGhhc0Zyb21Qcm9wKSB7XG4gICAgICBjb25maWcudmVsb2NpdHkgPSAwO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5jb25maWcgJiYgIWhhc0FzeW5jVG8pIHtcbiAgICAgIG1lcmdlQ29uZmlnKGNvbmZpZywgY2FsbFByb3AocHJvcHMuY29uZmlnLCBrZXkpLCBwcm9wcy5jb25maWcgIT09IGRlZmF1bHRQcm9wcy5jb25maWcgPyBjYWxsUHJvcChkZWZhdWx0UHJvcHMuY29uZmlnLCBrZXkpIDogdm9pZCAwKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWQodGhpcyk7XG5cbiAgICBpZiAoIW5vZGUgfHwgc2hhcmVkLmlzLnVuZCh0bykpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGdldEZpbmlzaGVkUmVzdWx0KHRoaXMsIHRydWUpKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNldCA9IHNoYXJlZC5pcy51bmQocHJvcHMucmVzZXQpID8gaGFzRnJvbVByb3AgJiYgIXByb3BzLmRlZmF1bHQgOiAhc2hhcmVkLmlzLnVuZChmcm9tKSAmJiBtYXRjaFByb3AocHJvcHMucmVzZXQsIGtleSk7XG4gICAgY29uc3QgdmFsdWUgPSByZXNldCA/IGZyb20gOiB0aGlzLmdldCgpO1xuICAgIGNvbnN0IGdvYWwgPSBjb21wdXRlR29hbCh0byk7XG4gICAgY29uc3QgaXNBbmltYXRhYmxlID0gc2hhcmVkLmlzLm51bShnb2FsKSB8fCBzaGFyZWQuaXMuYXJyKGdvYWwpIHx8IHNoYXJlZC5pc0FuaW1hdGVkU3RyaW5nKGdvYWwpO1xuICAgIGNvbnN0IGltbWVkaWF0ZSA9ICFoYXNBc3luY1RvICYmICghaXNBbmltYXRhYmxlIHx8IG1hdGNoUHJvcChkZWZhdWx0UHJvcHMuaW1tZWRpYXRlIHx8IHByb3BzLmltbWVkaWF0ZSwga2V5KSk7XG5cbiAgICBpZiAoaGFzVG9DaGFuZ2VkKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IGFuaW1hdGVkJDEuZ2V0QW5pbWF0ZWRUeXBlKHRvKTtcblxuICAgICAgaWYgKG5vZGVUeXBlICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5fc2V0KGdvYWwpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgRXJyb3IoYENhbm5vdCBhbmltYXRlIGJldHdlZW4gJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IGFuZCAke25vZGVUeXBlLm5hbWV9LCBhcyB0aGUgXCJ0b1wiIHByb3Agc3VnZ2VzdHNgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnb2FsVHlwZSA9IG5vZGUuY29uc3RydWN0b3I7XG4gICAgbGV0IHN0YXJ0ZWQgPSBzaGFyZWQuaGFzRmx1aWRWYWx1ZSh0byk7XG4gICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGNvbnN0IGhhc1ZhbHVlQ2hhbmdlZCA9IHJlc2V0IHx8ICFoYXNBbmltYXRlZCh0aGlzKSAmJiBoYXNGcm9tQ2hhbmdlZDtcblxuICAgICAgaWYgKGhhc1RvQ2hhbmdlZCB8fCBoYXNWYWx1ZUNoYW5nZWQpIHtcbiAgICAgICAgZmluaXNoZWQgPSBzaGFyZWQuaXNFcXVhbChjb21wdXRlR29hbCh2YWx1ZSksIGdvYWwpO1xuICAgICAgICBzdGFydGVkID0gIWZpbmlzaGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNoYXJlZC5pc0VxdWFsKGFuaW0uaW1tZWRpYXRlLCBpbW1lZGlhdGUpICYmICFpbW1lZGlhdGUgfHwgIXNoYXJlZC5pc0VxdWFsKGNvbmZpZy5kZWNheSwgZGVjYXkpIHx8ICFzaGFyZWQuaXNFcXVhbChjb25maWcudmVsb2NpdHksIHZlbG9jaXR5KSkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmluaXNoZWQgJiYgaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIGlmIChhbmltLmNoYW5nZWQgJiYgIXJlc2V0KSB7XG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghc3RhcnRlZCkge1xuICAgICAgICB0aGlzLl9zdG9wKHByZXZUbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFoYXNBc3luY1RvKSB7XG4gICAgICBpZiAoc3RhcnRlZCB8fCBzaGFyZWQuaGFzRmx1aWRWYWx1ZShwcmV2VG8pKSB7XG4gICAgICAgIGFuaW0udmFsdWVzID0gbm9kZS5nZXRQYXlsb2FkKCk7XG4gICAgICAgIGFuaW0udG9WYWx1ZXMgPSBzaGFyZWQuaGFzRmx1aWRWYWx1ZSh0bykgPyBudWxsIDogZ29hbFR5cGUgPT0gYW5pbWF0ZWQkMS5BbmltYXRlZFN0cmluZyA/IFsxXSA6IHNoYXJlZC50b0FycmF5KGdvYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbS5pbW1lZGlhdGUgIT0gaW1tZWRpYXRlKSB7XG4gICAgICAgIGFuaW0uaW1tZWRpYXRlID0gaW1tZWRpYXRlO1xuXG4gICAgICAgIGlmICghaW1tZWRpYXRlICYmICFyZXNldCkge1xuICAgICAgICAgIHRoaXMuX3NldChwcmV2VG8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvblJlc3RcbiAgICAgICAgfSA9IGFuaW07XG4gICAgICAgIHNoYXJlZC5lYWNoKEFDVElWRV9FVkVOVFMsIHR5cGUgPT4gbWVyZ2VBY3RpdmVGbih0aGlzLCBwcm9wcywgdHlwZSkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLCBjaGVja0ZpbmlzaGVkKHRoaXMsIHByZXZUbykpO1xuICAgICAgICBzaGFyZWQuZmx1c2hDYWxscyh0aGlzLl9wZW5kaW5nQ2FsbHMsIHJlc3VsdCk7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLmFkZChyZXNvbHZlKTtcblxuICAgICAgICBpZiAoYW5pbS5jaGFuZ2VkKSBzaGFyZWQucmFmLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBhbmltLmNoYW5nZWQgPSAhcmVzZXQ7XG4gICAgICAgICAgb25SZXN0ID09IG51bGwgPyB2b2lkIDAgOiBvblJlc3QocmVzdWx0LCB0aGlzKTtcblxuICAgICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgY2FsbFByb3AoZGVmYXVsdFByb3BzLm9uUmVzdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbS5vblN0YXJ0ID09IG51bGwgPyB2b2lkIDAgOiBhbmltLm9uU3RhcnQocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXNldCkge1xuICAgICAgdGhpcy5fc2V0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzQXN5bmNUbykge1xuICAgICAgcmVzb2x2ZShydW5Bc3luYyhwcm9wcy50bywgcHJvcHMsIHRoaXMuX3N0YXRlLCB0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH0gZWxzZSBpZiAoaXNBbmltYXRpbmcodGhpcykgJiYgIWhhc1RvQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLmFkZChyZXNvbHZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShnZXROb29wUmVzdWx0KHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgX2ZvY3VzKHZhbHVlKSB7XG4gICAgY29uc3QgYW5pbSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHZhbHVlICE9PSBhbmltLnRvKSB7XG4gICAgICBpZiAoc2hhcmVkLmdldEZsdWlkT2JzZXJ2ZXJzKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBhbmltLnRvID0gdmFsdWU7XG5cbiAgICAgIGlmIChzaGFyZWQuZ2V0Rmx1aWRPYnNlcnZlcnModGhpcykpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2F0dGFjaCgpIHtcbiAgICBsZXQgcHJpb3JpdHkgPSAwO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHNoYXJlZC5oYXNGbHVpZFZhbHVlKHRvKSkge1xuICAgICAgc2hhcmVkLmFkZEZsdWlkT2JzZXJ2ZXIodG8sIHRoaXMpO1xuXG4gICAgICBpZiAoaXNGcmFtZVZhbHVlKHRvKSkge1xuICAgICAgICBwcmlvcml0eSA9IHRvLnByaW9yaXR5ICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gIH1cblxuICBfZGV0YWNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuYW5pbWF0aW9uO1xuXG4gICAgaWYgKHNoYXJlZC5oYXNGbHVpZFZhbHVlKHRvKSkge1xuICAgICAgc2hhcmVkLnJlbW92ZUZsdWlkT2JzZXJ2ZXIodG8sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9zZXQoYXJnLCBpZGxlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc2hhcmVkLmdldEZsdWlkVmFsdWUoYXJnKTtcblxuICAgIGlmICghc2hhcmVkLmlzLnVuZCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IG9sZE5vZGUgPSBhbmltYXRlZCQxLmdldEFuaW1hdGVkKHRoaXMpO1xuXG4gICAgICBpZiAoIW9sZE5vZGUgfHwgIXNoYXJlZC5pc0VxdWFsKHZhbHVlLCBvbGROb2RlLmdldFZhbHVlKCkpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gYW5pbWF0ZWQkMS5nZXRBbmltYXRlZFR5cGUodmFsdWUpO1xuXG4gICAgICAgIGlmICghb2xkTm9kZSB8fCBvbGROb2RlLmNvbnN0cnVjdG9yICE9IG5vZGVUeXBlKSB7XG4gICAgICAgICAgYW5pbWF0ZWQkMS5zZXRBbmltYXRlZCh0aGlzLCBub2RlVHlwZS5jcmVhdGUodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGROb2RlLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvbGROb2RlKSB7XG4gICAgICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSwgaWRsZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0ZWQkMS5nZXRBbmltYXRlZCh0aGlzKTtcbiAgfVxuXG4gIF9vblN0YXJ0KCkge1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcblxuICAgIGlmICghYW5pbS5jaGFuZ2VkKSB7XG4gICAgICBhbmltLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgc2VuZEV2ZW50KHRoaXMsICdvblN0YXJ0JywgZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgY2hlY2tGaW5pc2hlZCh0aGlzLCBhbmltLnRvKSksIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkNoYW5nZSh2YWx1ZSwgaWRsZSkge1xuICAgIGlmICghaWRsZSkge1xuICAgICAgdGhpcy5fb25TdGFydCgpO1xuXG4gICAgICBjYWxsUHJvcCh0aGlzLmFuaW1hdGlvbi5vbkNoYW5nZSwgdmFsdWUsIHRoaXMpO1xuICAgIH1cblxuICAgIGNhbGxQcm9wKHRoaXMuZGVmYXVsdFByb3BzLm9uQ2hhbmdlLCB2YWx1ZSwgdGhpcyk7XG5cbiAgICBzdXBlci5fb25DaGFuZ2UodmFsdWUsIGlkbGUpO1xuICB9XG5cbiAgX3N0YXJ0KCkge1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICBhbmltYXRlZCQxLmdldEFuaW1hdGVkKHRoaXMpLnJlc2V0KHNoYXJlZC5nZXRGbHVpZFZhbHVlKGFuaW0udG8pKTtcblxuICAgIGlmICghYW5pbS5pbW1lZGlhdGUpIHtcbiAgICAgIGFuaW0uZnJvbVZhbHVlcyA9IGFuaW0udmFsdWVzLm1hcChub2RlID0+IG5vZGUubGFzdFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQW5pbWF0aW5nKHRoaXMpKSB7XG4gICAgICBzZXRBY3RpdmVCaXQodGhpcywgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgdGhpcy5fcmVzdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Jlc3VtZSgpIHtcbiAgICBpZiAoc2hhcmVkLkdsb2JhbHMuc2tpcEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcmVkLmZyYW1lTG9vcC5zdGFydCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBfc3RvcChnb2FsLCBjYW5jZWwpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIHNldEFjdGl2ZUJpdCh0aGlzLCBmYWxzZSk7XG4gICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb247XG4gICAgICBzaGFyZWQuZWFjaChhbmltLnZhbHVlcywgbm9kZSA9PiB7XG4gICAgICAgIG5vZGUuZG9uZSA9IHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGFuaW0udG9WYWx1ZXMpIHtcbiAgICAgICAgYW5pbS5vbkNoYW5nZSA9IGFuaW0ub25QYXVzZSA9IGFuaW0ub25SZXN1bWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHNoYXJlZC5jYWxsRmx1aWRPYnNlcnZlcnModGhpcywge1xuICAgICAgICB0eXBlOiAnaWRsZScsXG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYW5jZWwgPyBnZXRDYW5jZWxsZWRSZXN1bHQodGhpcy5nZXQoKSkgOiBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLmdldCgpLCBjaGVja0ZpbmlzaGVkKHRoaXMsIGdvYWwgIT0gbnVsbCA/IGdvYWwgOiBhbmltLnRvKSk7XG4gICAgICBzaGFyZWQuZmx1c2hDYWxscyh0aGlzLl9wZW5kaW5nQ2FsbHMsIHJlc3VsdCk7XG5cbiAgICAgIGlmIChhbmltLmNoYW5nZWQpIHtcbiAgICAgICAgYW5pbS5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHNlbmRFdmVudCh0aGlzLCAnb25SZXN0JywgcmVzdWx0LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjaGVja0ZpbmlzaGVkKHRhcmdldCwgdG8pIHtcbiAgY29uc3QgZ29hbCA9IGNvbXB1dGVHb2FsKHRvKTtcbiAgY29uc3QgdmFsdWUgPSBjb21wdXRlR29hbCh0YXJnZXQuZ2V0KCkpO1xuICByZXR1cm4gc2hhcmVkLmlzRXF1YWwodmFsdWUsIGdvYWwpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb29wVXBkYXRlKHByb3BzLCBsb29wID0gcHJvcHMubG9vcCwgdG8gPSBwcm9wcy50bykge1xuICBsZXQgbG9vcFJldCA9IGNhbGxQcm9wKGxvb3ApO1xuXG4gIGlmIChsb29wUmV0KSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gbG9vcFJldCAhPT0gdHJ1ZSAmJiBpbmZlclRvKGxvb3BSZXQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSAob3ZlcnJpZGVzIHx8IHByb3BzKS5yZXZlcnNlO1xuICAgIGNvbnN0IHJlc2V0ID0gIW92ZXJyaWRlcyB8fCBvdmVycmlkZXMucmVzZXQ7XG4gICAgcmV0dXJuIGNyZWF0ZVVwZGF0ZShfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGxvb3AsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHBhdXNlOiB1bmRlZmluZWQsXG4gICAgICB0bzogIXJldmVyc2UgfHwgaXNBc3luY1RvKHRvKSA/IHRvIDogdW5kZWZpbmVkLFxuICAgICAgZnJvbTogcmVzZXQgPyBwcm9wcy5mcm9tIDogdW5kZWZpbmVkLFxuICAgICAgcmVzZXRcbiAgICB9LCBvdmVycmlkZXMpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICB0byxcbiAgICBmcm9tXG4gIH0gPSBwcm9wcyA9IGluZmVyVG8ocHJvcHMpO1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICBpZiAoc2hhcmVkLmlzLm9iaih0bykpIGZpbmREZWZpbmVkKHRvLCBrZXlzKTtcbiAgaWYgKHNoYXJlZC5pcy5vYmooZnJvbSkpIGZpbmREZWZpbmVkKGZyb20sIGtleXMpO1xuICBwcm9wcy5rZXlzID0ga2V5cy5zaXplID8gQXJyYXkuZnJvbShrZXlzKSA6IG51bGw7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGRlY2xhcmVVcGRhdGUocHJvcHMpIHtcbiAgY29uc3QgdXBkYXRlID0gY3JlYXRlVXBkYXRlKHByb3BzKTtcblxuICBpZiAoc2hhcmVkLmlzLnVuZCh1cGRhdGUuZGVmYXVsdCkpIHtcbiAgICB1cGRhdGUuZGVmYXVsdCA9IGdldERlZmF1bHRQcm9wcyh1cGRhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZERlZmluZWQodmFsdWVzLCBrZXlzKSB7XG4gIHNoYXJlZC5lYWNoUHJvcCh2YWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB2YWx1ZSAhPSBudWxsICYmIGtleXMuYWRkKGtleSkpO1xufVxuXG5jb25zdCBBQ1RJVkVfRVZFTlRTID0gWydvblN0YXJ0JywgJ29uUmVzdCcsICdvbkNoYW5nZScsICdvblBhdXNlJywgJ29uUmVzdW1lJ107XG5cbmZ1bmN0aW9uIG1lcmdlQWN0aXZlRm4odGFyZ2V0LCBwcm9wcywgdHlwZSkge1xuICB0YXJnZXQuYW5pbWF0aW9uW3R5cGVdID0gcHJvcHNbdHlwZV0gIT09IGdldERlZmF1bHRQcm9wKHByb3BzLCB0eXBlKSA/IHJlc29sdmVQcm9wKHByb3BzW3R5cGVdLCB0YXJnZXQua2V5KSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2VuZEV2ZW50KHRhcmdldCwgdHlwZSwgLi4uYXJncykge1xuICB2YXIgX3RhcmdldCRhbmltYXRpb24kdHlwLCBfdGFyZ2V0JGFuaW1hdGlvbiwgX3RhcmdldCRkZWZhdWx0UHJvcHMkLCBfdGFyZ2V0JGRlZmF1bHRQcm9wcztcblxuICAoX3RhcmdldCRhbmltYXRpb24kdHlwID0gKF90YXJnZXQkYW5pbWF0aW9uID0gdGFyZ2V0LmFuaW1hdGlvbilbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JGFuaW1hdGlvbiR0eXAuY2FsbChfdGFyZ2V0JGFuaW1hdGlvbiwgLi4uYXJncyk7XG4gIChfdGFyZ2V0JGRlZmF1bHRQcm9wcyQgPSAoX3RhcmdldCRkZWZhdWx0UHJvcHMgPSB0YXJnZXQuZGVmYXVsdFByb3BzKVt0eXBlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQkZGVmYXVsdFByb3BzJC5jYWxsKF90YXJnZXQkZGVmYXVsdFByb3BzLCAuLi5hcmdzKTtcbn1cblxuY29uc3QgQkFUQ0hFRF9FVkVOVFMgPSBbJ29uU3RhcnQnLCAnb25DaGFuZ2UnLCAnb25SZXN0J107XG5sZXQgbmV4dElkID0gMTtcbmNsYXNzIENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcywgZmx1c2gpIHtcbiAgICB0aGlzLmlkID0gbmV4dElkKys7XG4gICAgdGhpcy5zcHJpbmdzID0ge307XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIHRoaXMuX2ZsdXNoID0gdm9pZCAwO1xuICAgIHRoaXMuX2luaXRpYWxQcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9sYXN0QXN5bmNJZCA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMuX2NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2l0ZW0gPSB2b2lkIDA7XG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgcGF1c2VRdWV1ZTogbmV3IFNldCgpLFxuICAgICAgcmVzdW1lUXVldWU6IG5ldyBTZXQoKSxcbiAgICAgIHRpbWVvdXRzOiBuZXcgU2V0KClcbiAgICB9O1xuICAgIHRoaXMuX2V2ZW50cyA9IHtcbiAgICAgIG9uU3RhcnQ6IG5ldyBNYXAoKSxcbiAgICAgIG9uQ2hhbmdlOiBuZXcgTWFwKCksXG4gICAgICBvblJlc3Q6IG5ldyBNYXAoKVxuICAgIH07XG4gICAgdGhpcy5fb25GcmFtZSA9IHRoaXMuX29uRnJhbWUuYmluZCh0aGlzKTtcblxuICAgIGlmIChmbHVzaCkge1xuICAgICAgdGhpcy5fZmx1c2ggPSBmbHVzaDtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHRoaXMuc3RhcnQoX2V4dGVuZHMoe1xuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LCBwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpZGxlKCkge1xuICAgIHJldHVybiAhdGhpcy5fc3RhdGUuYXN5bmNUbyAmJiBPYmplY3QudmFsdWVzKHRoaXMuc3ByaW5ncykuZXZlcnkoc3ByaW5nID0+IHtcbiAgICAgIHJldHVybiBzcHJpbmcuaWRsZSAmJiAhc3ByaW5nLmlzRGVsYXllZCAmJiAhc3ByaW5nLmlzUGF1c2VkO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gIH1cblxuICBzZXQgaXRlbShpdGVtKSB7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICBnZXQoKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgdGhpcy5lYWNoKChzcHJpbmcsIGtleSkgPT4gdmFsdWVzW2tleV0gPSBzcHJpbmcuZ2V0KCkpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBzZXQodmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXG4gICAgICBpZiAoIXNoYXJlZC5pcy51bmQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc3ByaW5nc1trZXldLnNldCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goY3JlYXRlVXBkYXRlKHByb3BzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGFydChwcm9wcykge1xuICAgIGxldCB7XG4gICAgICBxdWV1ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBxdWV1ZSA9IHNoYXJlZC50b0FycmF5KHByb3BzKS5tYXAoY3JlYXRlVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9mbHVzaCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoKHRoaXMsIHF1ZXVlKTtcbiAgICB9XG5cbiAgICBwcmVwYXJlS2V5cyh0aGlzLCBxdWV1ZSk7XG4gICAgcmV0dXJuIGZsdXNoVXBkYXRlUXVldWUodGhpcywgcXVldWUpO1xuICB9XG5cbiAgc3RvcChhcmcsIGtleXMpIHtcbiAgICBpZiAoYXJnICE9PSAhIWFyZykge1xuICAgICAga2V5cyA9IGFyZztcbiAgICB9XG5cbiAgICBpZiAoa2V5cykge1xuICAgICAgY29uc3Qgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncztcbiAgICAgIHNoYXJlZC5lYWNoKHNoYXJlZC50b0FycmF5KGtleXMpLCBrZXkgPT4gc3ByaW5nc1trZXldLnN0b3AoISFhcmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcEFzeW5jKHRoaXMuX3N0YXRlLCB0aGlzLl9sYXN0QXN5bmNJZCk7XG4gICAgICB0aGlzLmVhY2goc3ByaW5nID0+IHNwcmluZy5zdG9wKCEhYXJnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwYXVzZShrZXlzKSB7XG4gICAgaWYgKHNoYXJlZC5pcy51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoe1xuICAgICAgICBwYXVzZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheShrZXlzKSwga2V5ID0+IHNwcmluZ3Nba2V5XS5wYXVzZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlc3VtZShrZXlzKSB7XG4gICAgaWYgKHNoYXJlZC5pcy51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoe1xuICAgICAgICBwYXVzZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xuICAgICAgc2hhcmVkLmVhY2goc2hhcmVkLnRvQXJyYXkoa2V5cyksIGtleSA9PiBzcHJpbmdzW2tleV0ucmVzdW1lKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZWFjaChpdGVyYXRvcikge1xuICAgIHNoYXJlZC5lYWNoUHJvcCh0aGlzLnNwcmluZ3MsIGl0ZXJhdG9yKTtcbiAgfVxuXG4gIF9vbkZyYW1lKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU3RhcnQsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uUmVzdFxuICAgIH0gPSB0aGlzLl9ldmVudHM7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlLnNpemUgPiAwO1xuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9jaGFuZ2VkLnNpemUgPiAwO1xuXG4gICAgaWYgKGFjdGl2ZSAmJiAhdGhpcy5fc3RhcnRlZCB8fCBjaGFuZ2VkICYmICF0aGlzLl9zdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHNoYXJlZC5mbHVzaChvblN0YXJ0LCAoW29uU3RhcnQsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgb25TdGFydChyZXN1bHQsIHRoaXMsIHRoaXMuX2l0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaWRsZSA9ICFhY3RpdmUgJiYgdGhpcy5fc3RhcnRlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBjaGFuZ2VkIHx8IGlkbGUgJiYgb25SZXN0LnNpemUgPyB0aGlzLmdldCgpIDogbnVsbDtcblxuICAgIGlmIChjaGFuZ2VkICYmIG9uQ2hhbmdlLnNpemUpIHtcbiAgICAgIHNoYXJlZC5mbHVzaChvbkNoYW5nZSwgKFtvbkNoYW5nZSwgcmVzdWx0XSkgPT4ge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIG9uQ2hhbmdlKHJlc3VsdCwgdGhpcywgdGhpcy5faXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaWRsZSkge1xuICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgc2hhcmVkLmZsdXNoKG9uUmVzdCwgKFtvblJlc3QsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWVzO1xuICAgICAgICBvblJlc3QocmVzdWx0LCB0aGlzLCB0aGlzLl9pdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSAnY2hhbmdlJykge1xuICAgICAgdGhpcy5fY2hhbmdlZC5hZGQoZXZlbnQucGFyZW50KTtcblxuICAgICAgaWYgKCFldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5hZGQoZXZlbnQucGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gJ2lkbGUnKSB7XG4gICAgICB0aGlzLl9hY3RpdmUuZGVsZXRlKGV2ZW50LnBhcmVudCk7XG4gICAgfSBlbHNlIHJldHVybjtcblxuICAgIHNoYXJlZC5yYWYub25GcmFtZSh0aGlzLl9vbkZyYW1lKTtcbiAgfVxuXG59XG5mdW5jdGlvbiBmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHF1ZXVlKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZS5tYXAocHJvcHMgPT4gZmx1c2hVcGRhdGUoY3RybCwgcHJvcHMpKSkudGhlbihyZXN1bHRzID0+IGdldENvbWJpbmVkUmVzdWx0KGN0cmwsIHJlc3VsdHMpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZsdXNoVXBkYXRlKGN0cmwsIHByb3BzLCBpc0xvb3ApIHtcbiAgY29uc3Qge1xuICAgIGtleXMsXG4gICAgdG8sXG4gICAgZnJvbSxcbiAgICBsb29wLFxuICAgIG9uUmVzdCxcbiAgICBvblJlc29sdmVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBkZWZhdWx0cyA9IHNoYXJlZC5pcy5vYmoocHJvcHMuZGVmYXVsdCkgJiYgcHJvcHMuZGVmYXVsdDtcblxuICBpZiAobG9vcCkge1xuICAgIHByb3BzLmxvb3AgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0byA9PT0gZmFsc2UpIHByb3BzLnRvID0gbnVsbDtcbiAgaWYgKGZyb20gPT09IGZhbHNlKSBwcm9wcy5mcm9tID0gbnVsbDtcbiAgY29uc3QgYXN5bmNUbyA9IHNoYXJlZC5pcy5hcnIodG8pIHx8IHNoYXJlZC5pcy5mdW4odG8pID8gdG8gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGFzeW5jVG8pIHtcbiAgICBwcm9wcy50byA9IHVuZGVmaW5lZDtcbiAgICBwcm9wcy5vblJlc3QgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgIGRlZmF1bHRzLm9uUmVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkLmVhY2goQkFUQ0hFRF9FVkVOVFMsIGtleSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNba2V5XTtcblxuICAgICAgaWYgKHNoYXJlZC5pcy5mdW4oaGFuZGxlcikpIHtcbiAgICAgICAgY29uc3QgcXVldWUgPSBjdHJsWydfZXZlbnRzJ11ba2V5XTtcblxuICAgICAgICBwcm9wc1trZXldID0gKHtcbiAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICBjYW5jZWxsZWRcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHF1ZXVlLmdldChoYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHJlc3VsdC5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmVzdWx0LmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlLnNldChoYW5kbGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICBmaW5pc2hlZDogZmluaXNoZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGxlZDogY2FuY2VsbGVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICAgICAgZGVmYXVsdHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gY3RybFsnX3N0YXRlJ107XG5cbiAgaWYgKHByb3BzLnBhdXNlID09PSAhc3RhdGUucGF1c2VkKSB7XG4gICAgc3RhdGUucGF1c2VkID0gcHJvcHMucGF1c2U7XG4gICAgc2hhcmVkLmZsdXNoQ2FsbHMocHJvcHMucGF1c2UgPyBzdGF0ZS5wYXVzZVF1ZXVlIDogc3RhdGUucmVzdW1lUXVldWUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnBhdXNlZCkge1xuICAgIHByb3BzLnBhdXNlID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHByb21pc2VzID0gKGtleXMgfHwgT2JqZWN0LmtleXMoY3RybC5zcHJpbmdzKSkubWFwKGtleSA9PiBjdHJsLnNwcmluZ3Nba2V5XS5zdGFydChwcm9wcykpO1xuICBjb25zdCBjYW5jZWwgPSBwcm9wcy5jYW5jZWwgPT09IHRydWUgfHwgZ2V0RGVmYXVsdFByb3AocHJvcHMsICdjYW5jZWwnKSA9PT0gdHJ1ZTtcblxuICBpZiAoYXN5bmNUbyB8fCBjYW5jZWwgJiYgc3RhdGUuYXN5bmNJZCkge1xuICAgIHByb21pc2VzLnB1c2goc2NoZWR1bGVQcm9wcygrK2N0cmxbJ19sYXN0QXN5bmNJZCddLCB7XG4gICAgICBwcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBwYXVzZTogc2hhcmVkLm5vb3AsXG4gICAgICAgIHJlc3VtZTogc2hhcmVkLm5vb3AsXG5cbiAgICAgICAgc3RhcnQocHJvcHMsIHJlc29sdmUpIHtcbiAgICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgICBzdG9wQXN5bmMoc3RhdGUsIGN0cmxbJ19sYXN0QXN5bmNJZCddKTtcbiAgICAgICAgICAgIHJlc29sdmUoZ2V0Q2FuY2VsbGVkUmVzdWx0KGN0cmwpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub25SZXN0ID0gb25SZXN0O1xuICAgICAgICAgICAgcmVzb2x2ZShydW5Bc3luYyhhc3luY1RvLCBwcm9wcywgc3RhdGUsIGN0cmwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wYXVzZWQpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXN1bWUgPT4ge1xuICAgICAgc3RhdGUucmVzdW1lUXVldWUuYWRkKHJlc3VtZSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBnZXRDb21iaW5lZFJlc3VsdChjdHJsLCBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcykpO1xuXG4gIGlmIChsb29wICYmIHJlc3VsdC5maW5pc2hlZCAmJiAhKGlzTG9vcCAmJiByZXN1bHQubm9vcCkpIHtcbiAgICBjb25zdCBuZXh0UHJvcHMgPSBjcmVhdGVMb29wVXBkYXRlKHByb3BzLCBsb29wLCB0byk7XG5cbiAgICBpZiAobmV4dFByb3BzKSB7XG4gICAgICBwcmVwYXJlS2V5cyhjdHJsLCBbbmV4dFByb3BzXSk7XG4gICAgICByZXR1cm4gZmx1c2hVcGRhdGUoY3RybCwgbmV4dFByb3BzLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAob25SZXNvbHZlKSB7XG4gICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiBvblJlc29sdmUocmVzdWx0LCBjdHJsLCBjdHJsLml0ZW0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdzKGN0cmwsIHByb3BzKSB7XG4gIGNvbnN0IHNwcmluZ3MgPSBfZXh0ZW5kcyh7fSwgY3RybC5zcHJpbmdzKTtcblxuICBpZiAocHJvcHMpIHtcbiAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheShwcm9wcyksIHByb3BzID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzLmtleXMpKSB7XG4gICAgICAgIHByb3BzID0gY3JlYXRlVXBkYXRlKHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzaGFyZWQuaXMub2JqKHByb3BzLnRvKSkge1xuICAgICAgICBwcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICAgIHRvOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByZXBhcmVTcHJpbmdzKHNwcmluZ3MsIHByb3BzLCBrZXkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlU3ByaW5nKGtleSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldFNwcmluZ3MoY3RybCwgc3ByaW5ncyk7XG4gIHJldHVybiBzcHJpbmdzO1xufVxuZnVuY3Rpb24gc2V0U3ByaW5ncyhjdHJsLCBzcHJpbmdzKSB7XG4gIHNoYXJlZC5lYWNoUHJvcChzcHJpbmdzLCAoc3ByaW5nLCBrZXkpID0+IHtcbiAgICBpZiAoIWN0cmwuc3ByaW5nc1trZXldKSB7XG4gICAgICBjdHJsLnNwcmluZ3Nba2V5XSA9IHNwcmluZztcbiAgICAgIHNoYXJlZC5hZGRGbHVpZE9ic2VydmVyKHNwcmluZywgY3RybCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ByaW5nKGtleSwgb2JzZXJ2ZXIpIHtcbiAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZ1ZhbHVlKCk7XG4gIHNwcmluZy5rZXkgPSBrZXk7XG5cbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgc2hhcmVkLmFkZEZsdWlkT2JzZXJ2ZXIoc3ByaW5nLCBvYnNlcnZlcik7XG4gIH1cblxuICByZXR1cm4gc3ByaW5nO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlU3ByaW5ncyhzcHJpbmdzLCBwcm9wcywgY3JlYXRlKSB7XG4gIGlmIChwcm9wcy5rZXlzKSB7XG4gICAgc2hhcmVkLmVhY2gocHJvcHMua2V5cywga2V5ID0+IHtcbiAgICAgIGNvbnN0IHNwcmluZyA9IHNwcmluZ3Nba2V5XSB8fCAoc3ByaW5nc1trZXldID0gY3JlYXRlKGtleSkpO1xuICAgICAgc3ByaW5nWydfcHJlcGFyZU5vZGUnXShwcm9wcyk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZUtleXMoY3RybCwgcXVldWUpIHtcbiAgc2hhcmVkLmVhY2gocXVldWUsIHByb3BzID0+IHtcbiAgICBwcmVwYXJlU3ByaW5ncyhjdHJsLnNwcmluZ3MsIHByb3BzLCBrZXkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNwcmluZyhrZXksIGN0cmwpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQ2ID0gW1wiY2hpbGRyZW5cIl07XG5jb25zdCBTcHJpbmdDb250ZXh0ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ2KTtcblxuICBjb25zdCBpbmhlcml0ZWQgPSBSZWFjdC51c2VDb250ZXh0KGN0eCk7XG4gIGNvbnN0IHBhdXNlID0gcHJvcHMucGF1c2UgfHwgISFpbmhlcml0ZWQucGF1c2UsXG4gICAgICAgIGltbWVkaWF0ZSA9IHByb3BzLmltbWVkaWF0ZSB8fCAhIWluaGVyaXRlZC5pbW1lZGlhdGU7XG4gIHByb3BzID0gc2hhcmVkLnVzZU1lbW9PbmUoKCkgPT4gKHtcbiAgICBwYXVzZSxcbiAgICBpbW1lZGlhdGVcbiAgfSksIFtwYXVzZSwgaW1tZWRpYXRlXSk7XG4gIGNvbnN0IHtcbiAgICBQcm92aWRlclxuICB9ID0gY3R4O1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHByb3BzXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5jb25zdCBjdHggPSBtYWtlQ29udGV4dChTcHJpbmdDb250ZXh0LCB7fSk7XG5TcHJpbmdDb250ZXh0LlByb3ZpZGVyID0gY3R4LlByb3ZpZGVyO1xuU3ByaW5nQ29udGV4dC5Db25zdW1lciA9IGN0eC5Db25zdW1lcjtcblxuZnVuY3Rpb24gbWFrZUNvbnRleHQodGFyZ2V0LCBpbml0KSB7XG4gIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoaW5pdCkpO1xuICB0YXJnZXQuUHJvdmlkZXIuX2NvbnRleHQgPSB0YXJnZXQ7XG4gIHRhcmdldC5Db25zdW1lci5fY29udGV4dCA9IHRhcmdldDtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgU3ByaW5nUmVmID0gKCkgPT4ge1xuICBjb25zdCBjdXJyZW50ID0gW107XG5cbiAgY29uc3QgU3ByaW5nUmVmID0gZnVuY3Rpb24gU3ByaW5nUmVmKHByb3BzKSB7XG4gICAgc2hhcmVkLmRlcHJlY2F0ZURpcmVjdENhbGwoKTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgc2hhcmVkLmVhY2goY3VycmVudCwgKGN0cmwsIGkpID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaXMudW5kKHByb3BzKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IF9nZXRQcm9wcyhwcm9wcywgY3RybCwgaSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjdHJsLnN0YXJ0KHVwZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgU3ByaW5nUmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuXG4gIFNwcmluZ1JlZi5hZGQgPSBmdW5jdGlvbiAoY3RybCkge1xuICAgIGlmICghY3VycmVudC5pbmNsdWRlcyhjdHJsKSkge1xuICAgICAgY3VycmVudC5wdXNoKGN0cmwpO1xuICAgIH1cbiAgfTtcblxuICBTcHJpbmdSZWYuZGVsZXRlID0gZnVuY3Rpb24gKGN0cmwpIHtcbiAgICBjb25zdCBpID0gY3VycmVudC5pbmRleE9mKGN0cmwpO1xuICAgIGlmICh+aSkgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gIH07XG5cbiAgU3ByaW5nUmVmLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5wYXVzZSguLi5hcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBTcHJpbmdSZWYucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5yZXN1bWUoLi4uYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3ByaW5nUmVmLnNldCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCBjdHJsID0+IGN0cmwuc2V0KHZhbHVlcykpO1xuICB9O1xuXG4gIFNwcmluZ1JlZi5zdGFydCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCAoY3RybCwgaSkgPT4ge1xuICAgICAgaWYgKHNoYXJlZC5pcy51bmQocHJvcHMpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChjdHJsLnN0YXJ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5fZ2V0UHJvcHMocHJvcHMsIGN0cmwsIGkpO1xuXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCh1cGRhdGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIFNwcmluZ1JlZi5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZC5lYWNoKGN1cnJlbnQsIGN0cmwgPT4gY3RybC5zdG9wKC4uLmFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNwcmluZ1JlZi51cGRhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBzaGFyZWQuZWFjaChjdXJyZW50LCAoY3RybCwgaSkgPT4gY3RybC51cGRhdGUodGhpcy5fZ2V0UHJvcHMocHJvcHMsIGN0cmwsIGkpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgY29uc3QgX2dldFByb3BzID0gZnVuY3Rpb24gX2dldFByb3BzKGFyZywgY3RybCwgaW5kZXgpIHtcbiAgICByZXR1cm4gc2hhcmVkLmlzLmZ1bihhcmcpID8gYXJnKGluZGV4LCBjdHJsKSA6IGFyZztcbiAgfTtcblxuICBTcHJpbmdSZWYuX2dldFByb3BzID0gX2dldFByb3BzO1xuICByZXR1cm4gU3ByaW5nUmVmO1xufTtcblxuZnVuY3Rpb24gdXNlU3ByaW5ncyhsZW5ndGgsIHByb3BzLCBkZXBzKSB7XG4gIGNvbnN0IHByb3BzRm4gPSBzaGFyZWQuaXMuZnVuKHByb3BzKSAmJiBwcm9wcztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpIGRlcHMgPSBbXTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlTWVtbygoKSA9PiBwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IFNwcmluZ1JlZigpIDogdm9pZCAwLCBbXSk7XG4gIGNvbnN0IGxheW91dElkID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHNoYXJlZC51c2VGb3JjZVVwZGF0ZSgpO1xuICBjb25zdCBzdGF0ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBjdHJsczogW10sXG4gICAgcXVldWU6IFtdLFxuXG4gICAgZmx1c2goY3RybCwgdXBkYXRlcykge1xuICAgICAgY29uc3Qgc3ByaW5ncyA9IGdldFNwcmluZ3MoY3RybCwgdXBkYXRlcyk7XG4gICAgICBjb25zdCBjYW5GbHVzaFN5bmMgPSBsYXlvdXRJZC5jdXJyZW50ID4gMCAmJiAhc3RhdGUucXVldWUubGVuZ3RoICYmICFPYmplY3Qua2V5cyhzcHJpbmdzKS5zb21lKGtleSA9PiAhY3RybC5zcHJpbmdzW2tleV0pO1xuICAgICAgcmV0dXJuIGNhbkZsdXNoU3luYyA/IGZsdXNoVXBkYXRlUXVldWUoY3RybCwgdXBkYXRlcykgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0U3ByaW5ncyhjdHJsLCBzcHJpbmdzKTtcbiAgICAgICAgc3RhdGUucXVldWUucHVzaCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHVwZGF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfSksIFtdKTtcbiAgY29uc3QgY3RybHMgPSBSZWFjdC51c2VSZWYoWy4uLnN0YXRlLmN0cmxzXSk7XG4gIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgY29uc3QgcHJldkxlbmd0aCA9IHNoYXJlZC51c2VQcmV2KGxlbmd0aCkgfHwgMDtcbiAgUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goY3RybHMuY3VycmVudC5zbGljZShsZW5ndGgsIHByZXZMZW5ndGgpLCBjdHJsID0+IHtcbiAgICAgIGRldGFjaFJlZnMoY3RybCwgcmVmKTtcbiAgICAgIGN0cmwuc3RvcCh0cnVlKTtcbiAgICB9KTtcbiAgICBjdHJscy5jdXJyZW50Lmxlbmd0aCA9IGxlbmd0aDtcbiAgICBkZWNsYXJlVXBkYXRlcyhwcmV2TGVuZ3RoLCBsZW5ndGgpO1xuICB9LCBbbGVuZ3RoXSk7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGRlY2xhcmVVcGRhdGVzKDAsIE1hdGgubWluKHByZXZMZW5ndGgsIGxlbmd0aCkpO1xuICB9LCBkZXBzKTtcblxuICBmdW5jdGlvbiBkZWNsYXJlVXBkYXRlcyhzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgY3RybCA9IGN0cmxzLmN1cnJlbnRbaV0gfHwgKGN0cmxzLmN1cnJlbnRbaV0gPSBuZXcgQ29udHJvbGxlcihudWxsLCBzdGF0ZS5mbHVzaCkpO1xuICAgICAgY29uc3QgdXBkYXRlID0gcHJvcHNGbiA/IHByb3BzRm4oaSwgY3RybCkgOiBwcm9wc1tpXTtcblxuICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVzW2ldID0gZGVjbGFyZVVwZGF0ZSh1cGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNwcmluZ3MgPSBjdHJscy5jdXJyZW50Lm1hcCgoY3RybCwgaSkgPT4gZ2V0U3ByaW5ncyhjdHJsLCB1cGRhdGVzW2ldKSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFNwcmluZ0NvbnRleHQpO1xuICBjb25zdCBwcmV2Q29udGV4dCA9IHNoYXJlZC51c2VQcmV2KGNvbnRleHQpO1xuICBjb25zdCBoYXNDb250ZXh0ID0gY29udGV4dCAhPT0gcHJldkNvbnRleHQgJiYgaGFzUHJvcHMoY29udGV4dCk7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBsYXlvdXRJZC5jdXJyZW50Kys7XG4gICAgc3RhdGUuY3RybHMgPSBjdHJscy5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXVlXG4gICAgfSA9IHN0YXRlO1xuXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgc3RhdGUucXVldWUgPSBbXTtcbiAgICAgIHNoYXJlZC5lYWNoKHF1ZXVlLCBjYiA9PiBjYigpKTtcbiAgICB9XG5cbiAgICBzaGFyZWQuZWFjaChjdHJscy5jdXJyZW50LCAoY3RybCwgaSkgPT4ge1xuICAgICAgcmVmID09IG51bGwgPyB2b2lkIDAgOiByZWYuYWRkKGN0cmwpO1xuXG4gICAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuXG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHJlcGxhY2VSZWYoY3RybCwgdXBkYXRlLnJlZik7XG5cbiAgICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgICAgY3RybC5xdWV1ZS5wdXNoKHVwZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3RybC5zdGFydCh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBzaGFyZWQudXNlT25jZSgoKSA9PiAoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goc3RhdGUuY3RybHMsIGN0cmwgPT4gY3RybC5zdG9wKHRydWUpKTtcbiAgfSk7XG4gIGNvbnN0IHZhbHVlcyA9IHNwcmluZ3MubWFwKHggPT4gX2V4dGVuZHMoe30sIHgpKTtcbiAgcmV0dXJuIHJlZiA/IFt2YWx1ZXMsIHJlZl0gOiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIHVzZVNwcmluZyhwcm9wcywgZGVwcykge1xuICBjb25zdCBpc0ZuID0gc2hhcmVkLmlzLmZ1bihwcm9wcyk7XG4gIGNvbnN0IFtbdmFsdWVzXSwgcmVmXSA9IHVzZVNwcmluZ3MoMSwgaXNGbiA/IHByb3BzIDogW3Byb3BzXSwgaXNGbiA/IGRlcHMgfHwgW10gOiBkZXBzKTtcbiAgcmV0dXJuIGlzRm4gfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAyID8gW3ZhbHVlcywgcmVmXSA6IHZhbHVlcztcbn1cblxuY29uc3QgaW5pdFNwcmluZ1JlZiA9ICgpID0+IFNwcmluZ1JlZigpO1xuXG5jb25zdCB1c2VTcHJpbmdSZWYgPSAoKSA9PiBSZWFjdC51c2VTdGF0ZShpbml0U3ByaW5nUmVmKVswXTtcblxuY29uc3QgdXNlU3ByaW5nVmFsdWUgPSAoaW5pdGlhbCwgcHJvcHMpID0+IHtcbiAgY29uc3Qgc3ByaW5nVmFsdWUgPSBzaGFyZWQudXNlQ29uc3RhbnQoKCkgPT4gbmV3IFNwcmluZ1ZhbHVlKGluaXRpYWwsIHByb3BzKSk7XG4gIHNoYXJlZC51c2VPbmNlKCgpID0+ICgpID0+IHtcbiAgICBzcHJpbmdWYWx1ZS5zdG9wKCk7XG4gIH0pO1xuICByZXR1cm4gc3ByaW5nVmFsdWU7XG59O1xuXG5mdW5jdGlvbiB1c2VUcmFpbChsZW5ndGgsIHByb3BzQXJnLCBkZXBzKSB7XG4gIGNvbnN0IHByb3BzRm4gPSBzaGFyZWQuaXMuZnVuKHByb3BzQXJnKSAmJiBwcm9wc0FyZztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpIGRlcHMgPSBbXTtcbiAgbGV0IHJldmVyc2UgPSB0cnVlO1xuICBsZXQgcGFzc2VkUmVmID0gdW5kZWZpbmVkO1xuICBjb25zdCByZXN1bHQgPSB1c2VTcHJpbmdzKGxlbmd0aCwgKGksIGN0cmwpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IHByb3BzRm4gPyBwcm9wc0ZuKGksIGN0cmwpIDogcHJvcHNBcmc7XG4gICAgcGFzc2VkUmVmID0gcHJvcHMucmVmO1xuICAgIHJldmVyc2UgPSByZXZlcnNlICYmIHByb3BzLnJldmVyc2U7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBkZXBzIHx8IFt7fV0pO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2gocmVzdWx0WzFdLmN1cnJlbnQsIChjdHJsLCBpKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSByZXN1bHRbMV0uY3VycmVudFtpICsgKHJldmVyc2UgPyAxIDogLTEpXTtcbiAgICAgIHJlcGxhY2VSZWYoY3RybCwgcGFzc2VkUmVmKTtcblxuICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBjdHJsLnVwZGF0ZSh7XG4gICAgICAgICAgICB0bzogcGFyZW50LnNwcmluZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICB0bzogcGFyZW50LnNwcmluZ3NcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGRlcHMpO1xuXG4gIGlmIChwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMykge1xuICAgIHZhciBfcGFzc2VkUmVmO1xuXG4gICAgY29uc3QgcmVmID0gKF9wYXNzZWRSZWYgPSBwYXNzZWRSZWYpICE9IG51bGwgPyBfcGFzc2VkUmVmIDogcmVzdWx0WzFdO1xuXG4gICAgcmVmWydfZ2V0UHJvcHMnXSA9IChwcm9wc0FyZywgY3RybCwgaSkgPT4ge1xuICAgICAgY29uc3QgcHJvcHMgPSBzaGFyZWQuaXMuZnVuKHByb3BzQXJnKSA/IHByb3BzQXJnKGksIGN0cmwpIDogcHJvcHNBcmc7XG5cbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSByZWYuY3VycmVudFtpICsgKHByb3BzLnJldmVyc2UgPyAxIDogLTEpXTtcbiAgICAgICAgaWYgKHBhcmVudCkgcHJvcHMudG8gPSBwYXJlbnQuc3ByaW5ncztcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFswXTtcbn1cblxubGV0IFRyYW5zaXRpb25QaGFzZTtcblxuKGZ1bmN0aW9uIChUcmFuc2l0aW9uUGhhc2UpIHtcbiAgVHJhbnNpdGlvblBoYXNlW1wiTU9VTlRcIl0gPSBcIm1vdW50XCI7XG4gIFRyYW5zaXRpb25QaGFzZVtcIkVOVEVSXCJdID0gXCJlbnRlclwiO1xuICBUcmFuc2l0aW9uUGhhc2VbXCJVUERBVEVcIl0gPSBcInVwZGF0ZVwiO1xuICBUcmFuc2l0aW9uUGhhc2VbXCJMRUFWRVwiXSA9IFwibGVhdmVcIjtcbn0pKFRyYW5zaXRpb25QaGFzZSB8fCAoVHJhbnNpdGlvblBoYXNlID0ge30pKTtcblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbihkYXRhLCBwcm9wcywgZGVwcykge1xuICBjb25zdCBwcm9wc0ZuID0gc2hhcmVkLmlzLmZ1bihwcm9wcykgJiYgcHJvcHM7XG4gIGNvbnN0IHtcbiAgICByZXNldCxcbiAgICBzb3J0LFxuICAgIHRyYWlsID0gMCxcbiAgICBleHBpcmVzID0gdHJ1ZSxcbiAgICBleGl0QmVmb3JlRW50ZXIgPSBmYWxzZSxcbiAgICBvbkRlc3Ryb3llZCxcbiAgICByZWY6IHByb3BzUmVmLFxuICAgIGNvbmZpZzogcHJvcHNDb25maWdcbiAgfSA9IHByb3BzRm4gPyBwcm9wc0ZuKCkgOiBwcm9wcztcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlTWVtbygoKSA9PiBwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IFNwcmluZ1JlZigpIDogdm9pZCAwLCBbXSk7XG4gIGNvbnN0IGl0ZW1zID0gc2hhcmVkLnRvQXJyYXkoZGF0YSk7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gW107XG4gIGNvbnN0IHVzZWRUcmFuc2l0aW9ucyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldlRyYW5zaXRpb25zID0gcmVzZXQgPyBudWxsIDogdXNlZFRyYW5zaXRpb25zLmN1cnJlbnQ7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB1c2VkVHJhbnNpdGlvbnMuY3VycmVudCA9IHRyYW5zaXRpb25zO1xuICB9KTtcbiAgc2hhcmVkLnVzZU9uY2UoKCkgPT4ge1xuICAgIHNoYXJlZC5lYWNoKHRyYW5zaXRpb25zLCB0ID0+IHtcbiAgICAgIHJlZiA9PSBudWxsID8gdm9pZCAwIDogcmVmLmFkZCh0LmN0cmwpO1xuICAgICAgdC5jdHJsLnJlZiA9IHJlZjtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2hhcmVkLmVhY2godXNlZFRyYW5zaXRpb25zLmN1cnJlbnQsIHQgPT4ge1xuICAgICAgICBpZiAodC5leHBpcmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHQuZXhwaXJhdGlvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFjaFJlZnModC5jdHJsLCByZWYpO1xuICAgICAgICB0LmN0cmwuc3RvcCh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xuICBjb25zdCBrZXlzID0gZ2V0S2V5cyhpdGVtcywgcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzLCBwcmV2VHJhbnNpdGlvbnMpO1xuICBjb25zdCBleHBpcmVkID0gcmVzZXQgJiYgdXNlZFRyYW5zaXRpb25zLmN1cnJlbnQgfHwgW107XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHNoYXJlZC5lYWNoKGV4cGlyZWQsICh7XG4gICAgY3RybCxcbiAgICBpdGVtLFxuICAgIGtleVxuICB9KSA9PiB7XG4gICAgZGV0YWNoUmVmcyhjdHJsLCByZWYpO1xuICAgIGNhbGxQcm9wKG9uRGVzdHJveWVkLCBpdGVtLCBrZXkpO1xuICB9KSk7XG4gIGNvbnN0IHJldXNlZCA9IFtdO1xuICBpZiAocHJldlRyYW5zaXRpb25zKSBzaGFyZWQuZWFjaChwcmV2VHJhbnNpdGlvbnMsICh0LCBpKSA9PiB7XG4gICAgaWYgKHQuZXhwaXJlZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHQuZXhwaXJhdGlvbklkKTtcbiAgICAgIGV4cGlyZWQucHVzaCh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IHJldXNlZFtpXSA9IGtleXMuaW5kZXhPZih0LmtleSk7XG4gICAgICBpZiAofmkpIHRyYW5zaXRpb25zW2ldID0gdDtcbiAgICB9XG4gIH0pO1xuICBzaGFyZWQuZWFjaChpdGVtcywgKGl0ZW0sIGkpID0+IHtcbiAgICBpZiAoIXRyYW5zaXRpb25zW2ldKSB7XG4gICAgICB0cmFuc2l0aW9uc1tpXSA9IHtcbiAgICAgICAga2V5OiBrZXlzW2ldLFxuICAgICAgICBpdGVtLFxuICAgICAgICBwaGFzZTogVHJhbnNpdGlvblBoYXNlLk1PVU5ULFxuICAgICAgICBjdHJsOiBuZXcgQ29udHJvbGxlcigpXG4gICAgICB9O1xuICAgICAgdHJhbnNpdGlvbnNbaV0uY3RybC5pdGVtID0gaXRlbTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChyZXVzZWQubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBjb25zdCB7XG4gICAgICBsZWF2ZVxuICAgIH0gPSBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHM7XG4gICAgc2hhcmVkLmVhY2gocmV1c2VkLCAoa2V5SW5kZXgsIHByZXZJbmRleCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHByZXZUcmFuc2l0aW9uc1twcmV2SW5kZXhdO1xuXG4gICAgICBpZiAofmtleUluZGV4KSB7XG4gICAgICAgIGkgPSB0cmFuc2l0aW9ucy5pbmRleE9mKHQpO1xuICAgICAgICB0cmFuc2l0aW9uc1tpXSA9IF9leHRlbmRzKHt9LCB0LCB7XG4gICAgICAgICAgaXRlbTogaXRlbXNba2V5SW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChsZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoKytpLCAwLCB0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzaGFyZWQuaXMuZnVuKHNvcnQpKSB7XG4gICAgdHJhbnNpdGlvbnMuc29ydCgoYSwgYikgPT4gc29ydChhLml0ZW0sIGIuaXRlbSkpO1xuICB9XG5cbiAgbGV0IGRlbGF5ID0gLXRyYWlsO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHNoYXJlZC51c2VGb3JjZVVwZGF0ZSgpO1xuICBjb25zdCBkZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gbmV3IE1hcCgpO1xuICBjb25zdCBleGl0aW5nVHJhbnNpdGlvbnMgPSBSZWFjdC51c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgZm9yY2VDaGFuZ2UgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBzaGFyZWQuZWFjaCh0cmFuc2l0aW9ucywgKHQsIGkpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0LmtleTtcbiAgICBjb25zdCBwcmV2UGhhc2UgPSB0LnBoYXNlO1xuICAgIGNvbnN0IHAgPSBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHM7XG4gICAgbGV0IHRvO1xuICAgIGxldCBwaGFzZTtcbiAgICBsZXQgcHJvcHNEZWxheSA9IGNhbGxQcm9wKHAuZGVsYXkgfHwgMCwga2V5KTtcblxuICAgIGlmIChwcmV2UGhhc2UgPT0gVHJhbnNpdGlvblBoYXNlLk1PVU5UKSB7XG4gICAgICB0byA9IHAuZW50ZXI7XG4gICAgICBwaGFzZSA9IFRyYW5zaXRpb25QaGFzZS5FTlRFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGtleXMuaW5kZXhPZihrZXkpIDwgMDtcblxuICAgICAgaWYgKHByZXZQaGFzZSAhPSBUcmFuc2l0aW9uUGhhc2UuTEVBVkUpIHtcbiAgICAgICAgaWYgKGlzTGVhdmUpIHtcbiAgICAgICAgICB0byA9IHAubGVhdmU7XG4gICAgICAgICAgcGhhc2UgPSBUcmFuc2l0aW9uUGhhc2UuTEVBVkU7XG4gICAgICAgIH0gZWxzZSBpZiAodG8gPSBwLnVwZGF0ZSkge1xuICAgICAgICAgIHBoYXNlID0gVHJhbnNpdGlvblBoYXNlLlVQREFURTtcbiAgICAgICAgfSBlbHNlIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgdG8gPSBwLmVudGVyO1xuICAgICAgICBwaGFzZSA9IFRyYW5zaXRpb25QaGFzZS5FTlRFUjtcbiAgICAgIH0gZWxzZSByZXR1cm47XG4gICAgfVxuXG4gICAgdG8gPSBjYWxsUHJvcCh0bywgdC5pdGVtLCBpKTtcbiAgICB0byA9IHNoYXJlZC5pcy5vYmoodG8pID8gaW5mZXJUbyh0bykgOiB7XG4gICAgICB0b1xuICAgIH07XG5cbiAgICBpZiAoIXRvLmNvbmZpZykge1xuICAgICAgY29uc3QgY29uZmlnID0gcHJvcHNDb25maWcgfHwgZGVmYXVsdFByb3BzLmNvbmZpZztcbiAgICAgIHRvLmNvbmZpZyA9IGNhbGxQcm9wKGNvbmZpZywgdC5pdGVtLCBpLCBwaGFzZSk7XG4gICAgfVxuXG4gICAgZGVsYXkgKz0gdHJhaWw7XG5cbiAgICBjb25zdCBwYXlsb2FkID0gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywge1xuICAgICAgZGVsYXk6IHByb3BzRGVsYXkgKyBkZWxheSxcbiAgICAgIHJlZjogcHJvcHNSZWYsXG4gICAgICBpbW1lZGlhdGU6IHAuaW1tZWRpYXRlLFxuICAgICAgcmVzZXQ6IGZhbHNlXG4gICAgfSwgdG8pO1xuXG4gICAgaWYgKHBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5FTlRFUiAmJiBzaGFyZWQuaXMudW5kKHBheWxvYWQuZnJvbSkpIHtcbiAgICAgIGNvbnN0IF9wID0gcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzO1xuXG4gICAgICBjb25zdCBmcm9tID0gc2hhcmVkLmlzLnVuZChfcC5pbml0aWFsKSB8fCBwcmV2VHJhbnNpdGlvbnMgPyBfcC5mcm9tIDogX3AuaW5pdGlhbDtcbiAgICAgIHBheWxvYWQuZnJvbSA9IGNhbGxQcm9wKGZyb20sIHQuaXRlbSwgaSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgb25SZXNvbHZlXG4gICAgfSA9IHBheWxvYWQ7XG5cbiAgICBwYXlsb2FkLm9uUmVzb2x2ZSA9IHJlc3VsdCA9PiB7XG4gICAgICBjYWxsUHJvcChvblJlc29sdmUsIHJlc3VsdCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHVzZWRUcmFuc2l0aW9ucy5jdXJyZW50O1xuICAgICAgY29uc3QgdCA9IHRyYW5zaXRpb25zLmZpbmQodCA9PiB0LmtleSA9PT0ga2V5KTtcbiAgICAgIGlmICghdCkgcmV0dXJuO1xuXG4gICAgICBpZiAocmVzdWx0LmNhbmNlbGxlZCAmJiB0LnBoYXNlICE9IFRyYW5zaXRpb25QaGFzZS5VUERBVEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodC5jdHJsLmlkbGUpIHtcbiAgICAgICAgY29uc3QgaWRsZSA9IHRyYW5zaXRpb25zLmV2ZXJ5KHQgPT4gdC5jdHJsLmlkbGUpO1xuXG4gICAgICAgIGlmICh0LnBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5MRUFWRSkge1xuICAgICAgICAgIGNvbnN0IGV4cGlyeSA9IGNhbGxQcm9wKGV4cGlyZXMsIHQuaXRlbSk7XG5cbiAgICAgICAgICBpZiAoZXhwaXJ5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwaXJ5TXMgPSBleHBpcnkgPT09IHRydWUgPyAwIDogZXhwaXJ5O1xuICAgICAgICAgICAgdC5leHBpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFpZGxlICYmIGV4cGlyeU1zID4gMCkge1xuICAgICAgICAgICAgICBpZiAoZXhwaXJ5TXMgPD0gMHg3ZmZmZmZmZikgdC5leHBpcmF0aW9uSWQgPSBzZXRUaW1lb3V0KGZvcmNlVXBkYXRlLCBleHBpcnlNcyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRsZSAmJiB0cmFuc2l0aW9ucy5zb21lKHQgPT4gdC5leHBpcmVkKSkge1xuICAgICAgICAgIGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50LmRlbGV0ZSh0KTtcblxuICAgICAgICAgIGlmIChleGl0QmVmb3JlRW50ZXIpIHtcbiAgICAgICAgICAgIGZvcmNlQ2hhbmdlLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3ByaW5ncyA9IGdldFNwcmluZ3ModC5jdHJsLCBwYXlsb2FkKTtcblxuICAgIGlmIChwaGFzZSA9PT0gVHJhbnNpdGlvblBoYXNlLkxFQVZFICYmIGV4aXRCZWZvcmVFbnRlcikge1xuICAgICAgZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2V0KHQsIHtcbiAgICAgICAgcGhhc2UsXG4gICAgICAgIHNwcmluZ3MsXG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VzLnNldCh0LCB7XG4gICAgICAgIHBoYXNlLFxuICAgICAgICBzcHJpbmdzLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTcHJpbmdDb250ZXh0KTtcbiAgY29uc3QgcHJldkNvbnRleHQgPSBzaGFyZWQudXNlUHJldihjb250ZXh0KTtcbiAgY29uc3QgaGFzQ29udGV4dCA9IGNvbnRleHQgIT09IHByZXZDb250ZXh0ICYmIGhhc1Byb3BzKGNvbnRleHQpO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIHNoYXJlZC5lYWNoKHRyYW5zaXRpb25zLCB0ID0+IHtcbiAgICAgICAgdC5jdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY29udGV4dF0pO1xuICBzaGFyZWQuZWFjaChjaGFuZ2VzLCAoXywgdCkgPT4ge1xuICAgIGlmIChleGl0aW5nVHJhbnNpdGlvbnMuY3VycmVudC5zaXplKSB7XG4gICAgICBjb25zdCBpbmQgPSB0cmFuc2l0aW9ucy5maW5kSW5kZXgoc3RhdGUgPT4gc3RhdGUua2V5ID09PSB0LmtleSk7XG4gICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoaW5kLCAxKTtcbiAgICB9XG4gIH0pO1xuICBzaGFyZWQudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2hhcmVkLmVhY2goZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2l6ZSA/IGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50IDogY2hhbmdlcywgKHtcbiAgICAgIHBoYXNlLFxuICAgICAgcGF5bG9hZFxuICAgIH0sIHQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3RybFxuICAgICAgfSA9IHQ7XG4gICAgICB0LnBoYXNlID0gcGhhc2U7XG4gICAgICByZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5hZGQoY3RybCk7XG5cbiAgICAgIGlmIChoYXNDb250ZXh0ICYmIHBoYXNlID09IFRyYW5zaXRpb25QaGFzZS5FTlRFUikge1xuICAgICAgICBjdHJsLnN0YXJ0KHtcbiAgICAgICAgICBkZWZhdWx0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICByZXBsYWNlUmVmKGN0cmwsIHBheWxvYWQucmVmKTtcblxuICAgICAgICBpZiAoKGN0cmwucmVmIHx8IHJlZikgJiYgIWZvcmNlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICBjdHJsLnVwZGF0ZShwYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHJsLnN0YXJ0KHBheWxvYWQpO1xuXG4gICAgICAgICAgaWYgKGZvcmNlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZvcmNlQ2hhbmdlLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgcmVzZXQgPyB2b2lkIDAgOiBkZXBzKTtcblxuICBjb25zdCByZW5kZXJUcmFuc2l0aW9ucyA9IHJlbmRlciA9PiBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgdHJhbnNpdGlvbnMubWFwKCh0LCBpKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc3ByaW5nc1xuICAgIH0gPSBjaGFuZ2VzLmdldCh0KSB8fCB0LmN0cmw7XG4gICAgY29uc3QgZWxlbSA9IHJlbmRlcihfZXh0ZW5kcyh7fSwgc3ByaW5ncyksIHQuaXRlbSwgdCwgaSk7XG4gICAgcmV0dXJuIGVsZW0gJiYgZWxlbS50eXBlID8gUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KGVsZW0udHlwZSwgX2V4dGVuZHMoe30sIGVsZW0ucHJvcHMsIHtcbiAgICAgIGtleTogc2hhcmVkLmlzLnN0cih0LmtleSkgfHwgc2hhcmVkLmlzLm51bSh0LmtleSkgPyB0LmtleSA6IHQuY3RybC5pZCxcbiAgICAgIHJlZjogZWxlbS5yZWZcbiAgICB9KSkgOiBlbGVtO1xuICB9KSk7XG5cbiAgcmV0dXJuIHJlZiA/IFtyZW5kZXJUcmFuc2l0aW9ucywgcmVmXSA6IHJlbmRlclRyYW5zaXRpb25zO1xufVxubGV0IG5leHRLZXkgPSAxO1xuXG5mdW5jdGlvbiBnZXRLZXlzKGl0ZW1zLCB7XG4gIGtleSxcbiAga2V5cyA9IGtleVxufSwgcHJldlRyYW5zaXRpb25zKSB7XG4gIGlmIChrZXlzID09PSBudWxsKSB7XG4gICAgY29uc3QgcmV1c2VkID0gbmV3IFNldCgpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB7XG4gICAgICBjb25zdCB0ID0gcHJldlRyYW5zaXRpb25zICYmIHByZXZUcmFuc2l0aW9ucy5maW5kKHQgPT4gdC5pdGVtID09PSBpdGVtICYmIHQucGhhc2UgIT09IFRyYW5zaXRpb25QaGFzZS5MRUFWRSAmJiAhcmV1c2VkLmhhcyh0KSk7XG5cbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHJldXNlZC5hZGQodCk7XG4gICAgICAgIHJldHVybiB0LmtleTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5leHRLZXkrKztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaGFyZWQuaXMudW5kKGtleXMpID8gaXRlbXMgOiBzaGFyZWQuaXMuZnVuKGtleXMpID8gaXRlbXMubWFwKGtleXMpIDogc2hhcmVkLnRvQXJyYXkoa2V5cyk7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQ1ID0gW1wiY29udGFpbmVyXCJdO1xuY29uc3QgdXNlU2Nyb2xsID0gKF9yZWYgPSB7fSkgPT4ge1xuICBsZXQge1xuICAgIGNvbnRhaW5lclxuICB9ID0gX3JlZixcbiAgICAgIHNwcmluZ09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQkNSk7XG5cbiAgY29uc3QgW3Njcm9sbFZhbHVlcywgYXBpXSA9IHVzZVNwcmluZygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgc2Nyb2xsWDogMCxcbiAgICBzY3JvbGxZOiAwLFxuICAgIHNjcm9sbFhQcm9ncmVzczogMCxcbiAgICBzY3JvbGxZUHJvZ3Jlc3M6IDBcbiAgfSwgc3ByaW5nT3B0aW9ucyksIFtdKTtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBTY3JvbGwgPSBzaGFyZWQub25TY3JvbGwoKHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSkgPT4ge1xuICAgICAgYXBpLnN0YXJ0KHtcbiAgICAgICAgc2Nyb2xsWDogeC5jdXJyZW50LFxuICAgICAgICBzY3JvbGxYUHJvZ3Jlc3M6IHgucHJvZ3Jlc3MsXG4gICAgICAgIHNjcm9sbFk6IHkuY3VycmVudCxcbiAgICAgICAgc2Nyb2xsWVByb2dyZXNzOiB5LnByb2dyZXNzXG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBjb250YWluZXI6IChjb250YWluZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRhaW5lci5jdXJyZW50KSB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2hhcmVkLmVhY2goT2JqZWN0LnZhbHVlcyhzY3JvbGxWYWx1ZXMpLCB2YWx1ZSA9PiB2YWx1ZS5zdG9wKCkpO1xuICAgICAgY2xlYW51cFNjcm9sbCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNjcm9sbFZhbHVlcztcbn07XG5cbmNvbnN0IF9leGNsdWRlZCQ0ID0gW1wiY29udGFpbmVyXCJdO1xuY29uc3QgdXNlUmVzaXplID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29udGFpbmVyXG4gIH0gPSBfcmVmLFxuICAgICAgc3ByaW5nT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQ0KTtcblxuICBjb25zdCBbc2l6ZVZhbHVlcywgYXBpXSA9IHVzZVNwcmluZygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH0sIHNwcmluZ09wdGlvbnMpLCBbXSk7XG4gIHNoYXJlZC51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwU2Nyb2xsID0gc2hhcmVkLm9uUmVzaXplKCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0pID0+IHtcbiAgICAgIGFwaS5zdGFydCh7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGltbWVkaWF0ZTogc2l6ZVZhbHVlcy53aWR0aC5nZXQoKSA9PT0gMCB8fCBzaXplVmFsdWVzLmhlaWdodC5nZXQoKSA9PT0gMFxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgY29udGFpbmVyOiAoY29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNoYXJlZC5lYWNoKE9iamVjdC52YWx1ZXMoc2l6ZVZhbHVlcyksIHZhbHVlID0+IHZhbHVlLnN0b3AoKSk7XG4gICAgICBjbGVhbnVwU2Nyb2xsKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gc2l6ZVZhbHVlcztcbn07XG5cbmNvbnN0IF9leGNsdWRlZCQzID0gW1widG9cIiwgXCJmcm9tXCJdLFxuICAgICAgX2V4Y2x1ZGVkMiA9IFtcInJvb3RcIiwgXCJvbmNlXCIsIFwiYW1vdW50XCJdO1xuY29uc3QgZGVmYXVsdFRocmVzaG9sZE9wdGlvbnMgPSB7XG4gIGFueTogMCxcbiAgYWxsOiAxXG59O1xuZnVuY3Rpb24gdXNlSW5WaWV3KHByb3BzLCBhcmdzKSB7XG4gIGNvbnN0IFtpc0luVmlldywgc2V0SXNJblZpZXddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgcHJvcHNGbiA9IHNoYXJlZC5pcy5mdW4ocHJvcHMpICYmIHByb3BzO1xuICBjb25zdCBzcHJpbmdzUHJvcHMgPSBwcm9wc0ZuID8gcHJvcHNGbigpIDoge307XG5cbiAgY29uc3Qge1xuICAgIHRvID0ge30sXG4gICAgZnJvbSA9IHt9XG4gIH0gPSBzcHJpbmdzUHJvcHMsXG4gICAgICAgIHJlc3RTcHJpbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNwcmluZ3NQcm9wcywgX2V4Y2x1ZGVkJDMpO1xuXG4gIGNvbnN0IGludGVyc2VjdGlvbkFyZ3VtZW50cyA9IHByb3BzRm4gPyBhcmdzIDogcHJvcHM7XG4gIGNvbnN0IFtzcHJpbmdzLCBhcGldID0gdXNlU3ByaW5nKCgpID0+IF9leHRlbmRzKHtcbiAgICBmcm9tXG4gIH0sIHJlc3RTcHJpbmdQcm9wcyksIFtdKTtcbiAgc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcblxuICAgIGNvbnN0IF9yZWYgPSBpbnRlcnNlY3Rpb25Bcmd1bWVudHMgIT0gbnVsbCA/IGludGVyc2VjdGlvbkFyZ3VtZW50cyA6IHt9LFxuICAgICAgICAgIHtcbiAgICAgIHJvb3QsXG4gICAgICBvbmNlLFxuICAgICAgYW1vdW50ID0gJ2FueSdcbiAgICB9ID0gX3JlZixcbiAgICAgICAgICByZXN0QXJncyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZDIpO1xuXG4gICAgaWYgKCFlbGVtZW50IHx8IG9uY2UgJiYgaXNJblZpZXcgfHwgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgY29uc3Qgb25FbnRlciA9ICgpID0+IHtcbiAgICAgIGlmICh0bykge1xuICAgICAgICBhcGkuc3RhcnQodG8pO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0luVmlldyh0cnVlKTtcblxuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICBhcGkuc3RhcnQoZnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc0luVmlldyhmYWxzZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb25jZSA/IHVuZGVmaW5lZCA6IGNsZWFudXA7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUludGVyc2VjdGlvbiA9IGVudHJpZXMgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3Qgb25MZWF2ZSA9IGFjdGl2ZUludGVyc2VjdGlvbnMuZ2V0KGVudHJ5LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nID09PSBCb29sZWFuKG9uTGVhdmUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgY29uc3QgbmV3T25MZWF2ZSA9IG9uRW50ZXIoKTtcblxuICAgICAgICAgIGlmIChzaGFyZWQuaXMuZnVuKG5ld09uTGVhdmUpKSB7XG4gICAgICAgICAgICBhY3RpdmVJbnRlcnNlY3Rpb25zLnNldChlbnRyeS50YXJnZXQsIG5ld09uTGVhdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob25MZWF2ZSkge1xuICAgICAgICAgIG9uTGVhdmUoKTtcbiAgICAgICAgICBhY3RpdmVJbnRlcnNlY3Rpb25zLmRlbGV0ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlSW50ZXJzZWN0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICByb290OiByb290ICYmIHJvb3QuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInIHx8IEFycmF5LmlzQXJyYXkoYW1vdW50KSA/IGFtb3VudCA6IGRlZmF1bHRUaHJlc2hvbGRPcHRpb25zW2Ftb3VudF1cbiAgICB9LCByZXN0QXJncykpO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgfSwgW2ludGVyc2VjdGlvbkFyZ3VtZW50c10pO1xuXG4gIGlmIChwcm9wc0ZuKSB7XG4gICAgcmV0dXJuIFtyZWYsIHNwcmluZ3NdO1xuICB9XG5cbiAgcmV0dXJuIFtyZWYsIGlzSW5WaWV3XTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkJDIgPSBbXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFNwcmluZyhfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQyKTtcblxuICByZXR1cm4gY2hpbGRyZW4odXNlU3ByaW5nKHByb3BzKSk7XG59XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wiaXRlbXNcIiwgXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFRyYWlsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpdGVtcyxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJDEpO1xuXG4gIGNvbnN0IHRyYWlscyA9IHVzZVRyYWlsKGl0ZW1zLmxlbmd0aCwgcHJvcHMpO1xuICByZXR1cm4gaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkcmVuKGl0ZW0sIGluZGV4KTtcbiAgICByZXR1cm4gc2hhcmVkLmlzLmZ1bihyZXN1bHQpID8gcmVzdWx0KHRyYWlsc1tpbmRleF0pIDogcmVzdWx0O1xuICB9KTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wiaXRlbXNcIiwgXCJjaGlsZHJlblwiXTtcbmZ1bmN0aW9uIFRyYW5zaXRpb24oX3JlZikge1xuICBsZXQge1xuICAgIGl0ZW1zLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuXG4gIHJldHVybiB1c2VUcmFuc2l0aW9uKGl0ZW1zLCBwcm9wcykoY2hpbGRyZW4pO1xufVxuXG5jbGFzcyBJbnRlcnBvbGF0aW9uIGV4dGVuZHMgRnJhbWVWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pZGxlID0gdHJ1ZTtcbiAgICB0aGlzLmNhbGMgPSB2b2lkIDA7XG4gICAgdGhpcy5fYWN0aXZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuY2FsYyA9IHNoYXJlZC5jcmVhdGVJbnRlcnBvbGF0b3IoLi4uYXJncyk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2dldCgpO1xuXG4gICAgY29uc3Qgbm9kZVR5cGUgPSBhbmltYXRlZCQxLmdldEFuaW1hdGVkVHlwZSh2YWx1ZSk7XG4gICAgYW5pbWF0ZWQkMS5zZXRBbmltYXRlZCh0aGlzLCBub2RlVHlwZS5jcmVhdGUodmFsdWUpKTtcbiAgfVxuXG4gIGFkdmFuY2UoX2R0KSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9nZXQoKTtcblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoKTtcblxuICAgIGlmICghc2hhcmVkLmlzRXF1YWwodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgYW5pbWF0ZWQkMS5nZXRBbmltYXRlZCh0aGlzKS5zZXRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlKHZhbHVlLCB0aGlzLmlkbGUpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pZGxlICYmIGNoZWNrSWRsZSh0aGlzLl9hY3RpdmUpKSB7XG4gICAgICBiZWNvbWVJZGxlKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gc2hhcmVkLmlzLmFycih0aGlzLnNvdXJjZSkgPyB0aGlzLnNvdXJjZS5tYXAoc2hhcmVkLmdldEZsdWlkVmFsdWUpIDogc2hhcmVkLnRvQXJyYXkoc2hhcmVkLmdldEZsdWlkVmFsdWUodGhpcy5zb3VyY2UpKTtcbiAgICByZXR1cm4gdGhpcy5jYWxjKC4uLmlucHV0cyk7XG4gIH1cblxuICBfc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuaWRsZSAmJiAhY2hlY2tJZGxlKHRoaXMuX2FjdGl2ZSkpIHtcbiAgICAgIHRoaXMuaWRsZSA9IGZhbHNlO1xuICAgICAgc2hhcmVkLmVhY2goYW5pbWF0ZWQkMS5nZXRQYXlsb2FkKHRoaXMpLCBub2RlID0+IHtcbiAgICAgICAgbm9kZS5kb25lID0gZmFsc2U7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNoYXJlZC5HbG9iYWxzLnNraXBBbmltYXRpb24pIHtcbiAgICAgICAgc2hhcmVkLnJhZi5iYXRjaGVkVXBkYXRlcygoKSA9PiB0aGlzLmFkdmFuY2UoKSk7XG4gICAgICAgIGJlY29tZUlkbGUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFyZWQuZnJhbWVMb29wLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hdHRhY2goKSB7XG4gICAgbGV0IHByaW9yaXR5ID0gMTtcbiAgICBzaGFyZWQuZWFjaChzaGFyZWQudG9BcnJheSh0aGlzLnNvdXJjZSksIHNvdXJjZSA9PiB7XG4gICAgICBpZiAoc2hhcmVkLmhhc0ZsdWlkVmFsdWUoc291cmNlKSkge1xuICAgICAgICBzaGFyZWQuYWRkRmx1aWRPYnNlcnZlcihzb3VyY2UsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGcmFtZVZhbHVlKHNvdXJjZSkpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuaWRsZSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZS5hZGQoc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHksIHNvdXJjZS5wcmlvcml0eSArIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcblxuICAgIHRoaXMuX3N0YXJ0KCk7XG4gIH1cblxuICBfZGV0YWNoKCkge1xuICAgIHNoYXJlZC5lYWNoKHNoYXJlZC50b0FycmF5KHRoaXMuc291cmNlKSwgc291cmNlID0+IHtcbiAgICAgIGlmIChzaGFyZWQuaGFzRmx1aWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgICAgIHNoYXJlZC5yZW1vdmVGbHVpZE9ic2VydmVyKHNvdXJjZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9hY3RpdmUuY2xlYXIoKTtcblxuICAgIGJlY29tZUlkbGUodGhpcyk7XG4gIH1cblxuICBldmVudE9ic2VydmVkKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gJ2NoYW5nZScpIHtcbiAgICAgIGlmIChldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlLmFkZChldmVudC5wYXJlbnQpO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09ICdpZGxlJykge1xuICAgICAgdGhpcy5fYWN0aXZlLmRlbGV0ZShldmVudC5wYXJlbnQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSAncHJpb3JpdHknKSB7XG4gICAgICB0aGlzLnByaW9yaXR5ID0gc2hhcmVkLnRvQXJyYXkodGhpcy5zb3VyY2UpLnJlZHVjZSgoaGlnaGVzdCwgcGFyZW50KSA9PiBNYXRoLm1heChoaWdoZXN0LCAoaXNGcmFtZVZhbHVlKHBhcmVudCkgPyBwYXJlbnQucHJpb3JpdHkgOiAwKSArIDEpLCAwKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0lkbGUoc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UuaWRsZSAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRsZShhY3RpdmUpIHtcbiAgcmV0dXJuICFhY3RpdmUuc2l6ZSB8fCBBcnJheS5mcm9tKGFjdGl2ZSkuZXZlcnkoaXNJZGxlKTtcbn1cblxuZnVuY3Rpb24gYmVjb21lSWRsZShzZWxmKSB7XG4gIGlmICghc2VsZi5pZGxlKSB7XG4gICAgc2VsZi5pZGxlID0gdHJ1ZTtcbiAgICBzaGFyZWQuZWFjaChhbmltYXRlZCQxLmdldFBheWxvYWQoc2VsZiksIG5vZGUgPT4ge1xuICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzaGFyZWQuY2FsbEZsdWlkT2JzZXJ2ZXJzKHNlbGYsIHtcbiAgICAgIHR5cGU6ICdpZGxlJyxcbiAgICAgIHBhcmVudDogc2VsZlxuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IHRvID0gKHNvdXJjZSwgLi4uYXJncykgPT4gbmV3IEludGVycG9sYXRpb24oc291cmNlLCBhcmdzKTtcbmNvbnN0IGludGVycG9sYXRlID0gKHNvdXJjZSwgLi4uYXJncykgPT4gKHNoYXJlZC5kZXByZWNhdGVJbnRlcnBvbGF0ZSgpLCBuZXcgSW50ZXJwb2xhdGlvbihzb3VyY2UsIGFyZ3MpKTtcblxuc2hhcmVkLkdsb2JhbHMuYXNzaWduKHtcbiAgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yOiBzaGFyZWQuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yLFxuICB0bzogKHNvdXJjZSwgYXJncykgPT4gbmV3IEludGVycG9sYXRpb24oc291cmNlLCBhcmdzKVxufSk7XG5jb25zdCB1cGRhdGUgPSBzaGFyZWQuZnJhbWVMb29wLmFkdmFuY2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnR2xvYmFscycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuR2xvYmFsczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NyZWF0ZUludGVycG9sYXRvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuY3JlYXRlSW50ZXJwb2xhdG9yOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZWFzaW5ncycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWQuZWFzaW5nczsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkLnVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICd1c2VSZWR1Y2VkTW90aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYXJlZC51c2VSZWR1Y2VkTW90aW9uOyB9XG59KTtcbmV4cG9ydHMuQmFpbFNpZ25hbCA9IEJhaWxTaWduYWw7XG5leHBvcnRzLkNvbnRyb2xsZXIgPSBDb250cm9sbGVyO1xuZXhwb3J0cy5GcmFtZVZhbHVlID0gRnJhbWVWYWx1ZTtcbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XG5leHBvcnRzLlNwcmluZyA9IFNwcmluZztcbmV4cG9ydHMuU3ByaW5nQ29udGV4dCA9IFNwcmluZ0NvbnRleHQ7XG5leHBvcnRzLlNwcmluZ1JlZiA9IFNwcmluZ1JlZjtcbmV4cG9ydHMuU3ByaW5nVmFsdWUgPSBTcHJpbmdWYWx1ZTtcbmV4cG9ydHMuVHJhaWwgPSBUcmFpbDtcbmV4cG9ydHMuVHJhbnNpdGlvbiA9IFRyYW5zaXRpb247XG5leHBvcnRzLmNvbmZpZyA9IGNvbmZpZztcbmV4cG9ydHMuaW5mZXJUbyA9IGluZmVyVG87XG5leHBvcnRzLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5leHBvcnRzLnRvID0gdG87XG5leHBvcnRzLnVwZGF0ZSA9IHVwZGF0ZTtcbmV4cG9ydHMudXNlQ2hhaW4gPSB1c2VDaGFpbjtcbmV4cG9ydHMudXNlSW5WaWV3ID0gdXNlSW5WaWV3O1xuZXhwb3J0cy51c2VSZXNpemUgPSB1c2VSZXNpemU7XG5leHBvcnRzLnVzZVNjcm9sbCA9IHVzZVNjcm9sbDtcbmV4cG9ydHMudXNlU3ByaW5nID0gdXNlU3ByaW5nO1xuZXhwb3J0cy51c2VTcHJpbmdSZWYgPSB1c2VTcHJpbmdSZWY7XG5leHBvcnRzLnVzZVNwcmluZ1ZhbHVlID0gdXNlU3ByaW5nVmFsdWU7XG5leHBvcnRzLnVzZVNwcmluZ3MgPSB1c2VTcHJpbmdzO1xuZXhwb3J0cy51c2VUcmFpbCA9IHVzZVRyYWlsO1xuZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcbk9iamVjdC5rZXlzKGFuaW1hdGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFuaW1hdGVkW2tdOyB9XG4gIH0pO1xufSk7XG5PYmplY3Qua2V5cyhpbnRlcnBvbGF0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVycG9sYXRpb25ba107IH1cbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-core.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvY29yZS9kaXN0L3JlYWN0LXNwcmluZy1jb3JlLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsc0xBQTBEO0FBQzVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9jb3JlL2Rpc3QvcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLmpzPzIwY2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLWNvcmUuY2pzLnByb2QuanNcIik7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy1jb3JlLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar rafz = __webpack_require__(/*! @react-spring/rafz */ \"(ssr)/./node_modules/@react-spring/rafz/dist/react-spring-rafz.cjs.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction noop() {}\nconst defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {\n  value,\n  writable: true,\n  configurable: true\n});\nconst is = {\n  arr: Array.isArray,\n  obj: a => !!a && a.constructor.name === 'Object',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  und: a => a === undefined\n};\nfunction isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\nconst each = (obj, fn) => obj.forEach(fn);\nfunction eachProp(obj, fn, ctx) {\n  if (is.arr(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn.call(ctx, obj[i], `${i}`);\n    }\n\n    return;\n  }\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(ctx, obj[key], key);\n    }\n  }\n}\nconst toArray = a => is.und(a) ? [] : is.arr(a) ? a : [a];\nfunction flush(queue, iterator) {\n  if (queue.size) {\n    const items = Array.from(queue);\n    queue.clear();\n    each(items, iterator);\n  }\n}\nconst flushCalls = (queue, ...args) => flush(queue, fn => fn(...args));\nconst isSSR = () => typeof window === 'undefined' || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\n\nlet createStringInterpolator$1;\nlet to;\nlet colors$1 = null;\nlet skipAnimation = false;\nlet willAdvance = noop;\nconst assign = globals => {\n  if (globals.to) to = globals.to;\n  if (globals.now) rafz.raf.now = globals.now;\n  if (globals.colors !== undefined) colors$1 = globals.colors;\n  if (globals.skipAnimation != null) skipAnimation = globals.skipAnimation;\n  if (globals.createStringInterpolator) createStringInterpolator$1 = globals.createStringInterpolator;\n  if (globals.requestAnimationFrame) rafz.raf.use(globals.requestAnimationFrame);\n  if (globals.batchedUpdates) rafz.raf.batchedUpdates = globals.batchedUpdates;\n  if (globals.willAdvance) willAdvance = globals.willAdvance;\n  if (globals.frameLoop) rafz.raf.frameLoop = globals.frameLoop;\n};\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  get createStringInterpolator () { return createStringInterpolator$1; },\n  get to () { return to; },\n  get colors () { return colors$1; },\n  get skipAnimation () { return skipAnimation; },\n  get willAdvance () { return willAdvance; },\n  assign: assign\n});\n\nconst startQueue = new Set();\nlet currentFrame = [];\nlet prevFrame = [];\nlet priority = 0;\nconst frameLoop = {\n  get idle() {\n    return !startQueue.size && !currentFrame.length;\n  },\n\n  start(animation) {\n    if (priority > animation.priority) {\n      startQueue.add(animation);\n      rafz.raf.onStart(flushStartQueue);\n    } else {\n      startSafely(animation);\n      rafz.raf(advance);\n    }\n  },\n\n  advance,\n\n  sort(animation) {\n    if (priority) {\n      rafz.raf.onFrame(() => frameLoop.sort(animation));\n    } else {\n      const prevIndex = currentFrame.indexOf(animation);\n\n      if (~prevIndex) {\n        currentFrame.splice(prevIndex, 1);\n        startUnsafely(animation);\n      }\n    }\n  },\n\n  clear() {\n    currentFrame = [];\n    startQueue.clear();\n  }\n\n};\n\nfunction flushStartQueue() {\n  startQueue.forEach(startSafely);\n  startQueue.clear();\n  rafz.raf(advance);\n}\n\nfunction startSafely(animation) {\n  if (!currentFrame.includes(animation)) startUnsafely(animation);\n}\n\nfunction startUnsafely(animation) {\n  currentFrame.splice(findIndex(currentFrame, other => other.priority > animation.priority), 0, animation);\n}\n\nfunction advance(dt) {\n  const nextFrame = prevFrame;\n\n  for (let i = 0; i < currentFrame.length; i++) {\n    const animation = currentFrame[i];\n    priority = animation.priority;\n\n    if (!animation.idle) {\n      willAdvance(animation);\n      animation.advance(dt);\n\n      if (!animation.idle) {\n        nextFrame.push(animation);\n      }\n    }\n  }\n\n  priority = 0;\n  prevFrame = currentFrame;\n  prevFrame.length = 0;\n  currentFrame = nextFrame;\n  return currentFrame.length > 0;\n}\n\nfunction findIndex(arr, test) {\n  const index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst colors = {\n  transparent: 0x00000000,\n  aliceblue: 0xf0f8ffff,\n  antiquewhite: 0xfaebd7ff,\n  aqua: 0x00ffffff,\n  aquamarine: 0x7fffd4ff,\n  azure: 0xf0ffffff,\n  beige: 0xf5f5dcff,\n  bisque: 0xffe4c4ff,\n  black: 0x000000ff,\n  blanchedalmond: 0xffebcdff,\n  blue: 0x0000ffff,\n  blueviolet: 0x8a2be2ff,\n  brown: 0xa52a2aff,\n  burlywood: 0xdeb887ff,\n  burntsienna: 0xea7e5dff,\n  cadetblue: 0x5f9ea0ff,\n  chartreuse: 0x7fff00ff,\n  chocolate: 0xd2691eff,\n  coral: 0xff7f50ff,\n  cornflowerblue: 0x6495edff,\n  cornsilk: 0xfff8dcff,\n  crimson: 0xdc143cff,\n  cyan: 0x00ffffff,\n  darkblue: 0x00008bff,\n  darkcyan: 0x008b8bff,\n  darkgoldenrod: 0xb8860bff,\n  darkgray: 0xa9a9a9ff,\n  darkgreen: 0x006400ff,\n  darkgrey: 0xa9a9a9ff,\n  darkkhaki: 0xbdb76bff,\n  darkmagenta: 0x8b008bff,\n  darkolivegreen: 0x556b2fff,\n  darkorange: 0xff8c00ff,\n  darkorchid: 0x9932ccff,\n  darkred: 0x8b0000ff,\n  darksalmon: 0xe9967aff,\n  darkseagreen: 0x8fbc8fff,\n  darkslateblue: 0x483d8bff,\n  darkslategray: 0x2f4f4fff,\n  darkslategrey: 0x2f4f4fff,\n  darkturquoise: 0x00ced1ff,\n  darkviolet: 0x9400d3ff,\n  deeppink: 0xff1493ff,\n  deepskyblue: 0x00bfffff,\n  dimgray: 0x696969ff,\n  dimgrey: 0x696969ff,\n  dodgerblue: 0x1e90ffff,\n  firebrick: 0xb22222ff,\n  floralwhite: 0xfffaf0ff,\n  forestgreen: 0x228b22ff,\n  fuchsia: 0xff00ffff,\n  gainsboro: 0xdcdcdcff,\n  ghostwhite: 0xf8f8ffff,\n  gold: 0xffd700ff,\n  goldenrod: 0xdaa520ff,\n  gray: 0x808080ff,\n  green: 0x008000ff,\n  greenyellow: 0xadff2fff,\n  grey: 0x808080ff,\n  honeydew: 0xf0fff0ff,\n  hotpink: 0xff69b4ff,\n  indianred: 0xcd5c5cff,\n  indigo: 0x4b0082ff,\n  ivory: 0xfffff0ff,\n  khaki: 0xf0e68cff,\n  lavender: 0xe6e6faff,\n  lavenderblush: 0xfff0f5ff,\n  lawngreen: 0x7cfc00ff,\n  lemonchiffon: 0xfffacdff,\n  lightblue: 0xadd8e6ff,\n  lightcoral: 0xf08080ff,\n  lightcyan: 0xe0ffffff,\n  lightgoldenrodyellow: 0xfafad2ff,\n  lightgray: 0xd3d3d3ff,\n  lightgreen: 0x90ee90ff,\n  lightgrey: 0xd3d3d3ff,\n  lightpink: 0xffb6c1ff,\n  lightsalmon: 0xffa07aff,\n  lightseagreen: 0x20b2aaff,\n  lightskyblue: 0x87cefaff,\n  lightslategray: 0x778899ff,\n  lightslategrey: 0x778899ff,\n  lightsteelblue: 0xb0c4deff,\n  lightyellow: 0xffffe0ff,\n  lime: 0x00ff00ff,\n  limegreen: 0x32cd32ff,\n  linen: 0xfaf0e6ff,\n  magenta: 0xff00ffff,\n  maroon: 0x800000ff,\n  mediumaquamarine: 0x66cdaaff,\n  mediumblue: 0x0000cdff,\n  mediumorchid: 0xba55d3ff,\n  mediumpurple: 0x9370dbff,\n  mediumseagreen: 0x3cb371ff,\n  mediumslateblue: 0x7b68eeff,\n  mediumspringgreen: 0x00fa9aff,\n  mediumturquoise: 0x48d1ccff,\n  mediumvioletred: 0xc71585ff,\n  midnightblue: 0x191970ff,\n  mintcream: 0xf5fffaff,\n  mistyrose: 0xffe4e1ff,\n  moccasin: 0xffe4b5ff,\n  navajowhite: 0xffdeadff,\n  navy: 0x000080ff,\n  oldlace: 0xfdf5e6ff,\n  olive: 0x808000ff,\n  olivedrab: 0x6b8e23ff,\n  orange: 0xffa500ff,\n  orangered: 0xff4500ff,\n  orchid: 0xda70d6ff,\n  palegoldenrod: 0xeee8aaff,\n  palegreen: 0x98fb98ff,\n  paleturquoise: 0xafeeeeff,\n  palevioletred: 0xdb7093ff,\n  papayawhip: 0xffefd5ff,\n  peachpuff: 0xffdab9ff,\n  peru: 0xcd853fff,\n  pink: 0xffc0cbff,\n  plum: 0xdda0ddff,\n  powderblue: 0xb0e0e6ff,\n  purple: 0x800080ff,\n  rebeccapurple: 0x663399ff,\n  red: 0xff0000ff,\n  rosybrown: 0xbc8f8fff,\n  royalblue: 0x4169e1ff,\n  saddlebrown: 0x8b4513ff,\n  salmon: 0xfa8072ff,\n  sandybrown: 0xf4a460ff,\n  seagreen: 0x2e8b57ff,\n  seashell: 0xfff5eeff,\n  sienna: 0xa0522dff,\n  silver: 0xc0c0c0ff,\n  skyblue: 0x87ceebff,\n  slateblue: 0x6a5acdff,\n  slategray: 0x708090ff,\n  slategrey: 0x708090ff,\n  snow: 0xfffafaff,\n  springgreen: 0x00ff7fff,\n  steelblue: 0x4682b4ff,\n  tan: 0xd2b48cff,\n  teal: 0x008080ff,\n  thistle: 0xd8bfd8ff,\n  tomato: 0xff6347ff,\n  turquoise: 0x40e0d0ff,\n  violet: 0xee82eeff,\n  wheat: 0xf5deb3ff,\n  white: 0xffffffff,\n  whitesmoke: 0xf5f5f5ff,\n  yellow: 0xffff00ff,\n  yellowgreen: 0x9acd32ff\n};\n\nconst NUMBER = '[-+]?\\\\d*\\\\.?\\\\d+';\nconst PERCENTAGE = NUMBER + '%';\n\nfunction call(...parts) {\n  return '\\\\(\\\\s*(' + parts.join(')\\\\s*,\\\\s*(') + ')\\\\s*\\\\)';\n}\n\nconst rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));\nconst rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));\nconst hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));\nconst hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\nconst hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nconst hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nconst hex6 = /^#([0-9a-fA-F]{6})$/;\nconst hex8 = /^#([0-9a-fA-F]{8})$/;\n\nfunction normalizeColor(color) {\n  let match;\n\n  if (typeof color === 'number') {\n    return color >>> 0 === color && color >= 0 && color <= 0xffffffff ? color : null;\n  }\n\n  if (match = hex6.exec(color)) return parseInt(match[1] + 'ff', 16) >>> 0;\n\n  if (colors$1 && colors$1[color] !== undefined) {\n    return colors$1[color];\n  }\n\n  if (match = rgb.exec(color)) {\n    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 0x000000ff) >>> 0;\n  }\n\n  if (match = rgba.exec(color)) {\n    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n  }\n\n  if (match = hex3.exec(color)) {\n    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + 'ff', 16) >>> 0;\n  }\n\n  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;\n\n  if (match = hex4.exec(color)) {\n    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n  }\n\n  if (match = hsl.exec(color)) {\n    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 0x000000ff) >>> 0;\n  }\n\n  if (match = hsla.exec(color)) {\n    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n  }\n\n  return null;\n}\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\n\nfunction parse255(str) {\n  const int = parseInt(str, 10);\n  if (int < 0) return 0;\n  if (int > 255) return 255;\n  return int;\n}\n\nfunction parse360(str) {\n  const int = parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\n\nfunction parse1(str) {\n  const num = parseFloat(str);\n  if (num < 0) return 0;\n  if (num > 1) return 255;\n  return Math.round(num * 255);\n}\n\nfunction parsePercentage(str) {\n  const int = parseFloat(str);\n  if (int < 0) return 0;\n  if (int > 100) return 1;\n  return int / 100;\n}\n\nfunction colorToRgba(input) {\n  let int32Color = normalizeColor(input);\n  if (int32Color === null) return input;\n  int32Color = int32Color || 0;\n  let r = (int32Color & 0xff000000) >>> 24;\n  let g = (int32Color & 0x00ff0000) >>> 16;\n  let b = (int32Color & 0x0000ff00) >>> 8;\n  let a = (int32Color & 0x000000ff) / 255;\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nconst createInterpolator = (range, output, extrapolate) => {\n  if (is.fun(range)) {\n    return range;\n  }\n\n  if (is.arr(range)) {\n    return createInterpolator({\n      range,\n      output: output,\n      extrapolate\n    });\n  }\n\n  if (is.str(range.output[0])) {\n    return createStringInterpolator$1(range);\n  }\n\n  const config = range;\n  const outputRange = config.output;\n  const inputRange = config.range || [0, 1];\n  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || 'extend';\n  const extrapolateRight = config.extrapolateRight || config.extrapolate || 'extend';\n\n  const easing = config.easing || (t => t);\n\n  return input => {\n    const range = findRange(input, inputRange);\n    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight, config.map);\n  };\n};\n\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  let result = map ? map(input) : input;\n\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') return result;else if (extrapolateLeft === 'clamp') result = inputMin;\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') return result;else if (extrapolateRight === 'clamp') result = inputMax;\n  }\n\n  if (outputMin === outputMax) return outputMin;\n  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;\n  if (inputMin === -Infinity) result = -result;else if (inputMax === Infinity) result = result - inputMin;else result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  if (outputMin === -Infinity) result = -result;else if (outputMax === Infinity) result = result + outputMin;else result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\n\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;\n\n  return i - 1;\n}\n\nconst steps = (steps, direction = 'end') => progress => {\n  progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n  const expanded = progress * steps;\n  const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n  return clamp(0, 1, rounded / steps);\n};\n\nconst c1 = 1.70158;\nconst c2 = c1 * 1.525;\nconst c3 = c1 + 1;\nconst c4 = 2 * Math.PI / 3;\nconst c5 = 2 * Math.PI / 4.5;\n\nconst bounceOut = x => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\n  }\n};\n\nconst easings = {\n  linear: x => x,\n  easeInQuad: x => x * x,\n  easeOutQuad: x => 1 - (1 - x) * (1 - x),\n  easeInOutQuad: x => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,\n  easeInCubic: x => x * x * x,\n  easeOutCubic: x => 1 - Math.pow(1 - x, 3),\n  easeInOutCubic: x => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,\n  easeInQuart: x => x * x * x * x,\n  easeOutQuart: x => 1 - Math.pow(1 - x, 4),\n  easeInOutQuart: x => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,\n  easeInQuint: x => x * x * x * x * x,\n  easeOutQuint: x => 1 - Math.pow(1 - x, 5),\n  easeInOutQuint: x => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,\n  easeInSine: x => 1 - Math.cos(x * Math.PI / 2),\n  easeOutSine: x => Math.sin(x * Math.PI / 2),\n  easeInOutSine: x => -(Math.cos(Math.PI * x) - 1) / 2,\n  easeInExpo: x => x === 0 ? 0 : Math.pow(2, 10 * x - 10),\n  easeOutExpo: x => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),\n  easeInOutExpo: x => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,\n  easeInCirc: x => 1 - Math.sqrt(1 - Math.pow(x, 2)),\n  easeOutCirc: x => Math.sqrt(1 - Math.pow(x - 1, 2)),\n  easeInOutCirc: x => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,\n  easeInBack: x => c3 * x * x * x - c1 * x * x,\n  easeOutBack: x => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),\n  easeInOutBack: x => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,\n  easeInElastic: x => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),\n  easeOutElastic: x => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,\n  easeInOutElastic: x => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,\n  easeInBounce: x => 1 - bounceOut(1 - x),\n  easeOutBounce: bounceOut,\n  easeInOutBounce: x => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,\n  steps\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst $get = Symbol.for('FluidValue.get');\nconst $observers = Symbol.for('FluidValue.observers');\n\nconst hasFluidValue = arg => Boolean(arg && arg[$get]);\n\nconst getFluidValue = arg => arg && arg[$get] ? arg[$get]() : arg;\n\nconst getFluidObservers = target => target[$observers] || null;\n\nfunction callFluidObserver(observer, event) {\n  if (observer.eventObserved) {\n    observer.eventObserved(event);\n  } else {\n    observer(event);\n  }\n}\n\nfunction callFluidObservers(target, event) {\n  let observers = target[$observers];\n\n  if (observers) {\n    observers.forEach(observer => {\n      callFluidObserver(observer, event);\n    });\n  }\n}\n\nclass FluidValue {\n  constructor(get) {\n    this[$get] = void 0;\n    this[$observers] = void 0;\n\n    if (!get && !(get = this.get)) {\n      throw Error('Unknown getter');\n    }\n\n    setFluidGetter(this, get);\n  }\n\n}\n\nconst setFluidGetter = (target, get) => setHidden(target, $get, get);\n\nfunction addFluidObserver(target, observer) {\n  if (target[$get]) {\n    let observers = target[$observers];\n\n    if (!observers) {\n      setHidden(target, $observers, observers = new Set());\n    }\n\n    if (!observers.has(observer)) {\n      observers.add(observer);\n\n      if (target.observerAdded) {\n        target.observerAdded(observers.size, observer);\n      }\n    }\n  }\n\n  return observer;\n}\n\nfunction removeFluidObserver(target, observer) {\n  let observers = target[$observers];\n\n  if (observers && observers.has(observer)) {\n    const count = observers.size - 1;\n\n    if (count) {\n      observers.delete(observer);\n    } else {\n      target[$observers] = null;\n    }\n\n    if (target.observerRemoved) {\n      target.observerRemoved(count, observer);\n    }\n  }\n}\n\nconst setHidden = (target, key, value) => Object.defineProperty(target, key, {\n  value,\n  writable: true,\n  configurable: true\n});\n\nconst numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nconst colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\nconst unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, 'i');\nconst rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\nconst cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\nconst variableToRgba = input => {\n  const [token, fallback] = parseCSSVariable(input);\n\n  if (!token || isSSR()) {\n    return input;\n  }\n\n  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);\n\n  if (value) {\n    return value.trim();\n  } else if (fallback && fallback.startsWith('--')) {\n    const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);\n\n    if (_value) {\n      return _value;\n    } else {\n      return input;\n    }\n  } else if (fallback && cssVariableRegex.test(fallback)) {\n    return variableToRgba(fallback);\n  } else if (fallback) {\n    return fallback;\n  }\n\n  return input;\n};\n\nconst parseCSSVariable = current => {\n  const match = cssVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n};\n\nlet namedColorRegex;\n\nconst rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;\n\nconst createStringInterpolator = config => {\n  if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join('|')})(?!\\\\w)`, 'g') : /^\\b$/;\n  const output = config.output.map(value => {\n    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);\n  });\n  const keyframes = output.map(value => value.match(numberRegex).map(Number));\n  const outputRanges = keyframes[0].map((_, i) => keyframes.map(values => {\n    if (!(i in values)) {\n      throw Error('The arity of each \"output\" value must be equal');\n    }\n\n    return values[i];\n  }));\n  const interpolators = outputRanges.map(output => createInterpolator(_extends({}, config, {\n    output\n  })));\n  return input => {\n    var _output$find;\n\n    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find(value => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ''));\n    let i = 0;\n    return output[0].replace(numberRegex, () => `${interpolators[i++](input)}${missingUnit || ''}`).replace(rgbaRegex, rgbaRound);\n  };\n};\n\nconst prefix = 'react-spring: ';\nconst once = fn => {\n  const func = fn;\n  let called = false;\n\n  if (typeof func != 'function') {\n    throw new TypeError(`${prefix}once requires a function parameter`);\n  }\n\n  return (...args) => {\n    if (!called) {\n      func(...args);\n      called = true;\n    }\n  };\n};\nconst warnInterpolate = once(console.warn);\nfunction deprecateInterpolate() {\n  warnInterpolate(`${prefix}The \"interpolate\" function is deprecated in v9 (use \"to\" instead)`);\n}\nconst warnDirectCall = once(console.warn);\nfunction deprecateDirectCall() {\n  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use \".start\" instead), this will be removed in later 0.X.0 versions`);\n}\n\nfunction isAnimatedString(value) {\n  return is.str(value) && (value[0] == '#' || /\\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));\n}\n\nlet observer;\nconst resizeHandlers = new WeakMap();\n\nconst handleObservation = entries => entries.forEach(({\n  target,\n  contentRect\n}) => {\n  var _resizeHandlers$get;\n\n  return (_resizeHandlers$get = resizeHandlers.get(target)) == null ? void 0 : _resizeHandlers$get.forEach(handler => handler(contentRect));\n});\n\nfunction resizeElement(handler, target) {\n  if (!observer) {\n    if (typeof ResizeObserver !== 'undefined') {\n      observer = new ResizeObserver(handleObservation);\n    }\n  }\n\n  let elementHandlers = resizeHandlers.get(target);\n\n  if (!elementHandlers) {\n    elementHandlers = new Set();\n    resizeHandlers.set(target, elementHandlers);\n  }\n\n  elementHandlers.add(handler);\n\n  if (observer) {\n    observer.observe(target);\n  }\n\n  return () => {\n    const elementHandlers = resizeHandlers.get(target);\n    if (!elementHandlers) return;\n    elementHandlers.delete(handler);\n\n    if (!elementHandlers.size && observer) {\n      observer.unobserve(target);\n    }\n  };\n}\n\nconst listeners = new Set();\nlet cleanupWindowResizeHandler;\n\nconst createResizeHandler = () => {\n  const handleResize = () => {\n    listeners.forEach(callback => callback({\n      width: window.innerWidth,\n      height: window.innerHeight\n    }));\n  };\n\n  window.addEventListener('resize', handleResize);\n  return () => {\n    window.removeEventListener('resize', handleResize);\n  };\n};\n\nconst resizeWindow = callback => {\n  listeners.add(callback);\n\n  if (!cleanupWindowResizeHandler) {\n    cleanupWindowResizeHandler = createResizeHandler();\n  }\n\n  return () => {\n    listeners.delete(callback);\n\n    if (!listeners.size && cleanupWindowResizeHandler) {\n      cleanupWindowResizeHandler();\n      cleanupWindowResizeHandler = undefined;\n    }\n  };\n};\n\nconst onResize = (callback, {\n  container: _container = document.documentElement\n} = {}) => {\n  if (_container === document.documentElement) {\n    return resizeWindow(callback);\n  } else {\n    return resizeElement(callback, _container);\n  }\n};\n\nconst progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nconst SCROLL_KEYS = {\n  x: {\n    length: 'Width',\n    position: 'Left'\n  },\n  y: {\n    length: 'Height',\n    position: 'Top'\n  }\n};\nclass ScrollHandler {\n  constructor(callback, container) {\n    this.callback = void 0;\n    this.container = void 0;\n    this.info = void 0;\n\n    this.createAxis = () => ({\n      current: 0,\n      progress: 0,\n      scrollLength: 0\n    });\n\n    this.updateAxis = axisName => {\n      const axis = this.info[axisName];\n      const {\n        length,\n        position\n      } = SCROLL_KEYS[axisName];\n      axis.current = this.container[`scroll${position}`];\n      axis.scrollLength = this.container['scroll' + length] - this.container['client' + length];\n      axis.progress = progress(0, axis.scrollLength, axis.current);\n    };\n\n    this.update = () => {\n      this.updateAxis('x');\n      this.updateAxis('y');\n    };\n\n    this.sendEvent = () => {\n      this.callback(this.info);\n    };\n\n    this.advance = () => {\n      this.update();\n      this.sendEvent();\n    };\n\n    this.callback = callback;\n    this.container = container;\n    this.info = {\n      time: 0,\n      x: this.createAxis(),\n      y: this.createAxis()\n    };\n  }\n\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\n\nconst getTarget = container => container === document.documentElement ? window : container;\n\nconst onScroll = (callback, {\n  container: _container = document.documentElement\n} = {}) => {\n  let containerHandlers = onScrollHandlers.get(_container);\n\n  if (!containerHandlers) {\n    containerHandlers = new Set();\n    onScrollHandlers.set(_container, containerHandlers);\n  }\n\n  const containerHandler = new ScrollHandler(callback, _container);\n  containerHandlers.add(containerHandler);\n\n  if (!scrollListeners.has(_container)) {\n    const listener = () => {\n      var _containerHandlers;\n\n      (_containerHandlers = containerHandlers) == null ? void 0 : _containerHandlers.forEach(handler => handler.advance());\n      return true;\n    };\n\n    scrollListeners.set(_container, listener);\n    const target = getTarget(_container);\n    window.addEventListener('resize', listener, {\n      passive: true\n    });\n\n    if (_container !== document.documentElement) {\n      resizeListeners.set(_container, onResize(listener, {\n        container: _container\n      }));\n    }\n\n    target.addEventListener('scroll', listener, {\n      passive: true\n    });\n  }\n\n  const animateScroll = scrollListeners.get(_container);\n  rafz.raf(animateScroll);\n  return () => {\n    rafz.raf.cancel(animateScroll);\n    const containerHandlers = onScrollHandlers.get(_container);\n    if (!containerHandlers) return;\n    containerHandlers.delete(containerHandler);\n    if (containerHandlers.size) return;\n    const listener = scrollListeners.get(_container);\n    scrollListeners.delete(_container);\n\n    if (listener) {\n      var _resizeListeners$get;\n\n      getTarget(_container).removeEventListener('scroll', listener);\n      window.removeEventListener('resize', listener);\n      (_resizeListeners$get = resizeListeners.get(_container)) == null ? void 0 : _resizeListeners$get();\n    }\n  };\n};\n\nfunction useConstant(init) {\n  const ref = react.useRef(null);\n\n  if (ref.current === null) {\n    ref.current = init();\n  }\n\n  return ref.current;\n}\n\nconst useIsomorphicLayoutEffect = isSSR() ? react.useEffect : react.useLayoutEffect;\n\nconst useIsMounted = () => {\n  const isMounted = react.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return isMounted;\n};\n\nfunction useForceUpdate() {\n  const update = react.useState()[1];\n  const isMounted = useIsMounted();\n  return () => {\n    if (isMounted.current) {\n      update(Math.random());\n    }\n  };\n}\n\nfunction useMemoOne(getResult, inputs) {\n  const [initial] = react.useState(() => ({\n    inputs,\n    result: getResult()\n  }));\n  const committed = react.useRef();\n  const prevCache = committed.current;\n  let cache = prevCache;\n\n  if (cache) {\n    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));\n\n    if (!useCache) {\n      cache = {\n        inputs,\n        result: getResult()\n      };\n    }\n  } else {\n    cache = initial;\n  }\n\n  react.useEffect(() => {\n    committed.current = cache;\n\n    if (prevCache == initial) {\n      initial.inputs = initial.result = undefined;\n    }\n  }, [cache]);\n  return cache.result;\n}\n\nfunction areInputsEqual(next, prev) {\n  if (next.length !== prev.length) {\n    return false;\n  }\n\n  for (let i = 0; i < next.length; i++) {\n    if (next[i] !== prev[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst useOnce = effect => react.useEffect(effect, emptyDeps);\nconst emptyDeps = [];\n\nfunction usePrev(value) {\n  const prevRef = react.useRef();\n  react.useEffect(() => {\n    prevRef.current = value;\n  });\n  return prevRef.current;\n}\n\nconst useReducedMotion = () => {\n  const [reducedMotion, setReducedMotion] = react.useState(null);\n  useIsomorphicLayoutEffect(() => {\n    const mql = window.matchMedia('(prefers-reduced-motion)');\n\n    const handleMediaChange = e => {\n      setReducedMotion(e.matches);\n      assign({\n        skipAnimation: e.matches\n      });\n    };\n\n    handleMediaChange(mql);\n    mql.addEventListener('change', handleMediaChange);\n    return () => {\n      mql.removeEventListener('change', handleMediaChange);\n    };\n  }, []);\n  return reducedMotion;\n};\n\nObject.defineProperty(exports, \"raf\", ({\n  enumerable: true,\n  get: function () { return rafz.raf; }\n}));\nexports.FluidValue = FluidValue;\nexports.Globals = globals;\nexports.addFluidObserver = addFluidObserver;\nexports.callFluidObserver = callFluidObserver;\nexports.callFluidObservers = callFluidObservers;\nexports.clamp = clamp;\nexports.colorToRgba = colorToRgba;\nexports.colors = colors;\nexports.createInterpolator = createInterpolator;\nexports.createStringInterpolator = createStringInterpolator;\nexports.defineHidden = defineHidden;\nexports.deprecateDirectCall = deprecateDirectCall;\nexports.deprecateInterpolate = deprecateInterpolate;\nexports.each = each;\nexports.eachProp = eachProp;\nexports.easings = easings;\nexports.flush = flush;\nexports.flushCalls = flushCalls;\nexports.frameLoop = frameLoop;\nexports.getFluidObservers = getFluidObservers;\nexports.getFluidValue = getFluidValue;\nexports.hasFluidValue = hasFluidValue;\nexports.hex3 = hex3;\nexports.hex4 = hex4;\nexports.hex6 = hex6;\nexports.hex8 = hex8;\nexports.hsl = hsl;\nexports.hsla = hsla;\nexports.is = is;\nexports.isAnimatedString = isAnimatedString;\nexports.isEqual = isEqual;\nexports.isSSR = isSSR;\nexports.noop = noop;\nexports.onResize = onResize;\nexports.onScroll = onScroll;\nexports.once = once;\nexports.prefix = prefix;\nexports.removeFluidObserver = removeFluidObserver;\nexports.rgb = rgb;\nexports.rgba = rgba;\nexports.setFluidGetter = setFluidGetter;\nexports.toArray = toArray;\nexports.useConstant = useConstant;\nexports.useForceUpdate = useForceUpdate;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useMemoOne = useMemoOne;\nexports.useOnce = useOnce;\nexports.usePrev = usePrev;\nexports.useReducedMotion = useReducedMotion;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvc2hhcmVkL2Rpc3QvcmVhY3Qtc3ByaW5nLXNoYXJlZC5janMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLGlHQUFvQjtBQUN2QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsOEJBQThCLEVBQUU7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RSxjQUFjLFlBQVk7QUFDMUIsa0JBQWtCLGtCQUFrQjtBQUNwQyx5QkFBeUIsdUJBQXVCO0FBQ2hELHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQy9ELDZCQUE2QixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQy9FLDZCQUE2QixFQUFFO0FBQy9CLDZCQUE2QixFQUFFOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsMkRBQTJEO0FBQzFHO0FBQ0EsZ0RBQWdELDZEQUE2RDtBQUM3RztBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtDQUFrQyxFQUFFLEVBQUUsSUFBSSxZQUFZLEVBQUUsK0JBQStCLElBQUk7QUFDM0YsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELGVBQWUsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJLEdBQUc7O0FBRTdHO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsaUZBQWlGO0FBQ2pGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCwwQkFBMEIsRUFBRSxrQkFBa0I7QUFDakc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0Esc0lBQXNJO0FBQ3RJOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLHVDQUFzQztBQUN0QztBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsYUFBYTtBQUNiLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFdBQVc7QUFDWCxZQUFZO0FBQ1osVUFBVTtBQUNWLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2YsYUFBYTtBQUNiLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixjQUFjO0FBQ2QsMkJBQTJCO0FBQzNCLFdBQVc7QUFDWCxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGVBQWU7QUFDZix3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3NoYXJlZC9kaXN0L3JlYWN0LXNwcmluZy1zaGFyZWQuY2pzLmRldi5qcz9hZDBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHJhZnogPSByZXF1aXJlKCdAcmVhY3Qtc3ByaW5nL3JhZnonKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgZGVmaW5lSGlkZGVuID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gIHZhbHVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcbmNvbnN0IGlzID0ge1xuICBhcnI6IEFycmF5LmlzQXJyYXksXG4gIG9iajogYSA9PiAhIWEgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0JyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICB1bmQ6IGEgPT4gYSA9PT0gdW5kZWZpbmVkXG59O1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChpcy5hcnIoYSkpIHtcbiAgICBpZiAoIWlzLmFycihiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhID09PSBiO1xufVxuY29uc3QgZWFjaCA9IChvYmosIGZuKSA9PiBvYmouZm9yRWFjaChmbik7XG5mdW5jdGlvbiBlYWNoUHJvcChvYmosIGZuLCBjdHgpIHtcbiAgaWYgKGlzLmFycihvYmopKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGAke2l9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBmbi5jYWxsKGN0eCwgb2JqW2tleV0sIGtleSk7XG4gICAgfVxuICB9XG59XG5jb25zdCB0b0FycmF5ID0gYSA9PiBpcy51bmQoYSkgPyBbXSA6IGlzLmFycihhKSA/IGEgOiBbYV07XG5mdW5jdGlvbiBmbHVzaChxdWV1ZSwgaXRlcmF0b3IpIHtcbiAgaWYgKHF1ZXVlLnNpemUpIHtcbiAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ocXVldWUpO1xuICAgIHF1ZXVlLmNsZWFyKCk7XG4gICAgZWFjaChpdGVtcywgaXRlcmF0b3IpO1xuICB9XG59XG5jb25zdCBmbHVzaENhbGxzID0gKHF1ZXVlLCAuLi5hcmdzKSA9PiBmbHVzaChxdWV1ZSwgZm4gPT4gZm4oLi4uYXJncykpO1xuY29uc3QgaXNTU1IgPSAoKSA9PiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvciB8fCAvU2VydmVyU2lkZVJlbmRlcmluZ3xeRGVub1xcLy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmxldCBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IkMTtcbmxldCB0bztcbmxldCBjb2xvcnMkMSA9IG51bGw7XG5sZXQgc2tpcEFuaW1hdGlvbiA9IGZhbHNlO1xubGV0IHdpbGxBZHZhbmNlID0gbm9vcDtcbmNvbnN0IGFzc2lnbiA9IGdsb2JhbHMgPT4ge1xuICBpZiAoZ2xvYmFscy50bykgdG8gPSBnbG9iYWxzLnRvO1xuICBpZiAoZ2xvYmFscy5ub3cpIHJhZnoucmFmLm5vdyA9IGdsb2JhbHMubm93O1xuICBpZiAoZ2xvYmFscy5jb2xvcnMgIT09IHVuZGVmaW5lZCkgY29sb3JzJDEgPSBnbG9iYWxzLmNvbG9ycztcbiAgaWYgKGdsb2JhbHMuc2tpcEFuaW1hdGlvbiAhPSBudWxsKSBza2lwQW5pbWF0aW9uID0gZ2xvYmFscy5za2lwQW5pbWF0aW9uO1xuICBpZiAoZ2xvYmFscy5jcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IpIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvciQxID0gZ2xvYmFscy5jcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3I7XG4gIGlmIChnbG9iYWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSkgcmFmei5yYWYudXNlKGdsb2JhbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcbiAgaWYgKGdsb2JhbHMuYmF0Y2hlZFVwZGF0ZXMpIHJhZnoucmFmLmJhdGNoZWRVcGRhdGVzID0gZ2xvYmFscy5iYXRjaGVkVXBkYXRlcztcbiAgaWYgKGdsb2JhbHMud2lsbEFkdmFuY2UpIHdpbGxBZHZhbmNlID0gZ2xvYmFscy53aWxsQWR2YW5jZTtcbiAgaWYgKGdsb2JhbHMuZnJhbWVMb29wKSByYWZ6LnJhZi5mcmFtZUxvb3AgPSBnbG9iYWxzLmZyYW1lTG9vcDtcbn07XG5cbnZhciBnbG9iYWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldCBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IgKCkgeyByZXR1cm4gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yJDE7IH0sXG4gIGdldCB0byAoKSB7IHJldHVybiB0bzsgfSxcbiAgZ2V0IGNvbG9ycyAoKSB7IHJldHVybiBjb2xvcnMkMTsgfSxcbiAgZ2V0IHNraXBBbmltYXRpb24gKCkgeyByZXR1cm4gc2tpcEFuaW1hdGlvbjsgfSxcbiAgZ2V0IHdpbGxBZHZhbmNlICgpIHsgcmV0dXJuIHdpbGxBZHZhbmNlOyB9LFxuICBhc3NpZ246IGFzc2lnblxufSk7XG5cbmNvbnN0IHN0YXJ0UXVldWUgPSBuZXcgU2V0KCk7XG5sZXQgY3VycmVudEZyYW1lID0gW107XG5sZXQgcHJldkZyYW1lID0gW107XG5sZXQgcHJpb3JpdHkgPSAwO1xuY29uc3QgZnJhbWVMb29wID0ge1xuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIXN0YXJ0UXVldWUuc2l6ZSAmJiAhY3VycmVudEZyYW1lLmxlbmd0aDtcbiAgfSxcblxuICBzdGFydChhbmltYXRpb24pIHtcbiAgICBpZiAocHJpb3JpdHkgPiBhbmltYXRpb24ucHJpb3JpdHkpIHtcbiAgICAgIHN0YXJ0UXVldWUuYWRkKGFuaW1hdGlvbik7XG4gICAgICByYWZ6LnJhZi5vblN0YXJ0KGZsdXNoU3RhcnRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0U2FmZWx5KGFuaW1hdGlvbik7XG4gICAgICByYWZ6LnJhZihhZHZhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgYWR2YW5jZSxcblxuICBzb3J0KGFuaW1hdGlvbikge1xuICAgIGlmIChwcmlvcml0eSkge1xuICAgICAgcmFmei5yYWYub25GcmFtZSgoKSA9PiBmcmFtZUxvb3Auc29ydChhbmltYXRpb24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJldkluZGV4ID0gY3VycmVudEZyYW1lLmluZGV4T2YoYW5pbWF0aW9uKTtcblxuICAgICAgaWYgKH5wcmV2SW5kZXgpIHtcbiAgICAgICAgY3VycmVudEZyYW1lLnNwbGljZShwcmV2SW5kZXgsIDEpO1xuICAgICAgICBzdGFydFVuc2FmZWx5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIGN1cnJlbnRGcmFtZSA9IFtdO1xuICAgIHN0YXJ0UXVldWUuY2xlYXIoKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBmbHVzaFN0YXJ0UXVldWUoKSB7XG4gIHN0YXJ0UXVldWUuZm9yRWFjaChzdGFydFNhZmVseSk7XG4gIHN0YXJ0UXVldWUuY2xlYXIoKTtcbiAgcmFmei5yYWYoYWR2YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0U2FmZWx5KGFuaW1hdGlvbikge1xuICBpZiAoIWN1cnJlbnRGcmFtZS5pbmNsdWRlcyhhbmltYXRpb24pKSBzdGFydFVuc2FmZWx5KGFuaW1hdGlvbik7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VW5zYWZlbHkoYW5pbWF0aW9uKSB7XG4gIGN1cnJlbnRGcmFtZS5zcGxpY2UoZmluZEluZGV4KGN1cnJlbnRGcmFtZSwgb3RoZXIgPT4gb3RoZXIucHJpb3JpdHkgPiBhbmltYXRpb24ucHJpb3JpdHkpLCAwLCBhbmltYXRpb24pO1xufVxuXG5mdW5jdGlvbiBhZHZhbmNlKGR0KSB7XG4gIGNvbnN0IG5leHRGcmFtZSA9IHByZXZGcmFtZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRGcmFtZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGN1cnJlbnRGcmFtZVtpXTtcbiAgICBwcmlvcml0eSA9IGFuaW1hdGlvbi5wcmlvcml0eTtcblxuICAgIGlmICghYW5pbWF0aW9uLmlkbGUpIHtcbiAgICAgIHdpbGxBZHZhbmNlKGFuaW1hdGlvbik7XG4gICAgICBhbmltYXRpb24uYWR2YW5jZShkdCk7XG5cbiAgICAgIGlmICghYW5pbWF0aW9uLmlkbGUpIHtcbiAgICAgICAgbmV4dEZyYW1lLnB1c2goYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmlvcml0eSA9IDA7XG4gIHByZXZGcmFtZSA9IGN1cnJlbnRGcmFtZTtcbiAgcHJldkZyYW1lLmxlbmd0aCA9IDA7XG4gIGN1cnJlbnRGcmFtZSA9IG5leHRGcmFtZTtcbiAgcmV0dXJuIGN1cnJlbnRGcmFtZS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCB0ZXN0KSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyLmZpbmRJbmRleCh0ZXN0KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IGFyci5sZW5ndGggOiBpbmRleDtcbn1cblxuY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbmNvbnN0IGNvbG9ycyA9IHtcbiAgdHJhbnNwYXJlbnQ6IDB4MDAwMDAwMDAsXG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmZmZixcbiAgYW50aXF1ZXdoaXRlOiAweGZhZWJkN2ZmLFxuICBhcXVhOiAweDAwZmZmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNGZmLFxuICBhenVyZTogMHhmMGZmZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjZmYsXG4gIGJpc3F1ZTogMHhmZmU0YzRmZixcbiAgYmxhY2s6IDB4MDAwMDAwZmYsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZGZmLFxuICBibHVlOiAweDAwMDBmZmZmLFxuICBibHVldmlvbGV0OiAweDhhMmJlMmZmLFxuICBicm93bjogMHhhNTJhMmFmZixcbiAgYnVybHl3b29kOiAweGRlYjg4N2ZmLFxuICBidXJudHNpZW5uYTogMHhlYTdlNWRmZixcbiAgY2FkZXRibHVlOiAweDVmOWVhMGZmLFxuICBjaGFydHJldXNlOiAweDdmZmYwMGZmLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlZmYsXG4gIGNvcmFsOiAweGZmN2Y1MGZmLFxuICBjb3JuZmxvd2VyYmx1ZTogMHg2NDk1ZWRmZixcbiAgY29ybnNpbGs6IDB4ZmZmOGRjZmYsXG4gIGNyaW1zb246IDB4ZGMxNDNjZmYsXG4gIGN5YW46IDB4MDBmZmZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YmZmLFxuICBkYXJrY3lhbjogMHgwMDhiOGJmZixcbiAgZGFya2dvbGRlbnJvZDogMHhiODg2MGJmZixcbiAgZGFya2dyYXk6IDB4YTlhOWE5ZmYsXG4gIGRhcmtncmVlbjogMHgwMDY0MDBmZixcbiAgZGFya2dyZXk6IDB4YTlhOWE5ZmYsXG4gIGRhcmtraGFraTogMHhiZGI3NmJmZixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiZmYsXG4gIGRhcmtvbGl2ZWdyZWVuOiAweDU1NmIyZmZmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMGZmLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjY2ZmLFxuICBkYXJrcmVkOiAweDhiMDAwMGZmLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YWZmLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmZmYsXG4gIGRhcmtzbGF0ZWJsdWU6IDB4NDgzZDhiZmYsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmZmYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmZmYsXG4gIGRhcmt0dXJxdW9pc2U6IDB4MDBjZWQxZmYsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzZmYsXG4gIGRlZXBwaW5rOiAweGZmMTQ5M2ZmLFxuICBkZWVwc2t5Ymx1ZTogMHgwMGJmZmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjlmZixcbiAgZGltZ3JleTogMHg2OTY5NjlmZixcbiAgZG9kZ2VyYmx1ZTogMHgxZTkwZmZmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMmZmLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjBmZixcbiAgZm9yZXN0Z3JlZW46IDB4MjI4YjIyZmYsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGNmZixcbiAgZ2hvc3R3aGl0ZTogMHhmOGY4ZmZmZixcbiAgZ29sZDogMHhmZmQ3MDBmZixcbiAgZ29sZGVucm9kOiAweGRhYTUyMGZmLFxuICBncmF5OiAweDgwODA4MGZmLFxuICBncmVlbjogMHgwMDgwMDBmZixcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmZmYsXG4gIGdyZXk6IDB4ODA4MDgwZmYsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMGZmLFxuICBob3RwaW5rOiAweGZmNjliNGZmLFxuICBpbmRpYW5yZWQ6IDB4Y2Q1YzVjZmYsXG4gIGluZGlnbzogMHg0YjAwODJmZixcbiAgaXZvcnk6IDB4ZmZmZmYwZmYsXG4gIGtoYWtpOiAweGYwZTY4Y2ZmLFxuICBsYXZlbmRlcjogMHhlNmU2ZmFmZixcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjVmZixcbiAgbGF3bmdyZWVuOiAweDdjZmMwMGZmLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkZmYsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTZmZixcbiAgbGlnaHRjb3JhbDogMHhmMDgwODBmZixcbiAgbGlnaHRjeWFuOiAweGUwZmZmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDJmZixcbiAgbGlnaHRncmF5OiAweGQzZDNkM2ZmLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MGZmLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzZmYsXG4gIGxpZ2h0cGluazogMHhmZmI2YzFmZixcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhZmYsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhZmYsXG4gIGxpZ2h0c2t5Ymx1ZTogMHg4N2NlZmFmZixcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5ZmYsXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OWZmLFxuICBsaWdodHN0ZWVsYmx1ZTogMHhiMGM0ZGVmZixcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwZmYsXG4gIGxpbWU6IDB4MDBmZjAwZmYsXG4gIGxpbWVncmVlbjogMHgzMmNkMzJmZixcbiAgbGluZW46IDB4ZmFmMGU2ZmYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmZmYsXG4gIG1hcm9vbjogMHg4MDAwMDBmZixcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWFmZixcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2RmZixcbiAgbWVkaXVtb3JjaGlkOiAweGJhNTVkM2ZmLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiZmYsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MWZmLFxuICBtZWRpdW1zbGF0ZWJsdWU6IDB4N2I2OGVlZmYsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YWZmLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjZmYsXG4gIG1lZGl1bXZpb2xldHJlZDogMHhjNzE1ODVmZixcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MGZmLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhZmYsXG4gIG1pc3R5cm9zZTogMHhmZmU0ZTFmZixcbiAgbW9jY2FzaW46IDB4ZmZlNGI1ZmYsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZGZmLFxuICBuYXZ5OiAweDAwMDA4MGZmLFxuICBvbGRsYWNlOiAweGZkZjVlNmZmLFxuICBvbGl2ZTogMHg4MDgwMDBmZixcbiAgb2xpdmVkcmFiOiAweDZiOGUyM2ZmLFxuICBvcmFuZ2U6IDB4ZmZhNTAwZmYsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDBmZixcbiAgb3JjaGlkOiAweGRhNzBkNmZmLFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYWZmLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4ZmYsXG4gIHBhbGV0dXJxdW9pc2U6IDB4YWZlZWVlZmYsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzZmYsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1ZmYsXG4gIHBlYWNocHVmZjogMHhmZmRhYjlmZixcbiAgcGVydTogMHhjZDg1M2ZmZixcbiAgcGluazogMHhmZmMwY2JmZixcbiAgcGx1bTogMHhkZGEwZGRmZixcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTZmZixcbiAgcHVycGxlOiAweDgwMDA4MGZmLFxuICByZWJlY2NhcHVycGxlOiAweDY2MzM5OWZmLFxuICByZWQ6IDB4ZmYwMDAwZmYsXG4gIHJvc3licm93bjogMHhiYzhmOGZmZixcbiAgcm95YWxibHVlOiAweDQxNjllMWZmLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTNmZixcbiAgc2FsbW9uOiAweGZhODA3MmZmLFxuICBzYW5keWJyb3duOiAweGY0YTQ2MGZmLFxuICBzZWFncmVlbjogMHgyZThiNTdmZixcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlZmYsXG4gIHNpZW5uYTogMHhhMDUyMmRmZixcbiAgc2lsdmVyOiAweGMwYzBjMGZmLFxuICBza3libHVlOiAweDg3Y2VlYmZmLFxuICBzbGF0ZWJsdWU6IDB4NmE1YWNkZmYsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTBmZixcbiAgc2xhdGVncmV5OiAweDcwODA5MGZmLFxuICBzbm93OiAweGZmZmFmYWZmLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2ZmZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNGZmLFxuICB0YW46IDB4ZDJiNDhjZmYsXG4gIHRlYWw6IDB4MDA4MDgwZmYsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4ZmYsXG4gIHRvbWF0bzogMHhmZjYzNDdmZixcbiAgdHVycXVvaXNlOiAweDQwZTBkMGZmLFxuICB2aW9sZXQ6IDB4ZWU4MmVlZmYsXG4gIHdoZWF0OiAweGY1ZGViM2ZmLFxuICB3aGl0ZTogMHhmZmZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjVmZixcbiAgeWVsbG93OiAweGZmZmYwMGZmLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJmZlxufTtcblxuY29uc3QgTlVNQkVSID0gJ1stK10/XFxcXGQqXFxcXC4/XFxcXGQrJztcbmNvbnN0IFBFUkNFTlRBR0UgPSBOVU1CRVIgKyAnJSc7XG5cbmZ1bmN0aW9uIGNhbGwoLi4ucGFydHMpIHtcbiAgcmV0dXJuICdcXFxcKFxcXFxzKignICsgcGFydHMuam9pbignKVxcXFxzKixcXFxccyooJykgKyAnKVxcXFxzKlxcXFwpJztcbn1cblxuY29uc3QgcmdiID0gbmV3IFJlZ0V4cCgncmdiJyArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuY29uc3QgcmdiYSA9IG5ldyBSZWdFeHAoJ3JnYmEnICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbmNvbnN0IGhzbCA9IG5ldyBSZWdFeHAoJ2hzbCcgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuY29uc3QgaHNsYSA9IG5ldyBSZWdFeHAoJ2hzbGEnICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuY29uc3QgaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuY29uc3QgaGV4NCA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbmNvbnN0IGhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG5jb25zdCBoZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuXG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBsZXQgbWF0Y2g7XG5cbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29sb3IgPj4+IDAgPT09IGNvbG9yICYmIGNvbG9yID49IDAgJiYgY29sb3IgPD0gMHhmZmZmZmZmZiA/IGNvbG9yIDogbnVsbDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhleDYuZXhlYyhjb2xvcikpIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArICdmZicsIDE2KSA+Pj4gMDtcblxuICBpZiAoY29sb3JzJDEgJiYgY29sb3JzJDFbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JzJDFbY29sb3JdO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gcmdiLmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDB4MDAwMDAwZmYpID4+PiAwO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gcmdiYS5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhleDMuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgJ2ZmJywgMTYpID4+PiAwO1xuICB9XG5cbiAgaWYgKG1hdGNoID0gaGV4OC5leGVjKGNvbG9yKSkgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG5cbiAgaWYgKG1hdGNoID0gaGV4NC5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBtYXRjaFs0XSArIG1hdGNoWzRdLCAxNikgPj4+IDA7XG4gIH1cblxuICBpZiAobWF0Y2ggPSBoc2wuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAweDAwMDAwMGZmKSA+Pj4gMDtcbiAgfVxuXG4gIGlmIChtYXRjaCA9IGhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gIGlmICh0ID4gMSkgdCAtPSAxO1xuICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIgKiAyNTUpIDw8IDg7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICBjb25zdCBpbnQgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHJldHVybiAwO1xuICBpZiAoaW50ID4gMjU1KSByZXR1cm4gMjU1O1xuICByZXR1cm4gaW50O1xufVxuXG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gKGludCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkgcmV0dXJuIDA7XG4gIGlmIChudW0gPiAxKSByZXR1cm4gMjU1O1xuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnRhZ2Uoc3RyKSB7XG4gIGNvbnN0IGludCA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHJldHVybiAwO1xuICBpZiAoaW50ID4gMTAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYmEoaW5wdXQpIHtcbiAgbGV0IGludDMyQ29sb3IgPSBub3JtYWxpemVDb2xvcihpbnB1dCk7XG4gIGlmIChpbnQzMkNvbG9yID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIGludDMyQ29sb3IgPSBpbnQzMkNvbG9yIHx8IDA7XG4gIGxldCByID0gKGludDMyQ29sb3IgJiAweGZmMDAwMDAwKSA+Pj4gMjQ7XG4gIGxldCBnID0gKGludDMyQ29sb3IgJiAweDAwZmYwMDAwKSA+Pj4gMTY7XG4gIGxldCBiID0gKGludDMyQ29sb3IgJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgbGV0IGEgPSAoaW50MzJDb2xvciAmIDB4MDAwMDAwZmYpIC8gMjU1O1xuICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuXG5jb25zdCBjcmVhdGVJbnRlcnBvbGF0b3IgPSAocmFuZ2UsIG91dHB1dCwgZXh0cmFwb2xhdGUpID0+IHtcbiAgaWYgKGlzLmZ1bihyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoaXMuYXJyKHJhbmdlKSkge1xuICAgIHJldHVybiBjcmVhdGVJbnRlcnBvbGF0b3Ioe1xuICAgICAgcmFuZ2UsXG4gICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgIGV4dHJhcG9sYXRlXG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXMuc3RyKHJhbmdlLm91dHB1dFswXSkpIHtcbiAgICByZXR1cm4gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yJDEocmFuZ2UpO1xuICB9XG5cbiAgY29uc3QgY29uZmlnID0gcmFuZ2U7XG4gIGNvbnN0IG91dHB1dFJhbmdlID0gY29uZmlnLm91dHB1dDtcbiAgY29uc3QgaW5wdXRSYW5nZSA9IGNvbmZpZy5yYW5nZSB8fCBbMCwgMV07XG4gIGNvbnN0IGV4dHJhcG9sYXRlTGVmdCA9IGNvbmZpZy5leHRyYXBvbGF0ZUxlZnQgfHwgY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnO1xuICBjb25zdCBleHRyYXBvbGF0ZVJpZ2h0ID0gY29uZmlnLmV4dHJhcG9sYXRlUmlnaHQgfHwgY29uZmlnLmV4dHJhcG9sYXRlIHx8ICdleHRlbmQnO1xuXG4gIGNvbnN0IGVhc2luZyA9IGNvbmZpZy5lYXNpbmcgfHwgKHQgPT4gdCk7XG5cbiAgcmV0dXJuIGlucHV0ID0+IHtcbiAgICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdLCBvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV0sIGVhc2luZywgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBjb25maWcubWFwKTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4LCBlYXNpbmcsIGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgbWFwKSB7XG4gIGxldCByZXN1bHQgPSBtYXAgPyBtYXAoaW5wdXQpIDogaW5wdXQ7XG5cbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gJ2lkZW50aXR5JykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdjbGFtcCcpIHJlc3VsdCA9IGlucHV0TWluO1xuICB9XG5cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09ICdpZGVudGl0eScpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2NsYW1wJykgcmVzdWx0ID0gaW5wdXRNYXg7XG4gIH1cblxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHJldHVybiBvdXRwdXRNaW47XG4gIGlmIChpbnB1dE1pbiA9PT0gaW5wdXRNYXgpIHJldHVybiBpbnB1dCA8PSBpbnB1dE1pbiA/IG91dHB1dE1pbiA6IG91dHB1dE1heDtcbiAgaWYgKGlucHV0TWluID09PSAtSW5maW5pdHkpIHJlc3VsdCA9IC1yZXN1bHQ7ZWxzZSBpZiAoaW5wdXRNYXggPT09IEluZmluaXR5KSByZXN1bHQgPSByZXN1bHQgLSBpbnB1dE1pbjtlbHNlIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICBpZiAob3V0cHV0TWluID09PSAtSW5maW5pdHkpIHJlc3VsdCA9IC1yZXN1bHQ7ZWxzZSBpZiAob3V0cHV0TWF4ID09PSBJbmZpbml0eSkgcmVzdWx0ID0gcmVzdWx0ICsgb3V0cHV0TWluO2Vsc2UgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkgYnJlYWs7XG5cbiAgcmV0dXJuIGkgLSAxO1xufVxuXG5jb25zdCBzdGVwcyA9IChzdGVwcywgZGlyZWN0aW9uID0gJ2VuZCcpID0+IHByb2dyZXNzID0+IHtcbiAgcHJvZ3Jlc3MgPSBkaXJlY3Rpb24gPT09ICdlbmQnID8gTWF0aC5taW4ocHJvZ3Jlc3MsIDAuOTk5KSA6IE1hdGgubWF4KHByb2dyZXNzLCAwLjAwMSk7XG4gIGNvbnN0IGV4cGFuZGVkID0gcHJvZ3Jlc3MgKiBzdGVwcztcbiAgY29uc3Qgcm91bmRlZCA9IGRpcmVjdGlvbiA9PT0gJ2VuZCcgPyBNYXRoLmZsb29yKGV4cGFuZGVkKSA6IE1hdGguY2VpbChleHBhbmRlZCk7XG4gIHJldHVybiBjbGFtcCgwLCAxLCByb3VuZGVkIC8gc3RlcHMpO1xufTtcblxuY29uc3QgYzEgPSAxLjcwMTU4O1xuY29uc3QgYzIgPSBjMSAqIDEuNTI1O1xuY29uc3QgYzMgPSBjMSArIDE7XG5jb25zdCBjNCA9IDIgKiBNYXRoLlBJIC8gMztcbmNvbnN0IGM1ID0gMiAqIE1hdGguUEkgLyA0LjU7XG5cbmNvbnN0IGJvdW5jZU91dCA9IHggPT4ge1xuICBjb25zdCBuMSA9IDcuNTYyNTtcbiAgY29uc3QgZDEgPSAyLjc1O1xuXG4gIGlmICh4IDwgMSAvIGQxKSB7XG4gICAgcmV0dXJuIG4xICogeCAqIHg7XG4gIH0gZWxzZSBpZiAoeCA8IDIgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDEuNSAvIGQxKSAqIHggKyAwLjc1O1xuICB9IGVsc2UgaWYgKHggPCAyLjUgLyBkMSkge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuMjUgLyBkMSkgKiB4ICsgMC45Mzc1O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuMSAqICh4IC09IDIuNjI1IC8gZDEpICogeCArIDAuOTg0Mzc1O1xuICB9XG59O1xuXG5jb25zdCBlYXNpbmdzID0ge1xuICBsaW5lYXI6IHggPT4geCxcbiAgZWFzZUluUXVhZDogeCA9PiB4ICogeCxcbiAgZWFzZU91dFF1YWQ6IHggPT4gMSAtICgxIC0geCkgKiAoMSAtIHgpLFxuICBlYXNlSW5PdXRRdWFkOiB4ID0+IHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyLFxuICBlYXNlSW5DdWJpYzogeCA9PiB4ICogeCAqIHgsXG4gIGVhc2VPdXRDdWJpYzogeCA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpLFxuICBlYXNlSW5PdXRDdWJpYzogeCA9PiB4IDwgMC41ID8gNCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAzKSAvIDIsXG4gIGVhc2VJblF1YXJ0OiB4ID0+IHggKiB4ICogeCAqIHgsXG4gIGVhc2VPdXRRdWFydDogeCA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDQpLFxuICBlYXNlSW5PdXRRdWFydDogeCA9PiB4IDwgMC41ID8gOCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNCkgLyAyLFxuICBlYXNlSW5RdWludDogeCA9PiB4ICogeCAqIHggKiB4ICogeCxcbiAgZWFzZU91dFF1aW50OiB4ID0+IDEgLSBNYXRoLnBvdygxIC0geCwgNSksXG4gIGVhc2VJbk91dFF1aW50OiB4ID0+IHggPCAwLjUgPyAxNiAqIHggKiB4ICogeCAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDUpIC8gMixcbiAgZWFzZUluU2luZTogeCA9PiAxIC0gTWF0aC5jb3MoeCAqIE1hdGguUEkgLyAyKSxcbiAgZWFzZU91dFNpbmU6IHggPT4gTWF0aC5zaW4oeCAqIE1hdGguUEkgLyAyKSxcbiAgZWFzZUluT3V0U2luZTogeCA9PiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMixcbiAgZWFzZUluRXhwbzogeCA9PiB4ID09PSAwID8gMCA6IE1hdGgucG93KDIsIDEwICogeCAtIDEwKSxcbiAgZWFzZU91dEV4cG86IHggPT4geCA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogeCksXG4gIGVhc2VJbk91dEV4cG86IHggPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyBNYXRoLnBvdygyLCAyMCAqIHggLSAxMCkgLyAyIDogKDIgLSBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApKSAvIDIsXG4gIGVhc2VJbkNpcmM6IHggPT4gMSAtIE1hdGguc3FydCgxIC0gTWF0aC5wb3coeCwgMikpLFxuICBlYXNlT3V0Q2lyYzogeCA9PiBNYXRoLnNxcnQoMSAtIE1hdGgucG93KHggLSAxLCAyKSksXG4gIGVhc2VJbk91dENpcmM6IHggPT4geCA8IDAuNSA/ICgxIC0gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygyICogeCwgMikpKSAvIDIgOiAoTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAyKSkgKyAxKSAvIDIsXG4gIGVhc2VJbkJhY2s6IHggPT4gYzMgKiB4ICogeCAqIHggLSBjMSAqIHggKiB4LFxuICBlYXNlT3V0QmFjazogeCA9PiAxICsgYzMgKiBNYXRoLnBvdyh4IC0gMSwgMykgKyBjMSAqIE1hdGgucG93KHggLSAxLCAyKSxcbiAgZWFzZUluT3V0QmFjazogeCA9PiB4IDwgMC41ID8gTWF0aC5wb3coMiAqIHgsIDIpICogKChjMiArIDEpICogMiAqIHggLSBjMikgLyAyIDogKE1hdGgucG93KDIgKiB4IC0gMiwgMikgKiAoKGMyICsgMSkgKiAoeCAqIDIgLSAyKSArIGMyKSArIDIpIC8gMixcbiAgZWFzZUluRWxhc3RpYzogeCA9PiB4ID09PSAwID8gMCA6IHggPT09IDEgPyAxIDogLU1hdGgucG93KDIsIDEwICogeCAtIDEwKSAqIE1hdGguc2luKCh4ICogMTAgLSAxMC43NSkgKiBjNCksXG4gIGVhc2VPdXRFbGFzdGljOiB4ID0+IHggPT09IDAgPyAwIDogeCA9PT0gMSA/IDEgOiBNYXRoLnBvdygyLCAtMTAgKiB4KSAqIE1hdGguc2luKCh4ICogMTAgLSAwLjc1KSAqIGM0KSArIDEsXG4gIGVhc2VJbk91dEVsYXN0aWM6IHggPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyAtKE1hdGgucG93KDIsIDIwICogeCAtIDEwKSAqIE1hdGguc2luKCgyMCAqIHggLSAxMS4xMjUpICogYzUpKSAvIDIgOiBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApICogTWF0aC5zaW4oKDIwICogeCAtIDExLjEyNSkgKiBjNSkgLyAyICsgMSxcbiAgZWFzZUluQm91bmNlOiB4ID0+IDEgLSBib3VuY2VPdXQoMSAtIHgpLFxuICBlYXNlT3V0Qm91bmNlOiBib3VuY2VPdXQsXG4gIGVhc2VJbk91dEJvdW5jZTogeCA9PiB4IDwgMC41ID8gKDEgLSBib3VuY2VPdXQoMSAtIDIgKiB4KSkgLyAyIDogKDEgKyBib3VuY2VPdXQoMiAqIHggLSAxKSkgLyAyLFxuICBzdGVwc1xufTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5jb25zdCAkZ2V0ID0gU3ltYm9sLmZvcignRmx1aWRWYWx1ZS5nZXQnKTtcbmNvbnN0ICRvYnNlcnZlcnMgPSBTeW1ib2wuZm9yKCdGbHVpZFZhbHVlLm9ic2VydmVycycpO1xuXG5jb25zdCBoYXNGbHVpZFZhbHVlID0gYXJnID0+IEJvb2xlYW4oYXJnICYmIGFyZ1skZ2V0XSk7XG5cbmNvbnN0IGdldEZsdWlkVmFsdWUgPSBhcmcgPT4gYXJnICYmIGFyZ1skZ2V0XSA/IGFyZ1skZ2V0XSgpIDogYXJnO1xuXG5jb25zdCBnZXRGbHVpZE9ic2VydmVycyA9IHRhcmdldCA9PiB0YXJnZXRbJG9ic2VydmVyc10gfHwgbnVsbDtcblxuZnVuY3Rpb24gY2FsbEZsdWlkT2JzZXJ2ZXIob2JzZXJ2ZXIsIGV2ZW50KSB7XG4gIGlmIChvYnNlcnZlci5ldmVudE9ic2VydmVkKSB7XG4gICAgb2JzZXJ2ZXIuZXZlbnRPYnNlcnZlZChldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZXIoZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxGbHVpZE9ic2VydmVycyh0YXJnZXQsIGV2ZW50KSB7XG4gIGxldCBvYnNlcnZlcnMgPSB0YXJnZXRbJG9ic2VydmVyc107XG5cbiAgaWYgKG9ic2VydmVycykge1xuICAgIG9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IHtcbiAgICAgIGNhbGxGbHVpZE9ic2VydmVyKG9ic2VydmVyLCBldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgRmx1aWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGdldCkge1xuICAgIHRoaXNbJGdldF0gPSB2b2lkIDA7XG4gICAgdGhpc1skb2JzZXJ2ZXJzXSA9IHZvaWQgMDtcblxuICAgIGlmICghZ2V0ICYmICEoZ2V0ID0gdGhpcy5nZXQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBnZXR0ZXInKTtcbiAgICB9XG5cbiAgICBzZXRGbHVpZEdldHRlcih0aGlzLCBnZXQpO1xuICB9XG5cbn1cblxuY29uc3Qgc2V0Rmx1aWRHZXR0ZXIgPSAodGFyZ2V0LCBnZXQpID0+IHNldEhpZGRlbih0YXJnZXQsICRnZXQsIGdldCk7XG5cbmZ1bmN0aW9uIGFkZEZsdWlkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcikge1xuICBpZiAodGFyZ2V0WyRnZXRdKSB7XG4gICAgbGV0IG9ic2VydmVycyA9IHRhcmdldFskb2JzZXJ2ZXJzXTtcblxuICAgIGlmICghb2JzZXJ2ZXJzKSB7XG4gICAgICBzZXRIaWRkZW4odGFyZ2V0LCAkb2JzZXJ2ZXJzLCBvYnNlcnZlcnMgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikpIHtcbiAgICAgIG9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuXG4gICAgICBpZiAodGFyZ2V0Lm9ic2VydmVyQWRkZWQpIHtcbiAgICAgICAgdGFyZ2V0Lm9ic2VydmVyQWRkZWQob2JzZXJ2ZXJzLnNpemUsIG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZsdWlkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcikge1xuICBsZXQgb2JzZXJ2ZXJzID0gdGFyZ2V0WyRvYnNlcnZlcnNdO1xuXG4gIGlmIChvYnNlcnZlcnMgJiYgb2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikpIHtcbiAgICBjb25zdCBjb3VudCA9IG9ic2VydmVycy5zaXplIC0gMTtcblxuICAgIGlmIChjb3VudCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFskb2JzZXJ2ZXJzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5vYnNlcnZlclJlbW92ZWQpIHtcbiAgICAgIHRhcmdldC5vYnNlcnZlclJlbW92ZWQoY291bnQsIG9ic2VydmVyKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgc2V0SGlkZGVuID0gKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gIHZhbHVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgbnVtYmVyUmVnZXggPSAvWytcXC1dPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG5jb25zdCBjb2xvclJlZ2V4ID0gLygjKD86WzAtOWEtZl17Mn0pezIsNH18KCNbMC05YS1mXXszfSl8KHJnYnxoc2wpYT9cXCgoLT9cXGQrJT9bLFxcc10rKXsyLDN9XFxzKltcXGRcXC5dKyU/XFwpKS9naTtcbmNvbnN0IHVuaXRSZWdleCA9IG5ldyBSZWdFeHAoYCgke251bWJlclJlZ2V4LnNvdXJjZX0pKCV8W2Etel0rKWAsICdpJyk7XG5jb25zdCByZ2JhUmVnZXggPSAvcmdiYVxcKChbMC05XFwuLV0rKSwgKFswLTlcXC4tXSspLCAoWzAtOVxcLi1dKyksIChbMC05XFwuLV0rKVxcKS9naTtcbmNvbnN0IGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcblxuY29uc3QgdmFyaWFibGVUb1JnYmEgPSBpbnB1dCA9PiB7XG4gIGNvbnN0IFt0b2tlbiwgZmFsbGJhY2tdID0gcGFyc2VDU1NWYXJpYWJsZShpbnB1dCk7XG5cbiAgaWYgKCF0b2tlbiB8fCBpc1NTUigpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xuXG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gIH0gZWxzZSBpZiAoZmFsbGJhY2sgJiYgZmFsbGJhY2suc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgIGNvbnN0IF92YWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShmYWxsYmFjayk7XG5cbiAgICBpZiAoX3ZhbHVlKSB7XG4gICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZhbGxiYWNrICYmIGNzc1ZhcmlhYmxlUmVnZXgudGVzdChmYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdmFyaWFibGVUb1JnYmEoZmFsbGJhY2spO1xuICB9IGVsc2UgaWYgKGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuY29uc3QgcGFyc2VDU1NWYXJpYWJsZSA9IGN1cnJlbnQgPT4ge1xuICBjb25zdCBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFssXTtcbiAgY29uc3QgWywgdG9rZW4sIGZhbGxiYWNrXSA9IG1hdGNoO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59O1xuXG5sZXQgbmFtZWRDb2xvclJlZ2V4O1xuXG5jb25zdCByZ2JhUm91bmQgPSAoXywgcDEsIHAyLCBwMywgcDQpID0+IGByZ2JhKCR7TWF0aC5yb3VuZChwMSl9LCAke01hdGgucm91bmQocDIpfSwgJHtNYXRoLnJvdW5kKHAzKX0sICR7cDR9KWA7XG5cbmNvbnN0IGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvciA9IGNvbmZpZyA9PiB7XG4gIGlmICghbmFtZWRDb2xvclJlZ2V4KSBuYW1lZENvbG9yUmVnZXggPSBjb2xvcnMkMSA/IG5ldyBSZWdFeHAoYCgke09iamVjdC5rZXlzKGNvbG9ycyQxKS5qb2luKCd8Jyl9KSg/IVxcXFx3KWAsICdnJykgOiAvXlxcYiQvO1xuICBjb25zdCBvdXRwdXQgPSBjb25maWcub3V0cHV0Lm1hcCh2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGdldEZsdWlkVmFsdWUodmFsdWUpLnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgdmFyaWFibGVUb1JnYmEpLnJlcGxhY2UoY29sb3JSZWdleCwgY29sb3JUb1JnYmEpLnJlcGxhY2UobmFtZWRDb2xvclJlZ2V4LCBjb2xvclRvUmdiYSk7XG4gIH0pO1xuICBjb25zdCBrZXlmcmFtZXMgPSBvdXRwdXQubWFwKHZhbHVlID0+IHZhbHVlLm1hdGNoKG51bWJlclJlZ2V4KS5tYXAoTnVtYmVyKSk7XG4gIGNvbnN0IG91dHB1dFJhbmdlcyA9IGtleWZyYW1lc1swXS5tYXAoKF8sIGkpID0+IGtleWZyYW1lcy5tYXAodmFsdWVzID0+IHtcbiAgICBpZiAoIShpIGluIHZhbHVlcykpIHtcbiAgICAgIHRocm93IEVycm9yKCdUaGUgYXJpdHkgb2YgZWFjaCBcIm91dHB1dFwiIHZhbHVlIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzW2ldO1xuICB9KSk7XG4gIGNvbnN0IGludGVycG9sYXRvcnMgPSBvdXRwdXRSYW5nZXMubWFwKG91dHB1dCA9PiBjcmVhdGVJbnRlcnBvbGF0b3IoX2V4dGVuZHMoe30sIGNvbmZpZywge1xuICAgIG91dHB1dFxuICB9KSkpO1xuICByZXR1cm4gaW5wdXQgPT4ge1xuICAgIHZhciBfb3V0cHV0JGZpbmQ7XG5cbiAgICBjb25zdCBtaXNzaW5nVW5pdCA9ICF1bml0UmVnZXgudGVzdChvdXRwdXRbMF0pICYmICgoX291dHB1dCRmaW5kID0gb3V0cHV0LmZpbmQodmFsdWUgPT4gdW5pdFJlZ2V4LnRlc3QodmFsdWUpKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdXRwdXQkZmluZC5yZXBsYWNlKG51bWJlclJlZ2V4LCAnJykpO1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gb3V0cHV0WzBdLnJlcGxhY2UobnVtYmVyUmVnZXgsICgpID0+IGAke2ludGVycG9sYXRvcnNbaSsrXShpbnB1dCl9JHttaXNzaW5nVW5pdCB8fCAnJ31gKS5yZXBsYWNlKHJnYmFSZWdleCwgcmdiYVJvdW5kKTtcbiAgfTtcbn07XG5cbmNvbnN0IHByZWZpeCA9ICdyZWFjdC1zcHJpbmc6ICc7XG5jb25zdCBvbmNlID0gZm4gPT4ge1xuICBjb25zdCBmdW5jID0gZm47XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7cHJlZml4fW9uY2UgcmVxdWlyZXMgYSBmdW5jdGlvbiBwYXJhbWV0ZXJgKTtcbiAgfVxuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBmdW5jKC4uLmFyZ3MpO1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgd2FybkludGVycG9sYXRlID0gb25jZShjb25zb2xlLndhcm4pO1xuZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJwb2xhdGUoKSB7XG4gIHdhcm5JbnRlcnBvbGF0ZShgJHtwcmVmaXh9VGhlIFwiaW50ZXJwb2xhdGVcIiBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGluIHY5ICh1c2UgXCJ0b1wiIGluc3RlYWQpYCk7XG59XG5jb25zdCB3YXJuRGlyZWN0Q2FsbCA9IG9uY2UoY29uc29sZS53YXJuKTtcbmZ1bmN0aW9uIGRlcHJlY2F0ZURpcmVjdENhbGwoKSB7XG4gIHdhcm5EaXJlY3RDYWxsKGAke3ByZWZpeH1EaXJlY3RseSBjYWxsaW5nIHN0YXJ0IGluc3RlYWQgb2YgdXNpbmcgdGhlIGFwaSBvYmplY3QgaXMgZGVwcmVjYXRlZCBpbiB2OSAodXNlIFwiLnN0YXJ0XCIgaW5zdGVhZCksIHRoaXMgd2lsbCBiZSByZW1vdmVkIGluIGxhdGVyIDAuWC4wIHZlcnNpb25zYCk7XG59XG5cbmZ1bmN0aW9uIGlzQW5pbWF0ZWRTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIGlzLnN0cih2YWx1ZSkgJiYgKHZhbHVlWzBdID09ICcjJyB8fCAvXFxkLy50ZXN0KHZhbHVlKSB8fCAhaXNTU1IoKSAmJiBjc3NWYXJpYWJsZVJlZ2V4LnRlc3QodmFsdWUpIHx8IHZhbHVlIGluIChjb2xvcnMkMSB8fCB7fSkpO1xufVxuXG5sZXQgb2JzZXJ2ZXI7XG5jb25zdCByZXNpemVIYW5kbGVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IGhhbmRsZU9ic2VydmF0aW9uID0gZW50cmllcyA9PiBlbnRyaWVzLmZvckVhY2goKHtcbiAgdGFyZ2V0LFxuICBjb250ZW50UmVjdFxufSkgPT4ge1xuICB2YXIgX3Jlc2l6ZUhhbmRsZXJzJGdldDtcblxuICByZXR1cm4gKF9yZXNpemVIYW5kbGVycyRnZXQgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXNpemVIYW5kbGVycyRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoY29udGVudFJlY3QpKTtcbn0pO1xuXG5mdW5jdGlvbiByZXNpemVFbGVtZW50KGhhbmRsZXIsIHRhcmdldCkge1xuICBpZiAoIW9ic2VydmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZU9ic2VydmF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBsZXQgZWxlbWVudEhhbmRsZXJzID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCk7XG5cbiAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICBlbGVtZW50SGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgcmVzaXplSGFuZGxlcnMuc2V0KHRhcmdldCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgfVxuXG4gIGVsZW1lbnRIYW5kbGVycy5hZGQoaGFuZGxlcik7XG5cbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQpO1xuICB9XG5cbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KTtcbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVycykgcmV0dXJuO1xuICAgIGVsZW1lbnRIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG5cbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVycy5zaXplICYmIG9ic2VydmVyKSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUodGFyZ2V0KTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbmxldCBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcjtcblxuY29uc3QgY3JlYXRlUmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHtcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfSkpO1xuICB9O1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICB9O1xufTtcblxuY29uc3QgcmVzaXplV2luZG93ID0gY2FsbGJhY2sgPT4ge1xuICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcblxuICBpZiAoIWNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyKSB7XG4gICAgY2xlYW51cFdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSBjcmVhdGVSZXNpemVIYW5kbGVyKCk7XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFsaXN0ZW5lcnMuc2l6ZSAmJiBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgY2xlYW51cFdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IG9uUmVzaXplID0gKGNhbGxiYWNrLCB7XG4gIGNvbnRhaW5lcjogX2NvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxufSA9IHt9KSA9PiB7XG4gIGlmIChfY29udGFpbmVyID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcmVzaXplV2luZG93KGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzaXplRWxlbWVudChjYWxsYmFjaywgX2NvbnRhaW5lcik7XG4gIH1cbn07XG5cbmNvbnN0IHByb2dyZXNzID0gKG1pbiwgbWF4LCB2YWx1ZSkgPT4gbWF4IC0gbWluID09PSAwID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcblxuY29uc3QgU0NST0xMX0tFWVMgPSB7XG4gIHg6IHtcbiAgICBsZW5ndGg6ICdXaWR0aCcsXG4gICAgcG9zaXRpb246ICdMZWZ0J1xuICB9LFxuICB5OiB7XG4gICAgbGVuZ3RoOiAnSGVpZ2h0JyxcbiAgICBwb3NpdGlvbjogJ1RvcCdcbiAgfVxufTtcbmNsYXNzIFNjcm9sbEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgY29udGFpbmVyKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG5cbiAgICB0aGlzLmNyZWF0ZUF4aXMgPSAoKSA9PiAoe1xuICAgICAgY3VycmVudDogMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgc2Nyb2xsTGVuZ3RoOiAwXG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZUF4aXMgPSBheGlzTmFtZSA9PiB7XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5pbmZvW2F4aXNOYW1lXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBwb3NpdGlvblxuICAgICAgfSA9IFNDUk9MTF9LRVlTW2F4aXNOYW1lXTtcbiAgICAgIGF4aXMuY3VycmVudCA9IHRoaXMuY29udGFpbmVyW2BzY3JvbGwke3Bvc2l0aW9ufWBdO1xuICAgICAgYXhpcy5zY3JvbGxMZW5ndGggPSB0aGlzLmNvbnRhaW5lclsnc2Nyb2xsJyArIGxlbmd0aF0gLSB0aGlzLmNvbnRhaW5lclsnY2xpZW50JyArIGxlbmd0aF07XG4gICAgICBheGlzLnByb2dyZXNzID0gcHJvZ3Jlc3MoMCwgYXhpcy5zY3JvbGxMZW5ndGgsIGF4aXMuY3VycmVudCk7XG4gICAgfTtcblxuICAgIHRoaXMudXBkYXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVBeGlzKCd4Jyk7XG4gICAgICB0aGlzLnVwZGF0ZUF4aXMoJ3knKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZW5kRXZlbnQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5mbyk7XG4gICAgfTtcblxuICAgIHRoaXMuYWR2YW5jZSA9ICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLnNlbmRFdmVudCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5pbmZvID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIHg6IHRoaXMuY3JlYXRlQXhpcygpLFxuICAgICAgeTogdGhpcy5jcmVhdGVBeGlzKClcbiAgICB9O1xuICB9XG5cbn1cblxuY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlc2l6ZUxpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvblNjcm9sbEhhbmRsZXJzID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgZ2V0VGFyZ2V0ID0gY29udGFpbmVyID0+IGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogY29udGFpbmVyO1xuXG5jb25zdCBvblNjcm9sbCA9IChjYWxsYmFjaywge1xuICBjb250YWluZXI6IF9jb250YWluZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbn0gPSB7fSkgPT4ge1xuICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChfY29udGFpbmVyKTtcblxuICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgY29udGFpbmVySGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgb25TY3JvbGxIYW5kbGVycy5zZXQoX2NvbnRhaW5lciwgY29udGFpbmVySGFuZGxlcnMpO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVySGFuZGxlciA9IG5ldyBTY3JvbGxIYW5kbGVyKGNhbGxiYWNrLCBfY29udGFpbmVyKTtcbiAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuXG4gIGlmICghc2Nyb2xsTGlzdGVuZXJzLmhhcyhfY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb250YWluZXJIYW5kbGVycztcblxuICAgICAgKF9jb250YWluZXJIYW5kbGVycyA9IGNvbnRhaW5lckhhbmRsZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRhaW5lckhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyLmFkdmFuY2UoKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2Nyb2xsTGlzdGVuZXJzLnNldChfY29udGFpbmVyLCBsaXN0ZW5lcik7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KF9jb250YWluZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBsaXN0ZW5lciwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKF9jb250YWluZXIgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmVzaXplTGlzdGVuZXJzLnNldChfY29udGFpbmVyLCBvblJlc2l6ZShsaXN0ZW5lciwge1xuICAgICAgICBjb250YWluZXI6IF9jb250YWluZXJcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgbGlzdGVuZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGFuaW1hdGVTY3JvbGwgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpO1xuICByYWZ6LnJhZihhbmltYXRlU2Nyb2xsKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByYWZ6LnJhZi5jYW5jZWwoYW5pbWF0ZVNjcm9sbCk7XG4gICAgY29uc3QgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChfY29udGFpbmVyKTtcbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSByZXR1cm47XG4gICAgY29udGFpbmVySGFuZGxlcnMuZGVsZXRlKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIGlmIChjb250YWluZXJIYW5kbGVycy5zaXplKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBzY3JvbGxMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpO1xuICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoX2NvbnRhaW5lcik7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIHZhciBfcmVzaXplTGlzdGVuZXJzJGdldDtcblxuICAgICAgZ2V0VGFyZ2V0KF9jb250YWluZXIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGxpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICAoX3Jlc2l6ZUxpc3RlbmVycyRnZXQgPSByZXNpemVMaXN0ZW5lcnMuZ2V0KF9jb250YWluZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc2l6ZUxpc3RlbmVycyRnZXQoKTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gIGNvbnN0IHJlZiA9IHJlYWN0LnVzZVJlZihudWxsKTtcblxuICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgfVxuXG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzU1NSKCkgPyByZWFjdC51c2VFZmZlY3QgOiByZWFjdC51c2VMYXlvdXRFZmZlY3Q7XG5cbmNvbnN0IHVzZUlzTW91bnRlZCA9ICgpID0+IHtcbiAgY29uc3QgaXNNb3VudGVkID0gcmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn07XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICBjb25zdCB1cGRhdGUgPSByZWFjdC51c2VTdGF0ZSgpWzFdO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHVwZGF0ZShNYXRoLnJhbmRvbSgpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9PbmUoZ2V0UmVzdWx0LCBpbnB1dHMpIHtcbiAgY29uc3QgW2luaXRpYWxdID0gcmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICBpbnB1dHMsXG4gICAgcmVzdWx0OiBnZXRSZXN1bHQoKVxuICB9KSk7XG4gIGNvbnN0IGNvbW1pdHRlZCA9IHJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBwcmV2Q2FjaGUgPSBjb21taXR0ZWQuY3VycmVudDtcbiAgbGV0IGNhY2hlID0gcHJldkNhY2hlO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGNvbnN0IHVzZUNhY2hlID0gQm9vbGVhbihpbnB1dHMgJiYgY2FjaGUuaW5wdXRzICYmIGFyZUlucHV0c0VxdWFsKGlucHV0cywgY2FjaGUuaW5wdXRzKSk7XG5cbiAgICBpZiAoIXVzZUNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHtcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICByZXN1bHQ6IGdldFJlc3VsdCgpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGluaXRpYWw7XG4gIH1cblxuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbW1pdHRlZC5jdXJyZW50ID0gY2FjaGU7XG5cbiAgICBpZiAocHJldkNhY2hlID09IGluaXRpYWwpIHtcbiAgICAgIGluaXRpYWwuaW5wdXRzID0gaW5pdGlhbC5yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCBbY2FjaGVdKTtcbiAgcmV0dXJuIGNhY2hlLnJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV4dCwgcHJldikge1xuICBpZiAobmV4dC5sZW5ndGggIT09IHByZXYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5leHRbaV0gIT09IHByZXZbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgdXNlT25jZSA9IGVmZmVjdCA9PiByZWFjdC51c2VFZmZlY3QoZWZmZWN0LCBlbXB0eURlcHMpO1xuY29uc3QgZW1wdHlEZXBzID0gW107XG5cbmZ1bmN0aW9uIHVzZVByZXYodmFsdWUpIHtcbiAgY29uc3QgcHJldlJlZiA9IHJlYWN0LnVzZVJlZigpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHByZXZSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHByZXZSZWYuY3VycmVudDtcbn1cblxuY29uc3QgdXNlUmVkdWNlZE1vdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgW3JlZHVjZWRNb3Rpb24sIHNldFJlZHVjZWRNb3Rpb25dID0gcmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1xbCA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknKTtcblxuICAgIGNvbnN0IGhhbmRsZU1lZGlhQ2hhbmdlID0gZSA9PiB7XG4gICAgICBzZXRSZWR1Y2VkTW90aW9uKGUubWF0Y2hlcyk7XG4gICAgICBhc3NpZ24oe1xuICAgICAgICBza2lwQW5pbWF0aW9uOiBlLm1hdGNoZXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBoYW5kbGVNZWRpYUNoYW5nZShtcWwpO1xuICAgIG1xbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1xbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gcmVkdWNlZE1vdGlvbjtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncmFmJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZnoucmFmOyB9XG59KTtcbmV4cG9ydHMuRmx1aWRWYWx1ZSA9IEZsdWlkVmFsdWU7XG5leHBvcnRzLkdsb2JhbHMgPSBnbG9iYWxzO1xuZXhwb3J0cy5hZGRGbHVpZE9ic2VydmVyID0gYWRkRmx1aWRPYnNlcnZlcjtcbmV4cG9ydHMuY2FsbEZsdWlkT2JzZXJ2ZXIgPSBjYWxsRmx1aWRPYnNlcnZlcjtcbmV4cG9ydHMuY2FsbEZsdWlkT2JzZXJ2ZXJzID0gY2FsbEZsdWlkT2JzZXJ2ZXJzO1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5jb2xvclRvUmdiYSA9IGNvbG9yVG9SZ2JhO1xuZXhwb3J0cy5jb2xvcnMgPSBjb2xvcnM7XG5leHBvcnRzLmNyZWF0ZUludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcjtcbmV4cG9ydHMuY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yID0gY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yO1xuZXhwb3J0cy5kZWZpbmVIaWRkZW4gPSBkZWZpbmVIaWRkZW47XG5leHBvcnRzLmRlcHJlY2F0ZURpcmVjdENhbGwgPSBkZXByZWNhdGVEaXJlY3RDYWxsO1xuZXhwb3J0cy5kZXByZWNhdGVJbnRlcnBvbGF0ZSA9IGRlcHJlY2F0ZUludGVycG9sYXRlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMuZWFjaFByb3AgPSBlYWNoUHJvcDtcbmV4cG9ydHMuZWFzaW5ncyA9IGVhc2luZ3M7XG5leHBvcnRzLmZsdXNoID0gZmx1c2g7XG5leHBvcnRzLmZsdXNoQ2FsbHMgPSBmbHVzaENhbGxzO1xuZXhwb3J0cy5mcmFtZUxvb3AgPSBmcmFtZUxvb3A7XG5leHBvcnRzLmdldEZsdWlkT2JzZXJ2ZXJzID0gZ2V0Rmx1aWRPYnNlcnZlcnM7XG5leHBvcnRzLmdldEZsdWlkVmFsdWUgPSBnZXRGbHVpZFZhbHVlO1xuZXhwb3J0cy5oYXNGbHVpZFZhbHVlID0gaGFzRmx1aWRWYWx1ZTtcbmV4cG9ydHMuaGV4MyA9IGhleDM7XG5leHBvcnRzLmhleDQgPSBoZXg0O1xuZXhwb3J0cy5oZXg2ID0gaGV4NjtcbmV4cG9ydHMuaGV4OCA9IGhleDg7XG5leHBvcnRzLmhzbCA9IGhzbDtcbmV4cG9ydHMuaHNsYSA9IGhzbGE7XG5leHBvcnRzLmlzID0gaXM7XG5leHBvcnRzLmlzQW5pbWF0ZWRTdHJpbmcgPSBpc0FuaW1hdGVkU3RyaW5nO1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbmV4cG9ydHMuaXNTU1IgPSBpc1NTUjtcbmV4cG9ydHMubm9vcCA9IG5vb3A7XG5leHBvcnRzLm9uUmVzaXplID0gb25SZXNpemU7XG5leHBvcnRzLm9uU2Nyb2xsID0gb25TY3JvbGw7XG5leHBvcnRzLm9uY2UgPSBvbmNlO1xuZXhwb3J0cy5wcmVmaXggPSBwcmVmaXg7XG5leHBvcnRzLnJlbW92ZUZsdWlkT2JzZXJ2ZXIgPSByZW1vdmVGbHVpZE9ic2VydmVyO1xuZXhwb3J0cy5yZ2IgPSByZ2I7XG5leHBvcnRzLnJnYmEgPSByZ2JhO1xuZXhwb3J0cy5zZXRGbHVpZEdldHRlciA9IHNldEZsdWlkR2V0dGVyO1xuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmV4cG9ydHMudXNlQ29uc3RhbnQgPSB1c2VDb25zdGFudDtcbmV4cG9ydHMudXNlRm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZTtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW9PbmUgPSB1c2VNZW1vT25lO1xuZXhwb3J0cy51c2VPbmNlID0gdXNlT25jZTtcbmV4cG9ydHMudXNlUHJldiA9IHVzZVByZXY7XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js ***!
  \**********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-shared.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvc2hhcmVkL2Rpc3QvcmVhY3Qtc3ByaW5nLXNoYXJlZC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDRMQUE0RDtBQUM5RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvc2hhcmVkL2Rpc3QvcmVhY3Qtc3ByaW5nLXNoYXJlZC5janMuanM/MDdiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC1zcHJpbmctc2hhcmVkLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar fiber = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\");\nvar core = __webpack_require__(/*! @react-spring/core */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/core/dist/react-spring-core.cjs.js\");\nvar shared = __webpack_require__(/*! @react-spring/shared */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/shared/dist/react-spring-shared.cjs.js\");\nvar animated$1 = __webpack_require__(/*! @react-spring/animated */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/animated/dist/react-spring-animated.cjs.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\n\nconst primitives = ['primitive'].concat(Object.keys(THREE__namespace).filter(key => /^[A-Z]/.test(key)).map(key => key[0].toLowerCase() + key.slice(1)));\n\ncore.Globals.assign({\n  createStringInterpolator: shared.createStringInterpolator,\n  colors: shared.colors,\n  frameLoop: 'demand'\n});\nfiber.addEffect(() => {\n  shared.raf.advance();\n});\nconst host = animated$1.createHost(primitives, {\n  applyAnimatedValues: fiber.applyProps\n});\nconst animated = host.animated;\n\nexports.a = animated;\nexports.animated = animated;\nObject.keys(core).forEach(function (k) {\n  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () { return core[k]; }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvdGhyZWUvZGlzdC9yZWFjdC1zcHJpbmctdGhyZWUuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyxpR0FBb0I7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLGdJQUFvQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsc0lBQXNCO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLDRJQUF3QjtBQUNqRCxZQUFZLG1CQUFPLENBQUMseURBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLFNBQVM7QUFDVCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy90aHJlZS9kaXN0L3JlYWN0LXNwcmluZy10aHJlZS5janMuZGV2LmpzPzBlZTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZmliZXIgPSByZXF1aXJlKCdAcmVhY3QtdGhyZWUvZmliZXInKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9jb3JlJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9zaGFyZWQnKTtcbnZhciBhbmltYXRlZCQxID0gcmVxdWlyZSgnQHJlYWN0LXNwcmluZy9hbmltYXRlZCcpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoVEhSRUUpO1xuXG5jb25zdCBwcmltaXRpdmVzID0gWydwcmltaXRpdmUnXS5jb25jYXQoT2JqZWN0LmtleXMoVEhSRUVfX25hbWVzcGFjZSkuZmlsdGVyKGtleSA9PiAvXltBLVpdLy50ZXN0KGtleSkpLm1hcChrZXkgPT4ga2V5WzBdLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkpKTtcblxuY29yZS5HbG9iYWxzLmFzc2lnbih7XG4gIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcjogc2hhcmVkLmNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcixcbiAgY29sb3JzOiBzaGFyZWQuY29sb3JzLFxuICBmcmFtZUxvb3A6ICdkZW1hbmQnXG59KTtcbmZpYmVyLmFkZEVmZmVjdCgoKSA9PiB7XG4gIHNoYXJlZC5yYWYuYWR2YW5jZSgpO1xufSk7XG5jb25zdCBob3N0ID0gYW5pbWF0ZWQkMS5jcmVhdGVIb3N0KHByaW1pdGl2ZXMsIHtcbiAgYXBwbHlBbmltYXRlZFZhbHVlczogZmliZXIuYXBwbHlQcm9wc1xufSk7XG5jb25zdCBhbmltYXRlZCA9IGhvc3QuYW5pbWF0ZWQ7XG5cbmV4cG9ydHMuYSA9IGFuaW1hdGVkO1xuZXhwb3J0cy5hbmltYXRlZCA9IGFuaW1hdGVkO1xuT2JqZWN0LmtleXMoY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlW2tdOyB9XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-spring-three.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvdGhyZWUvZGlzdC9yZWFjdC1zcHJpbmctdGhyZWUuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx5TEFBMkQ7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3RocmVlL2Rpc3QvcmVhY3Qtc3ByaW5nLXRocmVlLmNqcy5qcz85OTAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXNwcmluZy10aHJlZS5janMucHJvZC5qc1wiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcmVhY3Qtc3ByaW5nLXRocmVlLmNqcy5kZXYuanNcIik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/three/dist/react-spring-three.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/types/animated.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/types/animated.js ***!
  \*************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/@react-spring/types/interpolation.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/@react-spring/types/interpolation.js ***!
  \******************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-e9909912.cjs.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-e9909912.cjs.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar constants = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\nvar create = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\nvar Reconciler = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\nvar scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\nvar suspendReact = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar create__default = /*#__PURE__*/_interopDefault(create);\nvar Reconciler__default = /*#__PURE__*/_interopDefault(Reconciler);\n\nvar threeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nconst catalogue = {};\nconst extend = objects => void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n  function createInstance(type, {\n    args = [],\n    attach,\n    ...props\n  }, root) {\n    let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n    let instance;\n    if (type === 'primitive') {\n      if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n      const object = props.object;\n      instance = prepare(object, {\n        type,\n        root,\n        attach,\n        primitive: true\n      });\n    } else {\n      const target = catalogue[name];\n      if (!target) {\n        throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n      }\n\n      // Throw if an object or literal was passed for args\n      if (!Array.isArray(args)) throw new Error('R3F: The args prop must be an array!');\n\n      // Instanciate new object, link it to the root\n      // Append memoized props with args so it's not forgotten\n      instance = prepare(new target(...args), {\n        type,\n        root,\n        attach,\n        // Save args in case we need to reconstruct later for HMR\n        memoizedProps: {\n          args\n        }\n      });\n    }\n\n    // Auto-attach geometries and materials\n    if (instance.__r3f.attach === undefined) {\n      if (instance instanceof THREE__namespace.BufferGeometry) instance.__r3f.attach = 'geometry';else if (instance instanceof THREE__namespace.Material) instance.__r3f.attach = 'material';\n    }\n\n    // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n    // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n    // why it passes \"true\" here\n    // There is no reason to apply props to injects\n    if (name !== 'inject') applyProps$1(instance, props);\n    return instance;\n  }\n  function appendChild(parentInstance, child) {\n    let added = false;\n    if (child) {\n      var _child$__r3f, _parentInstance$__r3f;\n      // The attach attribute implies that the object attaches itself on the parent\n      if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        // add in the usual parent-child way\n        parentInstance.add(child);\n        added = true;\n      }\n      // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n      // that is, anything that's a child in React but not a child in the scenegraph.\n      if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function insertBefore(parentInstance, child, beforeChild) {\n    let added = false;\n    if (child) {\n      var _child$__r3f2, _parentInstance$__r3f2;\n      if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n        attach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        child.parent = parentInstance;\n        child.dispatchEvent({\n          type: 'added'\n        });\n        const restSiblings = parentInstance.children.filter(sibling => sibling !== child);\n        const index = restSiblings.indexOf(beforeChild);\n        parentInstance.children = [...restSiblings.slice(0, index), child, ...restSiblings.slice(index)];\n        added = true;\n      }\n      if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n      if (!child.__r3f) prepare(child, {});\n      child.__r3f.parent = parentInstance;\n      updateInstance(child);\n      invalidateInstance(child);\n    }\n  }\n  function removeRecursive(array, parent, dispose = false) {\n    if (array) [...array].forEach(child => removeChild(parent, child, dispose));\n  }\n  function removeChild(parentInstance, child, dispose) {\n    if (child) {\n      var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n      // Clear the parent reference\n      if (child.__r3f) child.__r3f.parent = null;\n      // Remove child from the parents objects\n      if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter(x => x !== child);\n      // Remove attachment\n      if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n        detach(parentInstance, child, child.__r3f.attach);\n      } else if (child.isObject3D && parentInstance.isObject3D) {\n        var _child$__r3f4;\n        parentInstance.remove(child);\n        // Remove interactivity\n        if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n          removeInteractivity(child.__r3f.root, child);\n        }\n      }\n\n      // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n      // Never dispose of primitives because their state may be kept outside of React!\n      // In order for an object to be able to dispose it has to have\n      //   - a dispose method,\n      //   - it cannot be a <primitive object={...} />\n      //   - it cannot be a THREE.Scene, because three has broken it's own api\n      //\n      // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n      // when the reconciler calls it, but then carry our own check recursively\n      const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n      const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n\n      // Remove nested child objects. Primitives should not have objects and children that are\n      // attached to them declaratively ...\n      if (!isPrimitive) {\n        var _child$__r3f6;\n        removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n        removeRecursive(child.children, child, shouldDispose);\n      }\n\n      // Remove references\n      delete child.__r3f;\n\n      // Dispose item whenever the reconciler feels like it\n      if (shouldDispose && child.dispose && child.type !== 'Scene') {\n        const callback = () => {\n          try {\n            child.dispose();\n          } catch (e) {\n            /* ... */\n          }\n        };\n\n        // Schedule async at runtime, flush sync in testing\n        if (typeof IS_REACT_ACT_ENVIRONMENT === 'undefined') {\n          scheduler.unstable_scheduleCallback(scheduler.unstable_IdlePriority, callback);\n        } else {\n          callback();\n        }\n      }\n      invalidateInstance(parentInstance);\n    }\n  }\n  function switchInstance(instance, type, newProps, fiber) {\n    var _instance$__r3f;\n    const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n    if (!parent) return;\n    const newInstance = createInstance(type, newProps, instance.__r3f.root);\n\n    // https://github.com/pmndrs/react-three-fiber/issues/1348\n    // When args change the instance has to be re-constructed, which then\n    // forces r3f to re-parent the children and non-scene objects\n    if (instance.children) {\n      for (const child of instance.children) {\n        if (child.__r3f) appendChild(newInstance, child);\n      }\n      instance.children = instance.children.filter(child => !child.__r3f);\n    }\n    instance.__r3f.objects.forEach(child => appendChild(newInstance, child));\n    instance.__r3f.objects = [];\n    if (!instance.__r3f.autoRemovedBeforeAppend) {\n      removeChild(parent, instance);\n    }\n    if (newInstance.parent) {\n      newInstance.__r3f.autoRemovedBeforeAppend = true;\n    }\n    appendChild(parent, newInstance);\n\n    // Re-bind event handlers\n    if (newInstance.raycast && newInstance.__r3f.eventCount) {\n      const rootState = newInstance.__r3f.root.getState();\n      rootState.internal.interaction.push(newInstance);\n    }\n    [fiber, fiber.alternate].forEach(fiber => {\n      if (fiber !== null) {\n        fiber.stateNode = newInstance;\n        if (fiber.ref) {\n          if (typeof fiber.ref === 'function') fiber.ref(newInstance);else fiber.ref.current = newInstance;\n        }\n      }\n    });\n  }\n\n  // Don't handle text instances, warn on undefined behavior\n  const handleTextInstance = () => console.warn('Text is not allowed in the R3F tree! This could be stray whitespace or characters.');\n  const reconciler = Reconciler__default[\"default\"]({\n    createInstance,\n    removeChild,\n    appendChild,\n    appendInitialChild: appendChild,\n    insertBefore,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    supportsPersistence: false,\n    supportsHydration: false,\n    noTimeout: -1,\n    appendChildToContainer: (container, child) => {\n      if (!child) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n\n      // Link current root to the default scene\n      scene.__r3f.root = container;\n      appendChild(scene, child);\n    },\n    removeChildFromContainer: (container, child) => {\n      if (!child) return;\n      removeChild(container.getState().scene, child);\n    },\n    insertInContainerBefore: (container, child, beforeChild) => {\n      if (!child || !beforeChild) return;\n\n      // Don't append to unmounted container\n      const scene = container.getState().scene;\n      if (!scene.__r3f) return;\n      insertBefore(scene, child, beforeChild);\n    },\n    getRootHostContext: () => null,\n    getChildHostContext: parentHostContext => parentHostContext,\n    finalizeInitialChildren(instance) {\n      var _instance$__r3f2;\n      const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n      // https://github.com/facebook/react/issues/20271\n      // Returning true will trigger commitMount\n      return Boolean(localState.handlers);\n    },\n    prepareUpdate(instance, _type, oldProps, newProps) {\n      var _instance$__r3f3;\n      const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n\n      // Create diff-sets\n      if (localState.primitive && newProps.object && newProps.object !== instance) {\n        return [true];\n      } else {\n        // This is a data object, let's extract critical information about it\n        const {\n          args: argsNew = [],\n          children: cN,\n          ...restNew\n        } = newProps;\n        const {\n          args: argsOld = [],\n          children: cO,\n          ...restOld\n        } = oldProps;\n\n        // Throw if an object or literal was passed for args\n        if (!Array.isArray(argsNew)) throw new Error('R3F: the args prop must be an array!');\n\n        // If it has new props or arguments, then it needs to be re-instantiated\n        if (argsNew.some((value, index) => value !== argsOld[index])) return [true];\n        // Create a diff-set, flag if there are any changes\n        const diff = diffProps(instance, restNew, restOld, true);\n        if (diff.changes.length) return [false, diff];\n\n        // Otherwise do not touch the instance\n        return null;\n      }\n    },\n    commitUpdate(instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n      // Reconstruct when args or <primitive object={...} have changes\n      if (reconstruct) switchInstance(instance, type, newProps, fiber);\n      // Otherwise just overwrite props\n      else applyProps$1(instance, diff);\n    },\n    commitMount(instance, _type, _props, _int) {\n      var _instance$__r3f4;\n      // https://github.com/facebook/react/issues/20271\n      // This will make sure events are only added once to the central container\n      const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n      if (instance.raycast && localState.handlers && localState.eventCount) {\n        instance.__r3f.root.getState().internal.interaction.push(instance);\n      }\n    },\n    getPublicInstance: instance => instance,\n    prepareForCommit: () => null,\n    preparePortalMount: container => prepare(container.getState().scene),\n    resetAfterCommit: () => {},\n    shouldSetTextContent: () => false,\n    clearContainer: () => false,\n    hideInstance(instance) {\n      var _instance$__r3f5;\n      // Detach while the instance is hidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n      if (type && parent) detach(parent, instance, type);\n      if (instance.isObject3D) instance.visible = false;\n      invalidateInstance(instance);\n    },\n    unhideInstance(instance, props) {\n      var _instance$__r3f6;\n      // Re-attach when the instance is unhidden\n      const {\n        attach: type,\n        parent\n      } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n      if (type && parent) attach(parent, instance, type);\n      if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n      invalidateInstance(instance);\n    },\n    createTextInstance: handleTextInstance,\n    hideTextInstance: handleTextInstance,\n    unhideTextInstance: handleTextInstance,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n    // @ts-ignore\n    getCurrentEventPriority: () => _getEventPriority ? _getEventPriority() : constants.DefaultEventPriority,\n    beforeActiveInstanceBlur: () => {},\n    afterActiveInstanceBlur: () => {},\n    detachDeletedInstance: () => {},\n    now: typeof performance !== 'undefined' && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : () => 0,\n    // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n    scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n    cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n  });\n  return {\n    reconciler,\n    applyProps: applyProps$1\n  };\n}\n\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */\nconst hasColorSpace = object => 'colorSpace' in object || 'outputColorSpace' in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */\nconst getColorManagement = () => {\n  var _ColorManagement;\n  return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = def => def && def.isOrthographicCamera;\nconst isRef = obj => obj && obj.hasOwnProperty('current');\n\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === 'ReactNative') ? React__namespace.useLayoutEffect : React__namespace.useEffect;\nfunction useMutableCallback(fn) {\n  const ref = React__namespace.useRef(fn);\n  useIsomorphicLayoutEffect(() => void (ref.current = fn), [fn]);\n  return ref;\n}\nfunction Block({\n  set\n}) {\n  useIsomorphicLayoutEffect(() => {\n    set(new Promise(() => null));\n    return () => set(false);\n  }, [set]);\n  return null;\n}\nclass ErrorBoundary extends React__namespace.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false\n    };\n  }\n  componentDidCatch(err) {\n    this.props.set(err);\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nErrorBoundary.getDerivedStateFromError = () => ({\n  error: true\n});\nconst DEFAULT = '__default';\nconst DEFAULTS = new Map();\nconst isDiffSet = def => def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n  var _window$devicePixelRa;\n  // Err on the side of progress by assuming 2x dpr if we can't detect it\n  // This will happen in workers where window is defined but dpr isn't.\n  const target = typeof window !== 'undefined' ? (_window$devicePixelRa = window.devicePixelRatio) != null ? _window$devicePixelRa : 2 : 1;\n  return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n\n/**\r\n * Returns instance root state\r\n */\nconst getRootState = obj => {\n  var _r3f;\n  return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n// A collection of compare functions\nconst is = {\n  obj: a => a === Object(a) && !is.arr(a) && typeof a !== 'function',\n  fun: a => typeof a === 'function',\n  str: a => typeof a === 'string',\n  num: a => typeof a === 'number',\n  boo: a => typeof a === 'boolean',\n  und: a => a === void 0,\n  arr: a => Array.isArray(a),\n  equ(a, b, {\n    arrays = 'shallow',\n    objects = 'reference',\n    strict = true\n  } = {}) {\n    // Wrong type or one of the two undefined, doesn't match\n    if (typeof a !== typeof b || !!a !== !!b) return false;\n    // Atomic, just compare a against b\n    if (is.str(a) || is.num(a)) return a === b;\n    const isObj = is.obj(a);\n    if (isObj && objects === 'reference') return a === b;\n    const isArr = is.arr(a);\n    if (isArr && arrays === 'reference') return a === b;\n    // Array or Object, shallow compare first to see if it's a match\n    if ((isArr || isObj) && a === b) return true;\n    // Last resort, go through keys\n    let i;\n    // Check if a has all the keys of b\n    for (i in a) if (!(i in b)) return false;\n    // Check if values between keys match\n    if (isObj && arrays === 'shallow' && objects === 'shallow') {\n      for (i in strict ? b : a) if (!is.equ(a[i], b[i], {\n        strict,\n        objects: 'reference'\n      })) return false;\n    } else {\n      for (i in strict ? b : a) if (a[i] !== b[i]) return false;\n    }\n    // If i is undefined\n    if (is.und(i)) {\n      // If both arrays are empty we consider them equal\n      if (isArr && a.length === 0 && b.length === 0) return true;\n      // If both objects are empty we consider them equal\n      if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n      // Otherwise match them by value\n      if (a !== b) return false;\n    }\n    return true;\n  }\n};\n\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */\nfunction buildGraph(object) {\n  const data = {\n    nodes: {},\n    materials: {}\n  };\n  if (object) {\n    object.traverse(obj => {\n      if (obj.name) data.nodes[obj.name] = obj;\n      if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n    });\n  }\n  return data;\n}\n\n// Disposes an object and all its properties\nfunction dispose(obj) {\n  if (obj.dispose && obj.type !== 'Scene') obj.dispose();\n  for (const p in obj) {\n    p.dispose == null ? void 0 : p.dispose();\n    delete obj[p];\n  }\n}\n\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n  const instance = object;\n  instance.__r3f = {\n    type: '',\n    root: null,\n    previousAttach: null,\n    memoizedProps: {},\n    eventCount: 0,\n    handlers: {},\n    objects: [],\n    parent: null,\n    ...state\n  };\n  return object;\n}\nfunction resolve(instance, key) {\n  let target = instance;\n  if (key.includes('-')) {\n    const entries = key.split('-');\n    const last = entries.pop();\n    target = entries.reduce((acc, key) => acc[key], instance);\n    return {\n      target,\n      key: last\n    };\n  } else return {\n    target,\n    key\n  };\n}\n\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n  if (is.str(type)) {\n    // If attaching into an array (foo-0), create one\n    if (INDEX_REGEX.test(type)) {\n      const root = type.replace(INDEX_REGEX, '');\n      const {\n        target,\n        key\n      } = resolve(parent, root);\n      if (!Array.isArray(target[key])) target[key] = [];\n    }\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    child.__r3f.previousAttach = target[key];\n    target[key] = child;\n  } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n  var _child$__r3f, _child$__r3f2;\n  if (is.str(type)) {\n    const {\n      target,\n      key\n    } = resolve(parent, type);\n    const previous = child.__r3f.previousAttach;\n    // When the previous value was undefined, it means the value was never set to begin with\n    if (previous === undefined) delete target[key];\n    // Otherwise set the previous value\n    else target[key] = previous;\n  } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n  (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, {\n  children: cN,\n  key: kN,\n  ref: rN,\n  ...props\n}, {\n  children: cP,\n  key: kP,\n  ref: rP,\n  ...previous\n} = {}, remove = false) {\n  var _instance$__r3f;\n  const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n  const entries = Object.entries(props);\n  const changes = [];\n\n  // Catch removed props, prepend them so they can be reset or removed\n  if (remove) {\n    const previousKeys = Object.keys(previous);\n    for (let i = 0; i < previousKeys.length; i++) {\n      if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([previousKeys[i], DEFAULT + 'remove']);\n    }\n  }\n  entries.forEach(([key, value]) => {\n    var _instance$__r3f2;\n    // Bail out on primitive object\n    if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === 'object') return;\n    // When props match bail out\n    if (is.equ(value, previous[key])) return;\n    // Collect handlers and bail out\n    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([key, value, true, []]);\n    // Split dashed props\n    let entries = [];\n    if (key.includes('-')) entries = key.split('-');\n    changes.push([key, value, false, entries]);\n\n    // Reset pierced props\n    for (const prop in props) {\n      const value = props[prop];\n      if (prop.startsWith(`${key}-`)) changes.push([prop, value, false, prop.split('-')]);\n    }\n  });\n  const memoized = {\n    ...props\n  };\n  if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n  if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n  return {\n    memoized,\n    changes\n  };\n}\nconst __DEV__ = typeof process !== 'undefined' && \"development\" !== 'production';\n\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n  var _instance$__r3f3, _root$getState, _instance$__r3f4;\n  // Filter equals, events and reserved props\n  const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n  const root = localState.root;\n  const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n  const {\n    memoized,\n    changes\n  } = isDiffSet(data) ? data : diffProps(instance, data);\n  const prevHandlers = localState.eventCount;\n\n  // Prepare memoized props\n  if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n  for (let i = 0; i < changes.length; i++) {\n    let [key, value, isEvent, keys] = changes[i];\n\n    // Alias (output)encoding => (output)colorSpace (since r152)\n    // https://github.com/pmndrs/react-three-fiber/pull/2829\n    if (hasColorSpace(instance)) {\n      const sRGBEncoding = 3001;\n      const SRGBColorSpace = 'srgb';\n      const LinearSRGBColorSpace = 'srgb-linear';\n      if (key === 'encoding') {\n        key = 'colorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      } else if (key === 'outputEncoding') {\n        key = 'outputColorSpace';\n        value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n      }\n    }\n    let currentInstance = instance;\n    let targetProp = currentInstance[key];\n\n    // Revolve dashed props\n    if (keys.length) {\n      targetProp = keys.reduce((acc, key) => acc[key], instance);\n      // If the target is atomic, it forces us to switch the root\n      if (!(targetProp && targetProp.set)) {\n        const [name, ...reverseEntries] = keys.reverse();\n        currentInstance = reverseEntries.reverse().reduce((acc, key) => acc[key], instance);\n        key = name;\n      }\n    }\n\n    // https://github.com/mrdoob/three.js/issues/21209\n    // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n    // has no means to do this. Hence we curate a small collection of value-classes\n    // with their respective constructor/set arguments\n    // For removed props, try to set default values, if possible\n    if (value === DEFAULT + 'remove') {\n      if (currentInstance.constructor) {\n        // create a blank slate of the instance and copy the particular parameter.\n        let ctor = DEFAULTS.get(currentInstance.constructor);\n        if (!ctor) {\n          // @ts-ignore\n          ctor = new currentInstance.constructor();\n          DEFAULTS.set(currentInstance.constructor, ctor);\n        }\n        value = ctor[key];\n      } else {\n        // instance does not have constructor, just set it to 0\n        value = 0;\n      }\n    }\n\n    // Deal with pointer events ...\n    if (isEvent) {\n      if (value) localState.handlers[key] = value;else delete localState.handlers[key];\n      localState.eventCount = Object.keys(localState.handlers).length;\n    }\n    // Special treatment for objects with support for set/copy, and layers\n    else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof THREE__namespace.Layers)) {\n      // If value is an array\n      if (Array.isArray(value)) {\n        if (targetProp.fromArray) targetProp.fromArray(value);else targetProp.set(...value);\n      }\n      // Test again target.copy(class) next ...\n      else if (targetProp.copy && value && value.constructor && (\n      // Some environments may break strict identity checks by duplicating versions of three.js.\n      // Loosen to unminified names, ignoring descendents.\n      // https://github.com/pmndrs/react-three-fiber/issues/2856\n      // TODO: fix upstream and remove in v9\n      __DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n        targetProp.copy(value);\n      }\n      // If nothing else fits, just set the single value, ignore undefined\n      // https://github.com/pmndrs/react-three-fiber/issues/274\n      else if (value !== undefined) {\n        const isColor = targetProp instanceof THREE__namespace.Color;\n        // Allow setting array scalars\n        if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n        // Layers have no copy function, we must therefore copy the mask property\n        else if (targetProp instanceof THREE__namespace.Layers && value instanceof THREE__namespace.Layers) targetProp.mask = value.mask;\n        // Otherwise just set ...\n        else targetProp.set(value);\n        // For versions of three which don't support THREE.ColorManagement,\n        // Auto-convert sRGB colors\n        // https://github.com/pmndrs/react-three-fiber/issues/344\n        if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n      }\n      // Else, just overwrite the value\n    } else {\n      currentInstance[key] = value;\n\n      // Auto-convert sRGB textures, for now ...\n      // https://github.com/pmndrs/react-three-fiber/issues/344\n      if (currentInstance[key] instanceof THREE__namespace.Texture &&\n      // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n      currentInstance[key].format === THREE__namespace.RGBAFormat && currentInstance[key].type === THREE__namespace.UnsignedByteType) {\n        const texture = currentInstance[key];\n        if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;else texture.encoding = rootState.gl.outputEncoding;\n      }\n    }\n    invalidateInstance(instance);\n  }\n  if (localState.parent && rootState.internal && instance.raycast && prevHandlers !== localState.eventCount) {\n    // Pre-emptively remove the instance from the interaction manager\n    const index = rootState.internal.interaction.indexOf(instance);\n    if (index > -1) rootState.internal.interaction.splice(index, 1);\n    // Add the instance to the interaction manager only when it has handlers\n    if (localState.eventCount) rootState.internal.interaction.push(instance);\n  }\n\n  // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n  // Skip updates to the `onUpdate` prop itself\n  const isCircular = changes.length === 1 && changes[0][0] === 'onUpdate';\n  if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n  return instance;\n}\nfunction invalidateInstance(instance) {\n  var _instance$__r3f5, _instance$__r3f5$root;\n  const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n  if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n  instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n  // https://github.com/pmndrs/react-three-fiber/issues/92\n  // Do not mess with the camera if it belongs to the user\n  if (!camera.manual) {\n    if (isOrthographicCamera(camera)) {\n      camera.left = size.width / -2;\n      camera.right = size.width / 2;\n      camera.top = size.height / 2;\n      camera.bottom = size.height / -2;\n    } else {\n      camera.aspect = size.width / size.height;\n    }\n    camera.updateProjectionMatrix();\n    // https://github.com/pmndrs/react-three-fiber/issues/178\n    // Update matrix world since the renderer is a frame late\n    camera.updateMatrixWorld();\n  }\n}\n\nfunction makeId(event) {\n  return (event.eventObject || event.object).uuid + '/' + event.index + event.instanceId;\n}\n\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n  var _globalScope$event;\n  // Get a handle to the current global scope in window and worker contexts if able\n  // https://github.com/pmndrs/react-three-fiber/pull/2493\n  const globalScope = typeof self !== 'undefined' && self || typeof window !== 'undefined' && window;\n  if (!globalScope) return constants.DefaultEventPriority;\n  const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n  switch (name) {\n    case 'click':\n    case 'contextmenu':\n    case 'dblclick':\n    case 'pointercancel':\n    case 'pointerdown':\n    case 'pointerup':\n      return constants.DiscreteEventPriority;\n    case 'pointermove':\n    case 'pointerout':\n    case 'pointerover':\n    case 'pointerenter':\n    case 'pointerleave':\n    case 'wheel':\n      return constants.ContinuousEventPriority;\n    default:\n      return constants.DefaultEventPriority;\n  }\n}\n\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */\nfunction releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n  const captureData = captures.get(obj);\n  if (captureData) {\n    captures.delete(obj);\n    // If this was the last capturing object for this pointer\n    if (captures.size === 0) {\n      capturedMap.delete(pointerId);\n      captureData.target.releasePointerCapture(pointerId);\n    }\n  }\n}\nfunction removeInteractivity(store, object) {\n  const {\n    internal\n  } = store.getState();\n  // Removes every trace of an object from the data store\n  internal.interaction = internal.interaction.filter(o => o !== object);\n  internal.initialHits = internal.initialHits.filter(o => o !== object);\n  internal.hovered.forEach((value, key) => {\n    if (value.eventObject === object || value.object === object) {\n      // Clear out intersects, they are outdated by now\n      internal.hovered.delete(key);\n    }\n  });\n  internal.capturedMap.forEach((captures, pointerId) => {\n    releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n  });\n}\nfunction createEvents(store) {\n  /** Calculates delta */\n  function calculateDistance(event) {\n    const {\n      internal\n    } = store.getState();\n    const dx = event.offsetX - internal.initialClick[0];\n    const dy = event.offsetY - internal.initialClick[1];\n    return Math.round(Math.sqrt(dx * dx + dy * dy));\n  }\n\n  /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */\n  function filterPointerEvents(objects) {\n    return objects.filter(obj => ['Move', 'Over', 'Enter', 'Out', 'Leave'].some(name => {\n      var _r3f;\n      return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers['onPointer' + name];\n    }));\n  }\n  function intersect(event, filter) {\n    const state = store.getState();\n    const duplicates = new Set();\n    const intersections = [];\n    // Allow callers to eliminate event objects\n    const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n    // Reset all raycaster cameras to undefined\n    for (let i = 0; i < eventsObjects.length; i++) {\n      const state = getRootState(eventsObjects[i]);\n      if (state) {\n        state.raycaster.camera = undefined;\n      }\n    }\n    if (!state.previousRoot) {\n      // Make sure root-level pointer and ray are set up\n      state.events.compute == null ? void 0 : state.events.compute(event, state);\n    }\n    function handleRaycast(obj) {\n      const state = getRootState(obj);\n      // Skip event handling when noEvents is set, or when the raycasters camera is null\n      if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n\n      // When the camera is undefined we have to call the event layers update function\n      if (state.raycaster.camera === undefined) {\n        var _state$previousRoot;\n        state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n        // If the camera is still undefined we have to skip this layer entirely\n        if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n      }\n\n      // Intersect object by object\n      return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n    }\n\n    // Collect events\n    let hits = eventsObjects\n    // Intersect objects\n    .flatMap(handleRaycast)\n    // Sort by event priority and distance\n    .sort((a, b) => {\n      const aState = getRootState(a.object);\n      const bState = getRootState(b.object);\n      if (!aState || !bState) return a.distance - b.distance;\n      return bState.events.priority - aState.events.priority || a.distance - b.distance;\n    })\n    // Filter out duplicates\n    .filter(item => {\n      const id = makeId(item);\n      if (duplicates.has(id)) return false;\n      duplicates.add(id);\n      return true;\n    });\n\n    // https://github.com/mrdoob/three.js/issues/16031\n    // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n    if (state.events.filter) hits = state.events.filter(hits, state);\n\n    // Bubble up the events, find the event source (eventObject)\n    for (const hit of hits) {\n      let eventObject = hit.object;\n      // Bubble event up\n      while (eventObject) {\n        var _r3f2;\n        if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n          ...hit,\n          eventObject\n        });\n        eventObject = eventObject.parent;\n      }\n    }\n\n    // If the interaction is captured, make all capturing targets part of the intersect.\n    if ('pointerId' in event && state.internal.capturedMap.has(event.pointerId)) {\n      for (let captureData of state.internal.capturedMap.get(event.pointerId).values()) {\n        if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n      }\n    }\n    return intersections;\n  }\n\n  /**  Handles intersections by forwarding them to handlers */\n  function handleIntersects(intersections, event, delta, callback) {\n    const rootState = store.getState();\n\n    // If anything has been found, forward it to the event listeners\n    if (intersections.length) {\n      const localState = {\n        stopped: false\n      };\n      for (const hit of intersections) {\n        const state = getRootState(hit.object) || rootState;\n        const {\n          raycaster,\n          pointer,\n          camera,\n          internal\n        } = state;\n        const unprojectedPoint = new THREE__namespace.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n        const hasPointerCapture = id => {\n          var _internal$capturedMap, _internal$capturedMap2;\n          return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n        };\n        const setPointerCapture = id => {\n          const captureData = {\n            intersection: hit,\n            target: event.target\n          };\n          if (internal.capturedMap.has(id)) {\n            // if the pointerId was previously captured, we add the hit to the\n            // event capturedMap.\n            internal.capturedMap.get(id).set(hit.eventObject, captureData);\n          } else {\n            // if the pointerId was not previously captured, we create a map\n            // containing the hitObject, and the hit. hitObject is used for\n            // faster access.\n            internal.capturedMap.set(id, new Map([[hit.eventObject, captureData]]));\n          }\n          event.target.setPointerCapture(id);\n        };\n        const releasePointerCapture = id => {\n          const captures = internal.capturedMap.get(id);\n          if (captures) {\n            releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n          }\n        };\n\n        // Add native event props\n        let extractEventProps = {};\n        // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n        for (let prop in event) {\n          let property = event[prop];\n          // Only copy over atomics, leave functions alone as these should be\n          // called as event.nativeEvent.fn()\n          if (typeof property !== 'function') extractEventProps[prop] = property;\n        }\n        let raycastEvent = {\n          ...hit,\n          ...extractEventProps,\n          pointer,\n          intersections,\n          stopped: localState.stopped,\n          delta,\n          unprojectedPoint,\n          ray: raycaster.ray,\n          camera: camera,\n          // Hijack stopPropagation, which just sets a flag\n          stopPropagation() {\n            // https://github.com/pmndrs/react-three-fiber/issues/596\n            // Events are not allowed to stop propagation if the pointer has been captured\n            const capturesForPointer = 'pointerId' in event && internal.capturedMap.get(event.pointerId);\n\n            // We only authorize stopPropagation...\n            if (\n            // ...if this pointer hasn't been captured\n            !capturesForPointer ||\n            // ... or if the hit object is capturing the pointer\n            capturesForPointer.has(hit.eventObject)) {\n              raycastEvent.stopped = localState.stopped = true;\n              // Propagation is stopped, remove all other hover records\n              // An event handler is only allowed to flush other handlers if it is hovered itself\n              if (internal.hovered.size && Array.from(internal.hovered.values()).find(i => i.eventObject === hit.eventObject)) {\n                // Objects cannot flush out higher up objects that have already caught the event\n                const higher = intersections.slice(0, intersections.indexOf(hit));\n                cancelPointer([...higher, hit]);\n              }\n            }\n          },\n          // there should be a distinction between target and currentTarget\n          target: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          currentTarget: {\n            hasPointerCapture,\n            setPointerCapture,\n            releasePointerCapture\n          },\n          nativeEvent: event\n        };\n\n        // Call subscribers\n        callback(raycastEvent);\n        // Event bubbling may be interrupted by stopPropagation\n        if (localState.stopped === true) break;\n      }\n    }\n    return intersections;\n  }\n  function cancelPointer(intersections) {\n    const {\n      internal\n    } = store.getState();\n    for (const hoveredObj of internal.hovered.values()) {\n      // When no objects were hit or the the hovered object wasn't found underneath the cursor\n      // we call onPointerOut and delete the object from the hovered-elements map\n      if (!intersections.length || !intersections.find(hit => hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n        const eventObject = hoveredObj.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n        internal.hovered.delete(makeId(hoveredObj));\n        if (instance != null && instance.eventCount) {\n          // Clear out intersects, they are outdated by now\n          const data = {\n            ...hoveredObj,\n            intersections\n          };\n          handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n          handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n        }\n      }\n    }\n  }\n  function pointerMissed(event, objects) {\n    for (let i = 0; i < objects.length; i++) {\n      const instance = objects[i].__r3f;\n      instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n    }\n  }\n  function handlePointer(name) {\n    // Deal with cancelation\n    switch (name) {\n      case 'onPointerLeave':\n      case 'onPointerCancel':\n        return () => cancelPointer([]);\n      case 'onLostPointerCapture':\n        return event => {\n          const {\n            internal\n          } = store.getState();\n          if ('pointerId' in event && internal.capturedMap.has(event.pointerId)) {\n            // If the object event interface had onLostPointerCapture, we'd call it here on every\n            // object that's getting removed. We call it on the next frame because onLostPointerCapture\n            // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n            // happen in the object it originated from, leaving components in a in-between state.\n            requestAnimationFrame(() => {\n              // Only release if pointer-up didn't do it already\n              if (internal.capturedMap.has(event.pointerId)) {\n                internal.capturedMap.delete(event.pointerId);\n                cancelPointer([]);\n              }\n            });\n          }\n        };\n    }\n\n    // Any other pointer goes here ...\n    return function handleEvent(event) {\n      const {\n        onPointerMissed,\n        internal\n      } = store.getState();\n\n      // prepareRay(event)\n      internal.lastEvent.current = event;\n\n      // Get fresh intersects\n      const isPointerMove = name === 'onPointerMove';\n      const isClickEvent = name === 'onClick' || name === 'onContextMenu' || name === 'onDoubleClick';\n      const filter = isPointerMove ? filterPointerEvents : undefined;\n      const hits = intersect(event, filter);\n      const delta = isClickEvent ? calculateDistance(event) : 0;\n\n      // Save initial coordinates on pointer-down\n      if (name === 'onPointerDown') {\n        internal.initialClick = [event.offsetX, event.offsetY];\n        internal.initialHits = hits.map(hit => hit.eventObject);\n      }\n\n      // If a click yields no results, pass it back to the user as a miss\n      // Missed events have to come first in order to establish user-land side-effect clean up\n      if (isClickEvent && !hits.length) {\n        if (delta <= 2) {\n          pointerMissed(event, internal.interaction);\n          if (onPointerMissed) onPointerMissed(event);\n        }\n      }\n      // Take care of unhover\n      if (isPointerMove) cancelPointer(hits);\n      function onIntersect(data) {\n        const eventObject = data.eventObject;\n        const instance = eventObject.__r3f;\n        const handlers = instance == null ? void 0 : instance.handlers;\n\n        // Check presence of handlers\n        if (!(instance != null && instance.eventCount)) return;\n\n        /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/\n\n        if (isPointerMove) {\n          // Move event ...\n          if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n            // When enter or out is present take care of hover-state\n            const id = makeId(data);\n            const hoveredItem = internal.hovered.get(id);\n            if (!hoveredItem) {\n              // If the object wasn't previously hovered, book it and call its handler\n              internal.hovered.set(id, data);\n              handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n              handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n            } else if (hoveredItem.stopped) {\n              // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n              data.stopPropagation();\n            }\n          }\n          // Call mouse move\n          handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n        } else {\n          // All other events ...\n          const handler = handlers[name];\n          if (handler) {\n            // Forward all events back to their respective handlers with the exception of click events,\n            // which must use the initial target\n            if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n              // Missed events have to come first\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n              // Now call the handler\n              handler(data);\n            }\n          } else {\n            // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n            if (isClickEvent && internal.initialHits.includes(eventObject)) {\n              pointerMissed(event, internal.interaction.filter(object => !internal.initialHits.includes(object)));\n            }\n          }\n        }\n      }\n      handleIntersects(hits, event, delta, onIntersect);\n    };\n  }\n  return {\n    handlePointer\n  };\n}\n\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = ['set', 'get', 'setSize', 'setFrameloop', 'setDpr', 'events', 'invalidate', 'advance', 'size', 'viewport'];\nconst isRenderer = def => !!(def != null && def.render);\nconst context = /*#__PURE__*/React__namespace.createContext(null);\nconst createStore = (invalidate, advance) => {\n  const rootState = create__default[\"default\"]((set, get) => {\n    const position = new THREE__namespace.Vector3();\n    const defaultTarget = new THREE__namespace.Vector3();\n    const tempTarget = new THREE__namespace.Vector3();\n    function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n      const {\n        width,\n        height,\n        top,\n        left\n      } = size;\n      const aspect = width / height;\n      if (target instanceof THREE__namespace.Vector3) tempTarget.copy(target);else tempTarget.set(...target);\n      const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n      if (isOrthographicCamera(camera)) {\n        return {\n          width: width / camera.zoom,\n          height: height / camera.zoom,\n          top,\n          left,\n          factor: 1,\n          distance,\n          aspect\n        };\n      } else {\n        const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n        const h = 2 * Math.tan(fov / 2) * distance; // visible height\n        const w = h * (width / height);\n        return {\n          width: w,\n          height: h,\n          top,\n          left,\n          factor: width / w,\n          distance,\n          aspect\n        };\n      }\n    }\n    let performanceTimeout = undefined;\n    const setPerformanceCurrent = current => set(state => ({\n      performance: {\n        ...state.performance,\n        current\n      }\n    }));\n    const pointer = new THREE__namespace.Vector2();\n    const rootState = {\n      set,\n      get,\n      // Mock objects that have to be configured\n      gl: null,\n      camera: null,\n      raycaster: null,\n      events: {\n        priority: 1,\n        enabled: true,\n        connected: false\n      },\n      xr: null,\n      scene: null,\n      invalidate: (frames = 1) => invalidate(get(), frames),\n      advance: (timestamp, runGlobalEffects) => advance(timestamp, runGlobalEffects, get()),\n      legacy: false,\n      linear: false,\n      flat: false,\n      controls: null,\n      clock: new THREE__namespace.Clock(),\n      pointer,\n      mouse: pointer,\n      frameloop: 'always',\n      onPointerMissed: undefined,\n      performance: {\n        current: 1,\n        min: 0.5,\n        max: 1,\n        debounce: 200,\n        regress: () => {\n          const state = get();\n          // Clear timeout\n          if (performanceTimeout) clearTimeout(performanceTimeout);\n          // Set lower bound performance\n          if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n          // Go back to upper bound performance after a while unless something regresses meanwhile\n          performanceTimeout = setTimeout(() => setPerformanceCurrent(get().performance.max), state.performance.debounce);\n        }\n      },\n      size: {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        updateStyle: false\n      },\n      viewport: {\n        initialDpr: 0,\n        dpr: 0,\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        aspect: 0,\n        distance: 0,\n        factor: 0,\n        getCurrentViewport\n      },\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      })),\n      setSize: (width, height, updateStyle, top, left) => {\n        const camera = get().camera;\n        const size = {\n          width,\n          height,\n          top: top || 0,\n          left: left || 0,\n          updateStyle\n        };\n        set(state => ({\n          size,\n          viewport: {\n            ...state.viewport,\n            ...getCurrentViewport(camera, defaultTarget, size)\n          }\n        }));\n      },\n      setDpr: dpr => set(state => {\n        const resolved = calculateDpr(dpr);\n        return {\n          viewport: {\n            ...state.viewport,\n            dpr: resolved,\n            initialDpr: state.viewport.initialDpr || resolved\n          }\n        };\n      }),\n      setFrameloop: (frameloop = 'always') => {\n        const clock = get().clock;\n\n        // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n        clock.stop();\n        clock.elapsedTime = 0;\n        if (frameloop !== 'never') {\n          clock.start();\n          clock.elapsedTime = 0;\n        }\n        set(() => ({\n          frameloop\n        }));\n      },\n      previousRoot: undefined,\n      internal: {\n        active: false,\n        priority: 0,\n        frames: 0,\n        lastEvent: /*#__PURE__*/React__namespace.createRef(),\n        interaction: [],\n        hovered: new Map(),\n        subscribers: [],\n        initialClick: [0, 0],\n        initialHits: [],\n        capturedMap: new Map(),\n        subscribe: (ref, priority, store) => {\n          const internal = get().internal;\n          // If this subscription was given a priority, it takes rendering into its own hands\n          // For that reason we switch off automatic rendering and increase the manual flag\n          // As long as this flag is positive there can be no internal rendering at all\n          // because there could be multiple render subscriptions\n          internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n          internal.subscribers.push({\n            ref,\n            priority,\n            store\n          });\n          // Register subscriber and sort layers from lowest to highest, meaning,\n          // highest priority renders last (on top of the other frames)\n          internal.subscribers = internal.subscribers.sort((a, b) => a.priority - b.priority);\n          return () => {\n            const internal = get().internal;\n            if (internal != null && internal.subscribers) {\n              // Decrease manual flag if this subscription had a priority\n              internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n              // Remove subscriber from list\n              internal.subscribers = internal.subscribers.filter(s => s.ref !== ref);\n            }\n          };\n        }\n      }\n    };\n    return rootState;\n  });\n  const state = rootState.getState();\n  let oldSize = state.size;\n  let oldDpr = state.viewport.dpr;\n  let oldCamera = state.camera;\n  rootState.subscribe(() => {\n    const {\n      camera,\n      size,\n      viewport,\n      gl,\n      set\n    } = rootState.getState();\n\n    // Resize camera and renderer on changes to size and pixelratio\n    if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n      var _size$updateStyle;\n      oldSize = size;\n      oldDpr = viewport.dpr;\n      // Update camera & renderer\n      updateCamera(camera, size);\n      gl.setPixelRatio(viewport.dpr);\n      const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== 'undefined' && gl.domElement instanceof HTMLCanvasElement;\n      gl.setSize(size.width, size.height, updateStyle);\n    }\n\n    // Update viewport once the camera changes\n    if (camera !== oldCamera) {\n      oldCamera = camera;\n      // Update viewport\n      set(state => ({\n        viewport: {\n          ...state.viewport,\n          ...state.viewport.getCurrentViewport(camera)\n        }\n      }));\n    }\n  });\n\n  // Invalidate on any change\n  rootState.subscribe(state => invalidate(state));\n\n  // Return root state\n  return rootState;\n};\n\nfunction createSubs(callback, subs) {\n  const sub = {\n    callback\n  };\n  subs.add(sub);\n  return () => void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */\nconst addEffect = callback => createSubs(callback, globalEffects);\n\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */\nconst addAfterEffect = callback => createSubs(callback, globalAfterEffects);\n\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */\nconst addTail = callback => createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n  if (!effects.size) return;\n  for (const {\n    callback\n  } of effects.values()) {\n    callback(timestamp);\n  }\n}\nfunction flushGlobalEffects(type, timestamp) {\n  switch (type) {\n    case 'before':\n      return run(globalEffects, timestamp);\n    case 'after':\n      return run(globalAfterEffects, timestamp);\n    case 'tail':\n      return run(globalTailEffects, timestamp);\n  }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n  // Run local effects\n  let delta = state.clock.getDelta();\n  // In frameloop='never' mode, clock times are updated using the provided timestamp\n  if (state.frameloop === 'never' && typeof timestamp === 'number') {\n    delta = timestamp - state.clock.elapsedTime;\n    state.clock.oldTime = state.clock.elapsedTime;\n    state.clock.elapsedTime = timestamp;\n  }\n  // Call subscribers (useFrame)\n  subscribers = state.internal.subscribers;\n  for (i = 0; i < subscribers.length; i++) {\n    subscription = subscribers[i];\n    subscription.ref.current(subscription.store.getState(), delta, frame);\n  }\n  // Render content\n  if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n  // Decrease frame count\n  state.internal.frames = Math.max(0, state.internal.frames - 1);\n  return state.frameloop === 'always' ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n  let running = false;\n  let repeat;\n  let frame;\n  let state;\n  function loop(timestamp) {\n    frame = requestAnimationFrame(loop);\n    running = true;\n    repeat = 0;\n\n    // Run effects\n    flushGlobalEffects('before', timestamp);\n\n    // Render all roots\n    for (const root of roots.values()) {\n      var _state$gl$xr;\n      state = root.store.getState();\n      // If the frameloop is invalidated, do not run another frame\n      if (state.internal.active && (state.frameloop === 'always' || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n        repeat += render$1(timestamp, state);\n      }\n    }\n\n    // Run after-effects\n    flushGlobalEffects('after', timestamp);\n\n    // Stop the loop if nothing invalidates it\n    if (repeat === 0) {\n      // Tail call effects, they are called when rendering stops\n      flushGlobalEffects('tail', timestamp);\n\n      // Flag end of operation\n      running = false;\n      return cancelAnimationFrame(frame);\n    }\n  }\n  function invalidate(state, frames = 1) {\n    var _state$gl$xr2;\n    if (!state) return roots.forEach(root => invalidate(root.store.getState()), frames);\n    if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === 'never') return;\n    // Increase frames, do not go higher than 60\n    state.internal.frames = Math.min(60, state.internal.frames + frames);\n    // If the render-loop isn't active, start it\n    if (!running) {\n      running = true;\n      requestAnimationFrame(loop);\n    }\n  }\n  function advance(timestamp, runGlobalEffects = true, state, frame) {\n    if (runGlobalEffects) flushGlobalEffects('before', timestamp);\n    if (!state) for (const root of roots.values()) render$1(timestamp, root.store.getState());else render$1(timestamp, state, frame);\n    if (runGlobalEffects) flushGlobalEffects('after', timestamp);\n  }\n  return {\n    loop,\n    /**\r\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\r\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\r\n     */\n    invalidate,\n    /**\r\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\r\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\r\n     */\n    advance\n  };\n}\n\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */\nfunction useInstanceHandle(ref) {\n  const instance = React__namespace.useRef(null);\n  useIsomorphicLayoutEffect(() => void (instance.current = ref.current.__r3f), [ref]);\n  return instance;\n}\nfunction useStore() {\n  const store = React__namespace.useContext(context);\n  if (!store) throw new Error('R3F: Hooks can only be used within the Canvas component!');\n  return store;\n}\n\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */\nfunction useThree(selector = state => state, equalityFn) {\n  return useStore()(selector, equalityFn);\n}\n\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */\nfunction useFrame(callback, renderPriority = 0) {\n  const store = useStore();\n  const subscribe = store.getState().internal.subscribe;\n  // Memoize ref\n  const ref = useMutableCallback(callback);\n  // Subscribe on mount, unsubscribe on unmount\n  useIsomorphicLayoutEffect(() => subscribe(ref, renderPriority, store), [renderPriority, subscribe, store]);\n  return null;\n}\n\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */\nfunction useGraph(object) {\n  return React__namespace.useMemo(() => buildGraph(object), [object]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n  return function (Proto, ...input) {\n    // Construct new loader and run extensions\n    let loader = memoizedLoaders.get(Proto);\n    if (!loader) {\n      loader = new Proto();\n      memoizedLoaders.set(Proto, loader);\n    }\n    if (extensions) extensions(loader);\n    // Go through the urls and load them\n    return Promise.all(input.map(input => new Promise((res, reject) => loader.load(input, data => {\n      if (data.scene) Object.assign(data, buildGraph(data.scene));\n      res(data);\n    }, onProgress, error => reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`)))))).finally(() => loader.dispose == null ? void 0 : loader.dispose());\n  };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */\nfunction useLoader(Proto, input, extensions, onProgress) {\n  // Use suspense to load async assets\n  const keys = Array.isArray(input) ? input : [input];\n  const results = suspendReact.suspend(loadingFn(extensions, onProgress), [Proto, ...keys], {\n    equal: is.equ\n  });\n  // Return the object/s\n  return Array.isArray(input) ? results : results[0];\n}\n\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */\nuseLoader.preload = function (Proto, input, extensions) {\n  const keys = Array.isArray(input) ? input : [input];\n  return suspendReact.preload(loadingFn(extensions), [Proto, ...keys]);\n};\n\n/**\r\n * Removes a loaded asset from cache.\r\n */\nuseLoader.clear = function (Proto, input) {\n  const keys = Array.isArray(input) ? input : [input];\n  return suspendReact.clear([Proto, ...keys]);\n};\n\nconst roots = new Map();\nconst {\n  invalidate,\n  advance\n} = createLoop(roots);\nconst {\n  reconciler,\n  applyProps\n} = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n  objects: 'shallow',\n  strict: false\n};\nconst createRendererInstance = (gl, canvas) => {\n  const customRenderer = typeof gl === 'function' ? gl(canvas) : gl;\n  if (isRenderer(customRenderer)) return customRenderer;else return new THREE__namespace.WebGLRenderer({\n    powerPreference: 'high-performance',\n    canvas: canvas,\n    antialias: true,\n    alpha: true,\n    ...gl\n  });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n  const defaultStyle = typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement;\n  if (defaultSize) {\n    const {\n      width,\n      height,\n      top,\n      left,\n      updateStyle = defaultStyle\n    } = defaultSize;\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle\n    };\n  } else if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n    const {\n      width,\n      height,\n      top,\n      left\n    } = canvas.parentElement.getBoundingClientRect();\n    return {\n      width,\n      height,\n      top,\n      left,\n      updateStyle: defaultStyle\n    };\n  } else if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    return {\n      width: canvas.width,\n      height: canvas.height,\n      top: 0,\n      left: 0,\n      updateStyle: defaultStyle\n    };\n  }\n  return {\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0\n  };\n}\nfunction createRoot(canvas) {\n  // Check against mistaken use of createRoot\n  const prevRoot = roots.get(canvas);\n  const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n  const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n  if (prevRoot) console.warn('R3F.createRoot should only be called once!');\n\n  // Report when an error was detected in a previous render\n  // https://github.com/pmndrs/react-three-fiber/pull/2261\n  const logRecoverableError = typeof reportError === 'function' ?\n  // In modern browsers, reportError will dispatch an error event,\n  // emulating an uncaught JavaScript error.\n  reportError :\n  // In older browsers and test environments, fallback to console.error.\n  console.error;\n\n  // Create store\n  const store = prevStore || createStore(invalidate, advance);\n  // Create renderer\n  const fiber = prevFiber || reconciler.createContainer(store, constants.ConcurrentRoot, null, false, null, '', logRecoverableError, null);\n  // Map it\n  if (!prevRoot) roots.set(canvas, {\n    fiber,\n    store\n  });\n\n  // Locals\n  let onCreated;\n  let configured = false;\n  let lastCamera;\n  return {\n    configure(props = {}) {\n      let {\n        gl: glConfig,\n        size: propsSize,\n        scene: sceneOptions,\n        events,\n        onCreated: onCreatedCallback,\n        shadows = false,\n        linear = false,\n        flat = false,\n        legacy = false,\n        orthographic = false,\n        frameloop = 'always',\n        dpr = [1, 2],\n        performance,\n        raycaster: raycastOptions,\n        camera: cameraOptions,\n        onPointerMissed\n      } = props;\n      let state = store.getState();\n\n      // Set up renderer (one time only!)\n      let gl = state.gl;\n      if (!state.gl) state.set({\n        gl: gl = createRendererInstance(glConfig, canvas)\n      });\n\n      // Set up raycaster (one time only!)\n      let raycaster = state.raycaster;\n      if (!raycaster) state.set({\n        raycaster: raycaster = new THREE__namespace.Raycaster()\n      });\n\n      // Set raycaster options\n      const {\n        params,\n        ...options\n      } = raycastOptions || {};\n      if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n        ...options\n      });\n      if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n        params: {\n          ...raycaster.params,\n          ...params\n        }\n      });\n\n      // Create default camera, don't overwrite any user-set state\n      if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n        lastCamera = cameraOptions;\n        const isCamera = cameraOptions instanceof THREE__namespace.Camera;\n        const camera = isCamera ? cameraOptions : orthographic ? new THREE__namespace.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new THREE__namespace.PerspectiveCamera(75, 0, 0.1, 1000);\n        if (!isCamera) {\n          camera.position.z = 5;\n          if (cameraOptions) applyProps(camera, cameraOptions);\n          // Always look at center by default\n          if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n        }\n        state.set({\n          camera\n        });\n\n        // Configure raycaster\n        // https://github.com/pmndrs/react-xr/issues/300\n        raycaster.camera = camera;\n      }\n\n      // Set up scene (one time only!)\n      if (!state.scene) {\n        let scene;\n        if (sceneOptions instanceof THREE__namespace.Scene) {\n          scene = sceneOptions;\n        } else {\n          scene = new THREE__namespace.Scene();\n          if (sceneOptions) applyProps(scene, sceneOptions);\n        }\n        state.set({\n          scene: prepare(scene)\n        });\n      }\n\n      // Set up XR (one time only!)\n      if (!state.xr) {\n        var _gl$xr;\n        // Handle frame behavior in WebXR\n        const handleXRFrame = (timestamp, frame) => {\n          const state = store.getState();\n          if (state.frameloop === 'never') return;\n          advance(timestamp, true, state, frame);\n        };\n\n        // Toggle render switching on session\n        const handleSessionChange = () => {\n          const state = store.getState();\n          state.gl.xr.enabled = state.gl.xr.isPresenting;\n          state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n          if (!state.gl.xr.isPresenting) invalidate(state);\n        };\n\n        // WebXR session manager\n        const xr = {\n          connect() {\n            const gl = store.getState().gl;\n            gl.xr.addEventListener('sessionstart', handleSessionChange);\n            gl.xr.addEventListener('sessionend', handleSessionChange);\n          },\n          disconnect() {\n            const gl = store.getState().gl;\n            gl.xr.removeEventListener('sessionstart', handleSessionChange);\n            gl.xr.removeEventListener('sessionend', handleSessionChange);\n          }\n        };\n\n        // Subscribe to WebXR session events\n        if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === 'function') xr.connect();\n        state.set({\n          xr\n        });\n      }\n\n      // Set shadowmap\n      if (gl.shadowMap) {\n        const oldEnabled = gl.shadowMap.enabled;\n        const oldType = gl.shadowMap.type;\n        gl.shadowMap.enabled = !!shadows;\n        if (is.boo(shadows)) {\n          gl.shadowMap.type = THREE__namespace.PCFSoftShadowMap;\n        } else if (is.str(shadows)) {\n          var _types$shadows;\n          const types = {\n            basic: THREE__namespace.BasicShadowMap,\n            percentage: THREE__namespace.PCFShadowMap,\n            soft: THREE__namespace.PCFSoftShadowMap,\n            variance: THREE__namespace.VSMShadowMap\n          };\n          gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : THREE__namespace.PCFSoftShadowMap;\n        } else if (is.obj(shadows)) {\n          Object.assign(gl.shadowMap, shadows);\n        }\n        if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n      }\n\n      // Safely set color management if available.\n      // Avoid accessing THREE.ColorManagement to play nice with older versions\n      const ColorManagement = getColorManagement();\n      if (ColorManagement) {\n        if ('enabled' in ColorManagement) ColorManagement.enabled = !legacy;else if ('legacyMode' in ColorManagement) ColorManagement.legacyMode = legacy;\n      }\n\n      // Set color space and tonemapping preferences\n      const LinearEncoding = 3000;\n      const sRGBEncoding = 3001;\n      applyProps(gl, {\n        outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n        toneMapping: flat ? THREE__namespace.NoToneMapping : THREE__namespace.ACESFilmicToneMapping\n      });\n\n      // Update color management state\n      if (state.legacy !== legacy) state.set(() => ({\n        legacy\n      }));\n      if (state.linear !== linear) state.set(() => ({\n        linear\n      }));\n      if (state.flat !== flat) state.set(() => ({\n        flat\n      }));\n\n      // Set gl props\n      if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n      // Store events internally\n      if (events && !state.events.handlers) state.set({\n        events: events(store)\n      });\n      // Check size, allow it to take on container bounds initially\n      const size = computeInitialSize(canvas, propsSize);\n      if (!is.equ(size, state.size, shallowLoose)) {\n        state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n      }\n      // Check pixelratio\n      if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n      // Check frameloop\n      if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n      // Check pointer missed\n      if (!state.onPointerMissed) state.set({\n        onPointerMissed\n      });\n      // Check performance\n      if (performance && !is.equ(performance, state.performance, shallowLoose)) state.set(state => ({\n        performance: {\n          ...state.performance,\n          ...performance\n        }\n      }));\n\n      // Set locals\n      onCreated = onCreatedCallback;\n      configured = true;\n      return this;\n    },\n    render(children) {\n      // The root has to be configured before it can be rendered\n      if (!configured) this.configure();\n      reconciler.updateContainer( /*#__PURE__*/React__namespace.createElement(Provider, {\n        store: store,\n        children: children,\n        onCreated: onCreated,\n        rootElement: canvas\n      }), fiber, null, () => undefined);\n      return store;\n    },\n    unmount() {\n      unmountComponentAtNode(canvas);\n    }\n  };\n}\nfunction render(children, canvas, config) {\n  console.warn('R3F.render is no longer supported in React 18. Use createRoot instead!');\n  const root = createRoot(canvas);\n  root.configure(config);\n  return root.render(children);\n}\nfunction Provider({\n  store,\n  children,\n  onCreated,\n  rootElement\n}) {\n  useIsomorphicLayoutEffect(() => {\n    const state = store.getState();\n    // Flag the canvas active, rendering will now begin\n    state.set(state => ({\n      internal: {\n        ...state.internal,\n        active: true\n      }\n    }));\n    // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n    if (onCreated) onCreated(state);\n    // Connect events to the targets parent, this is done to ensure events are registered on\n    // a shared target, and not on the canvas itself\n    if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React__namespace.createElement(context.Provider, {\n    value: store\n  }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n  const root = roots.get(canvas);\n  const fiber = root == null ? void 0 : root.fiber;\n  if (fiber) {\n    const state = root == null ? void 0 : root.store.getState();\n    if (state) state.internal.active = false;\n    reconciler.updateContainer(null, fiber, null, () => {\n      if (state) {\n        setTimeout(() => {\n          try {\n            var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n            state.events.disconnect == null ? void 0 : state.events.disconnect();\n            (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n            (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n            if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n            dispose(state);\n            roots.delete(canvas);\n            if (callback) callback(canvas);\n          } catch (e) {\n            /* ... */\n          }\n        }, 500);\n      }\n    });\n  }\n}\nfunction createPortal(children, container, state) {\n  return /*#__PURE__*/React__namespace.createElement(Portal, {\n    key: container.uuid,\n    children: children,\n    container: container,\n    state: state\n  });\n}\nfunction Portal({\n  state = {},\n  children,\n  container\n}) {\n  /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */\n  const {\n    events,\n    size,\n    ...rest\n  } = state;\n  const previousRoot = useStore();\n  const [raycaster] = React__namespace.useState(() => new THREE__namespace.Raycaster());\n  const [pointer] = React__namespace.useState(() => new THREE__namespace.Vector2());\n  const inject = React__namespace.useCallback((rootState, injectState) => {\n    const intersect = {\n      ...rootState\n    }; // all prev state props\n\n    // Only the fields of \"rootState\" that do not differ from injectState\n    // Some props should be off-limits\n    // Otherwise filter out the props that are different and let the inject layer take precedence\n    Object.keys(rootState).forEach(key => {\n      if (\n      // Some props should be off-limits\n      privateKeys.includes(key) ||\n      // Otherwise filter out the props that are different and let the inject layer take precedence\n      // Unless the inject layer props is undefined, then we keep the root layer\n      rootState[key] !== injectState[key] && injectState[key]) {\n        delete intersect[key];\n      }\n    });\n    let viewport = undefined;\n    if (injectState && size) {\n      const camera = injectState.camera;\n      // Calculate the override viewport, if present\n      viewport = rootState.viewport.getCurrentViewport(camera, new THREE__namespace.Vector3(), size);\n      // Update the portal camera, if it differs from the previous layer\n      if (camera !== rootState.camera) updateCamera(camera, size);\n    }\n    return {\n      // The intersect consists of the previous root state\n      ...intersect,\n      // Portals have their own scene, which forms the root, a raycaster and a pointer\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      // Their previous root is the layer before it\n      previousRoot,\n      // Events, size and viewport can be overridden by the inject layer\n      events: {\n        ...rootState.events,\n        ...(injectState == null ? void 0 : injectState.events),\n        ...events\n      },\n      size: {\n        ...rootState.size,\n        ...size\n      },\n      viewport: {\n        ...rootState.viewport,\n        ...viewport\n      },\n      ...rest\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [state]);\n  const [usePortalStore] = React__namespace.useState(() => {\n    // Create a mirrored store, based on the previous root with a few overrides ...\n    const previousState = previousRoot.getState();\n    const store = create__default[\"default\"]((set, get) => ({\n      ...previousState,\n      scene: container,\n      raycaster,\n      pointer,\n      mouse: pointer,\n      previousRoot,\n      events: {\n        ...previousState.events,\n        ...events\n      },\n      size: {\n        ...previousState.size,\n        ...size\n      },\n      ...rest,\n      // Set and get refer to this root-state\n      set,\n      get,\n      // Layers are allowed to override events\n      setEvents: events => set(state => ({\n        ...state,\n        events: {\n          ...state.events,\n          ...events\n        }\n      }))\n    }));\n    return store;\n  });\n  React__namespace.useEffect(() => {\n    // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n    const unsub = previousRoot.subscribe(prev => usePortalStore.setState(state => inject(prev, state)));\n    return () => {\n      unsub();\n      usePortalStore.destroy();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  React__namespace.useEffect(() => {\n    usePortalStore.setState(injectState => inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inject]);\n  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, reconciler.createPortal( /*#__PURE__*/React__namespace.createElement(context.Provider, {\n    value: usePortalStore\n  }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n  bundleType:  false ? 0 : 1,\n  rendererPackageName: '@react-three/fiber',\n  version: React__namespace.version\n});\nconst act = React__namespace.unstable_act;\n\nexports.Block = Block;\nexports.ErrorBoundary = ErrorBoundary;\nexports.act = act;\nexports.addAfterEffect = addAfterEffect;\nexports.addEffect = addEffect;\nexports.addTail = addTail;\nexports.advance = advance;\nexports.applyProps = applyProps;\nexports.buildGraph = buildGraph;\nexports.context = context;\nexports.createEvents = createEvents;\nexports.createPortal = createPortal;\nexports.createRoot = createRoot;\nexports.dispose = dispose;\nexports.extend = extend;\nexports.flushGlobalEffects = flushGlobalEffects;\nexports.getRootState = getRootState;\nexports.invalidate = invalidate;\nexports.isRef = isRef;\nexports.reconciler = reconciler;\nexports.render = render;\nexports.roots = roots;\nexports.threeTypes = threeTypes;\nexports.unmountComponentAtNode = unmountComponentAtNode;\nexports.useFrame = useFrame;\nexports.useGraph = useGraph;\nexports.useInstanceHandle = useInstanceHandle;\nexports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;\nexports.useLoader = useLoader;\nexports.useMutableCallback = useMutableCallback;\nexports.useStore = useStore;\nexports.useThree = useThree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtZTk5MDk5MTIuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMseURBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLHNGQUE0QjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsMERBQVM7QUFDOUIsaUJBQWlCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFXO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlOztBQUUxQywrQkFBK0IsaUNBQWlDOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixzQkFBc0IsRUFBRSxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGtHQUFrRztBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBb0I7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrVUFBK1U7QUFDL1U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnREFBZ0Q7QUFDaEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMERBQTBELE1BQU0sSUFBSSx1Q0FBdUM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxNQUFxQyxHQUFHLENBQUM7QUFDdkQ7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxhQUFhO0FBQ2IscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGNBQWM7QUFDZCwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsaUJBQWlCO0FBQ2pCLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2FyZC8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9pbmRleC1lOTkwOTkxMi5janMuZGV2LmpzP2M2MzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cycpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJ3p1c3RhbmQnKTtcbnZhciBSZWNvbmNpbGVyID0gcmVxdWlyZSgncmVhY3QtcmVjb25jaWxlcicpO1xudmFyIHNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHN1c3BlbmRSZWFjdCA9IHJlcXVpcmUoJ3N1c3BlbmQtcmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG5bXCJkZWZhdWx0XCJdID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBUSFJFRV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFRIUkVFKTtcbnZhciBSZWFjdF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKFJlYWN0KTtcbnZhciBjcmVhdGVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KGNyZWF0ZSk7XG52YXIgUmVjb25jaWxlcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHQoUmVjb25jaWxlcik7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFX19uYW1lc3BhY2UuQnVmZmVyR2VvbWV0cnkpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdnZW9tZXRyeSc7ZWxzZSBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLk1hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3RTaWJsaW5ncyA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihzaWJsaW5nID0+IHNpYmxpbmcgIT09IGNoaWxkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXN0U2libGluZ3MuaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuID0gWy4uLnJlc3RTaWJsaW5ncy5zbGljZSgwLCBpbmRleCksIGNoaWxkLCAuLi5yZXN0U2libGluZ3Muc2xpY2UoaW5kZXgpXTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuX19yM2YpIHByZXBhcmUoY2hpbGQsIHt9KTtcbiAgICAgIGNoaWxkLl9fcjNmLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUmVjdXJzaXZlKGFycmF5LCBwYXJlbnQsIGRpc3Bvc2UgPSBmYWxzZSkge1xuICAgIGlmIChhcnJheSkgWy4uLmFycmF5XS5mb3JFYWNoKGNoaWxkID0+IHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UkX19yM2YzLCBfY2hpbGQkX19yM2YzLCBfY2hpbGQkX19yM2Y1O1xuICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgIGlmIChjaGlsZC5fX3IzZikgY2hpbGQuX19yM2YucGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBjaGlsZCBmcm9tIHRoZSBwYXJlbnRzIG9iamVjdHNcbiAgICAgIGlmICgoX3BhcmVudEluc3RhbmNlJF9fcjNmMyA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMub2JqZWN0cykgcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IHBhcmVudEluc3RhbmNlLl9fcjNmLm9iamVjdHMuZmlsdGVyKHggPT4geCAhPT0gY2hpbGQpO1xuICAgICAgLy8gUmVtb3ZlIGF0dGFjaG1lbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMyA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNDtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgLy8gUmVtb3ZlIGludGVyYWN0aXZpdHlcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShjaGlsZC5fX3IzZi5yb290LCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soc2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIGNvbnN0IHBhcmVudCA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZi5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBjb25zdCBuZXdJbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCBpbnN0YW5jZS5fX3IzZi5yb290KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzEzNDhcbiAgICAvLyBXaGVuIGFyZ3MgY2hhbmdlIHRoZSBpbnN0YW5jZSBoYXMgdG8gYmUgcmUtY29uc3RydWN0ZWQsIHdoaWNoIHRoZW5cbiAgICAvLyBmb3JjZXMgcjNmIHRvIHJlLXBhcmVudCB0aGUgY2hpbGRyZW4gYW5kIG5vbi1zY2VuZSBvYmplY3RzXG4gICAgaWYgKGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fX3IzZikgYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5fX3IzZik7XG4gICAgfVxuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMuZm9yRWFjaChjaGlsZCA9PiBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpKTtcbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gW107XG4gICAgaWYgKCFpbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCkge1xuICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChuZXdJbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIG5ld0luc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdJbnN0YW5jZSk7XG5cbiAgICAvLyBSZS1iaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gbmV3SW5zdGFuY2UuX19yM2Yucm9vdC5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh7XG4gICAgY3JlYXRlSW5zdGFuY2UsXG4gICAgcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQsXG4gICAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmUsXG4gICAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgICBpc1ByaW1hcnlSZW5kZXJlcjogZmFsc2UsXG4gICAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gICAgc3VwcG9ydHNIeWRyYXRpb246IGZhbHNlLFxuICAgIG5vVGltZW91dDogLTEsXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG5cbiAgICAgIC8vIExpbmsgY3VycmVudCByb290IHRvIHRoZSBkZWZhdWx0IHNjZW5lXG4gICAgICBzY2VuZS5fX3IzZi5yb290ID0gY29udGFpbmVyO1xuICAgICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcbiAgICAgIHJlbW92ZUNoaWxkKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcbiAgICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gbnVsbCxcbiAgICBnZXRDaGlsZEhvc3RDb250ZXh0OiBwYXJlbnRIb3N0Q29udGV4dCA9PiBwYXJlbnRIb3N0Q29udGV4dCxcbiAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YyIDoge307XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBSZXR1cm5pbmcgdHJ1ZSB3aWxsIHRyaWdnZXIgY29tbWl0TW91bnRcbiAgICAgIHJldHVybiBCb29sZWFuKGxvY2FsU3RhdGUuaGFuZGxlcnMpO1xuICAgIH0sXG4gICAgcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgX3R5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjM7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG5cbiAgICAgIC8vIENyZWF0ZSBkaWZmLXNldHNcbiAgICAgIGlmIChsb2NhbFN0YXRlLnByaW1pdGl2ZSAmJiBuZXdQcm9wcy5vYmplY3QgJiYgbmV3UHJvcHMub2JqZWN0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gW3RydWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRhdGEgb2JqZWN0LCBsZXQncyBleHRyYWN0IGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzTmV3ID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNOLFxuICAgICAgICAgIC4uLnJlc3ROZXdcbiAgICAgICAgfSA9IG5ld1Byb3BzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc09sZCA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTyxcbiAgICAgICAgICAuLi5yZXN0T2xkXG4gICAgICAgIH0gPSBvbGRQcm9wcztcblxuICAgICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzTmV3KSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IHRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcblxuICAgICAgICAvLyBJZiBpdCBoYXMgbmV3IHByb3BzIG9yIGFyZ3VtZW50cywgdGhlbiBpdCBuZWVkcyB0byBiZSByZS1pbnN0YW50aWF0ZWRcbiAgICAgICAgaWYgKGFyZ3NOZXcuc29tZSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSAhPT0gYXJnc09sZFtpbmRleF0pKSByZXR1cm4gW3RydWVdO1xuICAgICAgICAvLyBDcmVhdGUgYSBkaWZmLXNldCwgZmxhZyBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZQcm9wcyhpbnN0YW5jZSwgcmVzdE5ldywgcmVzdE9sZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkaWZmLmNoYW5nZXMubGVuZ3RoKSByZXR1cm4gW2ZhbHNlLCBkaWZmXTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZG8gbm90IHRvdWNoIHRoZSBpbnN0YW5jZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgW3JlY29uc3RydWN0LCBkaWZmXSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICAgIGlmIChyZWNvbnN0cnVjdCkgc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcik7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBvdmVyd3JpdGUgcHJvcHNcbiAgICAgIGVsc2UgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkaWZmKTtcbiAgICB9LFxuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCBfdHlwZSwgX3Byb3BzLCBfaW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNDtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgZXZlbnRzIGFyZSBvbmx5IGFkZGVkIG9uY2UgdG8gdGhlIGNlbnRyYWwgY29udGFpbmVyXG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjQgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjQgOiB7fTtcbiAgICAgIGlmIChpbnN0YW5jZS5yYXljYXN0ICYmIGxvY2FsU3RhdGUuaGFuZGxlcnMgJiYgbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgICAgIGluc3RhbmNlLl9fcjNmLnJvb3QuZ2V0U3RhdGUoKS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFB1YmxpY0luc3RhbmNlOiBpbnN0YW5jZSA9PiBpbnN0YW5jZSxcbiAgICBwcmVwYXJlRm9yQ29tbWl0OiAoKSA9PiBudWxsLFxuICAgIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUpLFxuICAgIHJlc2V0QWZ0ZXJDb21taXQ6ICgpID0+IHt9LFxuICAgIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNTtcbiAgICAgIC8vIERldGFjaCB3aGlsZSB0aGUgaW5zdGFuY2UgaXMgaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjUgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QpIGluc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y2O1xuICAgICAgLy8gUmUtYXR0YWNoIHdoZW4gdGhlIGluc3RhbmNlIGlzIHVuaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjYgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjYgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QgJiYgcHJvcHMudmlzaWJsZSA9PSBudWxsIHx8IHByb3BzLnZpc2libGUpIGluc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIGhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MTYzNTY4NzRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHk6ICgpID0+IF9nZXRFdmVudFByaW9yaXR5ID8gX2dldEV2ZW50UHJpb3JpdHkoKSA6IGNvbnN0YW50cy5EZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxyXG4gKiBSZXR1cm5zIGB0cnVlYCB3aXRoIGNvcnJlY3QgVFMgdHlwZSBpbmZlcmVuY2UgaWYgYW4gb2JqZWN0IGhhcyBhIGNvbmZpZ3VyYWJsZSBjb2xvciBzcGFjZSAoc2luY2UgcjE1MikuXHJcbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcclxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxyXG4gKi9cbmNvbnN0IGdldENvbG9yTWFuYWdlbWVudCA9ICgpID0+IHtcbiAgdmFyIF9Db2xvck1hbmFnZW1lbnQ7XG4gIHJldHVybiAoX0NvbG9yTWFuYWdlbWVudCA9IGNhdGFsb2d1ZS5Db2xvck1hbmFnZW1lbnQpICE9IG51bGwgPyBfQ29sb3JNYW5hZ2VtZW50IDogbnVsbDtcbn07XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuXG4vKipcclxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cclxuICpcclxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cclxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcclxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XHJcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdCA6IFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19uYW1lc3BhY2UuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIHRoaXMucHJvcHMuc2V0KGVycik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbkVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pO1xuY29uc3QgREVGQVVMVCA9ICdfX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVFMgPSBuZXcgTWFwKCk7XG5jb25zdCBpc0RpZmZTZXQgPSBkZWYgPT4gZGVmICYmICEhZGVmLm1lbW9pemVkICYmICEhZGVmLmNoYW5nZXM7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuY29uc3QgZ2V0Um9vdFN0YXRlID0gb2JqID0+IHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufTtcbi8vIEEgY29sbGVjdGlvbiBvZiBjb21wYXJlIGZ1bmN0aW9uc1xuY29uc3QgaXMgPSB7XG4gIG9iajogYSA9PiBhID09PSBPYmplY3QoYSkgJiYgIWlzLmFycihhKSAmJiB0eXBlb2YgYSAhPT0gJ2Z1bmN0aW9uJyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICBib286IGEgPT4gdHlwZW9mIGEgPT09ICdib29sZWFuJyxcbiAgdW5kOiBhID0+IGEgPT09IHZvaWQgMCxcbiAgYXJyOiBhID0+IEFycmF5LmlzQXJyYXkoYSksXG4gIGVxdShhLCBiLCB7XG4gICAgYXJyYXlzID0gJ3NoYWxsb3cnLFxuICAgIG9iamVjdHMgPSAncmVmZXJlbmNlJyxcbiAgICBzdHJpY3QgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIC8vIFdyb25nIHR5cGUgb3Igb25lIG9mIHRoZSB0d28gdW5kZWZpbmVkLCBkb2Vzbid0IG1hdGNoXG4gICAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYiB8fCAhIWEgIT09ICEhYikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEF0b21pYywganVzdCBjb21wYXJlIGEgYWdhaW5zdCBiXG4gICAgaWYgKGlzLnN0cihhKSB8fCBpcy5udW0oYSkpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzT2JqID0gaXMub2JqKGEpO1xuICAgIGlmIChpc09iaiAmJiBvYmplY3RzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNBcnIgPSBpcy5hcnIoYSk7XG4gICAgaWYgKGlzQXJyICYmIGFycmF5cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIC8vIEFycmF5IG9yIE9iamVjdCwgc2hhbGxvdyBjb21wYXJlIGZpcnN0IHRvIHNlZSBpZiBpdCdzIGEgbWF0Y2hcbiAgICBpZiAoKGlzQXJyIHx8IGlzT2JqKSAmJiBhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBMYXN0IHJlc29ydCwgZ28gdGhyb3VnaCBrZXlzXG4gICAgbGV0IGk7XG4gICAgLy8gQ2hlY2sgaWYgYSBoYXMgYWxsIHRoZSBrZXlzIG9mIGJcbiAgICBmb3IgKGkgaW4gYSkgaWYgKCEoaSBpbiBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHZhbHVlcyBiZXR3ZWVuIGtleXMgbWF0Y2hcbiAgICBpZiAoaXNPYmogJiYgYXJyYXlzID09PSAnc2hhbGxvdycgJiYgb2JqZWN0cyA9PT0gJ3NoYWxsb3cnKSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmICghaXMuZXF1KGFbaV0sIGJbaV0sIHtcbiAgICAgICAgc3RyaWN0LFxuICAgICAgICBvYmplY3RzOiAncmVmZXJlbmNlJ1xuICAgICAgfSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBpIGlzIHVuZGVmaW5lZFxuICAgIGlmIChpcy51bmQoaSkpIHtcbiAgICAgIC8vIElmIGJvdGggYXJyYXlzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNBcnIgJiYgYS5sZW5ndGggPT09IDAgJiYgYi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gSWYgYm90aCBvYmplY3RzIGFyZSBlbXB0eSB3ZSBjb25zaWRlciB0aGVtIGVxdWFsXG4gICAgICBpZiAoaXNPYmogJiYgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBPdGhlcndpc2UgbWF0Y2ggdGhlbSBieSB2YWx1ZVxuICAgICAgaWYgKGEgIT09IGIpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRC5cclxuICovXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9XG4gIH07XG4gIGlmIChvYmplY3QpIHtcbiAgICBvYmplY3QudHJhdmVyc2Uob2JqID0+IHtcbiAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2Rlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gRGlzcG9zZXMgYW4gb2JqZWN0IGFuZCBhbGwgaXRzIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGRpc3Bvc2Uob2JqKSB7XG4gIGlmIChvYmouZGlzcG9zZSAmJiBvYmoudHlwZSAhPT0gJ1NjZW5lJykgb2JqLmRpc3Bvc2UoKTtcbiAgZm9yIChjb25zdCBwIGluIG9iaikge1xuICAgIHAuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogcC5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIG9ialtwXTtcbiAgfVxufVxuXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgc2NlbmUgY2FycmllcyBhIHNtYWxsIExvY2FsU3RhdGUgZGVzY3JpcHRvclxuZnVuY3Rpb24gcHJlcGFyZShvYmplY3QsIHN0YXRlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0O1xuICBpbnN0YW5jZS5fX3IzZiA9IHtcbiAgICB0eXBlOiAnJyxcbiAgICByb290OiBudWxsLFxuICAgIHByZXZpb3VzQXR0YWNoOiBudWxsLFxuICAgIG1lbW9pemVkUHJvcHM6IHt9LFxuICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgaGFuZGxlcnM6IHt9LFxuICAgIG9iamVjdHM6IFtdLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICAuLi5zdGF0ZVxuICB9O1xuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnN0YW5jZSwga2V5KSB7XG4gIGxldCB0YXJnZXQgPSBpbnN0YW5jZTtcbiAgaWYgKGtleS5pbmNsdWRlcygnLScpKSB7XG4gICAgY29uc3QgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhc3QgPSBlbnRyaWVzLnBvcCgpO1xuICAgIHRhcmdldCA9IGVudHJpZXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5OiBsYXN0XG4gICAgfTtcbiAgfSBlbHNlIHJldHVybiB7XG4gICAgdGFyZ2V0LFxuICAgIGtleVxuICB9O1xufVxuXG4vLyBDaGVja3MgaWYgYSBkYXNoLWNhc2VkIHN0cmluZyBlbmRzIHdpdGggYW4gaW50ZWdlclxuY29uc3QgSU5ERVhfUkVHRVggPSAvLVxcZCskLztcbmZ1bmN0aW9uIGF0dGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICAvLyBJZiBhdHRhY2hpbmcgaW50byBhbiBhcnJheSAoZm9vLTApLCBjcmVhdGUgb25lXG4gICAgaWYgKElOREVYX1JFR0VYLnRlc3QodHlwZSkpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSB0eXBlLnJlcGxhY2UoSU5ERVhfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXlcbiAgICAgIH0gPSByZXNvbHZlKHBhcmVudCwgcm9vdCk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB0YXJnZXRba2V5XSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdGFyZ2V0W2tleV07XG4gICAgdGFyZ2V0W2tleV0gPSBjaGlsZDtcbiAgfSBlbHNlIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdHlwZShwYXJlbnQsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGRldGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIHZhciBfY2hpbGQkX19yM2YsIF9jaGlsZCRfX3IzZjI7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNvbnN0IHByZXZpb3VzID0gY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2g7XG4gICAgLy8gV2hlbiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhlIHZhbHVlIHdhcyBuZXZlciBzZXQgdG8gYmVnaW4gd2l0aFxuICAgIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBlbHNlIHRhcmdldFtrZXldID0gcHJldmlvdXM7XG4gIH0gZWxzZSAoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2ggPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2NoaWxkJF9fcjNmMi5wcmV2aW91c0F0dGFjaDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBkaWZmUHJvcHMoaW5zdGFuY2UsIHtcbiAgY2hpbGRyZW46IGNOLFxuICBrZXk6IGtOLFxuICByZWY6IHJOLFxuICAuLi5wcm9wc1xufSwge1xuICBjaGlsZHJlbjogY1AsXG4gIGtleToga1AsXG4gIHJlZjogclAsXG4gIC4uLnByZXZpb3VzXG59ID0ge30sIHJlbW92ZSA9IGZhbHNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmIDoge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wcyk7XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcblxuICAvLyBDYXRjaCByZW1vdmVkIHByb3BzLCBwcmVwZW5kIHRoZW0gc28gdGhleSBjYW4gYmUgcmVzZXQgb3IgcmVtb3ZlZFxuICBpZiAocmVtb3ZlKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXlzID0gT2JqZWN0LmtleXMocHJldmlvdXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldmlvdXNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByZXZpb3VzS2V5c1tpXSkpIGVudHJpZXMudW5zaGlmdChbcHJldmlvdXNLZXlzW2ldLCBERUZBVUxUICsgJ3JlbW92ZSddKTtcbiAgICB9XG4gIH1cbiAgZW50cmllcy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAvLyBCYWlsIG91dCBvbiBwcmltaXRpdmUgb2JqZWN0XG4gICAgaWYgKChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmMi5wcmltaXRpdmUgJiYga2V5ID09PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIC8vIFdoZW4gcHJvcHMgbWF0Y2ggYmFpbCBvdXRcbiAgICBpZiAoaXMuZXF1KHZhbHVlLCBwcmV2aW91c1trZXldKSkgcmV0dXJuO1xuICAgIC8vIENvbGxlY3QgaGFuZGxlcnMgYW5kIGJhaWwgb3V0XG4gICAgaWYgKC9eb24oUG9pbnRlcnxDbGlja3xEb3VibGVDbGlja3xDb250ZXh0TWVudXxXaGVlbCkvLnRlc3Qoa2V5KSkgcmV0dXJuIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgdHJ1ZSwgW11dKTtcbiAgICAvLyBTcGxpdCBkYXNoZWQgcHJvcHNcbiAgICBsZXQgZW50cmllcyA9IFtdO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgZmFsc2UsIGVudHJpZXNdKTtcblxuICAgIC8vIFJlc2V0IHBpZXJjZWQgcHJvcHNcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICBpZiAocHJvcC5zdGFydHNXaXRoKGAke2tleX0tYCkpIGNoYW5nZXMucHVzaChbcHJvcCwgdmFsdWUsIGZhbHNlLCBwcm9wLnNwbGl0KCctJyldKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtZW1vaXplZCA9IHtcbiAgICAuLi5wcm9wc1xuICB9O1xuICBpZiAobG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzKSBtZW1vaXplZC5hcmdzID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3M7XG4gIGlmIChsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaCkgbWVtb2l6ZWQuYXR0YWNoID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaDtcbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH07XG59XG5jb25zdCBfX0RFVl9fID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBhIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkYXRhKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YzLCBfcm9vdCRnZXRTdGF0ZSwgX2luc3RhbmNlJF9fcjNmNDtcbiAgLy8gRmlsdGVyIGVxdWFscywgZXZlbnRzIGFuZCByZXNlcnZlZCBwcm9wc1xuICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcbiAgY29uc3Qgcm9vdCA9IGxvY2FsU3RhdGUucm9vdDtcbiAgY29uc3Qgcm9vdFN0YXRlID0gKF9yb290JGdldFN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSgpKSAhPSBudWxsID8gX3Jvb3QkZ2V0U3RhdGUgOiB7fTtcbiAgY29uc3Qge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfSA9IGlzRGlmZlNldChkYXRhKSA/IGRhdGEgOiBkaWZmUHJvcHMoaW5zdGFuY2UsIGRhdGEpO1xuICBjb25zdCBwcmV2SGFuZGxlcnMgPSBsb2NhbFN0YXRlLmV2ZW50Q291bnQ7XG5cbiAgLy8gUHJlcGFyZSBtZW1vaXplZCBwcm9wc1xuICBpZiAoaW5zdGFuY2UuX19yM2YpIGluc3RhbmNlLl9fcjNmLm1lbW9pemVkUHJvcHMgPSBtZW1vaXplZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlLCBpc0V2ZW50LCBrZXlzXSA9IGNoYW5nZXNbaV07XG5cbiAgICAvLyBBbGlhcyAob3V0cHV0KWVuY29kaW5nID0+IChvdXRwdXQpY29sb3JTcGFjZSAoc2luY2UgcjE1MilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjgyOVxuICAgIGlmIChoYXNDb2xvclNwYWNlKGluc3RhbmNlKSkge1xuICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgIGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuICAgICAgY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xuICAgICAgaWYgKGtleSA9PT0gJ2VuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnY29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ291dHB1dEVuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnb3V0cHV0Q29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBsZXQgdGFyZ2V0UHJvcCA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuXG4gICAgLy8gUmV2b2x2ZSBkYXNoZWQgcHJvcHNcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldFByb3AgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGF0b21pYywgaXQgZm9yY2VzIHVzIHRvIHN3aXRjaCB0aGUgcm9vdFxuICAgICAgaWYgKCEodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCkpIHtcbiAgICAgICAgY29uc3QgW25hbWUsIC4uLnJldmVyc2VFbnRyaWVzXSA9IGtleXMucmV2ZXJzZSgpO1xuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSByZXZlcnNlRW50cmllcy5yZXZlcnNlKCkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgICAga2V5ID0gbmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTIwOVxuICAgIC8vIEhNUi9mYXN0LXJlZnJlc2ggcmVsaWVzIG9uIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCBvdXQgcHJvcHMsIGJ1dCB0aHJlZWpzXG4gICAgLy8gaGFzIG5vIG1lYW5zIHRvIGRvIHRoaXMuIEhlbmNlIHdlIGN1cmF0ZSBhIHNtYWxsIGNvbGxlY3Rpb24gb2YgdmFsdWUtY2xhc3Nlc1xuICAgIC8vIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25zdHJ1Y3Rvci9zZXQgYXJndW1lbnRzXG4gICAgLy8gRm9yIHJlbW92ZWQgcHJvcHMsIHRyeSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHZhbHVlID09PSBERUZBVUxUICsgJ3JlbW92ZScpIHtcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgYmxhbmsgc2xhdGUgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3B5IHRoZSBwYXJ0aWN1bGFyIHBhcmFtZXRlci5cbiAgICAgICAgbGV0IGN0b3IgPSBERUZBVUxUUy5nZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCFjdG9yKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGN0b3IgPSBuZXcgY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgREVGQVVMVFMuc2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvciwgY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBjdG9yW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGNvbnN0cnVjdG9yLCBqdXN0IHNldCBpdCB0byAwXG4gICAgICAgIHZhbHVlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcG9pbnRlciBldmVudHMgLi4uXG4gICAgaWYgKGlzRXZlbnQpIHtcbiAgICAgIGlmICh2YWx1ZSkgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldID0gdmFsdWU7ZWxzZSBkZWxldGUgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldO1xuICAgICAgbG9jYWxTdGF0ZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMobG9jYWxTdGF0ZS5oYW5kbGVycykubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yIHNldC9jb3B5LCBhbmQgbGF5ZXJzXG4gICAgZWxzZSBpZiAodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCAmJiAodGFyZ2V0UHJvcC5jb3B5IHx8IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkxheWVycykpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHRhcmdldFByb3AuZnJvbUFycmF5KSB0YXJnZXRQcm9wLmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXRQcm9wLnNldCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGFnYWluIHRhcmdldC5jb3B5KGNsYXNzKSBuZXh0IC4uLlxuICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcC5jb3B5ICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIChcbiAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIG1heSBicmVhayBzdHJpY3QgaWRlbnRpdHkgY2hlY2tzIGJ5IGR1cGxpY2F0aW5nIHZlcnNpb25zIG9mIHRocmVlLmpzLlxuICAgICAgLy8gTG9vc2VuIHRvIHVubWluaWZpZWQgbmFtZXMsIGlnbm9yaW5nIGRlc2NlbmRlbnRzLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjg1NlxuICAgICAgLy8gVE9ETzogZml4IHVwc3RyZWFtIGFuZCByZW1vdmUgaW4gdjlcbiAgICAgIF9fREVWX18gPyB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yLm5hbWUgPT09IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXRQcm9wLmNvbnN0cnVjdG9yID09PSB2YWx1ZS5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGFyZ2V0UHJvcC5jb3B5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdGhpbmcgZWxzZSBmaXRzLCBqdXN0IHNldCB0aGUgc2luZ2xlIHZhbHVlLCBpZ25vcmUgdW5kZWZpbmVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yNzRcbiAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgaXNDb2xvciA9IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkNvbG9yO1xuICAgICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgICAgaWYgKCFpc0NvbG9yICYmIHRhcmdldFByb3Auc2V0U2NhbGFyKSB0YXJnZXRQcm9wLnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAgIC8vIExheWVycyBoYXZlIG5vIGNvcHkgZnVuY3Rpb24sIHdlIG11c3QgdGhlcmVmb3JlIGNvcHkgdGhlIG1hc2sgcHJvcGVydHlcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFX19uYW1lc3BhY2UuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5MYXllcnMpIHRhcmdldFByb3AubWFzayA9IHZhbHVlLm1hc2s7XG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHNldCAuLi5cbiAgICAgICAgZWxzZSB0YXJnZXRQcm9wLnNldCh2YWx1ZSk7XG4gICAgICAgIC8vIEZvciB2ZXJzaW9ucyBvZiB0aHJlZSB3aGljaCBkb24ndCBzdXBwb3J0IFRIUkVFLkNvbG9yTWFuYWdlbWVudCxcbiAgICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgY29sb3JzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgICBpZiAoIWdldENvbG9yTWFuYWdlbWVudCgpICYmICFyb290U3RhdGUubGluZWFyICYmIGlzQ29sb3IpIHRhcmdldFByb3AuY29udmVydFNSR0JUb0xpbmVhcigpO1xuICAgICAgfVxuICAgICAgLy8gRWxzZSwganVzdCBvdmVyd3JpdGUgdGhlIHZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRJbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cbiAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIHRleHR1cmVzLCBmb3Igbm93IC4uLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlW2tleV0gaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLlRleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0uZm9ybWF0ID09PSBUSFJFRV9fbmFtZXNwYWNlLlJHQkFGb3JtYXQgJiYgY3VycmVudEluc3RhbmNlW2tleV0udHlwZSA9PT0gVEhSRUVfX25hbWVzcGFjZS5VbnNpZ25lZEJ5dGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaWYgKGhhc0NvbG9yU3BhY2UodGV4dHVyZSkgJiYgaGFzQ29sb3JTcGFjZShyb290U3RhdGUuZ2wpKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSByb290U3RhdGUuZ2wub3V0cHV0Q29sb3JTcGFjZTtlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSByb290U3RhdGUuZ2wub3V0cHV0RW5jb2Rpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGxvY2FsU3RhdGUucGFyZW50ICYmIHJvb3RTdGF0ZS5pbnRlcm5hbCAmJiBpbnN0YW5jZS5yYXljYXN0ICYmIHByZXZIYW5kbGVycyAhPT0gbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5pbmRleE9mKGluc3RhbmNlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnNwbGljZShpbmRleCwgMSk7XG4gICAgLy8gQWRkIHRoZSBpbnN0YW5jZSB0byB0aGUgaW50ZXJhY3Rpb24gbWFuYWdlciBvbmx5IHdoZW4gaXQgaGFzIGhhbmRsZXJzXG4gICAgaWYgKGxvY2FsU3RhdGUuZXZlbnRDb3VudCkgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmNC5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y1LCBfaW5zdGFuY2UkX19yM2Y1JHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2Y1JHJvb3QgPSBfaW5zdGFuY2UkX19yM2Y1LnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjUkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIGNvbnN0YW50cy5EZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgY29uc3QgbmFtZSA9IChfZ2xvYmFsU2NvcGUkZXZlbnQgPSBnbG9iYWxTY29wZS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxTY29wZSRldmVudC50eXBlO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgIHJldHVybiBjb25zdGFudHMuRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIHJldHVybiBjb25zdGFudHMuQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb25zdGFudHMuRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cclxuICogVGhpcyBpcyBjYWxsZWQgYnkgcmVsZWFzZVBvaW50ZXJDYXB0dXJlIGluIHRoZSBBUEksIGFuZCB3aGVuIGFuIG9iamVjdCBpcyByZW1vdmVkLlxyXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCkgfHwgcm9vdFN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIGludGVybmFsXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcclxuICAgICAgICBNQVlCRSBUT0RPLCBERUxFVEUgSUYgTk9UOiBcclxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXHJcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xyXG4gICAgICAgICAgQWxzbywgYXJlIHdlIE9LIHdpdGggc3RyYWlnaHQgdXAgbWFraW5nIHBpY2tpbmcgdXAgbXVsdGlwbGUgb2JqZWN0cyBpbXBvc3NpYmxlP1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxyXG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcclxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlZE1lc2hTZXQuZ2V0KGV2ZW50T2JqZWN0KVxyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cclxuICAgICAgICAgIH1cclxuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoaXNQb2ludGVyTW92ZSkge1xuICAgICAgICAgIC8vIE1vdmUgZXZlbnQgLi4uXG4gICAgICAgICAgaWYgKGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyT3V0IHx8IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGVudGVyIG9yIG91dCBpcyBwcmVzZW50IHRha2UgY2FyZSBvZiBob3Zlci1zdGF0ZVxuICAgICAgICAgICAgY29uc3QgaWQgPSBtYWtlSWQoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkSXRlbSA9IGludGVybmFsLmhvdmVyZWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICghaG92ZXJlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXNuJ3QgcHJldmlvdXNseSBob3ZlcmVkLCBib29rIGl0IGFuZCBjYWxsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgIGludGVybmFsLmhvdmVyZWQuc2V0KGlkLCBkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3ZlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3ZlcihkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2FzIHByZXZpb3VzbHkgaG92ZXJlZCBhbmQgc3RvcHBlZCwgd2Ugc2hvdWxkbid0IGFsbG93IG90aGVyIGl0ZW1zIHRvIHByb2NlZWRcbiAgICAgICAgICAgICAgZGF0YS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBtb3VzZSBtb3ZlXG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTW92ZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbGwgb3RoZXIgZXZlbnRzIC4uLlxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgLy8gRm9yd2FyZCBhbGwgZXZlbnRzIGJhY2sgdG8gdGhlaXIgcmVzcGVjdGl2ZSBoYW5kbGVycyB3aXRoIHRoZSBleGNlcHRpb24gb2YgY2xpY2sgZXZlbnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggbXVzdCB1c2UgdGhlIGluaXRpYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoIWlzQ2xpY2tFdmVudCB8fCBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3RcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgICAvLyBOb3cgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG9uUG9pbnRlck1pc3NlZCBvbiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIHBvaW50ZXIgb3Zlci9vdXQgaGFuZGxlcnMsIGJ1dCBub3QgY2xpY2sgYW5kIHdlcmVuJ3QgaGl0XG4gICAgICAgICAgICBpZiAoaXNDbGlja0V2ZW50ICYmIGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYW5kbGVJbnRlcnNlY3RzKGhpdHMsIGV2ZW50LCBkZWx0YSwgb25JbnRlcnNlY3QpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH07XG59XG5cbi8vIEtleXMgdGhhdCBzaG91bGRuJ3QgYmUgY29waWVkIGJldHdlZW4gUjNGIHN0b3Jlc1xuY29uc3QgcHJpdmF0ZUtleXMgPSBbJ3NldCcsICdnZXQnLCAnc2V0U2l6ZScsICdzZXRGcmFtZWxvb3AnLCAnc2V0RHByJywgJ2V2ZW50cycsICdpbnZhbGlkYXRlJywgJ2FkdmFuY2UnLCAnc2l6ZScsICd2aWV3cG9ydCddO1xuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RhdGUgPSBjcmVhdGVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKChzZXQsIGdldCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMygpO1xuICAgIGNvbnN0IGRlZmF1bHRUYXJnZXQgPSBuZXcgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjMoKTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhID0gZ2V0KCkuY2FtZXJhLCB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LCBzaXplID0gZ2V0KCkuc2l6ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBzaXplO1xuICAgICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5WZWN0b3IzKSB0ZW1wVGFyZ2V0LmNvcHkodGFyZ2V0KTtlbHNlIHRlbXBUYXJnZXQuc2V0KC4uLnRhcmdldCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5kaXN0YW5jZVRvKHRlbXBUYXJnZXQpO1xuICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IHZlcnRpY2FsIGZvdiB0byByYWRpYW5zXG4gICAgICAgIGNvbnN0IGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcbiAgICAgICAgY29uc3QgdyA9IGggKiAod2lkdGggLyBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IHdpZHRoIC8gdyxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBlcmZvcm1hbmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZXRQZXJmb3JtYW5jZUN1cnJlbnQgPSBjdXJyZW50ID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcG9pbnRlciA9IG5ldyBUSFJFRV9fbmFtZXNwYWNlLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgaW5pdGlhbERwcjogMCxcbiAgICAgICAgZHByOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGFzcGVjdDogMCxcbiAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgIGZhY3RvcjogMCxcbiAgICAgICAgZ2V0Q3VycmVudFZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgIHNldFNpemU6ICh3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSwgdG9wLCBsZWZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wOiB0b3AgfHwgMCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IHx8IDAsXG4gICAgICAgICAgdXBkYXRlU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVSZWYoKSxcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIHZhciBfc2l6ZSR1cGRhdGVTdHlsZTtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGdsLnNldFBpeGVsUmF0aW8odmlld3BvcnQuZHByKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVN0eWxlID0gKF9zaXplJHVwZGF0ZVN0eWxlID0gc2l6ZS51cGRhdGVTdHlsZSkgIT0gbnVsbCA/IF9zaXplJHVwZGF0ZVN0eWxlIDogdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBnbC5kb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICBnbC5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB1cGRhdGVTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXdwb3J0IG9uY2UgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAgaWYgKGNhbWVyYSAhPT0gb2xkQ2FtZXJhKSB7XG4gICAgICBvbGRDYW1lcmEgPSBjYW1lcmE7XG4gICAgICAvLyBVcGRhdGUgdmlld3BvcnRcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEpXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEludmFsaWRhdGUgb24gYW55IGNoYW5nZVxuICByb290U3RhdGUuc3Vic2NyaWJlKHN0YXRlID0+IGludmFsaWRhdGUoc3RhdGUpKTtcblxuICAvLyBSZXR1cm4gcm9vdCBzdGF0ZVxuICByZXR1cm4gcm9vdFN0YXRlO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3VicyhjYWxsYmFjaywgc3Vicykge1xuICBjb25zdCBzdWIgPSB7XG4gICAgY2FsbGJhY2tcbiAgfTtcbiAgc3Vicy5hZGQoc3ViKTtcbiAgcmV0dXJuICgpID0+IHZvaWQgc3Vicy5kZWxldGUoc3ViKTtcbn1cbmxldCBpO1xubGV0IGdsb2JhbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbFRhaWxFZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRFZmZlY3RcclxuICovXG5jb25zdCBhZGRFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkQWZ0ZXJFZmZlY3RcclxuICovXG5jb25zdCBhZGRBZnRlckVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEFmdGVyRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZFRhaWxcclxuICovXG5jb25zdCBhZGRUYWlsID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsVGFpbEVmZmVjdHMpO1xuZnVuY3Rpb24gcnVuKGVmZmVjdHMsIHRpbWVzdGFtcCkge1xuICBpZiAoIWVmZmVjdHMuc2l6ZSkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHtcbiAgICBjYWxsYmFja1xuICB9IG9mIGVmZmVjdHMudmFsdWVzKCkpIHtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEdsb2JhbEVmZmVjdHModHlwZSwgdGltZXN0YW1wKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxBZnRlckVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAndGFpbCc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbFRhaWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICB9XG59XG5sZXQgc3Vic2NyaWJlcnM7XG5sZXQgc3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcbiAgLy8gSW4gZnJhbWVsb29wPSduZXZlcicgbW9kZSwgY2xvY2sgdGltZXMgYXJlIHVwZGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcFxuICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInICYmIHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgZGVsdGEgPSB0aW1lc3RhbXAgLSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5vbGRUaW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2suZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXA7XG4gIH1cbiAgLy8gQ2FsbCBzdWJzY3JpYmVycyAodXNlRnJhbWUpXG4gIHN1YnNjcmliZXJzID0gc3RhdGUuaW50ZXJuYWwuc3Vic2NyaWJlcnM7XG4gIGZvciAoaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZXJzW2ldO1xuICAgIHN1YnNjcmlwdGlvbi5yZWYuY3VycmVudChzdWJzY3JpcHRpb24uc3RvcmUuZ2V0U3RhdGUoKSwgZGVsdGEsIGZyYW1lKTtcbiAgfVxuICAvLyBSZW5kZXIgY29udGVudFxuICBpZiAoIXN0YXRlLmludGVybmFsLnByaW9yaXR5ICYmIHN0YXRlLmdsLnJlbmRlcikgc3RhdGUuZ2wucmVuZGVyKHN0YXRlLnNjZW5lLCBzdGF0ZS5jYW1lcmEpO1xuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9vcChyb290cykge1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICBsZXQgcmVwZWF0O1xuICBsZXQgZnJhbWU7XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICByZXBlYXQgPSAwO1xuXG4gICAgLy8gUnVuIGVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHJvb3RzXG4gICAgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSB7XG4gICAgICB2YXIgX3N0YXRlJGdsJHhyO1xuICAgICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICAgIGlmIChzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgJiYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgfHwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID4gMCkgJiYgISgoX3N0YXRlJGdsJHhyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyLmlzUHJlc2VudGluZykpIHtcbiAgICAgICAgcmVwZWF0ICs9IHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBhZnRlci1lZmZlY3RzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgICBpZiAocmVwZWF0ID09PSAwKSB7XG4gICAgICAvLyBUYWlsIGNhbGwgZWZmZWN0cywgdGhleSBhcmUgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzXG4gICAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgICAvLyBGbGFnIGVuZCBvZiBvcGVyYXRpb25cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgICB2YXIgX3N0YXRlJGdsJHhyMjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpKSwgZnJhbWVzKTtcbiAgICBpZiAoKF9zdGF0ZSRnbCR4cjIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIyLmlzUHJlc2VudGluZyB8fCAhc3RhdGUuaW50ZXJuYWwuYWN0aXZlIHx8IHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgIC8vIEluY3JlYXNlIGZyYW1lcywgZG8gbm90IGdvIGhpZ2hlciB0aGFuIDYwXG4gICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5taW4oNjAsIHN0YXRlLmludGVybmFsLmZyYW1lcyArIGZyYW1lcyk7XG4gICAgLy8gSWYgdGhlIHJlbmRlci1sb29wIGlzbid0IGFjdGl2ZSwgc3RhcnQgaXRcbiAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cyA9IHRydWUsIHN0YXRlLCBmcmFtZSkge1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gICAgaWYgKCFzdGF0ZSkgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSByZW5kZXIkMSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSk7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9vcCxcbiAgICAvKipcclxuICAgICAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxyXG4gICAgICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2ludmFsaWRhdGVcclxuICAgICAqL1xuICAgIGludmFsaWRhdGUsXG4gICAgLyoqXHJcbiAgICAgKiBBZHZhbmNlcyB0aGUgZnJhbWVsb29wIGFuZCBydW5zIHJlbmRlciBlZmZlY3RzLCB1c2VmdWwgZm9yIHdoZW4gbWFudWFsbHkgcmVuZGVyaW5nIHZpYSBgZnJhbWVsb29wPVwibmV2ZXJcImAuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWR2YW5jZVxyXG4gICAgICovXG4gICAgYWR2YW5jZVxuICB9O1xufVxuXG4vKipcclxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyN1c2VJbnN0YW5jZUhhbmRsZVxyXG4gKlxyXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxyXG4gKi9cbmZ1bmN0aW9uIHVzZUluc3RhbmNlSGFuZGxlKHJlZikge1xuICBjb25zdCBpbnN0YW5jZSA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGluc3RhbmNlLmN1cnJlbnQgPSByZWYuY3VycmVudC5fX3IzZiksIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3RfX25hbWVzcGFjZS51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3RfX25hbWVzcGFjZS51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoUHJvdG8sIC4uLmlucHV0KSB7XG4gICAgLy8gQ29uc3RydWN0IG5ldyBsb2FkZXIgYW5kIHJ1biBleHRlbnNpb25zXG4gICAgbGV0IGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBsb2FkZXIgPSBuZXcgUHJvdG8oKTtcbiAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgdXJscyBhbmQgbG9hZCB0aGVtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGlucHV0Lm1hcChpbnB1dCA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IGxvYWRlci5sb2FkKGlucHV0LCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnNjZW5lKSBPYmplY3QuYXNzaWduKGRhdGEsIGJ1aWxkR3JhcGgoZGF0YS5zY2VuZSkpO1xuICAgICAgcmVzKGRhdGEpO1xuICAgIH0sIG9uUHJvZ3Jlc3MsIGVycm9yID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7aW5wdXR9OiAke2Vycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlfWApKSkpKSkuZmluYWxseSgoKSA9PiBsb2FkZXIuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyLmRpc3Bvc2UoKSk7XG4gIH07XG59XG4vKipcclxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIC8vIFVzZSBzdXNwZW5zZSB0byBsb2FkIGFzeW5jIGFzc2V0c1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIGNvbnN0IHJlc3VsdHMgPSBzdXNwZW5kUmVhY3Quc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBzdXNwZW5kUmVhY3QucHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cclxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHN1c3BlbmRSZWFjdC5jbGVhcihbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbmNvbnN0IHJvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qge1xuICBpbnZhbGlkYXRlLFxuICBhZHZhbmNlXG59ID0gY3JlYXRlTG9vcChyb290cyk7XG5jb25zdCB7XG4gIHJlY29uY2lsZXIsXG4gIGFwcGx5UHJvcHNcbn0gPSBjcmVhdGVSZW5kZXJlcihyb290cywgZ2V0RXZlbnRQcmlvcml0eSk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmNvbnN0IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UgPSAoZ2wsIGNhbnZhcykgPT4ge1xuICBjb25zdCBjdXN0b21SZW5kZXJlciA9IHR5cGVvZiBnbCA9PT0gJ2Z1bmN0aW9uJyA/IGdsKGNhbnZhcykgOiBnbDtcbiAgaWYgKGlzUmVuZGVyZXIoY3VzdG9tUmVuZGVyZXIpKSByZXR1cm4gY3VzdG9tUmVuZGVyZXI7ZWxzZSByZXR1cm4gbmV3IFRIUkVFX19uYW1lc3BhY2UuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBjb25zdGFudHMuQ29uY3VycmVudFJvb3QsIG51bGwsIGZhbHNlLCBudWxsLCAnJywgbG9nUmVjb3ZlcmFibGVFcnJvciwgbnVsbCk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSByb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBjb25maWd1cmVkID0gZmFsc2U7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSBzdGF0ZS5zZXQoe1xuICAgICAgICBnbDogZ2wgPSBjcmVhdGVSZW5kZXJlckluc3RhbmNlKGdsQ29uZmlnLCBjYW52YXMpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHVwIHJheWNhc3RlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgcmF5Y2FzdGVyID0gc3RhdGUucmF5Y2FzdGVyO1xuICAgICAgaWYgKCFyYXljYXN0ZXIpIHN0YXRlLnNldCh7XG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdGVyID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRV9fbmFtZXNwYWNlLkNhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFX19uYW1lc3BhY2UuT3J0aG9ncmFwaGljQ2FtZXJhKDAsIDAsIDAsIDAsIDAuMSwgMTAwMCkgOiBuZXcgVEhSRUVfX25hbWVzcGFjZS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUVfX25hbWVzcGFjZS5TY2VuZSkge1xuICAgICAgICAgIHNjZW5lID0gc2NlbmVPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjZW5lID0gbmV3IFRIUkVFX19uYW1lc3BhY2UuU2NlbmUoKTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmU6IHByZXBhcmUoc2NlbmUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFX19uYW1lc3BhY2UuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUVfX25hbWVzcGFjZS5CYXNpY1NoYWRvd01hcCxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IFRIUkVFX19uYW1lc3BhY2UuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUVfX25hbWVzcGFjZS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFX19uYW1lc3BhY2UuVlNNU2hhZG93TWFwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IChfdHlwZXMkc2hhZG93cyA9IHR5cGVzW3NoYWRvd3NdKSAhPSBudWxsID8gX3R5cGVzJHNoYWRvd3MgOiBUSFJFRV9fbmFtZXNwYWNlLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2FmZWx5IHNldCBjb2xvciBtYW5hZ2VtZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgIC8vIEF2b2lkIGFjY2Vzc2luZyBUSFJFRS5Db2xvck1hbmFnZW1lbnQgdG8gcGxheSBuaWNlIHdpdGggb2xkZXIgdmVyc2lvbnNcbiAgICAgIGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IGdldENvbG9yTWFuYWdlbWVudCgpO1xuICAgICAgaWYgKENvbG9yTWFuYWdlbWVudCkge1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O2Vsc2UgaWYgKCdsZWdhY3lNb2RlJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5sZWdhY3lNb2RlID0gbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICBvdXRwdXRFbmNvZGluZzogbGluZWFyID8gTGluZWFyRW5jb2RpbmcgOiBzUkdCRW5jb2RpbmcsXG4gICAgICAgIHRvbmVNYXBwaW5nOiBmbGF0ID8gVEhSRUVfX25hbWVzcGFjZS5Ob1RvbmVNYXBwaW5nIDogVEhSRUVfX25hbWVzcGFjZS5BQ0VTRmlsbWljVG9uZU1hcHBpbmdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgY29sb3IgbWFuYWdlbWVudCBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLmxlZ2FjeSAhPT0gbGVnYWN5KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGVnYWN5XG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUubGluZWFyICE9PSBsaW5lYXIpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsaW5lYXJcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5mbGF0ICE9PSBmbGF0KSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgZmxhdFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgZ2wgcHJvcHNcbiAgICAgIGlmIChnbENvbmZpZyAmJiAhaXMuZnVuKGdsQ29uZmlnKSAmJiAhaXNSZW5kZXJlcihnbENvbmZpZykgJiYgIWlzLmVxdShnbENvbmZpZywgZ2wsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMoZ2wsIGdsQ29uZmlnKTtcbiAgICAgIC8vIFN0b3JlIGV2ZW50cyBpbnRlcm5hbGx5XG4gICAgICBpZiAoZXZlbnRzICYmICFzdGF0ZS5ldmVudHMuaGFuZGxlcnMpIHN0YXRlLnNldCh7XG4gICAgICAgIGV2ZW50czogZXZlbnRzKHN0b3JlKVxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBzaXplLCBhbGxvdyBpdCB0byB0YWtlIG9uIGNvbnRhaW5lciBib3VuZHMgaW5pdGlhbGx5XG4gICAgICBjb25zdCBzaXplID0gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgcHJvcHNTaXplKTtcbiAgICAgIGlmICghaXMuZXF1KHNpemUsIHN0YXRlLnNpemUsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgc3RhdGUuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgc2l6ZS51cGRhdGVTdHlsZSwgc2l6ZS50b3AsIHNpemUubGVmdCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBwaXhlbHJhdGlvXG4gICAgICBpZiAoZHByICYmIHN0YXRlLnZpZXdwb3J0LmRwciAhPT0gY2FsY3VsYXRlRHByKGRwcikpIHN0YXRlLnNldERwcihkcHIpO1xuICAgICAgLy8gQ2hlY2sgZnJhbWVsb29wXG4gICAgICBpZiAoc3RhdGUuZnJhbWVsb29wICE9PSBmcmFtZWxvb3ApIHN0YXRlLnNldEZyYW1lbG9vcChmcmFtZWxvb3ApO1xuICAgICAgLy8gQ2hlY2sgcG9pbnRlciBtaXNzZWRcbiAgICAgIGlmICghc3RhdGUub25Qb2ludGVyTWlzc2VkKSBzdGF0ZS5zZXQoe1xuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChwZXJmb3JtYW5jZSAmJiAhaXMuZXF1KHBlcmZvcm1hbmNlLCBzdGF0ZS5wZXJmb3JtYW5jZSwgc2hhbGxvd0xvb3NlKSkgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgICAgLi4ucGVyZm9ybWFuY2VcbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTZXQgbG9jYWxzXG4gICAgICBvbkNyZWF0ZWQgPSBvbkNyZWF0ZWRDYWxsYmFjaztcbiAgICAgIGNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXIoY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRoZSByb290IGhhcyB0byBiZSBjb25maWd1cmVkIGJlZm9yZSBpdCBjYW4gYmUgcmVuZGVyZWRcbiAgICAgIGlmICghY29uZmlndXJlZCkgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgfSksIGZpYmVyLCBudWxsLCAoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4sIGNhbnZhcywgY29uZmlnKSB7XG4gIGNvbnNvbGUud2FybignUjNGLnJlbmRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgY3JlYXRlUm9vdCBpbnN0ZWFkIScpO1xuICBjb25zdCByb290ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICByb290LmNvbmZpZ3VyZShjb25maWcpO1xuICByZXR1cm4gcm9vdC5yZW5kZXIoY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZml5IHRoYXQgaW5pdCBpcyBjb21wbGV0ZWQsIHRoZSBzY2VuZSBncmFwaCBleGlzdHMsIGJ1dCBub3RoaW5nIGhhcyB5ZXQgcmVuZGVyZWRcbiAgICBpZiAob25DcmVhdGVkKSBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgIC8vIENvbm5lY3QgZXZlbnRzIHRvIHRoZSB0YXJnZXRzIHBhcmVudCwgdGhpcyBpcyBkb25lIHRvIGVuc3VyZSBldmVudHMgYXJlIHJlZ2lzdGVyZWQgb25cbiAgICAvLyBhIHNoYXJlZCB0YXJnZXQsIGFuZCBub3Qgb24gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICBpZiAoIXN0b3JlLmdldFN0YXRlKCkuZXZlbnRzLmNvbm5lY3RlZCkgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KHJvb3RFbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7XG4gICAga2V5OiBjb250YWluZXIudXVpZCxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gUG9ydGFsKHtcbiAgc3RhdGUgPSB7fSxcbiAgY2hpbGRyZW4sXG4gIGNvbnRhaW5lclxufSkge1xuICAvKiogVGhpcyBoYXMgdG8gYmUgYSBjb21wb25lbnQgYmVjYXVzZSBpdCB3b3VsZCBub3QgYmUgYWJsZSB0byBjYWxsIHVzZVRocmVlL3VzZVN0b3JlIG90aGVyd2lzZSBzaW5jZVxyXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XHJcbiAgICogIDxDYW52YXM+XHJcbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUVfX25hbWVzcGFjZS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0X19uYW1lc3BhY2UudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gUmVhY3RfX25hbWVzcGFjZS51c2VDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHtcbiAgICAgIC4uLnJvb3RTdGF0ZVxuICAgIH07IC8vIGFsbCBwcmV2IHN0YXRlIHByb3BzXG5cbiAgICAvLyBPbmx5IHRoZSBmaWVsZHMgb2YgXCJyb290U3RhdGVcIiB0aGF0IGRvIG5vdCBkaWZmZXIgZnJvbSBpbmplY3RTdGF0ZVxuICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICBPYmplY3Qua2V5cyhyb290U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAgIHByaXZhdGVLZXlzLmluY2x1ZGVzKGtleSkgfHxcbiAgICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgICAgLy8gVW5sZXNzIHRoZSBpbmplY3QgbGF5ZXIgcHJvcHMgaXMgdW5kZWZpbmVkLCB0aGVuIHdlIGtlZXAgdGhlIHJvb3QgbGF5ZXJcbiAgICAgIHJvb3RTdGF0ZVtrZXldICE9PSBpbmplY3RTdGF0ZVtrZXldICYmIGluamVjdFN0YXRlW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIGludGVyc2VjdFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUgJiYgc2l6ZSkge1xuICAgICAgY29uc3QgY2FtZXJhID0gaW5qZWN0U3RhdGUuY2FtZXJhO1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVycmlkZSB2aWV3cG9ydCwgaWYgcHJlc2VudFxuICAgICAgdmlld3BvcnQgPSByb290U3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgbmV3IFRIUkVFX19uYW1lc3BhY2UuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5pbnRlcnNlY3QsXG4gICAgICAvLyBQb3J0YWxzIGhhdmUgdGhlaXIgb3duIHNjZW5lLCB3aGljaCBmb3JtcyB0aGUgcm9vdCwgYSByYXljYXN0ZXIgYW5kIGEgcG9pbnRlclxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIC8vIFRoZWlyIHByZXZpb3VzIHJvb3QgaXMgdGhlIGxheWVyIGJlZm9yZSBpdFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgLy8gRXZlbnRzLCBzaXplIGFuZCB2aWV3cG9ydCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgaW5qZWN0IGxheWVyXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uKGluamVjdFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBpbmplY3RTdGF0ZS5ldmVudHMpLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAuLi52aWV3cG9ydFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzdGF0ZV0pO1xuICBjb25zdCBbdXNlUG9ydGFsU3RvcmVdID0gUmVhY3RfX25hbWVzcGFjZS51c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgLi4ucmVzdCxcbiAgICAgIC8vIFNldCBhbmQgZ2V0IHJlZmVyIHRvIHRoaXMgcm9vdC1zdGF0ZVxuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH0pO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIHByZXZpb3VzIHJvb3Qtc3RhdGUgYW5kIGNvcHkgY2hhbmdlcyBvdmVyIHRvIHRoZSBtaXJyb3JlZCBwb3J0YWwtc3RhdGVcbiAgICBjb25zdCB1bnN1YiA9IHByZXZpb3VzUm9vdC5zdWJzY3JpYmUocHJldiA9PiB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QocHJldiwgc3RhdGUpKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICB1c2VQb3J0YWxTdG9yZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKGluamVjdFN0YXRlID0+IGluamVjdChwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSwgaW5qZWN0U3RhdGUpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpbmplY3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoUmVhY3RfX25hbWVzcGFjZS5GcmFnbWVudCwgbnVsbCwgcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZVxuICB9LCBjaGlsZHJlbiksIHVzZVBvcnRhbFN0b3JlLCBudWxsKSk7XG59XG5yZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGJ1bmRsZVR5cGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwIDogMSxcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gIHZlcnNpb246IFJlYWN0X19uYW1lc3BhY2UudmVyc2lvblxufSk7XG5jb25zdCBhY3QgPSBSZWFjdF9fbmFtZXNwYWNlLnVuc3RhYmxlX2FjdDtcblxuZXhwb3J0cy5CbG9jayA9IEJsb2NrO1xuZXhwb3J0cy5FcnJvckJvdW5kYXJ5ID0gRXJyb3JCb3VuZGFyeTtcbmV4cG9ydHMuYWN0ID0gYWN0O1xuZXhwb3J0cy5hZGRBZnRlckVmZmVjdCA9IGFkZEFmdGVyRWZmZWN0O1xuZXhwb3J0cy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG5leHBvcnRzLmFkZFRhaWwgPSBhZGRUYWlsO1xuZXhwb3J0cy5hZHZhbmNlID0gYWR2YW5jZTtcbmV4cG9ydHMuYXBwbHlQcm9wcyA9IGFwcGx5UHJvcHM7XG5leHBvcnRzLmJ1aWxkR3JhcGggPSBidWlsZEdyYXBoO1xuZXhwb3J0cy5jb250ZXh0ID0gY29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRXZlbnRzID0gY3JlYXRlRXZlbnRzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5leHBvcnRzLmNyZWF0ZVJvb3QgPSBjcmVhdGVSb290O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZXhwb3J0cy5mbHVzaEdsb2JhbEVmZmVjdHMgPSBmbHVzaEdsb2JhbEVmZmVjdHM7XG5leHBvcnRzLmdldFJvb3RTdGF0ZSA9IGdldFJvb3RTdGF0ZTtcbmV4cG9ydHMuaW52YWxpZGF0ZSA9IGludmFsaWRhdGU7XG5leHBvcnRzLmlzUmVmID0gaXNSZWY7XG5leHBvcnRzLnJlY29uY2lsZXIgPSByZWNvbmNpbGVyO1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLnJvb3RzID0gcm9vdHM7XG5leHBvcnRzLnRocmVlVHlwZXMgPSB0aHJlZVR5cGVzO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbmV4cG9ydHMudXNlRnJhbWUgPSB1c2VGcmFtZTtcbmV4cG9ydHMudXNlR3JhcGggPSB1c2VHcmFwaDtcbmV4cG9ydHMudXNlSW5zdGFuY2VIYW5kbGUgPSB1c2VJbnN0YW5jZUhhbmRsZTtcbmV4cG9ydHMudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZUxvYWRlciA9IHVzZUxvYWRlcjtcbmV4cG9ydHMudXNlTXV0YWJsZUNhbGxiYWNrID0gdXNlTXV0YWJsZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VTdG9yZSA9IHVzZVN0b3JlO1xuZXhwb3J0cy51c2VUaHJlZSA9IHVzZVRocmVlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-e9909912.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar index = __webpack_require__(/*! ./index-e9909912.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-e9909912.cjs.dev.js\");\nvar _extends = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar THREE = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\");\nvar useMeasure = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/web.cjs.js\");\nvar itsFine = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.cjs\");\n__webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n__webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n__webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n__webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n__webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.cjs.js\");\n\nfunction _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\nvar THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);\nvar useMeasure__default = /*#__PURE__*/_interopDefault(useMeasure);\n\nconst DOM_EVENTS = {\n  onClick: ['click', false],\n  onContextMenu: ['contextmenu', false],\n  onDoubleClick: ['dblclick', false],\n  onWheel: ['wheel', true],\n  onPointerDown: ['pointerdown', true],\n  onPointerUp: ['pointerup', true],\n  onPointerLeave: ['pointerleave', true],\n  onPointerMove: ['pointermove', true],\n  onPointerCancel: ['pointercancel', true],\n  onLostPointerCapture: ['lostpointercapture', true]\n};\n\n/** Default R3F event manager for web */\nfunction createPointerEvents(store) {\n  const {\n    handlePointer\n  } = index.createEvents(store);\n  return {\n    priority: 1,\n    enabled: true,\n    compute(event, state, previous) {\n      // https://github.com/pmndrs/react-three-fiber/pull/782\n      // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n      state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n      state.raycaster.setFromCamera(state.pointer, state.camera);\n    },\n    connected: undefined,\n    handlers: Object.keys(DOM_EVENTS).reduce((acc, key) => ({\n      ...acc,\n      [key]: handlePointer(key)\n    }), {}),\n    update: () => {\n      var _internal$lastEvent;\n      const {\n        events,\n        internal\n      } = store.getState();\n      if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n    },\n    connect: target => {\n      var _events$handlers;\n      const {\n        set,\n        events\n      } = store.getState();\n      events.disconnect == null ? void 0 : events.disconnect();\n      set(state => ({\n        events: {\n          ...state.events,\n          connected: target\n        }\n      }));\n      Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event]) => {\n        const [eventName, passive] = DOM_EVENTS[name];\n        target.addEventListener(eventName, event, {\n          passive\n        });\n      });\n    },\n    disconnect: () => {\n      const {\n        set,\n        events\n      } = store.getState();\n      if (events.connected) {\n        var _events$handlers2;\n        Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event]) => {\n          if (events && events.connected instanceof HTMLElement) {\n            const [eventName] = DOM_EVENTS[name];\n            events.connected.removeEventListener(eventName, event);\n          }\n        });\n        set(state => ({\n          events: {\n            ...state.events,\n            connected: undefined\n          }\n        }));\n      }\n    }\n  };\n}\n\nconst CanvasImpl = /*#__PURE__*/React__namespace.forwardRef(function Canvas({\n  children,\n  fallback,\n  resize,\n  style,\n  gl,\n  events = createPointerEvents,\n  eventSource,\n  eventPrefix,\n  shadows,\n  linear,\n  flat,\n  legacy,\n  orthographic,\n  frameloop,\n  dpr,\n  performance,\n  raycaster,\n  camera,\n  scene,\n  onPointerMissed,\n  onCreated,\n  ...props\n}, forwardedRef) {\n  // Create a known catalogue of Threejs-native elements\n  // This will include the entire THREE namespace by default, users can extend\n  // their own elements by using the createRoot API instead\n  React__namespace.useMemo(() => index.extend(THREE__namespace), []);\n  const Bridge = itsFine.useContextBridge();\n  const [containerRef, containerRect] = useMeasure__default[\"default\"]({\n    scroll: true,\n    debounce: {\n      scroll: 50,\n      resize: 0\n    },\n    ...resize\n  });\n  const canvasRef = React__namespace.useRef(null);\n  const divRef = React__namespace.useRef(null);\n  React__namespace.useImperativeHandle(forwardedRef, () => canvasRef.current);\n  const handlePointerMissed = index.useMutableCallback(onPointerMissed);\n  const [block, setBlock] = React__namespace.useState(false);\n  const [error, setError] = React__namespace.useState(false);\n\n  // Suspend this component if block is a promise (2nd run)\n  if (block) throw block;\n  // Throw exception outwards if anything within canvas throws\n  if (error) throw error;\n  const root = React__namespace.useRef(null);\n  index.useIsomorphicLayoutEffect(() => {\n    const canvas = canvasRef.current;\n    if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n      if (!root.current) root.current = index.createRoot(canvas);\n      root.current.configure({\n        gl,\n        events,\n        shadows,\n        linear,\n        flat,\n        legacy,\n        orthographic,\n        frameloop,\n        dpr,\n        performance,\n        raycaster,\n        camera,\n        scene,\n        size: containerRect,\n        // Pass mutable reference to onPointerMissed so it's free to update\n        onPointerMissed: (...args) => handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n        onCreated: state => {\n          // Connect to event source\n          state.events.connect == null ? void 0 : state.events.connect(eventSource ? index.isRef(eventSource) ? eventSource.current : eventSource : divRef.current);\n          // Set up compute function\n          if (eventPrefix) {\n            state.setEvents({\n              compute: (event, state) => {\n                const x = event[eventPrefix + 'X'];\n                const y = event[eventPrefix + 'Y'];\n                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                state.raycaster.setFromCamera(state.pointer, state.camera);\n              }\n            });\n          }\n          // Call onCreated callback\n          onCreated == null ? void 0 : onCreated(state);\n        }\n      });\n      root.current.render( /*#__PURE__*/React__namespace.createElement(Bridge, null, /*#__PURE__*/React__namespace.createElement(index.ErrorBoundary, {\n        set: setError\n      }, /*#__PURE__*/React__namespace.createElement(React__namespace.Suspense, {\n        fallback: /*#__PURE__*/React__namespace.createElement(index.Block, {\n          set: setBlock\n        })\n      }, children))));\n    }\n  });\n  React__namespace.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) return () => index.unmountComponentAtNode(canvas);\n  }, []);\n\n  // When the event source is not this div, we need to set pointer-events to none\n  // Or else the canvas will block events from reaching the event source\n  const pointerEvents = eventSource ? 'none' : 'auto';\n  return /*#__PURE__*/React__namespace.createElement(\"div\", _extends({\n    ref: divRef,\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden',\n      pointerEvents,\n      ...style\n    }\n  }, props), /*#__PURE__*/React__namespace.createElement(\"div\", {\n    ref: containerRef,\n    style: {\n      width: '100%',\n      height: '100%'\n    }\n  }, /*#__PURE__*/React__namespace.createElement(\"canvas\", {\n    ref: canvasRef,\n    style: {\n      display: 'block'\n    }\n  }, fallback)));\n});\n\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */\nconst Canvas = /*#__PURE__*/React__namespace.forwardRef(function CanvasWrapper(props, ref) {\n  return /*#__PURE__*/React__namespace.createElement(itsFine.FiberProvider, null, /*#__PURE__*/React__namespace.createElement(CanvasImpl, _extends({}, props, {\n    ref: ref\n  })));\n});\n\nexports.ReactThreeFiber = index.threeTypes;\nexports._roots = index.roots;\nexports.act = index.act;\nexports.addAfterEffect = index.addAfterEffect;\nexports.addEffect = index.addEffect;\nexports.addTail = index.addTail;\nexports.advance = index.advance;\nexports.applyProps = index.applyProps;\nexports.buildGraph = index.buildGraph;\nexports.context = index.context;\nexports.createEvents = index.createEvents;\nexports.createPortal = index.createPortal;\nexports.createRoot = index.createRoot;\nexports.dispose = index.dispose;\nexports.extend = index.extend;\nexports.flushGlobalEffects = index.flushGlobalEffects;\nexports.getRootState = index.getRootState;\nexports.invalidate = index.invalidate;\nexports.reconciler = index.reconciler;\nexports.render = index.render;\nexports.unmountComponentAtNode = index.unmountComponentAtNode;\nexports.useFrame = index.useFrame;\nexports.useGraph = index.useGraph;\nexports.useInstanceHandle = index.useInstanceHandle;\nexports.useLoader = index.useLoader;\nexports.useStore = index.useStore;\nexports.useThree = index.useThree;\nexports.Canvas = Canvas;\nexports.events = createPointerEvents;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuY2pzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQywyR0FBNkI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLDhGQUFnQztBQUN2RCxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHlEQUFPO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFtQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsOERBQVU7QUFDaEMsbUJBQU8sQ0FBQyxzRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQywwREFBUztBQUNqQixtQkFBTyxDQUFDLHdFQUFrQjtBQUMxQixtQkFBTyxDQUFDLDBEQUFXO0FBQ25CLG1CQUFPLENBQUMsc0VBQWU7O0FBRXZCLCtCQUErQixpQ0FBaUM7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSkFBcUo7QUFDcko7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCx1QkFBdUI7QUFDdkIsY0FBYztBQUNkLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGNBQWM7QUFDZCwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmQvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuY2pzLmRldi5qcz9kZDE5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGluZGV4ID0gcmVxdWlyZSgnLi9pbmRleC1lOTkwOTkxMi5janMuZGV2LmpzJyk7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpO1xudmFyIHVzZU1lYXN1cmUgPSByZXF1aXJlKCdyZWFjdC11c2UtbWVhc3VyZScpO1xudmFyIGl0c0ZpbmUgPSByZXF1aXJlKCdpdHMtZmluZScpO1xucmVxdWlyZSgncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnKTtcbnJlcXVpcmUoJ3p1c3RhbmQnKTtcbnJlcXVpcmUoJ3JlYWN0LXJlY29uY2lsZXInKTtcbnJlcXVpcmUoJ3NjaGVkdWxlcicpO1xucmVxdWlyZSgnc3VzcGVuZC1yZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbltcImRlZmF1bHRcIl0gPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIFJlYWN0X19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUmVhY3QpO1xudmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoVEhSRUUpO1xudmFyIHVzZU1lYXN1cmVfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0KHVzZU1lYXN1cmUpO1xuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBpbmRleC5jcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgcGFzc2l2ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgX2V2ZW50cyRoYW5kbGVyczI7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzMiA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMyIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5jb25uZWN0ZWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENhbnZhc0ltcGwgPSAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4gaW5kZXguZXh0ZW5kKFRIUkVFX19uYW1lc3BhY2UpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IGl0c0ZpbmUudXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3RfX25hbWVzcGFjZS51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0X19uYW1lc3BhY2UudXNlUmVmKG51bGwpO1xuICBSZWFjdF9fbmFtZXNwYWNlLnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSBpbmRleC51c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBTdXNwZW5kIHRoaXMgY29tcG9uZW50IGlmIGJsb2NrIGlzIGEgcHJvbWlzZSAoMm5kIHJ1bilcbiAgaWYgKGJsb2NrKSB0aHJvdyBibG9jaztcbiAgLy8gVGhyb3cgZXhjZXB0aW9uIG91dHdhcmRzIGlmIGFueXRoaW5nIHdpdGhpbiBjYW52YXMgdGhyb3dzXG4gIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIGNvbnN0IHJvb3QgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVJlZihudWxsKTtcbiAgaW5kZXgudXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBpbmRleC5jcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgc2hhZG93cyxcbiAgICAgICAgbGluZWFyLFxuICAgICAgICBmbGF0LFxuICAgICAgICBsZWdhY3ksXG4gICAgICAgIG9ydGhvZ3JhcGhpYyxcbiAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICBkcHIsXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgc2NlbmUsXG4gICAgICAgIHNpemU6IGNvbnRhaW5lclJlY3QsXG4gICAgICAgIC8vIFBhc3MgbXV0YWJsZSByZWZlcmVuY2UgdG8gb25Qb2ludGVyTWlzc2VkIHNvIGl0J3MgZnJlZSB0byB1cGRhdGVcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkOiAoLi4uYXJncykgPT4gaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQoLi4uYXJncyksXG4gICAgICAgIG9uQ3JlYXRlZDogc3RhdGUgPT4ge1xuICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXZlbnQgc291cmNlXG4gICAgICAgICAgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KGV2ZW50U291cmNlID8gaW5kZXguaXNSZWYoZXZlbnRTb3VyY2UpID8gZXZlbnRTb3VyY2UuY3VycmVudCA6IGV2ZW50U291cmNlIDogZGl2UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIC8vIFNldCB1cCBjb21wdXRlIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKGV2ZW50UHJlZml4KSB7XG4gICAgICAgICAgICBzdGF0ZS5zZXRFdmVudHMoe1xuICAgICAgICAgICAgICBjb21wdXRlOiAoZXZlbnQsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1gnXTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWSddO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KHggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oeSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBvbkNyZWF0ZWQgY2FsbGJhY2tcbiAgICAgICAgICBvbkNyZWF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcm9vdC5jdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChCcmlkZ2UsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoaW5kZXguRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBzZXQ6IHNldEVycm9yXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KFJlYWN0X19uYW1lc3BhY2UuU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoaW5kZXguQmxvY2ssIHtcbiAgICAgICAgICBzZXQ6IHNldEJsb2NrXG4gICAgICAgIH0pXG4gICAgICB9LCBjaGlsZHJlbikpKSk7XG4gICAgfVxuICB9KTtcbiAgUmVhY3RfX25hbWVzcGFjZS51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiBpbmRleC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICAvLyBXaGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm90IHRoaXMgZGl2LCB3ZSBuZWVkIHRvIHNldCBwb2ludGVyLWV2ZW50cyB0byBub25lXG4gIC8vIE9yIGVsc2UgdGhlIGNhbnZhcyB3aWxsIGJsb2NrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBldmVudCBzb3VyY2VcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGV2ZW50U291cmNlID8gJ25vbmUnIDogJ2F1dG8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHJlZjogY2FudmFzUmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9LCBmYWxsYmFjaykpKTtcbn0pO1xuXG4vKipcclxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvY2FudmFzXHJcbiAqL1xuY29uc3QgQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0X19uYW1lc3BhY2UuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoaXRzRmluZS5GaWJlclByb3ZpZGVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX25hbWVzcGFjZS5jcmVhdGVFbGVtZW50KENhbnZhc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKSk7XG59KTtcblxuZXhwb3J0cy5SZWFjdFRocmVlRmliZXIgPSBpbmRleC50aHJlZVR5cGVzO1xuZXhwb3J0cy5fcm9vdHMgPSBpbmRleC5yb290cztcbmV4cG9ydHMuYWN0ID0gaW5kZXguYWN0O1xuZXhwb3J0cy5hZGRBZnRlckVmZmVjdCA9IGluZGV4LmFkZEFmdGVyRWZmZWN0O1xuZXhwb3J0cy5hZGRFZmZlY3QgPSBpbmRleC5hZGRFZmZlY3Q7XG5leHBvcnRzLmFkZFRhaWwgPSBpbmRleC5hZGRUYWlsO1xuZXhwb3J0cy5hZHZhbmNlID0gaW5kZXguYWR2YW5jZTtcbmV4cG9ydHMuYXBwbHlQcm9wcyA9IGluZGV4LmFwcGx5UHJvcHM7XG5leHBvcnRzLmJ1aWxkR3JhcGggPSBpbmRleC5idWlsZEdyYXBoO1xuZXhwb3J0cy5jb250ZXh0ID0gaW5kZXguY29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRXZlbnRzID0gaW5kZXguY3JlYXRlRXZlbnRzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBpbmRleC5jcmVhdGVQb3J0YWw7XG5leHBvcnRzLmNyZWF0ZVJvb3QgPSBpbmRleC5jcmVhdGVSb290O1xuZXhwb3J0cy5kaXNwb3NlID0gaW5kZXguZGlzcG9zZTtcbmV4cG9ydHMuZXh0ZW5kID0gaW5kZXguZXh0ZW5kO1xuZXhwb3J0cy5mbHVzaEdsb2JhbEVmZmVjdHMgPSBpbmRleC5mbHVzaEdsb2JhbEVmZmVjdHM7XG5leHBvcnRzLmdldFJvb3RTdGF0ZSA9IGluZGV4LmdldFJvb3RTdGF0ZTtcbmV4cG9ydHMuaW52YWxpZGF0ZSA9IGluZGV4LmludmFsaWRhdGU7XG5leHBvcnRzLnJlY29uY2lsZXIgPSBpbmRleC5yZWNvbmNpbGVyO1xuZXhwb3J0cy5yZW5kZXIgPSBpbmRleC5yZW5kZXI7XG5leHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGUgPSBpbmRleC51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuZXhwb3J0cy51c2VGcmFtZSA9IGluZGV4LnVzZUZyYW1lO1xuZXhwb3J0cy51c2VHcmFwaCA9IGluZGV4LnVzZUdyYXBoO1xuZXhwb3J0cy51c2VJbnN0YW5jZUhhbmRsZSA9IGluZGV4LnVzZUluc3RhbmNlSGFuZGxlO1xuZXhwb3J0cy51c2VMb2FkZXIgPSBpbmRleC51c2VMb2FkZXI7XG5leHBvcnRzLnVzZVN0b3JlID0gaW5kZXgudXNlU3RvcmU7XG5leHBvcnRzLnVzZVRocmVlID0gaW5kZXgudXNlVGhyZWU7XG5leHBvcnRzLkNhbnZhcyA9IENhbnZhcztcbmV4cG9ydHMuZXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./react-three-fiber.cjs.dev.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.dev.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmNqcy5qcz9jZDdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3JlYWN0LXRocmVlLWZpYmVyLmNqcy5wcm9kLmpzXCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9yZWFjdC10aHJlZS1maWJlci5janMuZGV2LmpzXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n\t0;\n})(this, (function (exports, three) { 'use strict';\n\n\t// Split strategy constants\n\tconst CENTER = 0;\n\tconst AVERAGE = 1;\n\tconst SAH = 2;\n\n\t// Traversal constants\n\tconst NOT_INTERSECTED = 0;\n\tconst INTERSECTED = 1;\n\tconst CONTAINED = 2;\n\n\t// SAH cost constants\n\t// TODO: hone these costs more. The relative difference between them should be the\n\t// difference in measured time to perform a triangle intersection vs traversing\n\t// bounds.\n\tconst TRIANGLE_INTERSECT_COST = 1.25;\n\tconst TRAVERSAL_COST = 1;\n\n\n\t// Build constants\n\tconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\n\tconst IS_LEAFNODE_FLAG = 0xFFFF;\n\n\t// EPSILON for computing floating point error during build\n\t// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\n\tconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n\tconst SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\n\tfunction getVertexCount( geo ) {\n\n\t\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n\t}\n\n\tfunction getTriCount( geo ) {\n\n\t\treturn getVertexCount( geo ) / 3;\n\n\t}\n\n\tfunction getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t}\n\n\t// ensures that an index is present on the geometry\n\tfunction ensureIndex( geo, options ) {\n\n\t\tif ( ! geo.index ) {\n\n\t\t\tconst vertexCount = geo.attributes.position.count;\n\t\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\t\tgeo.setIndex( new three.BufferAttribute( index, 1 ) );\n\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\tindex[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n\t// region in the geometry index that belongs to a different set of material groups requires\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\n\t//\n\t// [-------------------------------------------------------------]\n\t// |__________________|\n\t//   g0 = [0, 20]  |______________________||_____________________|\n\t//                      g1 = [16, 40]           g2 = [41, 60]\n\t//\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\tfunction getFullGeometryRange( geo ) {\n\n\t\tconst triCount = getTriCount( geo );\n\t\tconst drawRange = geo.drawRange;\n\t\tconst start = drawRange.start / 3;\n\t\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\t\tconst offset = Math.max( 0, start );\n\t\tconst count = Math.min( triCount, end ) - offset;\n\t\treturn [ {\n\t\t\toffset: Math.floor( offset ),\n\t\t\tcount: Math.floor( count ),\n\t\t} ];\n\n\t}\n\n\tfunction getRootIndexRanges( geo ) {\n\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\t\treturn getFullGeometryRange( geo );\n\n\t\t}\n\n\t\tconst ranges = [];\n\t\tconst rangeBoundaries = new Set();\n\n\t\tconst drawRange = geo.drawRange;\n\t\tconst drawRangeStart = drawRange.start / 3;\n\t\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\t\tfor ( const group of geo.groups ) {\n\n\t\t\tconst groupStart = group.start / 3;\n\t\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t\t}\n\n\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\t\tconst start = sortedBoundaries[ i ];\n\t\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\t\tranges.push( {\n\t\t\t\toffset: Math.floor( start ),\n\t\t\t\tcount: Math.floor( end - start ),\n\t\t\t} );\n\n\t\t}\n\n\t\treturn ranges;\n\n\t}\n\n\tfunction hasGroupGaps( geometry ) {\n\n\t\tif ( geometry.groups.length === 0 ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tconst vertexCount = getTriCount( geometry );\n\t\tconst groups = getRootIndexRanges( geometry )\n\t\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\t\tconst finalGroup = groups[ groups.length - 1 ];\n\t\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\t\tlet total = 0;\n\t\tgroups.forEach( ( { count } ) => total += count );\n\t\treturn vertexCount !== total;\n\n\t}\n\n\tfunction arrayToBox( nodeIndex32, array, target ) {\n\n\t\ttarget.min.x = array[ nodeIndex32 ];\n\t\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\t\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\t\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\t\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\t\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\t\treturn target;\n\n\t}\n\n\tfunction makeEmptyBounds( target ) {\n\n\t\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\t\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n\t}\n\n\tfunction getLongestEdgeIndex( bounds ) {\n\n\t\tlet splitDimIdx = - 1;\n\t\tlet splitDist = - Infinity;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\t\tif ( dist > splitDist ) {\n\n\t\t\t\tsplitDist = dist;\n\t\t\t\tsplitDimIdx = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn splitDimIdx;\n\n\t}\n\n\t// copies bounds a into bounds b\n\tfunction copyBounds( source, target ) {\n\n\t\ttarget.set( source );\n\n\t}\n\n\t// sets bounds target to the union of bounds a and b\n\tfunction unionBounds( a, b, target ) {\n\n\t\tlet aVal, bVal;\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst d3 = d + 3;\n\n\t\t\t// set the minimum values\n\t\t\taVal = a[ d ];\n\t\t\tbVal = b[ d ];\n\t\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t\t// set the max values\n\t\t\taVal = a[ d3 ];\n\t\t\tbVal = b[ d3 ];\n\t\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t\t}\n\n\t}\n\n\t// expands the given bounds by the provided triangle bounds\n\tfunction expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\t\tconst tMin = tCenter - tHalf;\n\t\t\tconst tMax = tCenter + tHalf;\n\n\t\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\t\tbounds[ d ] = tMin;\n\n\t\t\t}\n\n\t\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// compute bounds surface area\n\tfunction computeSurfaceArea( bounds ) {\n\n\t\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\t\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\t\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\t\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n\t}\n\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n\t// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n\t// These are computed together to avoid redundant accesses to bounds array.\n\tfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\t\tlet minx = Infinity;\n\t\tlet miny = Infinity;\n\t\tlet minz = Infinity;\n\t\tlet maxx = - Infinity;\n\t\tlet maxy = - Infinity;\n\t\tlet maxz = - Infinity;\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tconst includeCentroid = centroidTarget !== null;\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tconst hx = triangleBounds[ i + 1 ];\n\t\t\tconst lx = cx - hx;\n\t\t\tconst rx = cx + hx;\n\t\t\tif ( lx < minx ) minx = lx;\n\t\t\tif ( rx > maxx ) maxx = rx;\n\t\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tconst hy = triangleBounds[ i + 3 ];\n\t\t\tconst ly = cy - hy;\n\t\t\tconst ry = cy + hy;\n\t\t\tif ( ly < miny ) miny = ly;\n\t\t\tif ( ry > maxy ) maxy = ry;\n\t\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tconst hz = triangleBounds[ i + 5 ];\n\t\t\tconst lz = cz - hz;\n\t\t\tconst rz = cz + hz;\n\t\t\tif ( lz < minz ) minz = lz;\n\t\t\tif ( rz > maxz ) maxz = rz;\n\t\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\ttarget[ 0 ] = minx;\n\t\ttarget[ 1 ] = miny;\n\t\ttarget[ 2 ] = minz;\n\n\t\ttarget[ 3 ] = maxx;\n\t\ttarget[ 4 ] = maxy;\n\t\ttarget[ 5 ] = maxz;\n\n\t\tif ( includeCentroid ) {\n\n\t\t\tcentroidTarget[ 0 ] = cminx;\n\t\t\tcentroidTarget[ 1 ] = cminy;\n\t\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t\t}\n\n\t}\n\n\t// A stand alone function for retrieving the centroid bounds.\n\tfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tif ( cx < cminx ) cminx = cx;\n\t\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tif ( cy < cminy ) cminy = cy;\n\t\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tif ( cz < cminz ) cminz = cz;\n\t\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size tris.length * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tfunction computeTriangleBounds( geo, fullBounds ) {\n\n\t\t// clear the bounds to empty\n\t\tmakeEmptyBounds( fullBounds );\n\n\t\tconst posAttr = geo.attributes.position;\n\t\tconst index = geo.index ? geo.index.array : null;\n\t\tconst triCount = getTriCount( geo );\n\t\tconst triangleBounds = new Float32Array( triCount * 6 );\n\t\tconst normalized = posAttr.normalized;\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\t\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst tri6 = tri * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangleBounds;\n\n\t}\n\n\tconst BIN_COUNT = 32;\n\tconst binsSort = ( a, b ) => a.candidate - b.candidate;\n\tconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\t\treturn {\n\n\t\t\tcount: 0,\n\t\t\tbounds: new Float32Array( 6 ),\n\t\t\trightCacheBounds: new Float32Array( 6 ),\n\t\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\t\tcandidate: 0,\n\n\t\t};\n\n\t} );\n\tconst leftBounds = new Float32Array( 6 );\n\n\tfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\t\tlet axis = - 1;\n\t\tlet pos = 0;\n\n\t\t// Center\n\t\tif ( strategy === CENTER ) {\n\n\t\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t\t}\n\n\t\t} else if ( strategy === AVERAGE ) {\n\n\t\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t\t}\n\n\t\t} else if ( strategy === SAH ) {\n\n\t\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t// iterate over all axes\n\t\t\tconst cStart = offset * 6;\n\t\t\tconst cEnd = ( offset + count ) * 6;\n\t\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t\t// the triangle positions because it will be faster.\n\t\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t\t// initialize the bin candidates\n\t\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t\t// set the candidates\n\t\t\t\t\tlet b = 0;\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tbounds,\n\t\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t\t} = bin;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t\t// remove redundant splits\n\t\t\t\t\tlet splitCount = count;\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// expand all the bounds\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset the bins\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tbin.count = 0;\n\t\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// iterate over all center positions\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet leftCount = 0;\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t\t}\n\n\t\treturn { axis, pos };\n\n\t}\n\n\t// returns the average coordinate on the specified axis of the all the provided triangles\n\tfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\t\tlet avg = 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t\t}\n\n\t\treturn avg / count;\n\n\t}\n\n\tclass MeshBVHNode {\n\n\t\tconstructor() {\n\n\t\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\t}\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\t\t\t\tlet t = indirectBuffer[ left ];\n\t\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\t\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst useUint32 = triCount > 2 ** 16;\n\t\tconst byteCount = useUint32 ? 4 : 2;\n\n\t\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\t\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tindirectBuffer[ i ] = i;\n\n\t\t}\n\n\t\treturn indirectBuffer;\n\n\t}\n\n\tfunction buildTree( bvh, options ) {\n\n\t\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t\t// We can't use the geometry bounding box if it's available because it may be out of date.\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tconst maxDepth = options.maxDepth;\n\t\tconst verbose = options.verbose;\n\t\tconst maxLeafTris = options.maxLeafTris;\n\t\tconst strategy = options.strategy;\n\t\tconst onProgress = options.onProgress;\n\t\tconst totalTriangles = getTriCount( geometry );\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tlet reachedMaxDepth = false;\n\n\t\tconst fullBounds = new Float32Array( 6 );\n\t\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\t\tconst triangleBounds = computeTriangleBounds( geometry, fullBounds );\n\t\tconst partionFunc = options.indirect ? partition_indirect : partition;\n\n\t\tconst roots = [];\n\t\tconst ranges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\n\t\tif ( ranges.length === 1 ) {\n\n\t\t\tconst range = ranges[ 0 ];\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = fullBounds;\n\t\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t} else {\n\n\t\t\tfor ( let range of ranges ) {\n\n\t\t\t\tconst root = new MeshBVHNode();\n\t\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\t\troots.push( root );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn roots;\n\n\t\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\t\tif ( onProgress ) {\n\n\t\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\t\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\t\treachedMaxDepth = true;\n\t\t\t\tif ( verbose ) {\n\n\t\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\t\tconsole.warn( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// early out if we've met our capacity\n\t\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// Find where to split the volume\n\t\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\t\tif ( split.axis === - 1 ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t\t// create the two new child nodes\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\n\t\t\t} else {\n\n\t\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t\t// create the left child and compute its bounding box\n\t\t\t\tconst left = new MeshBVHNode();\n\t\t\t\tconst lstart = offset;\n\t\t\t\tconst lcount = splitOffset - offset;\n\t\t\t\tnode.left = left;\n\t\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t\t// repeat for right\n\t\t\t\tconst right = new MeshBVHNode();\n\t\t\t\tconst rstart = splitOffset;\n\t\t\t\tconst rcount = count - lcount;\n\t\t\t\tnode.right = right;\n\t\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t}\n\n\t}\n\n\tfunction buildPackedTree( bvh, options ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tif ( options.indirect ) {\n\n\t\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! bvh._indirectBuffer ) {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\t// boundingData  \t\t\t\t: 6 float32\n\t\t// right / offset \t\t\t\t: 1 uint32\n\t\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\t\tconst roots = buildTree( bvh, options );\n\n\t\tlet float32Array;\n\t\tlet uint32Array;\n\t\tlet uint16Array;\n\t\tconst packedRoots = [];\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tlet nodeCount = countNodes( root );\n\n\t\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tpopulateBuffer( 0, root );\n\t\t\tpackedRoots.push( buffer );\n\n\t\t}\n\n\t\tbvh._roots = packedRoots;\n\t\treturn;\n\n\t\tfunction countNodes( node ) {\n\n\t\t\tif ( node.count ) {\n\n\t\t\t\treturn 1;\n\n\t\t\t} else {\n\n\t\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction populateBuffer( byteOffset, node ) {\n\n\t\t\tconst stride4Offset = byteOffset / 4;\n\t\t\tconst stride2Offset = byteOffset / 2;\n\t\t\tconst isLeaf = ! ! node.count;\n\t\t\tconst boundingData = node.boundingData;\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t\t}\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = node.offset;\n\t\t\t\tconst count = node.count;\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node.left;\n\t\t\t\tconst right = node.right;\n\t\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\t\tlet nextUnusedPointer;\n\t\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t\t}\n\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\t\treturn nextUnusedPointer;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass SeparatingAxisBounds {\n\n\t\tconstructor() {\n\n\t\t\tthis.min = Infinity;\n\t\t\tthis.max = - Infinity;\n\n\t\t}\n\n\t\tsetFromPointsField( points, field ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = p[ field ];\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tsetFromPoints( axis, points ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = axis.dot( p );\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tisSeparated( other ) {\n\n\t\t\treturn this.min > other.max || other.min > this.max;\n\n\t\t}\n\n\t}\n\n\tSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\t\tconst p = new three.Vector3();\n\t\treturn function setFromBox( axis, box ) {\n\n\t\t\tconst boxMin = box.min;\n\t\t\tconst boxMax = box.max;\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t};\n\n\t} )();\n\n\tconst areIntersecting = ( function () {\n\n\t\tconst cacheSatBounds = new SeparatingAxisBounds();\n\t\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\t\tconst points1 = shape1.points;\n\t\t\tconst satAxes1 = shape1.satAxes;\n\t\t\tconst satBounds1 = shape1.satBounds;\n\n\t\t\tconst points2 = shape2.points;\n\t\t\tconst satAxes2 = shape2.satAxes;\n\t\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t\t// check axes of the first shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check axes of the second shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointLineToLine = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\t\tconst dir1 = new three.Vector3();\n\t\tconst dir2 = new three.Vector3();\n\t\tconst v02 = new three.Vector3();\n\t\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\t\tconst v0 = l1.start;\n\t\t\tconst v10 = dir1;\n\t\t\tconst v2 = l2.start;\n\t\t\tconst v32 = dir2;\n\n\t\t\tv02.subVectors( v0, v2 );\n\t\t\tdir1.subVectors( l1.end, l1.start );\n\t\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t\t// float d0232 = v02.Dot(v32);\n\t\t\tconst d0232 = v02.dot( v32 );\n\n\t\t\t// float d3210 = v32.Dot(v10);\n\t\t\tconst d3210 = v32.dot( v10 );\n\n\t\t\t// float d3232 = v32.Dot(v32);\n\t\t\tconst d3232 = v32.dot( v32 );\n\n\t\t\t// float d0210 = v02.Dot(v10);\n\t\t\tconst d0210 = v02.dot( v10 );\n\n\t\t\t// float d1010 = v10.Dot(v10);\n\t\t\tconst d1010 = v10.dot( v10 );\n\n\t\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\t\tlet d, d2;\n\t\t\tif ( denom !== 0 ) {\n\n\t\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t\t} else {\n\n\t\t\t\td = 0;\n\n\t\t\t}\n\n\t\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\t\tresult.x = d;\n\t\t\tresult.y = d2;\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointsSegmentToSegment = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\t\tconst paramResult = new three.Vector2();\n\t\tconst temp1 = new three.Vector3();\n\t\tconst temp2 = new three.Vector3();\n\t\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\t\tlet d = paramResult.x;\n\t\t\tlet d2 = paramResult.y;\n\t\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\tl1.at( d, target1 );\n\t\t\t\tl2.at( d2, target2 );\n\n\t\t\t\treturn;\n\n\t\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t\t// Only d2 is out of bounds.\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t\t}\n\n\t\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\t\treturn;\n\n\t\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\t// Only d is out of bounds.\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t\t}\n\n\t\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// Both u and u2 are out of bounds.\n\t\t\t\tlet p;\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tp = l1.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = l1.end;\n\n\t\t\t\t}\n\n\t\t\t\tlet p2;\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tp2 = l2.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp2 = l2.end;\n\n\t\t\t\t}\n\n\t\t\t\tconst closestPoint = temp1;\n\t\t\t\tconst closestPoint2 = temp2;\n\t\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\t\ttarget2.copy( p2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget1.copy( p );\n\t\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tconst sphereIntersectTriangle = ( function () {\n\n\t\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\t\tconst closestPointTemp = new three.Vector3();\n\t\tconst projectedPointTemp = new three.Vector3();\n\t\tconst planeTemp = new three.Plane();\n\t\tconst lineTemp = new three.Line3();\n\t\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\t\tconst { radius, center } = sphere;\n\t\t\tconst { a, b, c } = triangle;\n\n\t\t\t// phase 1\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = b;\n\t\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = b;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t\t// phase 2\n\t\t\tconst plane = triangle.getPlane( planeTemp );\n\t\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\t\tif ( dp <= radius ) {\n\n\t\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\t\tif ( cp ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t} )();\n\n\tconst ZERO_EPSILON = 1e-15;\n\tfunction isNearZero( value ) {\n\n\t\treturn Math.abs( value ) < ZERO_EPSILON;\n\n\t}\n\n\tclass ExtendedTriangle extends three.Triangle {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tthis.isExtendedTriangle = true;\n\t\t\tthis.satAxes = new Array( 4 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.points = [ this.a, this.b, this.c ];\n\t\t\tthis.sphere = new three.Sphere();\n\t\t\tthis.plane = new three.Plane();\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst a = this.a;\n\t\t\tconst b = this.b;\n\t\t\tconst c = this.c;\n\t\t\tconst points = this.points;\n\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst satBounds = this.satBounds;\n\n\t\t\tconst axis0 = satAxes[ 0 ];\n\t\t\tconst sab0 = satBounds[ 0 ];\n\t\t\tthis.getNormal( axis0 );\n\t\t\tsab0.setFromPoints( axis0, points );\n\n\t\t\tconst axis1 = satAxes[ 1 ];\n\t\t\tconst sab1 = satBounds[ 1 ];\n\t\t\taxis1.subVectors( a, b );\n\t\t\tsab1.setFromPoints( axis1, points );\n\n\t\t\tconst axis2 = satAxes[ 2 ];\n\t\t\tconst sab2 = satBounds[ 2 ];\n\t\t\taxis2.subVectors( b, c );\n\t\t\tsab2.setFromPoints( axis2, points );\n\n\t\t\tconst axis3 = satAxes[ 3 ];\n\t\t\tconst sab3 = satBounds[ 3 ];\n\t\t\taxis3.subVectors( c, a );\n\t\t\tsab3.setFromPoints( axis3, points );\n\n\t\t\tthis.sphere.setFromPoints( this.points );\n\t\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\t\tconst point1 = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\t\tconst edge = new three.Line3();\n\n\t\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\t\tconst { start, end } = segment;\n\t\t\tconst points = this.points;\n\t\t\tlet distSq;\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check the triangle edges\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\t\tedge.start.copy( points[ i ] );\n\t\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check end points\n\t\t\tthis.closestPointToPoint( start, point1 );\n\t\t\tdistSq = start.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t\t}\n\n\t\t\tthis.closestPointToPoint( end, point1 );\n\t\t\tdistSq = end.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri2 = new ExtendedTriangle();\n\t\tconst arr1 = new Array( 3 );\n\t\tconst arr2 = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new three.Vector3();\n\t\tconst dir = new three.Vector3();\n\t\tconst dir1 = new three.Vector3();\n\t\tconst dir2 = new three.Vector3();\n\t\tconst tempDir = new three.Vector3();\n\t\tconst edge = new three.Line3();\n\t\tconst edge1 = new three.Line3();\n\t\tconst edge2 = new three.Line3();\n\t\tconst tempPoint = new three.Vector3();\n\n\t\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points = tri.points;\n\t\t\tlet count = 0;\n\t\t\tlet startPointIntersection = - 1;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst { start, end } = edge;\n\t\t\t\tstart.copy( points[ i ] );\n\t\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\t\tedge.delta( dir );\n\n\t\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\t\ttempPoint.copy( start );\n\n\t\t\t\t}\n\n\t\t\t\t// ignore the end point\n\t\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t\t// the start point if necessary\n\t\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tcount = 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcount ++;\n\t\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\t\tsaTri2.copy( other );\n\t\t\t\tsaTri2.update();\n\t\t\t\tother = saTri2;\n\n\t\t\t} else if ( other.needsUpdate ) {\n\n\t\t\t\tother.update();\n\n\t\t\t}\n\n\t\t\tconst plane1 = this.plane;\n\t\t\tconst plane2 = other.plane;\n\n\t\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\t\tconst satBounds1 = this.satBounds;\n\t\t\t\tconst satAxes1 = this.satAxes;\n\t\t\t\tarr2[ 0 ] = other.a;\n\t\t\t\tarr2[ 1 ] = other.b;\n\t\t\t\tarr2[ 2 ] = other.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\tconst satBounds2 = other.satBounds;\n\t\t\t\tconst satAxes2 = other.satAxes;\n\t\t\t\tarr1[ 0 ] = this.a;\n\t\t\t\tarr1[ 1 ] = this.b;\n\t\t\t\tarr1[ 2 ] = this.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// check crossed axes\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\t// find the edge that intersects the other triangle plane\n\t\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find the other triangles edge that intersects this plane\n\t\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\t\tedge1.delta( dir1 );\n\t\t\t\tedge2.delta( dir2 );\n\n\t\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\t\tlet tmp = edge2.start;\n\t\t\t\t\tedge2.start = edge2.end;\n\t\t\t\t\tedge2.end = tmp;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the edges are overlapping\n\t\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\t\tconst separated1 = e1 < s2;\n\t\t\t\tconst separated2 = s1 < e2;\n\n\t\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// assign the target output\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new three.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\t\tconst point = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\t\tconst cornerFields = [ 'a', 'b', 'c' ];\n\t\tconst line1 = new three.Line3();\n\t\tconst line2 = new three.Line3();\n\n\t\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check all point distances\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet dist;\n\t\t\t\tconst field = cornerFields[ i ];\n\t\t\t\tconst otherVec = other[ field ];\n\t\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t\t}\n\n\n\t\t\t\tconst thisVec = this[ field ];\n\t\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst f11 = cornerFields[ i ];\n\t\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass OrientedBox {\n\n\t\tconstructor( min, max, matrix ) {\n\n\t\t\tthis.isOrientedBox = true;\n\t\t\tthis.min = new three.Vector3();\n\t\t\tthis.max = new three.Vector3();\n\t\t\tthis.matrix = new three.Matrix4();\n\t\t\tthis.invMatrix = new three.Matrix4();\n\t\t\tthis.points = new Array( 8 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satAxes = new Array( 3 ).fill().map( () => new three.Vector3() );\n\t\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tif ( min ) this.min.copy( min );\n\t\t\tif ( max ) this.max.copy( max );\n\t\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t\t}\n\n\t\tset( min, max, matrix ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\t\tthis.matrix.copy( matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tcopy( other ) {\n\n\t\t\tthis.min.copy( other.min );\n\t\t\tthis.max.copy( other.max );\n\t\t\tthis.matrix.copy( other.matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tOrientedBox.prototype.update = ( function () {\n\n\t\treturn function update() {\n\n\t\t\tconst matrix = this.matrix;\n\t\t\tconst min = this.min;\n\t\t\tconst max = this.max;\n\n\t\t\tconst points = this.points;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst minVec = points[ 0 ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst index = 1 << i;\n\t\t\t\tconst pi = points[ index ];\n\n\t\t\t\taxis.subVectors( minVec, pi );\n\t\t\t\tsb.setFromPoints( axis, points );\n\n\t\t\t}\n\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\t\tthis.needsUpdate = false;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsBox = ( function () {\n\n\t\tconst aabbBounds = new SeparatingAxisBounds();\n\t\treturn function intersectsBox( box ) {\n\n\t\t\t// TODO: should this be doing SAT against the AABB?\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\t\taabbBounds.min = min.x;\n\t\t\taabbBounds.max = max.x;\n\t\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.y;\n\t\t\taabbBounds.max = max.y;\n\t\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.z;\n\t\t\taabbBounds.max = max.z;\n\t\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri = new ExtendedTriangle();\n\t\tconst pointsArr = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new three.Vector3();\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\t\tsaTri.copy( triangle );\n\t\t\t\tsaTri.update();\n\t\t\t\ttriangle = saTri;\n\n\t\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\t\ttriangle.update();\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\n\t\t\tpointsArr[ 0 ] = triangle.a;\n\t\t\tpointsArr[ 1 ] = triangle.b;\n\t\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst sa = satAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst triSatBounds = triangle.satBounds;\n\t\t\tconst triSatAxes = triangle.satAxes;\n\t\t\tconst points = this.points;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = triSatBounds[ i ];\n\t\t\t\tconst sa = triSatAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\t\treturn function closestPointToPoint( point, target1 ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\ttarget1\n\t\t\t\t.copy( point )\n\t\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t\t.clamp( this.min, this.max )\n\t\t\t\t.applyMatrix4( this.matrix );\n\n\t\t\treturn target1;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new three.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToBox = ( function () {\n\n\t\tconst xyzFields = [ 'x', 'y', 'z' ];\n\t\tconst segments1 = new Array( 12 ).fill().map( () => new three.Line3() );\n\t\tconst segments2 = new Array( 12 ).fill().map( () => new three.Line3() );\n\n\t\tconst point1 = new three.Vector3();\n\t\tconst point2 = new three.Vector3();\n\n\t\t// early out if we find a value below threshold\n\t\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tbox.getCenter( point2 );\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tconst threshold2 = threshold * threshold;\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst points = this.points;\n\n\n\t\t\t// iterate over every edge and compare distances\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check over all these points\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate and check all line segment distances\n\t\t\tlet count = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t\t// get obb line segments\n\t\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t\t// get aabb line segments\n\t\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check all the other boxes point\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\tconst l1 = segments1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass PrimitivePool {\n\n\t\tconstructor( getNewPrimitive ) {\n\n\t\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\t\tthis._primitives = [];\n\n\t\t}\n\n\t\tgetPrimitive() {\n\n\t\t\tconst primitives = this._primitives;\n\t\t\tif ( primitives.length === 0 ) {\n\n\t\t\t\treturn this._getNewPrimitive();\n\n\t\t\t} else {\n\n\t\t\t\treturn primitives.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t\treleasePrimitive( primitive ) {\n\n\t\t\tthis._primitives.push( primitive );\n\n\t\t}\n\n\t}\n\n\tclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\t\tconstructor() {\n\n\t\t\tsuper( () => new ExtendedTriangle() );\n\n\t\t}\n\n\t}\n\n\tconst ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n\n\tfunction IS_LEAF( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n\t}\n\n\tfunction OFFSET( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction COUNT( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 14 ];\n\n\t}\n\n\tfunction LEFT_NODE( n32 ) {\n\n\t\treturn n32 + 8;\n\n\t}\n\n\tfunction RIGHT_NODE( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction SPLIT_AXIS( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 7 ];\n\n\t}\n\n\tfunction BOUNDING_DATA_INDEX( n32 ) {\n\n\t\treturn n32;\n\n\t}\n\n\tclass _BufferStack {\n\n\t\tconstructor() {\n\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tconst stack = [];\n\t\t\tlet prevBuffer = null;\n\t\t\tthis.setBuffer = buffer => {\n\n\t\t\t\tif ( prevBuffer ) {\n\n\t\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t\t}\n\n\t\t\t\tprevBuffer = buffer;\n\t\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t\t};\n\n\t\t\tthis.clearBuffer = () => {\n\n\t\t\t\tprevBuffer = null;\n\t\t\t\tthis.float32Array = null;\n\t\t\t\tthis.uint16Array = null;\n\t\t\t\tthis.uint32Array = null;\n\n\t\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\tconst BufferStack = new _BufferStack();\n\n\tlet _box1$1, _box2$1;\n\tconst boxStack = [];\n\tconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new three.Box3() );\n\n\tfunction shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t\t// setup\n\t\t_box1$1 = boxPool.getPrimitive();\n\t\t_box2$1 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1$1, _box2$1 );\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\t\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t// cleanup\n\t\tBufferStack.clearBuffer();\n\t\tboxPool.releasePrimitive( _box1$1 );\n\t\tboxPool.releasePrimitive( _box2$1 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2$1 = boxStack[ length - 1 ];\n\t\t\t_box1$1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1$1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1$1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tbox2 = _box2$1;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2$1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t\t// Define these inside the function so it has access to the local variables needed\n\t\t\t// when converting to the buffer equivalents\n\t\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t}\n\n\t\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\t// adjust offset to point to the right node\n\t\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\t// return the end offset of the triangle range\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst temp = /* @__PURE__ */ new three.Vector3();\n\tconst temp1$2 = /* @__PURE__ */ new three.Vector3();\n\n\tfunction closestPointToPoint(\n\t\tbvh,\n\t\tpoint,\n\t\ttarget = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tbvh.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1$2.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1$2.clone();\n\t\telse target.point.copy( temp1$2 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\t// Ripped and modified From THREE.js Mesh raycast\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\n\tconst _vA = /* @__PURE__ */ new three.Vector3();\n\tconst _vB = /* @__PURE__ */ new three.Vector3();\n\tconst _vC = /* @__PURE__ */ new three.Vector3();\n\n\tconst _uvA = /* @__PURE__ */ new three.Vector2();\n\tconst _uvB = /* @__PURE__ */ new three.Vector2();\n\tconst _uvC = /* @__PURE__ */ new three.Vector2();\n\n\tconst _normalA = /* @__PURE__ */ new three.Vector3();\n\tconst _normalB = /* @__PURE__ */ new three.Vector3();\n\tconst _normalC = /* @__PURE__ */ new three.Vector3();\n\n\tconst _intersectionPoint = /* @__PURE__ */ new three.Vector3();\n\tfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\t\tlet intersect;\n\t\tif ( side === three.BackSide ) {\n\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t} else {\n\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== three.DoubleSide, point );\n\n\t\t}\n\n\t\tif ( intersect === null ) return null;\n\n\t\tconst distance = ray.origin.distanceTo( point );\n\n\t\treturn {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: point.clone(),\n\n\t\t};\n\n\t}\n\n\tfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t\t_vA.fromBufferAttribute( position, a );\n\t\t_vB.fromBufferAttribute( position, b );\n\t\t_vC.fromBufferAttribute( position, c );\n\n\t\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\t\tif ( intersection ) {\n\n\t\t\tif ( uv ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\t\tintersection.uv = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( uv1 ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\t\tintersection.uv1 = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\t\tintersection.normal = three.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new three.Vector3() );\n\t\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new three.Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\n\t\t\tthree.Triangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\t\tintersection.face = face;\n\t\t\tintersection.faceIndex = a;\n\n\t\t}\n\n\t\treturn intersection;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\n\tfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\t\tconst triOffset = tri * 3;\n\t\tlet a = triOffset + 0;\n\t\tlet b = triOffset + 1;\n\t\tlet c = triOffset + 2;\n\n\t\tconst index = geo.index;\n\t\tif ( geo.index ) {\n\n\t\t\ta = index.getX( a );\n\t\t\tb = index.getX( b );\n\t\t\tc = index.getX( c );\n\n\t\t}\n\n\t\tconst { position, normal, uv, uv1 } = geo.attributes;\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tif ( intersections ) intersections.push( intersection );\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// sets the vertices of triangle `tri` with the 3 vertices after i\n\tfunction setTriangle( tri, i, index, pos ) {\n\n\t\tconst ta = tri.a;\n\t\tconst tb = tri.b;\n\t\tconst tc = tri.c;\n\n\t\tlet i0 = i;\n\t\tlet i1 = i + 1;\n\t\tlet i2 = i + 2;\n\t\tif ( index ) {\n\n\t\t\ti0 = index.getX( i0 );\n\t\t\ti1 = index.getX( i1 );\n\t\t\ti2 = index.getX( i2 );\n\n\t\t}\n\n\t\tta.x = pos.getX( i0 );\n\t\tta.y = pos.getY( i0 );\n\t\tta.z = pos.getZ( i0 );\n\n\t\ttb.x = pos.getX( i1 );\n\t\ttb.y = pos.getY( i1 );\n\t\ttb.z = pos.getZ( i1 );\n\n\t\ttc.x = pos.getX( i2 );\n\t\ttc.y = pos.getY( i2 );\n\t\ttc.z = pos.getZ( i2 );\n\n\t}\n\n\tconst tempV1 = /* @__PURE__ */ new three.Vector3();\n\tconst tempV2 = /* @__PURE__ */ new three.Vector3();\n\tconst tempV3 = /* @__PURE__ */ new three.Vector3();\n\tconst tempUV1 = /* @__PURE__ */ new three.Vector2();\n\tconst tempUV2 = /* @__PURE__ */ new three.Vector2();\n\tconst tempUV3 = /* @__PURE__ */ new three.Vector2();\n\n\tfunction getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\t\tconst indices = geometry.getIndex().array;\n\t\tconst positions = geometry.getAttribute( 'position' );\n\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\tconst a = indices[ triangleIndex * 3 ];\n\t\tconst b = indices[ triangleIndex * 3 + 1 ];\n\t\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\t\ttempV1.fromBufferAttribute( positions, a );\n\t\ttempV2.fromBufferAttribute( positions, b );\n\t\ttempV3.fromBufferAttribute( positions, c );\n\n\t\t// find the associated material index\n\t\tlet materialIndex = 0;\n\t\tconst groups = geometry.groups;\n\t\tconst firstVertexIndex = triangleIndex * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tconst { start, count } = group;\n\t\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\t\tmaterialIndex = group.materialIndex;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// extract uvs\n\t\tlet uv = null;\n\t\tif ( uvs ) {\n\n\t\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\t\tif ( target && target.uv ) uv = target.uv;\n\t\t\telse uv = new three.Vector2();\n\n\t\t\tthree.Triangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t\t}\n\n\t\t// adjust the provided target or create a new one\n\t\tif ( target ) {\n\n\t\t\tif ( ! target.face ) target.face = { };\n\t\t\ttarget.face.a = a;\n\t\t\ttarget.face.b = b;\n\t\t\ttarget.face.c = c;\n\t\t\ttarget.face.materialIndex = materialIndex;\n\t\t\tif ( ! target.face.normal ) target.face.normal = new three.Vector3();\n\t\t\tthree.Triangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\t\tif ( uv ) target.uv = uv;\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tface: {\n\t\t\t\t\ta: a,\n\t\t\t\t\tb: b,\n\t\t\t\t\tc: c,\n\t\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\t\tnormal: three.Triangle.getNormal( tempV1, tempV2, tempV3, new three.Vector3() )\n\t\t\t\t},\n\t\t\t\tuv: uv\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\n\t\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\n\t\t\ttri = i;\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst _boundingBox = /* @__PURE__ */ new three.Box3();\n\tfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\t\tarrayToBox( nodeIndex32, array, _boundingBox );\n\t\treturn ray.intersectBox( _boundingBox, target );\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\t\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles_indirect(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\t\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tconst _boxIntersection$3 = /* @__PURE__ */ new three.Vector3();\n\tfunction raycast( bvh, root, side, ray, intersects ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast$1( 0, bvh, side, ray, intersects );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast$1( nodeIndex32, bvh, side, ray, intersects ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection$3 ) ) {\n\n\t\t\t\t_raycast$1( leftIndex, bvh, side, ray, intersects );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection$3 ) ) {\n\n\t\t\t\t_raycast$1( rightIndex, bvh, side, ray, intersects );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\tconst _boxIntersection$2 = /* @__PURE__ */ new three.Vector3();\n\tconst _xyzFields$1 = [ 'x', 'y', 'z' ];\n\tfunction raycastFirst( bvh, root, side, ray ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst$1( 0, bvh, side, ray );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst$1( nodeIndex32, bvh, side, ray ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields$1[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection$2 );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst$1( c1, bvh, side, ray ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection$2 );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst$1( c2, bvh, side, ray ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$2 = /* @__PURE__ */ new three.Box3();\n\tconst triangle$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat$1 = /* @__PURE__ */ new three.Matrix4();\n\n\tconst obb$4 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$3 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry$1( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry$1( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$4.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$4;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat$1.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$3 );\n\t\t\t\tobb2$3.matrix.copy( invertedMat$1 );\n\t\t\t\tobb2$3.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$3.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2$1, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle$1, i, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle$1.a.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.b.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.c.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2$1, i2, index, pos );\n\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle$1.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$2 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$2 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix$1 = /* @__PURE__ */ new three.Matrix4();\n\tconst obb$3 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1$1 = /* @__PURE__ */ new three.Vector3();\n\tconst temp2$1 = /* @__PURE__ */ new three.Vector3();\n\tconst temp3$1 = /* @__PURE__ */ new three.Vector3();\n\tconst temp4$1 = /* @__PURE__ */ new three.Vector3();\n\n\tfunction closestPointToGeometry(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$3.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$3.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1$1;\n\t\tlet tempTargetDest1 = temp2$1;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3$1;\n\t\t\ttempTargetDest2 = temp4$1;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix$1.copy( geometryToBvh ).invert();\n\t\tobb2$2.matrix.copy( tempMatrix$1 );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$3.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2$2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2$2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2$2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2$2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix$1 );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix$1 );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tlet index = t + j;\n\t\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tconst _boxIntersection$1 = /* @__PURE__ */ new three.Vector3();\n\tfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast( 0, bvh, side, ray, intersects );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, _boxIntersection$1 ) ) {\n\n\t\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, _boxIntersection$1 ) ) {\n\n\t\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\tconst _boxIntersection = /* @__PURE__ */ new three.Vector3();\n\tconst _xyzFields = [ 'x', 'y', 'z' ];\n\tfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst( 0, bvh, side, ray );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$1 = /* @__PURE__ */ new three.Box3();\n\tconst triangle = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat = /* @__PURE__ */ new three.Matrix4();\n\n\tconst obb$2 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$1 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$2.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$2;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$1 );\n\t\t\t\tobb2$1.matrix.copy( invertedMat );\n\t\t\t\tobb2$1.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$1.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$1 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$1 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix = /* @__PURE__ */ new three.Matrix4();\n\tconst obb$1 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1 = /* @__PURE__ */ new three.Vector3();\n\tconst temp2 = /* @__PURE__ */ new three.Vector3();\n\tconst temp3 = /* @__PURE__ */ new three.Vector3();\n\tconst temp4 = /* @__PURE__ */ new three.Vector3();\n\n\tfunction closestPointToGeometry_indirect(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$1.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$1.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$1.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tfunction isSharedArrayBufferSupported() {\n\n\t\treturn typeof SharedArrayBuffer !== 'undefined';\n\n\t}\n\n\tconst _bufferStack1 = new BufferStack.constructor();\n\tconst _bufferStack2 = new BufferStack.constructor();\n\tconst _boxPool = new PrimitivePool( () => new three.Box3() );\n\tconst _leftBox1 = new three.Box3();\n\tconst _rightBox1 = new three.Box3();\n\n\tconst _leftBox2 = new three.Box3();\n\tconst _rightBox2 = new three.Box3();\n\n\tlet _active = false;\n\n\tfunction bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\t\tif ( _active ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t\t}\n\n\t\t_active = true;\n\n\t\tconst roots = bvh._roots;\n\t\tconst otherRoots = otherBvh._roots;\n\t\tlet result;\n\t\tlet offset1 = 0;\n\t\tlet offset2 = 0;\n\t\tconst invMat = new three.Matrix4().copy( matrixToLocal ).invert();\n\n\t\t// iterate over the first set of roots\n\t\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\t\toffset2 = 0;\n\n\t\t\t// prep the initial root box\n\t\t\tconst localBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t\t// iterate over the second set of roots\n\t\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\t\tresult = _traverse(\n\t\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\t\tlocalBox,\n\t\t\t\t);\n\n\t\t\t\t_bufferStack2.clearBuffer();\n\t\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// release stack info\n\t\t\t_boxPool.releasePrimitive( localBox );\n\t\t\t_bufferStack1.clearBuffer();\n\t\t\toffset1 += roots[ i ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_active = false;\n\t\treturn result;\n\n\t}\n\n\tfunction _traverse(\n\t\tnode1Index32,\n\t\tnode2Index32,\n\t\tmatrix2to1,\n\t\tmatrix1to2,\n\t\tintersectsRangesFunc,\n\n\t\t// offsets for ids\n\t\tnode1IndexByteOffset = 0,\n\t\tnode2IndexByteOffset = 0,\n\n\t\t// tree depth\n\t\tdepth1 = 0,\n\t\tdepth2 = 0,\n\n\t\tcurrBox = null,\n\t\treversed = false,\n\n\t) {\n\n\t\t// get the buffer stacks associated with the current indices\n\t\tlet bufferStack1, bufferStack2;\n\t\tif ( reversed ) {\n\n\t\t\tbufferStack1 = _bufferStack2;\n\t\t\tbufferStack2 = _bufferStack1;\n\n\t\t} else {\n\n\t\t\tbufferStack1 = _bufferStack1;\n\t\t\tbufferStack2 = _bufferStack2;\n\n\t\t}\n\n\t\t// get the local instances of the typed buffers\n\t\tconst\n\t\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\t\tconst node1Index16 = node1Index32 * 2;\n\t\tconst node2Index16 = node2Index32 * 2;\n\t\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\t\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\t\tlet result = false;\n\t\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t\tif ( reversed ) {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t} else if ( isLeaf2 ) {\n\n\t\t\t// SWAP\n\t\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t\t// to traverse down the first one\n\n\t\t\t// get the new box to use\n\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t\t// get the child bounds to check before traversal\n\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\tresult = (\n\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t) || (\n\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t} else {\n\n\t\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t\t// intersect with the current bounds\n\n\t\t\t// get the child bounds to check\n\t\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t\t// continue to traverse both children if they both intersect\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t) || _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else if ( leftIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t} else if ( rightIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tconst obb = /* @__PURE__ */ new OrientedBox();\n\tconst tempBox = /* @__PURE__ */ new three.Box3();\n\n\tclass MeshBVH {\n\n\t\tstatic serialize( bvh, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tcloneBuffers: true,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst geometry = bvh.geometry;\n\t\t\tconst rootData = bvh._roots;\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tlet result;\n\t\t\tif ( options.cloneBuffers ) {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData,\n\t\t\t\t\tindex: indexAttribute.array,\n\t\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tsetIndex: true,\n\t\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst { index, roots, indirectBuffer } = data;\n\t\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\t\tbvh._roots = roots;\n\t\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\t\tif ( options.setIndex ) {\n\n\t\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\t\tconst newIndex = new three.BufferAttribute( data.index, 1, false );\n\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvh;\n\n\t\t}\n\n\t\tget indirect() {\n\n\t\t\treturn ! ! this._indirectBuffer;\n\n\t\t}\n\n\t\tconstructor( geometry, options = {} ) {\n\n\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t\t}\n\n\t\t\t// default options\n\t\t\toptions = Object.assign( {\n\n\t\t\t\tstrategy: CENTER,\n\t\t\t\tmaxDepth: 40,\n\t\t\t\tmaxLeafTris: 10,\n\t\t\t\tverbose: true,\n\t\t\t\tuseSharedArrayBuffer: false,\n\t\t\t\tsetBoundingBox: true,\n\t\t\t\tonProgress: null,\n\t\t\t\tindirect: false,\n\n\t\t\t\t// undocumented options\n\n\t\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t\t}, options );\n\n\t\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t\t}\n\n\t\t\t// retain references to the geometry so we can use them it without having to\n\t\t\t// take a geometry reference in every function.\n\t\t\tthis.geometry = geometry;\n\t\t\tthis._roots = null;\n\t\t\tthis._indirectBuffer = null;\n\t\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\t\tbuildPackedTree( this, options );\n\n\t\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new three.Box3() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst { _indirectBuffer } = this;\n\t\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t\t}\n\n\t\trefit( nodeIndices = null ) {\n\n\t\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\t\treturn refitFunc( this, nodeIndices );\n\n\t\t}\n\n\t\ttraverse( callback, rootIndex = 0 ) {\n\n\t\t\tconst buffer = this._roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\t_traverse( 0 );\n\n\t\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\t\tconst node16Index = node32Index * 2;\n\t\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: use node functions here\n\t\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Core Cast Functions */\n\t\traycast( ray, materialOrSide = three.FrontSide ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst intersects = [];\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst startCount = intersects.length;\n\n\t\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\traycastFirst( ray, materialOrSide = three.FrontSide ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tlet closestResult = null;\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\t\tclosestResult = result;\n\t\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn closestResult;\n\n\t\t}\n\n\t\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\t\tlet result = false;\n\t\t\tconst roots = this._roots;\n\t\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tshapecast( callbacks ) {\n\n\t\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\t\tlet {\n\t\t\t\tboundsTraverseOrder,\n\t\t\t\tintersectsBounds,\n\t\t\t\tintersectsRange,\n\t\t\t\tintersectsTriangle,\n\t\t\t} = callbacks;\n\n\t\t\t// wrap the intersectsRange function\n\t\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else if ( ! intersectsRange ) {\n\n\t\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\t\treturn contained;\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// run shapecast\n\t\t\tlet result = false;\n\t\t\tlet byteOffset = 0;\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst root = roots[ i ];\n\t\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += root.byteLength;\n\n\t\t\t}\n\n\t\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t\tlet {\n\t\t\t\tintersectsRanges,\n\t\t\t\tintersectsTriangles,\n\t\t\t} = callbacks;\n\n\t\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr1 = this.geometry.index;\n\t\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\t\tconst assignTriangle1 = this.indirect ?\n\t\t\t\ti1 => {\n\n\n\t\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t} :\n\t\t\t\ti1 => {\n\n\t\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t};\n\n\t\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\t\ti2 => {\n\n\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t} :\n\t\t\t\ti2 => {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t};\n\n\t\t\t// generate triangle callback if needed\n\t\t\tif ( intersectsTriangles ) {\n\n\t\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t};\n\n\t\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t\t}\n\n\n\t\t/* Derived Cast Functions */\n\t\tintersectsBox( box, boxToMesh ) {\n\n\t\t\tobb.set( box.min, box.max, boxToMesh );\n\t\t\tobb.needsUpdate = true;\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\t\treturn closestPointToGeometryFunc(\n\t\t\t\tthis,\n\t\t\t\totherGeometry,\n\t\t\t\tgeometryToBvh,\n\t\t\t\ttarget1,\n\t\t\t\ttarget2,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\treturn closestPointToPoint(\n\t\t\t\tthis,\n\t\t\t\tpoint,\n\t\t\t\ttarget,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tgetBoundingBox( target ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t\tconst roots = this._roots;\n\t\t\troots.forEach( buffer => {\n\n\t\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\t\ttarget.union( tempBox );\n\n\t\t\t} );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\tconst boundingBox = /* @__PURE__ */ new three.Box3();\n\tclass MeshBVHRootVisualizer extends three.Object3D {\n\n\t\tget isMesh() {\n\n\t\t\treturn ! this.displayEdges;\n\n\t\t}\n\n\t\tget isLineSegments() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tget isLine() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tconstructor( mesh, material, depth = 10, group = 0 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.material = material;\n\t\t\tthis.geometry = new three.BufferGeometry();\n\t\t\tthis.name = 'MeshBVHRootVisualizer';\n\t\t\tthis.depth = depth;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._group = group;\n\n\t\t}\n\n\t\traycast() {}\n\n\t\tupdate() {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst boundsTree = this.mesh.geometry.boundsTree;\n\t\t\tconst group = this._group;\n\t\t\tgeometry.dispose();\n\t\t\tthis.visible = false;\n\t\t\tif ( boundsTree ) {\n\n\t\t\t\t// count the number of bounds required\n\t\t\t\tconst targetDepth = this.depth - 1;\n\t\t\t\tconst displayParents = this.displayParents;\n\t\t\t\tlet boundsCount = 0;\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\t\tif ( depth === targetDepth || isLeaf ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\t// fill in the position buffer with the bounds corners\n\t\t\t\tlet posIndex = 0;\n\t\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\n\t\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn terminate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\tlet indexArray;\n\t\t\t\tlet indices;\n\t\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t\t// x axis\n\t\t\t\t\t\t0, 4,\n\t\t\t\t\t\t1, 5,\n\t\t\t\t\t\t2, 6,\n\t\t\t\t\t\t3, 7,\n\n\t\t\t\t\t\t// y axis\n\t\t\t\t\t\t0, 2,\n\t\t\t\t\t\t1, 3,\n\t\t\t\t\t\t4, 6,\n\t\t\t\t\t\t5, 7,\n\n\t\t\t\t\t\t// z axis\n\t\t\t\t\t\t0, 1,\n\t\t\t\t\t\t2, 3,\n\t\t\t\t\t\t4, 5,\n\t\t\t\t\t\t6, 7,\n\t\t\t\t\t] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t\t// X-, X+\n\t\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t\t] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t\t}\n\n\t\t\t\tconst indexLength = indices.length;\n\t\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\t\tconst posOffset = i * 8;\n\t\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the geometry\n\t\t\t\tgeometry.setIndex(\n\t\t\t\t\tnew three.BufferAttribute( indexArray, 1, false ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'position',\n\t\t\t\t\tnew three.BufferAttribute( positionArray, 3, false ),\n\t\t\t\t);\n\t\t\t\tthis.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHVisualizer extends three.Group {\n\n\t\tget color() {\n\n\t\t\treturn this.edgeMaterial.color;\n\n\t\t}\n\n\t\tget opacity() {\n\n\t\t\treturn this.edgeMaterial.opacity;\n\n\t\t}\n\n\t\tset opacity( v ) {\n\n\t\t\tthis.edgeMaterial.opacity = v;\n\t\t\tthis.meshMaterial.opacity = v;\n\n\t\t}\n\n\t\tconstructor( mesh, depth = 10 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.name = 'MeshBVHVisualizer';\n\t\t\tthis.depth = depth;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._roots = [];\n\n\t\t\tconst edgeMaterial = new three.LineBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tconst meshMaterial = new three.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\t\tthis.edgeMaterial = edgeMaterial;\n\t\t\tthis.meshMaterial = meshMaterial;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst bvh = this.mesh.geometry.boundsTree;\n\t\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\t\tconst root = this._roots.pop();\n\t\t\t\troot.geometry.dispose();\n\t\t\t\tthis.remove( root );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\n\t\t\t\t\tthis.add( root );\n\t\t\t\t\tthis._roots.push( root );\n\n\t\t\t\t}\n\n\t\t\t\tconst root = this._roots[ i ];\n\t\t\t\troot.depth = this.depth;\n\t\t\t\troot.mesh = this.mesh;\n\t\t\t\troot.displayParents = this.displayParents;\n\t\t\t\troot.displayEdges = this.displayEdges;\n\t\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n\t\t\t\troot.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdateMatrixWorld( ...args ) {\n\n\t\t\tthis.position.copy( this.mesh.position );\n\t\t\tthis.rotation.copy( this.mesh.rotation );\n\t\t\tthis.scale.copy( this.mesh.scale );\n\n\t\t\tsuper.updateMatrixWorld( ...args );\n\n\t\t}\n\n\t\tcopy( source ) {\n\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.mesh = source.mesh;\n\n\t\t}\n\n\t\tclone() {\n\n\t\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis.edgeMaterial.dispose();\n\t\t\tthis.meshMaterial.dispose();\n\n\t\t\tconst children = this.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst _box1 = /* @__PURE__ */ new three.Box3();\n\tconst _box2 = /* @__PURE__ */ new three.Box3();\n\tconst _vec = /* @__PURE__ */ new three.Vector3();\n\n\t// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\n\tfunction getPrimitiveSize( el ) {\n\n\t\tswitch ( typeof el ) {\n\n\t\t\tcase 'number':\n\t\t\t\treturn 8;\n\t\t\tcase 'string':\n\t\t\t\treturn el.length * 2;\n\t\t\tcase 'boolean':\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction isTypedArray( arr ) {\n\n\t\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\t\treturn regex.test( arr.constructor.name );\n\n\t}\n\n\tfunction getRootExtremes( bvh, group ) {\n\n\t\tconst result = {\n\t\t\tnodeCount: 0,\n\t\t\tleafNodeCount: 0,\n\n\t\t\tdepth: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\ttris: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\tsplits: [ 0, 0, 0 ],\n\t\t\tsurfaceAreaScore: 0,\n\t\t};\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\t\tresult.nodeCount ++;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tresult.leafNodeCount ++;\n\n\t\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t} else {\n\n\t\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\t\tif ( result.tris.min === Infinity ) {\n\n\t\t\tresult.tris.min = 0;\n\t\t\tresult.tris.max = 0;\n\n\t\t}\n\n\t\tif ( result.depth.min === Infinity ) {\n\n\t\t\tresult.depth.min = 0;\n\t\t\tresult.depth.max = 0;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction getBVHExtremes( bvh ) {\n\n\t\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n\t}\n\n\tfunction estimateMemoryInBytes( obj ) {\n\n\t\tconst traversed = new Set();\n\t\tconst stack = [ obj ];\n\t\tlet bytes = 0;\n\n\t\twhile ( stack.length ) {\n\n\t\t\tconst curr = stack.pop();\n\t\t\tif ( traversed.has( curr ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\ttraversed.add( curr );\n\n\t\t\tfor ( let key in curr ) {\n\n\t\t\t\tif ( ! curr.hasOwnProperty( key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\t\tconst value = curr[ key ];\n\t\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bytes;\n\n\t}\n\n\tfunction validateBounds( bvh ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst depthStack = [];\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tlet passes = true;\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tdepth,\n\t\t\t\tisLeaf,\n\t\t\t\tboundingData,\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t};\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\tarrayToBox( 0, boundingData, _box1 );\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\t// check triangles\n\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\tconst i0 = index.getX( i );\n\t\t\t\t\tconst i1 = index.getX( i + 1 );\n\t\t\t\t\tconst i2 = index.getX( i + 2 );\n\n\t\t\t\t\tlet isContained;\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\t\tpasses = passes && isContained;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\t// check if my bounds fit in my parents\n\t\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn passes;\n\n\t}\n\n\t// Returns a simple, human readable object that represents the BVH.\n\tfunction getJSONStructure( bvh ) {\n\n\t\tconst depthStack = [];\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tbounds: arrayToBox( 0, boundingData, new three.Box3() ),\n\t\t\t};\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tinfo.count = count;\n\t\t\t\tinfo.offset = offset;\n\n\t\t\t} else {\n\n\t\t\t\tinfo.left = null;\n\t\t\t\tinfo.right = null;\n\n\t\t\t}\n\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\t// traversal hits the left then right node\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\t\t\tif ( parent ) {\n\n\t\t\t\tif ( parent.left === null ) {\n\n\t\t\t\t\tparent.left = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparent.right = info;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn depthStack[ 0 ];\n\n\t}\n\n\t// converts the given BVH raycast intersection to align with the three.js raycast\n\t// structure (include object, world space distance and point).\n\tfunction convertRaycastIntersect( hit, object, raycaster ) {\n\n\t\tif ( hit === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\thit.point.applyMatrix4( object.matrixWorld );\n\t\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\t\thit.object = object;\n\n\t\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\t\treturn null;\n\n\t\t} else {\n\n\t\t\treturn hit;\n\n\t\t}\n\n\t}\n\n\tconst ray = /* @__PURE__ */ new three.Ray();\n\tconst tmpInverseMatrix = /* @__PURE__ */ new three.Matrix4();\n\tconst origMeshRaycastFunc = three.Mesh.prototype.raycast;\n\n\tfunction acceleratedRaycast( raycaster, intersects ) {\n\n\t\tif ( this.geometry.boundsTree ) {\n\n\t\t\tif ( this.material === undefined ) return;\n\n\t\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t\tconst bvh = this.geometry.boundsTree;\n\t\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material ), this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst hits = bvh.raycast( ray, this.material );\n\t\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction computeBoundsTree( options ) {\n\n\t\tthis.boundsTree = new MeshBVH( this, options );\n\t\treturn this.boundsTree;\n\n\t}\n\n\tfunction disposeBoundsTree() {\n\n\t\tthis.boundsTree = null;\n\n\t}\n\n\tfunction countToStringFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return 'R';\n\t\t\tcase 2: return 'RG';\n\t\t\tcase 3: return 'RGBA';\n\t\t\tcase 4: return 'RGBA';\n\n\t\t}\n\n\t\tthrow new Error();\n\n\t}\n\n\tfunction countToFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return three.RedFormat;\n\t\t\tcase 2: return three.RGFormat;\n\t\t\tcase 3: return three.RGBAFormat;\n\t\t\tcase 4: return three.RGBAFormat;\n\n\t\t}\n\n\t}\n\n\tfunction countToIntFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return three.RedIntegerFormat;\n\t\t\tcase 2: return three.RGIntegerFormat;\n\t\t\tcase 3: return three.RGBAIntegerFormat;\n\t\t\tcase 4: return three.RGBAIntegerFormat;\n\n\t\t}\n\n\t}\n\n\tclass VertexAttributeTexture extends three.DataTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis.minFilter = three.NearestFilter;\n\t\t\tthis.magFilter = three.NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.overrideItemSize = null;\n\t\t\tthis._forcedType = null;\n\n\t\t}\n\n\t\tupdateFrom( attr ) {\n\n\t\t\tconst overrideItemSize = this.overrideItemSize;\n\t\t\tconst originalItemSize = attr.itemSize;\n\t\t\tconst originalCount = attr.count;\n\t\t\tif ( overrideItemSize !== null ) {\n\n\t\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t\t}\n\n\t\t\t\tattr.itemSize = overrideItemSize;\n\t\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t\t}\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tconst count = attr.count;\n\t\t\tconst normalized = attr.normalized;\n\t\t\tconst originalBufferCons = attr.array.constructor;\n\t\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\t\tlet targetType = this._forcedType;\n\t\t\tlet finalStride = itemSize;\n\n\t\t\t// derive the type of texture this should be in the shader\n\t\t\tif ( targetType === null ) {\n\n\t\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\t\tcase Float32Array:\n\t\t\t\t\t\ttargetType = three.FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Uint8Array:\n\t\t\t\t\tcase Uint16Array:\n\t\t\t\t\tcase Uint32Array:\n\t\t\t\t\t\ttargetType = three.UnsignedIntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Int8Array:\n\t\t\t\t\tcase Int16Array:\n\t\t\t\t\tcase Int32Array:\n\t\t\t\t\t\ttargetType = three.IntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get the target format to store the texture as\n\t\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\t\tswitch ( targetType ) {\n\n\t\t\t\tcase three.FloatType:\n\t\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = three.UnsignedByteType;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttype = three.ByteType;\n\t\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\t\ttype = three.FloatType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three.IntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\t\ttype = three.ByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\t\ttype = three.ShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\t\ttype = three.IntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase three.UnsignedIntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\t\ttype = three.UnsignedByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\t\ttype = three.UnsignedShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\t\ttype = three.UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// there will be a mismatch between format length and final length because\n\t\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\t\tif ( finalStride === 3 && ( format === three.RGBAFormat || format === three.RGBAIntegerFormat ) ) {\n\n\t\t\t\tfinalStride = 4;\n\n\t\t\t}\n\n\t\t\t// copy the data over to the new texture array\n\t\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\n\t\t\tconst length = finalStride * dimension * dimension;\n\t\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\t\tconst originalNormalized = attr.normalized;\n\t\t\tattr.normalized = false;\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst ii = finalStride * i;\n\t\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tattr.normalized = originalNormalized;\n\n\t\t\tthis.internalFormat = internalFormat;\n\t\t\tthis.format = format;\n\t\t\tthis.type = type;\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\t\t\tthis.image.data = dataArray;\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.dispose();\n\n\t\t\tattr.itemSize = originalItemSize;\n\t\t\tattr.count = originalCount;\n\n\t\t}\n\n\t}\n\n\tclass UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.UnsignedIntType;\n\n\t\t}\n\n\t}\n\n\tclass IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.IntType;\n\n\t\t}\n\n\n\t}\n\n\tclass FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = three.FloatType;\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHUniformStruct {\n\n\t\tconstructor() {\n\n\t\t\tthis.index = new UIntVertexAttributeTexture();\n\t\t\tthis.position = new FloatVertexAttributeTexture();\n\t\t\tthis.bvhBounds = new three.DataTexture();\n\t\t\tthis.bvhContents = new three.DataTexture();\n\t\t\tthis._cachedIndexAttr = null;\n\n\t\t\tthis.index.overrideItemSize = 3;\n\n\t\t}\n\n\t\tupdateFrom( bvh ) {\n\n\t\t\tconst { geometry } = bvh;\n\t\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t\t// dereference a new index attribute if we're using indirect storage\n\t\t\tif ( bvh.indirect ) {\n\n\t\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\t\tif (\n\t\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t\t) {\n\n\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\t\tthis._cachedIndexAttr = new three.BufferAttribute( array, 1, false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\t\tif ( index ) index.dispose();\n\t\t\tif ( position ) position.dispose();\n\t\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\t\tconst unpacked = target.array;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tconst i3 = 3 * i;\n\t\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\t\tconst roots = bvh._roots;\n\n\t\tif ( roots.length !== 1 ) {\n\n\t\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t\t}\n\n\t\tconst root = roots[ 0 ];\n\t\tconst uint16Array = new Uint16Array( root );\n\t\tconst uint32Array = new Uint32Array( root );\n\t\tconst float32Array = new Float32Array( root );\n\n\t\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t\t// the width so we can expand the row by two and still have a square texture\n\t\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\t\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\t\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\t\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\t\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\t\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t\t}\n\n\t\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t\t} else {\n\n\t\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tboundsTexture.image.data = boundsArray;\n\t\tboundsTexture.image.width = boundsDimension;\n\t\tboundsTexture.image.height = boundsDimension;\n\t\tboundsTexture.format = three.RGBAFormat;\n\t\tboundsTexture.type = three.FloatType;\n\t\tboundsTexture.internalFormat = 'RGBA32F';\n\t\tboundsTexture.minFilter = three.NearestFilter;\n\t\tboundsTexture.magFilter = three.NearestFilter;\n\t\tboundsTexture.generateMipmaps = false;\n\t\tboundsTexture.needsUpdate = true;\n\t\tboundsTexture.dispose();\n\n\t\tcontentsTexture.image.data = contentsArray;\n\t\tcontentsTexture.image.width = contentsDimension;\n\t\tcontentsTexture.image.height = contentsDimension;\n\t\tcontentsTexture.format = three.RGIntegerFormat;\n\t\tcontentsTexture.type = three.UnsignedIntType;\n\t\tcontentsTexture.internalFormat = 'RG32UI';\n\t\tcontentsTexture.minFilter = three.NearestFilter;\n\t\tcontentsTexture.magFilter = three.NearestFilter;\n\t\tcontentsTexture.generateMipmaps = false;\n\t\tcontentsTexture.needsUpdate = true;\n\t\tcontentsTexture.dispose();\n\n\t}\n\n\t// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n\t// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n\t// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n\tconst shaderStructs = /* glsl */`\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n\tconst shaderIntersectFunction = /* glsl */`\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n\n// Raycasting\nfloat intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tfloat dist = max( t0, 0.0 );\n\n\treturn t1 >= dist ? dist : INFINITY;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection, uint offset, uint count,\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nfloat intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax );\n\n}\n\nbool bvhIntersectFirstHit(\n\tBVH bvh, vec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = 1e20;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance == INFINITY || boundsHitDistance > triangleDistance ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n\t// Distance to Point\n\tconst shaderDistanceFunction = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\tBVH bvh, vec3 point, uint offset, uint count, float closestDistanceSquared,\n\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tuvec3 localIndices;\n\tvec3 localBarycoord;\n\tvec3 localNormal;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( bvh.index, i ).xyz;\n\t\tvec3 a = texelFetch1D( bvh.position, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( bvh.position, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( bvh.position, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, BVH bvh, uint currNodeIndex ) {\n\n\tvec3 boundsMin = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 0u ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvh.bvhBounds, currNodeIndex * 2u + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\nfloat bvhClosestPointToPoint(\n\tBVH bvh, vec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ 60 ];\n\tstack[ 0 ] = 0u;\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < 60 ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh, point, offset, count, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n\tconst _positionVector = /*@__PURE__*/ new three.Vector3();\n\tconst _normalVector = /*@__PURE__*/ new three.Vector3();\n\tconst _tangentVector = /*@__PURE__*/ new three.Vector3();\n\tconst _tangentVector4 = /*@__PURE__*/ new three.Vector4();\n\n\tconst _morphVector = /*@__PURE__*/ new three.Vector3();\n\tconst _temp = /*@__PURE__*/ new three.Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/ new three.Vector4();\n\tconst _skinWeight = /*@__PURE__*/ new three.Vector4();\n\tconst _matrix = /*@__PURE__*/ new three.Matrix4();\n\tconst _boneMatrix = /*@__PURE__*/ new three.Matrix4();\n\n\t// Confirms that the two provided attributes are compatible\n\tfunction validateAttributes( attr1, attr2 ) {\n\n\t\tif ( ! attr1 && ! attr2 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sameCount = attr1.count === attr2.count;\n\t\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\t\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\t\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\t\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Clones the given attribute with a new compatible buffer attribute but no data\n\tfunction createAttributeClone( attr, countOverride = null ) {\n\n\t\tconst cons = attr.array.constructor;\n\t\tconst normalized = attr.normalized;\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = countOverride === null ? attr.count : countOverride;\n\n\t\treturn new three.BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n\t}\n\n\t// target offset is the number of elements in the target buffer stride to skip before copying the\n\t// attributes contents in to.\n\tfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\tconst io = i + targetOffset;\n\t\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = target.array;\n\t\t\tconst cons = array.constructor;\n\t\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\t\ttemp.set( attr.array );\n\n\t\t}\n\n\t}\n\n\t// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\tfunction addScaledMatrix( target, matrix, scale ) {\n\n\t\tconst targetArray = target.elements;\n\t\tconst matrixArray = matrix.elements;\n\t\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t\t}\n\n\t}\n\n\t// A version of \"SkinnedMesh.boneTransform\" for normals\n\tfunction boneNormalTransform( mesh, index, target ) {\n\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst geometry = mesh.geometry;\n\t\tconst bones = skeleton.bones;\n\t\tconst boneInverses = skeleton.boneInverses;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_matrix.elements.fill( 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\t\ttarget.transformDirection( _matrix );\n\n\t\treturn target;\n\n\t}\n\n\t// Applies the morph target data to the target vector\n\tfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t\t_morphVector.set( 0, 0, 0 );\n\t\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\t\tconst influence = morphInfluences[ j ];\n\t\t\tconst morphAttribute = morphData[ j ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttarget.add( _morphVector );\n\n\t}\n\n\t// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\n\tfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new three.BufferGeometry() ) {\n\n\t\tconst isIndexed = geometries[ 0 ].index !== null;\n\t\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\t\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tconst attributes = {};\n\n\t\tlet offset = 0;\n\n\t\ttargetGeometry.clearGroups();\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\t\t\tlet attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\t\tattributes[ name ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t\t}\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tlet count;\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\t\tif ( isIndexed ) {\n\n\t\t\tlet forceUpdateIndex = false;\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\tlet indexCount = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setIndex( new three.BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\t\tforceUpdateIndex = true;\n\n\t\t\t}\n\n\t\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tlet indexOffset = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge attributes\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attrList = attributes[ name ];\n\t\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\t\tlet count = 0;\n\t\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t\t}\n\n\t\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\t\tconst attr = attrList[ i ];\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t\t}\n\n\t\t\t\toffset += attr.count;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\tfunction checkTypedArrayEquality( a, b ) {\n\n\t\tif ( a === null || b === null ) {\n\n\t\t\treturn a === b;\n\n\t\t}\n\n\t\tif ( a.length !== b.length ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t// Checks whether the geometry changed between this and last evaluation\n\tclass GeometryDiff {\n\n\t\tconstructor( mesh ) {\n\n\t\t\tthis.matrixWorld = new three.Matrix4();\n\t\t\tthis.geometryHash = null;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.primitiveCount = - 1;\n\t\t\tthis.mesh = mesh;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst skeleton = mesh.skeleton;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\t\tthis.primitiveCount = primitiveCount;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t\t}\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\t// copy data if possible otherwise clone it\n\t\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdidChange() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tconst identical =\n\t\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\t\treturn ! identical;\n\n\t\t}\n\n\t}\n\n\tclass StaticGeometryGenerator {\n\n\t\tconstructor( meshes ) {\n\n\t\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\t\tmeshes = [ meshes ];\n\n\t\t\t}\n\n\t\t\tconst finalMeshes = [];\n\t\t\tmeshes.forEach( object => {\n\n\t\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tthis.meshes = finalMeshes;\n\t\t\tthis.useGroups = true;\n\t\t\tthis.applyWorldTransforms = true;\n\t\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new three.BufferGeometry() );\n\t\t\tthis._diffMap = new WeakMap();\n\n\t\t}\n\n\t\tgetMaterials() {\n\n\t\t\tconst materials = [];\n\t\t\tthis.meshes.forEach( mesh => {\n\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tgenerate( targetGeometry = new three.BufferGeometry() ) {\n\n\t\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\t\tlet skipAttributes = [];\n\t\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdiff.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskipAttributes.push( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t\t_convertToStaticGeometry( mesh, targetGeometry = new three.BufferGeometry() ) {\n\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t\t// initialize the attributes if they don't exist\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\ttargetGeometry.index = geometry.index;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes.position ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t\t}\n\n\t\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t\t}\n\n\t\t\t// ensure the attributes are consistent\n\t\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\t\tif ( includeNormal ) {\n\n\t\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent ) {\n\n\t\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t\t}\n\n\t\t\t// generate transformed vertex attribute data\n\t\t\tconst position = attributes.position;\n\t\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\t\tconst normalMatrix = new three.Matrix3();\n\t\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t\t}\n\n\t\t\t\t// apply morph target transform\n\t\t\t\tif ( morphInfluences ) {\n\n\t\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// apply bone transform\n\t\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the vectors of the attributes\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// copy other attributes over\n\t\t\tfor ( const i in this.attributes ) {\n\n\t\t\t\tconst key = this.attributes[ i ];\n\t\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t}\n\n\texports.AVERAGE = AVERAGE;\n\texports.CENTER = CENTER;\n\texports.CONTAINED = CONTAINED;\n\texports.ExtendedTriangle = ExtendedTriangle;\n\texports.FloatVertexAttributeTexture = FloatVertexAttributeTexture;\n\texports.INTERSECTED = INTERSECTED;\n\texports.IntVertexAttributeTexture = IntVertexAttributeTexture;\n\texports.MeshBVH = MeshBVH;\n\texports.MeshBVHUniformStruct = MeshBVHUniformStruct;\n\texports.MeshBVHVisualizer = MeshBVHVisualizer;\n\texports.NOT_INTERSECTED = NOT_INTERSECTED;\n\texports.OrientedBox = OrientedBox;\n\texports.SAH = SAH;\n\texports.StaticGeometryGenerator = StaticGeometryGenerator;\n\texports.UIntVertexAttributeTexture = UIntVertexAttributeTexture;\n\texports.VertexAttributeTexture = VertexAttributeTexture;\n\texports.acceleratedRaycast = acceleratedRaycast;\n\texports.computeBoundsTree = computeBoundsTree;\n\texports.disposeBoundsTree = disposeBoundsTree;\n\texports.estimateMemoryInBytes = estimateMemoryInBytes;\n\texports.getBVHExtremes = getBVHExtremes;\n\texports.getJSONStructure = getJSONStructure;\n\texports.getTriangleHitPointInfo = getTriangleHitPointInfo;\n\texports.shaderDistanceFunction = shaderDistanceFunction;\n\texports.shaderIntersectFunction = shaderIntersectFunction;\n\texports.shaderStructs = shaderStructs;\n\texports.validateBounds = validateBounds;\n\n}));\n//# sourceMappingURL=index.umd.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL2J1aWxkL2luZGV4LnVtZC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxDQUFDLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlEQUFPO0FBQ2hHLENBQUMsQ0FDOEk7QUFDL0ksQ0FBQyxxQ0FBcUM7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDOztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsUUFBUTtBQUM5Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxTQUFTOztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELFNBQVM7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixnQkFBZ0I7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixRQUFROztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7O0FBRXJDO0FBQ0Esd0JBQXdCLGlCQUFpQjs7QUFFekM7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQSxzQkFBc0IsZUFBZTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLE9BQU87O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMkIsVUFBVTs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFROztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQW1COztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKLDJEQUEyRCxXQUFXOztBQUV0RTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUEscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTzs7QUFFckQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFdBQVc7QUFDeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCOztBQUVyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7O0FBRTVCLHFCQUFxQixRQUFROztBQUU3QixzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0IsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBLHVCQUF1QixRQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTs7QUFFNUIscUJBQXFCLFFBQVE7O0FBRTdCLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCLHNCQUFzQixTQUFTOztBQUUvQix1QkFBdUIsU0FBUzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixRQUFROztBQUU1QixxQkFBcUIsUUFBUTs7QUFFN0Isc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixRQUFROztBQUU1QjtBQUNBLHNCQUFzQixTQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUseUNBQXlDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwyQkFBMkI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQSxXQUFXLGVBQWU7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEMsOENBQThDLFNBQVM7OztBQUd2RDs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBLDhDQUE4QyxTQUFTOztBQUV2RDs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxXQUFXO0FBQ3JCLFVBQVUsUUFBUTtBQUNsQjtBQUNBLDRDQUE0QyxPQUFPOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSwwREFBMEQsT0FBTzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsT0FBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDLDhDQUE4QyxTQUFTOztBQUV2RDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0EsOENBQThDLFNBQVM7O0FBRXZEO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsV0FBVztBQUNyQixVQUFVLFFBQVE7QUFDbEI7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSx5Q0FBeUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0EsSUFBSTs7QUFFSixpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0REFBNEQsT0FBTzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsS0FBSzs7QUFFTDs7QUFFQSwwREFBMEQsT0FBTzs7QUFFakU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOzs7QUFHQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBLG1FQUFtRSxTQUFTOzs7QUFHNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELE9BQU87OztBQUcxRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7QUFDUixRQUFROztBQUVSLE9BQU87O0FBRVA7QUFDQTtBQUNBLHVDQUF1QyxTQUFTOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxPQUFPOzs7QUFHeEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7QUFDQSxzQkFBc0IsT0FBTzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUk7O0FBRUosaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSx5Q0FBeUM7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsT0FBTzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUEsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxPQUFPOztBQUVyRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBLG1FQUFtRSxTQUFTOztBQUU1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxPQUFPOztBQUUxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUUFBUTtBQUNSLFFBQVE7O0FBRVIsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87O0FBRXhEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsK0JBQStCO0FBQzFDLHdDQUF3Qyx3Q0FBd0M7QUFDaEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVELFFBQVE7O0FBRS9EOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0QsU0FBUzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFNBQVM7O0FBRTlEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUVBQXFFLGVBQWU7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCLHlCQUF5QixRQUFROztBQUVqQztBQUNBLDBCQUEwQixRQUFROztBQUVsQztBQUNBLDJCQUEyQixRQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsaUJBQWlCOztBQUV0QztBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjs7QUFFdkM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsZ0JBQWdCOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMERBQTBELE9BQU87O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQSxzQ0FBc0MsT0FBTzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVzs7QUFFL0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsMENBQTBDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EseUlBQXlJO0FBQ3pJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0MsT0FBTzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87O0FBRWxEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsUUFBUTs7QUFFbEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EseURBQXlELDBEQUEwRDs7QUFFbkg7QUFDQSxVQUFVLDhEQUE4RDs7QUFFeEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrRkFBK0Y7O0FBRS9GOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0dBQWdHOztBQUVoRzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsdUJBQXVCOztBQUU1Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsaUJBQWlCOztBQUV4QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTzs7QUFFaEQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxpQ0FBaUMsT0FBTzs7QUFFeEM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFEQUFxRDtBQUNoRSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7O0FBRUEsbURBQW1ELDJCQUEyQjs7QUFFOUU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELE9BQU87O0FBRTFEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJkLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9idWlsZC9pbmRleC51bWQuY2pzPzFhMzQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCd0aHJlZScpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAndGhyZWUnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5NZXNoQlZITGliID0gZ2xvYmFsLk1lc2hCVkhMaWIgfHwge30sIGdsb2JhbC5USFJFRSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSkgeyAndXNlIHN0cmljdCc7XG5cblx0Ly8gU3BsaXQgc3RyYXRlZ3kgY29uc3RhbnRzXG5cdGNvbnN0IENFTlRFUiA9IDA7XG5cdGNvbnN0IEFWRVJBR0UgPSAxO1xuXHRjb25zdCBTQUggPSAyO1xuXG5cdC8vIFRyYXZlcnNhbCBjb25zdGFudHNcblx0Y29uc3QgTk9UX0lOVEVSU0VDVEVEID0gMDtcblx0Y29uc3QgSU5URVJTRUNURUQgPSAxO1xuXHRjb25zdCBDT05UQUlORUQgPSAyO1xuXG5cdC8vIFNBSCBjb3N0IGNvbnN0YW50c1xuXHQvLyBUT0RPOiBob25lIHRoZXNlIGNvc3RzIG1vcmUuIFRoZSByZWxhdGl2ZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlbSBzaG91bGQgYmUgdGhlXG5cdC8vIGRpZmZlcmVuY2UgaW4gbWVhc3VyZWQgdGltZSB0byBwZXJmb3JtIGEgdHJpYW5nbGUgaW50ZXJzZWN0aW9uIHZzIHRyYXZlcnNpbmdcblx0Ly8gYm91bmRzLlxuXHRjb25zdCBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCA9IDEuMjU7XG5cdGNvbnN0IFRSQVZFUlNBTF9DT1NUID0gMTtcblxuXG5cdC8vIEJ1aWxkIGNvbnN0YW50c1xuXHRjb25zdCBCWVRFU19QRVJfTk9ERSA9IDYgKiA0ICsgNCArIDQ7XG5cdGNvbnN0IElTX0xFQUZOT0RFX0ZMQUcgPSAweEZGRkY7XG5cblx0Ly8gRVBTSUxPTiBmb3IgY29tcHV0aW5nIGZsb2F0aW5nIHBvaW50IGVycm9yIGR1cmluZyBidWlsZFxuXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYWNoaW5lX2Vwc2lsb24jVmFsdWVzX2Zvcl9zdGFuZGFyZF9oYXJkd2FyZV9mbG9hdGluZ19wb2ludF9hcml0aG1ldGljc1xuXHRjb25zdCBGTE9BVDMyX0VQU0lMT04gPSBNYXRoLnBvdyggMiwgLSAyNCApO1xuXG5cdGNvbnN0IFNLSVBfR0VORVJBVElPTiA9IFN5bWJvbCggJ1NLSVBfR0VORVJBVElPTicgKTtcblxuXHRmdW5jdGlvbiBnZXRWZXJ0ZXhDb3VudCggZ2VvICkge1xuXG5cdFx0cmV0dXJuIGdlby5pbmRleCA/IGdlby5pbmRleC5jb3VudCA6IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmlDb3VudCggZ2VvICkge1xuXG5cdFx0cmV0dXJuIGdldFZlcnRleENvdW50KCBnZW8gKSAvIDM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEluZGV4QXJyYXkoIHZlcnRleENvdW50LCBCdWZmZXJDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyICkge1xuXG5cdFx0aWYgKCB2ZXJ0ZXhDb3VudCA+IDY1NTM1ICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQzMkFycmF5KCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIDQgKiB2ZXJ0ZXhDb3VudCApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQxNkFycmF5KCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIDIgKiB2ZXJ0ZXhDb3VudCApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIGVuc3VyZXMgdGhhdCBhbiBpbmRleCBpcyBwcmVzZW50IG9uIHRoZSBnZW9tZXRyeVxuXHRmdW5jdGlvbiBlbnN1cmVJbmRleCggZ2VvLCBvcHRpb25zICkge1xuXG5cdFx0aWYgKCAhIGdlby5pbmRleCApIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4Q291bnQgPSBnZW8uYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcblx0XHRcdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4QXJyYXkoIHZlcnRleENvdW50LCBCdWZmZXJDb25zdHJ1Y3RvciApO1xuXHRcdFx0Z2VvLnNldEluZGV4KCBuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBpbmRleCwgMSApICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGluZGV4WyBpIF0gPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIENvbXB1dGVzIHRoZSBzZXQgb2YgeyBvZmZzZXQsIGNvdW50IH0gcmFuZ2VzIHdoaWNoIG5lZWQgaW5kZXBlbmRlbnQgQlZIIHJvb3RzLiBFYWNoXG5cdC8vIHJlZ2lvbiBpbiB0aGUgZ2VvbWV0cnkgaW5kZXggdGhhdCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IHNldCBvZiBtYXRlcmlhbCBncm91cHMgcmVxdWlyZXNcblx0Ly8gYSBzZXBhcmF0ZSBCVkggcm9vdCwgc28gdGhhdCB0cmlhbmdsZXMgaW5kaWNlcyBiZWxvbmdpbmcgdG8gb25lIGdyb3VwIG5ldmVyIGdldCBzd2FwcGVkXG5cdC8vIHdpdGggdHJpYW5nbGUgaW5kaWNlcyBiZWxvbmdzIHRvIGFub3RoZXIgZ3JvdXAuIEZvciBleGFtcGxlLCBpZiB0aGUgZ3JvdXBzIHdlcmUgbGlrZSB0aGlzOlxuXHQvL1xuXHQvLyBbLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV1cblx0Ly8gfF9fX19fX19fX19fX19fX19fX3xcblx0Ly8gICBnMCA9IFswLCAyMF0gIHxfX19fX19fX19fX19fX19fX19fX19ffHxfX19fX19fX19fX19fX19fX19fX198XG5cdC8vICAgICAgICAgICAgICAgICAgICAgIGcxID0gWzE2LCA0MF0gICAgICAgICAgIGcyID0gWzQxLCA2MF1cblx0Ly9cblx0Ly8gd2Ugd291bGQgbmVlZCBmb3VyIEJWSCByb290czogWzAsIDE1XSwgWzE2LCAyMF0sIFsyMSwgNDBdLCBbNDEsIDYwXS5cblx0ZnVuY3Rpb24gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlbyApIHtcblxuXHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIGdlbyApO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlby5kcmF3UmFuZ2U7XG5cdFx0Y29uc3Qgc3RhcnQgPSBkcmF3UmFuZ2Uuc3RhcnQgLyAzO1xuXHRcdGNvbnN0IGVuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgLyAzO1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gTWF0aC5tYXgoIDAsIHN0YXJ0ICk7XG5cdFx0Y29uc3QgY291bnQgPSBNYXRoLm1pbiggdHJpQ291bnQsIGVuZCApIC0gb2Zmc2V0O1xuXHRcdHJldHVybiBbIHtcblx0XHRcdG9mZnNldDogTWF0aC5mbG9vciggb2Zmc2V0ICksXG5cdFx0XHRjb3VudDogTWF0aC5mbG9vciggY291bnQgKSxcblx0XHR9IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJvb3RJbmRleFJhbmdlcyggZ2VvICkge1xuXG5cdFx0aWYgKCAhIGdlby5ncm91cHMgfHwgISBnZW8uZ3JvdXBzLmxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGdldEZ1bGxHZW9tZXRyeVJhbmdlKCBnZW8gKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJhbmdlcyA9IFtdO1xuXHRcdGNvbnN0IHJhbmdlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcblxuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IGdlby5kcmF3UmFuZ2U7XG5cdFx0Y29uc3QgZHJhd1JhbmdlU3RhcnQgPSBkcmF3UmFuZ2Uuc3RhcnQgLyAzO1xuXHRcdGNvbnN0IGRyYXdSYW5nZUVuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgLyAzO1xuXHRcdGZvciAoIGNvbnN0IGdyb3VwIG9mIGdlby5ncm91cHMgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwU3RhcnQgPSBncm91cC5zdGFydCAvIDM7XG5cdFx0XHRjb25zdCBncm91cEVuZCA9ICggZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCApIC8gMztcblx0XHRcdHJhbmdlQm91bmRhcmllcy5hZGQoIE1hdGgubWF4KCBkcmF3UmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApICk7XG5cdFx0XHRyYW5nZUJvdW5kYXJpZXMuYWRkKCBNYXRoLm1pbiggZHJhd1JhbmdlRW5kLCBncm91cEVuZCApICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIG5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcGFzcyBpbiBhIGNvbXBhcmF0b3IsIGl0IHNvcnRzIHRoZW0gbGV4aWNvZ3JhcGhpY2FsbHkgYXMgc3RyaW5ncyA6LShcblx0XHRjb25zdCBzb3J0ZWRCb3VuZGFyaWVzID0gQXJyYXkuZnJvbSggcmFuZ2VCb3VuZGFyaWVzLnZhbHVlcygpICkuc29ydCggKCBhLCBiICkgPT4gYSAtIGIgKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3J0ZWRCb3VuZGFyaWVzLmxlbmd0aCAtIDE7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gc29ydGVkQm91bmRhcmllc1sgaSBdO1xuXHRcdFx0Y29uc3QgZW5kID0gc29ydGVkQm91bmRhcmllc1sgaSArIDEgXTtcblxuXHRcdFx0cmFuZ2VzLnB1c2goIHtcblx0XHRcdFx0b2Zmc2V0OiBNYXRoLmZsb29yKCBzdGFydCApLFxuXHRcdFx0XHRjb3VudDogTWF0aC5mbG9vciggZW5kIC0gc3RhcnQgKSxcblx0XHRcdH0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByYW5nZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0dyb3VwR2FwcyggZ2VvbWV0cnkgKSB7XG5cblx0XHRpZiAoIGdlb21ldHJ5Lmdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZlcnRleENvdW50ID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdFx0Y29uc3QgZ3JvdXBzID0gZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW9tZXRyeSApXG5cdFx0XHQuc29ydCggKCBhLCBiICkgPT4gYS5vZmZzZXQgLSBiLm9mZnNldCApO1xuXG5cdFx0Y29uc3QgZmluYWxHcm91cCA9IGdyb3Vwc1sgZ3JvdXBzLmxlbmd0aCAtIDEgXTtcblx0XHRmaW5hbEdyb3VwLmNvdW50ID0gTWF0aC5taW4oIHZlcnRleENvdW50IC0gZmluYWxHcm91cC5vZmZzZXQsIGZpbmFsR3JvdXAuY291bnQgKTtcblxuXHRcdGxldCB0b3RhbCA9IDA7XG5cdFx0Z3JvdXBzLmZvckVhY2goICggeyBjb3VudCB9ICkgPT4gdG90YWwgKz0gY291bnQgKTtcblx0XHRyZXR1cm4gdmVydGV4Q291bnQgIT09IHRvdGFsO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheVRvQm94KCBub2RlSW5kZXgzMiwgYXJyYXksIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5taW4ueCA9IGFycmF5WyBub2RlSW5kZXgzMiBdO1xuXHRcdHRhcmdldC5taW4ueSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDEgXTtcblx0XHR0YXJnZXQubWluLnogPSBhcnJheVsgbm9kZUluZGV4MzIgKyAyIF07XG5cblx0XHR0YXJnZXQubWF4LnggPSBhcnJheVsgbm9kZUluZGV4MzIgKyAzIF07XG5cdFx0dGFyZ2V0Lm1heC55ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgNCBdO1xuXHRcdHRhcmdldC5tYXgueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDUgXTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VFbXB0eUJvdW5kcyggdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0WyAwIF0gPSB0YXJnZXRbIDEgXSA9IHRhcmdldFsgMiBdID0gSW5maW5pdHk7XG5cdFx0dGFyZ2V0WyAzIF0gPSB0YXJnZXRbIDQgXSA9IHRhcmdldFsgNSBdID0gLSBJbmZpbml0eTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggYm91bmRzICkge1xuXG5cdFx0bGV0IHNwbGl0RGltSWR4ID0gLSAxO1xuXHRcdGxldCBzcGxpdERpc3QgPSAtIEluZmluaXR5O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZGlzdCA9IGJvdW5kc1sgaSArIDMgXSAtIGJvdW5kc1sgaSBdO1xuXHRcdFx0aWYgKCBkaXN0ID4gc3BsaXREaXN0ICkge1xuXG5cdFx0XHRcdHNwbGl0RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdHNwbGl0RGltSWR4ID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwbGl0RGltSWR4O1xuXG5cdH1cblxuXHQvLyBjb3BpZXMgYm91bmRzIGEgaW50byBib3VuZHMgYlxuXHRmdW5jdGlvbiBjb3B5Qm91bmRzKCBzb3VyY2UsIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5zZXQoIHNvdXJjZSApO1xuXG5cdH1cblxuXHQvLyBzZXRzIGJvdW5kcyB0YXJnZXQgdG8gdGhlIHVuaW9uIG9mIGJvdW5kcyBhIGFuZCBiXG5cdGZ1bmN0aW9uIHVuaW9uQm91bmRzKCBhLCBiLCB0YXJnZXQgKSB7XG5cblx0XHRsZXQgYVZhbCwgYlZhbDtcblx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0XHRjb25zdCBkMyA9IGQgKyAzO1xuXG5cdFx0XHQvLyBzZXQgdGhlIG1pbmltdW0gdmFsdWVzXG5cdFx0XHRhVmFsID0gYVsgZCBdO1xuXHRcdFx0YlZhbCA9IGJbIGQgXTtcblx0XHRcdHRhcmdldFsgZCBdID0gYVZhbCA8IGJWYWwgPyBhVmFsIDogYlZhbDtcblxuXHRcdFx0Ly8gc2V0IHRoZSBtYXggdmFsdWVzXG5cdFx0XHRhVmFsID0gYVsgZDMgXTtcblx0XHRcdGJWYWwgPSBiWyBkMyBdO1xuXHRcdFx0dGFyZ2V0WyBkMyBdID0gYVZhbCA+IGJWYWwgPyBhVmFsIDogYlZhbDtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZXhwYW5kcyB0aGUgZ2l2ZW4gYm91bmRzIGJ5IHRoZSBwcm92aWRlZCB0cmlhbmdsZSBib3VuZHNcblx0ZnVuY3Rpb24gZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggc3RhcnRJbmRleCwgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApIHtcblxuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRDZW50ZXIgPSB0cmlhbmdsZUJvdW5kc1sgc3RhcnRJbmRleCArIDIgKiBkIF07XG5cdFx0XHRjb25zdCB0SGFsZiA9IHRyaWFuZ2xlQm91bmRzWyBzdGFydEluZGV4ICsgMiAqIGQgKyAxIF07XG5cblx0XHRcdGNvbnN0IHRNaW4gPSB0Q2VudGVyIC0gdEhhbGY7XG5cdFx0XHRjb25zdCB0TWF4ID0gdENlbnRlciArIHRIYWxmO1xuXG5cdFx0XHRpZiAoIHRNaW4gPCBib3VuZHNbIGQgXSApIHtcblxuXHRcdFx0XHRib3VuZHNbIGQgXSA9IHRNaW47XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0TWF4ID4gYm91bmRzWyBkICsgMyBdICkge1xuXG5cdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IHRNYXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gY29tcHV0ZSBib3VuZHMgc3VyZmFjZSBhcmVhXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdXJmYWNlQXJlYSggYm91bmRzICkge1xuXG5cdFx0Y29uc3QgZDAgPSBib3VuZHNbIDMgXSAtIGJvdW5kc1sgMCBdO1xuXHRcdGNvbnN0IGQxID0gYm91bmRzWyA0IF0gLSBib3VuZHNbIDEgXTtcblx0XHRjb25zdCBkMiA9IGJvdW5kc1sgNSBdIC0gYm91bmRzWyAyIF07XG5cblx0XHRyZXR1cm4gMiAqICggZDAgKiBkMSArIGQxICogZDIgKyBkMiAqIGQwICk7XG5cblx0fVxuXG5cdC8vIGNvbXB1dGVzIHRoZSB1bmlvbiBvZiB0aGUgYm91bmRzIG9mIGFsbCBvZiB0aGUgZ2l2ZW4gdHJpYW5nbGVzIGFuZCBwdXRzIHRoZSByZXN1bHRpbmcgYm94IGluIHRhcmdldC4gSWZcblx0Ly8gY2VudHJvaWRUYXJnZXQgaXMgcHJvdmlkZWQgdGhlbiBhIGJvdW5kaW5nIGJveCBpcyBjb21wdXRlZCBmb3IgdGhlIGNlbnRyb2lkcyBvZiB0aGUgdHJpYW5nbGVzLCBhcyB3ZWxsLlxuXHQvLyBUaGVzZSBhcmUgY29tcHV0ZWQgdG9nZXRoZXIgdG8gYXZvaWQgcmVkdW5kYW50IGFjY2Vzc2VzIHRvIGJvdW5kcyBhcnJheS5cblx0ZnVuY3Rpb24gZ2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgdGFyZ2V0LCBjZW50cm9pZFRhcmdldCA9IG51bGwgKSB7XG5cblx0XHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRcdGxldCBtaW55ID0gSW5maW5pdHk7XG5cdFx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0XHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IG1heHkgPSAtIEluZmluaXR5O1xuXHRcdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRcdGxldCBjbWlueCA9IEluZmluaXR5O1xuXHRcdGxldCBjbWlueSA9IEluZmluaXR5O1xuXHRcdGxldCBjbWlueiA9IEluZmluaXR5O1xuXHRcdGxldCBjbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgY21heHogPSAtIEluZmluaXR5O1xuXG5cdFx0Y29uc3QgaW5jbHVkZUNlbnRyb2lkID0gY2VudHJvaWRUYXJnZXQgIT09IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiA2LCBlbmQgPSAoIG9mZnNldCArIGNvdW50ICkgKiA2OyBpIDwgZW5kOyBpICs9IDYgKSB7XG5cblx0XHRcdGNvbnN0IGN4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAwIF07XG5cdFx0XHRjb25zdCBoeCA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMSBdO1xuXHRcdFx0Y29uc3QgbHggPSBjeCAtIGh4O1xuXHRcdFx0Y29uc3QgcnggPSBjeCArIGh4O1xuXHRcdFx0aWYgKCBseCA8IG1pbnggKSBtaW54ID0gbHg7XG5cdFx0XHRpZiAoIHJ4ID4gbWF4eCApIG1heHggPSByeDtcblx0XHRcdGlmICggaW5jbHVkZUNlbnRyb2lkICYmIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3ggPiBjbWF4eCApIGNtYXh4ID0gY3g7XG5cblx0XHRcdGNvbnN0IGN5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAyIF07XG5cdFx0XHRjb25zdCBoeSA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMyBdO1xuXHRcdFx0Y29uc3QgbHkgPSBjeSAtIGh5O1xuXHRcdFx0Y29uc3QgcnkgPSBjeSArIGh5O1xuXHRcdFx0aWYgKCBseSA8IG1pbnkgKSBtaW55ID0gbHk7XG5cdFx0XHRpZiAoIHJ5ID4gbWF4eSApIG1heHkgPSByeTtcblx0XHRcdGlmICggaW5jbHVkZUNlbnRyb2lkICYmIGN5IDwgY21pbnkgKSBjbWlueSA9IGN5O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRcdGNvbnN0IGN6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA0IF07XG5cdFx0XHRjb25zdCBoeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNSBdO1xuXHRcdFx0Y29uc3QgbHogPSBjeiAtIGh6O1xuXHRcdFx0Y29uc3QgcnogPSBjeiArIGh6O1xuXHRcdFx0aWYgKCBseiA8IG1pbnogKSBtaW56ID0gbHo7XG5cdFx0XHRpZiAoIHJ6ID4gbWF4eiApIG1heHogPSByejtcblx0XHRcdGlmICggaW5jbHVkZUNlbnRyb2lkICYmIGN6IDwgY21pbnogKSBjbWlueiA9IGN6O1xuXHRcdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3ogPiBjbWF4eiApIGNtYXh6ID0gY3o7XG5cblx0XHR9XG5cblx0XHR0YXJnZXRbIDAgXSA9IG1pbng7XG5cdFx0dGFyZ2V0WyAxIF0gPSBtaW55O1xuXHRcdHRhcmdldFsgMiBdID0gbWluejtcblxuXHRcdHRhcmdldFsgMyBdID0gbWF4eDtcblx0XHR0YXJnZXRbIDQgXSA9IG1heHk7XG5cdFx0dGFyZ2V0WyA1IF0gPSBtYXh6O1xuXG5cdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgKSB7XG5cblx0XHRcdGNlbnRyb2lkVGFyZ2V0WyAwIF0gPSBjbWlueDtcblx0XHRcdGNlbnRyb2lkVGFyZ2V0WyAxIF0gPSBjbWlueTtcblx0XHRcdGNlbnRyb2lkVGFyZ2V0WyAyIF0gPSBjbWluejtcblxuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDMgXSA9IGNtYXh4O1xuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDQgXSA9IGNtYXh5O1xuXHRcdFx0Y2VudHJvaWRUYXJnZXRbIDUgXSA9IGNtYXh6O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBBIHN0YW5kIGFsb25lIGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSBjZW50cm9pZCBib3VuZHMuXG5cdGZ1bmN0aW9uIGdldENlbnRyb2lkQm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgY2VudHJvaWRUYXJnZXQgKSB7XG5cblx0XHRsZXQgY21pbnggPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnkgPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnogPSBJbmZpbml0eTtcblx0XHRsZXQgY21heHggPSAtIEluZmluaXR5O1xuXHRcdGxldCBjbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0ICogNiwgZW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjsgaSA8IGVuZDsgaSArPSA2ICkge1xuXG5cdFx0XHRjb25zdCBjeCA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMCBdO1xuXHRcdFx0aWYgKCBjeCA8IGNtaW54ICkgY21pbnggPSBjeDtcblx0XHRcdGlmICggY3ggPiBjbWF4eCApIGNtYXh4ID0gY3g7XG5cblx0XHRcdGNvbnN0IGN5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAyIF07XG5cdFx0XHRpZiAoIGN5IDwgY21pbnkgKSBjbWlueSA9IGN5O1xuXHRcdFx0aWYgKCBjeSA+IGNtYXh5ICkgY21heHkgPSBjeTtcblxuXHRcdFx0Y29uc3QgY3ogPSB0cmlhbmdsZUJvdW5kc1sgaSArIDQgXTtcblx0XHRcdGlmICggY3ogPCBjbWlueiApIGNtaW56ID0gY3o7XG5cdFx0XHRpZiAoIGN6ID4gY21heHogKSBjbWF4eiA9IGN6O1xuXG5cdFx0fVxuXG5cdFx0Y2VudHJvaWRUYXJnZXRbIDAgXSA9IGNtaW54O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyAxIF0gPSBjbWlueTtcblx0XHRjZW50cm9pZFRhcmdldFsgMiBdID0gY21pbno7XG5cblx0XHRjZW50cm9pZFRhcmdldFsgMyBdID0gY21heHg7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDQgXSA9IGNtYXh5O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyA1IF0gPSBjbWF4ejtcblxuXHR9XG5cblxuXHQvLyBwcmVjb21wdXRlcyB0aGUgYm91bmRpbmcgYm94IGZvciBlYWNoIHRyaWFuZ2xlOyByZXF1aXJlZCBmb3IgcXVpY2tseSBjYWxjdWxhdGluZyB0cmVlIHNwbGl0cy5cblx0Ly8gcmVzdWx0IGlzIGFuIGFycmF5IG9mIHNpemUgdHJpcy5sZW5ndGggKiA2IHdoZXJlIHRyaWFuZ2xlIGkgbWFwcyB0byBhXG5cdC8vIFt4X2NlbnRlciwgeF9kZWx0YSwgeV9jZW50ZXIsIHlfZGVsdGEsIHpfY2VudGVyLCB6X2RlbHRhXSB0dXBsZSBzdGFydGluZyBhdCBpbmRleCBpICogNixcblx0Ly8gcmVwcmVzZW50aW5nIHRoZSBjZW50ZXIgYW5kIGhhbGYtZXh0ZW50IGluIGVhY2ggZGltZW5zaW9uIG9mIHRyaWFuZ2xlIGlcblx0ZnVuY3Rpb24gY29tcHV0ZVRyaWFuZ2xlQm91bmRzKCBnZW8sIGZ1bGxCb3VuZHMgKSB7XG5cblx0XHQvLyBjbGVhciB0aGUgYm91bmRzIHRvIGVtcHR5XG5cdFx0bWFrZUVtcHR5Qm91bmRzKCBmdWxsQm91bmRzICk7XG5cblx0XHRjb25zdCBwb3NBdHRyID0gZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW8uaW5kZXggPyBnZW8uaW5kZXguYXJyYXkgOiBudWxsO1xuXHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIGdlbyApO1xuXHRcdGNvbnN0IHRyaWFuZ2xlQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheSggdHJpQ291bnQgKiA2ICk7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IHBvc0F0dHIubm9ybWFsaXplZDtcblxuXHRcdC8vIHVzZWQgZm9yIG5vbi1ub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRcdGNvbnN0IHBvc0FyciA9IHBvc0F0dHIuYXJyYXk7XG5cblx0XHQvLyBzdXBwb3J0IGZvciBhbiBpbnRlcmxlYXZlZCBwb3NpdGlvbiBidWZmZXJcblx0XHRjb25zdCBidWZmZXJPZmZzZXQgPSBwb3NBdHRyLm9mZnNldCB8fCAwO1xuXHRcdGxldCBzdHJpZGUgPSAzO1xuXHRcdGlmICggcG9zQXR0ci5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRzdHJpZGUgPSBwb3NBdHRyLmRhdGEuc3RyaWRlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBmb3Igbm9ybWFsaXplZCBwb3NpdGlvbnNcblx0XHRjb25zdCBnZXR0ZXJzID0gWyAnZ2V0WCcsICdnZXRZJywgJ2dldFonIF07XG5cblx0XHRmb3IgKCBsZXQgdHJpID0gMDsgdHJpIDwgdHJpQ291bnQ7IHRyaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdHJpMyA9IHRyaSAqIDM7XG5cdFx0XHRjb25zdCB0cmk2ID0gdHJpICogNjtcblxuXHRcdFx0bGV0IGFpID0gdHJpMyArIDA7XG5cdFx0XHRsZXQgYmkgPSB0cmkzICsgMTtcblx0XHRcdGxldCBjaSA9IHRyaTMgKyAyO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRcdGFpID0gaW5kZXhbIGFpIF07XG5cdFx0XHRcdGJpID0gaW5kZXhbIGJpIF07XG5cdFx0XHRcdGNpID0gaW5kZXhbIGNpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2UgYWRkIHRoZSBzdHJpZGUgYW5kIG9mZnNldCBoZXJlIHNpbmNlIHdlIGFjY2VzcyB0aGUgYXJyYXkgZGlyZWN0bHlcblx0XHRcdC8vIGJlbG93IGZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZVxuXHRcdFx0aWYgKCAhIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0YWkgPSBhaSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdFx0YmkgPSBiaSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdFx0Y2kgPSBjaSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgZWwgPSAwOyBlbCA8IDM7IGVsICsrICkge1xuXG5cdFx0XHRcdGxldCBhLCBiLCBjO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsaXplZCApIHtcblxuXHRcdFx0XHRcdGEgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGFpICk7XG5cdFx0XHRcdFx0YiA9IHBvc0F0dHJbIGdldHRlcnNbIGVsIF0gXSggYmkgKTtcblx0XHRcdFx0XHRjID0gcG9zQXR0clsgZ2V0dGVyc1sgZWwgXSBdKCBjaSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRhID0gcG9zQXJyWyBhaSArIGVsIF07XG5cdFx0XHRcdFx0YiA9IHBvc0FyclsgYmkgKyBlbCBdO1xuXHRcdFx0XHRcdGMgPSBwb3NBcnJbIGNpICsgZWwgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IG1pbiA9IGE7XG5cdFx0XHRcdGlmICggYiA8IG1pbiApIG1pbiA9IGI7XG5cdFx0XHRcdGlmICggYyA8IG1pbiApIG1pbiA9IGM7XG5cblx0XHRcdFx0bGV0IG1heCA9IGE7XG5cdFx0XHRcdGlmICggYiA+IG1heCApIG1heCA9IGI7XG5cdFx0XHRcdGlmICggYyA+IG1heCApIG1heCA9IGM7XG5cblx0XHRcdFx0Ly8gSW5jcmVhc2UgdGhlIGJvdW5kcyBzaXplIGJ5IGZsb2F0MzIgZXBzaWxvbiB0byBhdm9pZCBwcmVjaXNpb24gZXJyb3JzIHdoZW5cblx0XHRcdFx0Ly8gY29udmVydGluZyB0byAzMiBiaXQgZmxvYXQuIFNjYWxlIHRoZSBlcHNpbG9uIGJ5IHRoZSBzaXplIG9mIHRoZSBudW1iZXJzIGJlaW5nXG5cdFx0XHRcdC8vIHdvcmtlZCB3aXRoLlxuXHRcdFx0XHRjb25zdCBoYWxmRXh0ZW50cyA9ICggbWF4IC0gbWluICkgLyAyO1xuXHRcdFx0XHRjb25zdCBlbDIgPSBlbCAqIDI7XG5cdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyB0cmk2ICsgZWwyICsgMCBdID0gbWluICsgaGFsZkV4dGVudHM7XG5cdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyB0cmk2ICsgZWwyICsgMSBdID0gaGFsZkV4dGVudHMgKyAoIE1hdGguYWJzKCBtaW4gKSArIGhhbGZFeHRlbnRzICkgKiBGTE9BVDMyX0VQU0lMT047XG5cblx0XHRcdFx0aWYgKCBtaW4gPCBmdWxsQm91bmRzWyBlbCBdICkgZnVsbEJvdW5kc1sgZWwgXSA9IG1pbjtcblx0XHRcdFx0aWYgKCBtYXggPiBmdWxsQm91bmRzWyBlbCArIDMgXSApIGZ1bGxCb3VuZHNbIGVsICsgMyBdID0gbWF4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVCb3VuZHM7XG5cblx0fVxuXG5cdGNvbnN0IEJJTl9DT1VOVCA9IDMyO1xuXHRjb25zdCBiaW5zU29ydCA9ICggYSwgYiApID0+IGEuY2FuZGlkYXRlIC0gYi5jYW5kaWRhdGU7XG5cdGNvbnN0IHNhaEJpbnMgPSBuZXcgQXJyYXkoIEJJTl9DT1VOVCApLmZpbGwoKS5tYXAoICgpID0+IHtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGNvdW50OiAwLFxuXHRcdFx0Ym91bmRzOiBuZXcgRmxvYXQzMkFycmF5KCA2ICksXG5cdFx0XHRyaWdodENhY2hlQm91bmRzOiBuZXcgRmxvYXQzMkFycmF5KCA2ICksXG5cdFx0XHRsZWZ0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdGNhbmRpZGF0ZTogMCxcblxuXHRcdH07XG5cblx0fSApO1xuXHRjb25zdCBsZWZ0Qm91bmRzID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXG5cdGZ1bmN0aW9uIGdldE9wdGltYWxTcGxpdCggbm9kZUJvdW5kaW5nRGF0YSwgY2VudHJvaWRCb3VuZGluZ0RhdGEsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzdHJhdGVneSApIHtcblxuXHRcdGxldCBheGlzID0gLSAxO1xuXHRcdGxldCBwb3MgPSAwO1xuXG5cdFx0Ly8gQ2VudGVyXG5cdFx0aWYgKCBzdHJhdGVneSA9PT0gQ0VOVEVSICkge1xuXG5cdFx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggY2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdGlmICggYXhpcyAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHBvcyA9ICggY2VudHJvaWRCb3VuZGluZ0RhdGFbIGF4aXMgXSArIGNlbnRyb2lkQm91bmRpbmdEYXRhWyBheGlzICsgMyBdICkgLyAyO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBzdHJhdGVneSA9PT0gQVZFUkFHRSApIHtcblxuXHRcdFx0YXhpcyA9IGdldExvbmdlc3RFZGdlSW5kZXgoIG5vZGVCb3VuZGluZ0RhdGEgKTtcblx0XHRcdGlmICggYXhpcyAhPT0gLSAxICkge1xuXG5cdFx0XHRcdHBvcyA9IGdldEF2ZXJhZ2UoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBheGlzICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHN0cmF0ZWd5ID09PSBTQUggKSB7XG5cblx0XHRcdGNvbnN0IHJvb3RTdXJmYWNlQXJlYSA9IGNvbXB1dGVTdXJmYWNlQXJlYSggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdFx0bGV0IGJlc3RDb3N0ID0gVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgKiBjb3VudDtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBheGVzXG5cdFx0XHRjb25zdCBjU3RhcnQgPSBvZmZzZXQgKiA2O1xuXHRcdFx0Y29uc3QgY0VuZCA9ICggb2Zmc2V0ICsgY291bnQgKSAqIDY7XG5cdFx0XHRmb3IgKCBsZXQgYSA9IDA7IGEgPCAzOyBhICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF4aXNMZWZ0ID0gY2VudHJvaWRCb3VuZGluZ0RhdGFbIGEgXTtcblx0XHRcdFx0Y29uc3QgYXhpc1JpZ2h0ID0gY2VudHJvaWRCb3VuZGluZ0RhdGFbIGEgKyAzIF07XG5cdFx0XHRcdGNvbnN0IGF4aXNMZW5ndGggPSBheGlzUmlnaHQgLSBheGlzTGVmdDtcblx0XHRcdFx0Y29uc3QgYmluV2lkdGggPSBheGlzTGVuZ3RoIC8gQklOX0NPVU5UO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZmV3ZXIgdHJpYW5nbGVzIHRoYW4gd2UncmUgcGxhbm5pbmcgdG8gc3BsaXQgdGhlbiBqdXN0IGNoZWNrIGFsbFxuXHRcdFx0XHQvLyB0aGUgdHJpYW5nbGUgcG9zaXRpb25zIGJlY2F1c2UgaXQgd2lsbCBiZSBmYXN0ZXIuXG5cdFx0XHRcdGlmICggY291bnQgPCBCSU5fQ09VTlQgLyA0ICkge1xuXG5cdFx0XHRcdFx0Ly8gaW5pdGlhbGl6ZSB0aGUgYmluIGNhbmRpZGF0ZXNcblx0XHRcdFx0XHRjb25zdCB0cnVuY2F0ZWRCaW5zID0gWyAuLi5zYWhCaW5zIF07XG5cdFx0XHRcdFx0dHJ1bmNhdGVkQmlucy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0XHRcdC8vIHNldCB0aGUgY2FuZGlkYXRlc1xuXHRcdFx0XHRcdGxldCBiID0gMDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiwgYiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYiBdO1xuXHRcdFx0XHRcdFx0YmluLmNhbmRpZGF0ZSA9IHRyaWFuZ2xlQm91bmRzWyBjICsgMiAqIGEgXTtcblx0XHRcdFx0XHRcdGJpbi5jb3VudCA9IDA7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRcdFx0Ym91bmRzLFxuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHMsXG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHMsXG5cdFx0XHRcdFx0XHR9ID0gYmluO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzWyBkIF0gPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdFx0bGVmdENhY2hlQm91bmRzWyBkIF0gPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcdFx0bGVmdENhY2hlQm91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBib3VuZHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRydW5jYXRlZEJpbnMuc29ydCggYmluc1NvcnQgKTtcblxuXHRcdFx0XHRcdC8vIHJlbW92ZSByZWR1bmRhbnQgc3BsaXRzXG5cdFx0XHRcdFx0bGV0IHNwbGl0Q291bnQgPSBjb3VudDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgYmkgPSAwOyBiaSA8IHNwbGl0Q291bnQ7IGJpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiaSBdO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBiaSArIDEgPCBzcGxpdENvdW50ICYmIHRydW5jYXRlZEJpbnNbIGJpICsgMSBdLmNhbmRpZGF0ZSA9PT0gYmluLmNhbmRpZGF0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHR0cnVuY2F0ZWRCaW5zLnNwbGljZSggYmkgKyAxLCAxICk7XG5cdFx0XHRcdFx0XHRcdHNwbGl0Q291bnQgLS07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGZpbmQgdGhlIGFwcHJvcHJpYXRlIGJpbiBmb3IgZWFjaCB0cmlhbmdsZSBhbmQgZXhwYW5kIHRoZSBib3VuZHMuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGMgPSBjU3RhcnQ7IGMgPCBjRW5kOyBjICs9IDYgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNlbnRlciA9IHRyaWFuZ2xlQm91bmRzWyBjICsgMiAqIGEgXTtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjZW50ZXIgPj0gYmluLmNhbmRpZGF0ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBjLCB0cmlhbmdsZUJvdW5kcywgYmluLmxlZnRDYWNoZUJvdW5kcyApO1xuXHRcdFx0XHRcdFx0XHRcdGJpbi5jb3VudCArKztcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGV4cGFuZCBhbGwgdGhlIGJvdW5kc1xuXHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBsZWZ0Q291bnQgPSBiaW4uY291bnQ7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodENvdW50ID0gY291bnQgLSBiaW4uY291bnQ7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRCb3VuZHMgPSBiaW4ubGVmdENhY2hlQm91bmRzO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRCb3VuZHMgPSBiaW4ucmlnaHRDYWNoZUJvdW5kcztcblxuXHRcdFx0XHRcdFx0bGV0IGxlZnRQcm9iID0gMDtcblx0XHRcdFx0XHRcdGlmICggbGVmdENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGxlZnRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBsZWZ0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bGV0IHJpZ2h0UHJvYiA9IDA7XG5cdFx0XHRcdFx0XHRpZiAoIHJpZ2h0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmlnaHRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCByaWdodEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvc3QgPSBUUkFWRVJTQUxfQ09TVCArIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogKFxuXHRcdFx0XHRcdFx0XHRsZWZ0UHJvYiAqIGxlZnRDb3VudCArIHJpZ2h0UHJvYiAqIHJpZ2h0Q291bnRcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICggY29zdCA8IGJlc3RDb3N0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGF4aXMgPSBhO1xuXHRcdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IGJpbi5jYW5kaWRhdGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gcmVzZXQgdGhlIGJpbnNcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBCSU5fQ09VTlQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGkgXTtcblx0XHRcdFx0XHRcdGJpbi5jb3VudCA9IDA7XG5cdFx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gYXhpc0xlZnQgKyBiaW5XaWR0aCArIGkgKiBiaW5XaWR0aDtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYm91bmRzID0gYmluLmJvdW5kcztcblx0XHRcdFx0XHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ym91bmRzWyBkIF0gPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcdFx0Ym91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBjZW50ZXIgcG9zaXRpb25zXG5cdFx0XHRcdFx0Zm9yICggbGV0IGMgPSBjU3RhcnQ7IGMgPCBjRW5kOyBjICs9IDYgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHRyaUNlbnRlciA9IHRyaWFuZ2xlQm91bmRzWyBjICsgMiAqIGEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHJlbGF0aXZlQ2VudGVyID0gdHJpQ2VudGVyIC0gYXhpc0xlZnQ7XG5cblx0XHRcdFx0XHRcdC8vIGluIHRoZSBwYXJ0aXRpb24gZnVuY3Rpb24gaWYgdGhlIGNlbnRyb2lkIGxpZXMgb24gdGhlIHNwbGl0IHBsYW5lIHRoZW4gaXQgaXNcblx0XHRcdFx0XHRcdC8vIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdFx0XHRcdFx0XHRsZXQgYmluSW5kZXggPSB+IH4gKCByZWxhdGl2ZUNlbnRlciAvIGJpbldpZHRoICk7XG5cdFx0XHRcdFx0XHRpZiAoIGJpbkluZGV4ID49IEJJTl9DT1VOVCApIGJpbkluZGV4ID0gQklOX0NPVU5UIC0gMTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgYmluSW5kZXggXTtcblx0XHRcdFx0XHRcdGJpbi5jb3VudCArKztcblxuXHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5ib3VuZHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNhY2hlIHRoZSB1bmlvbmVkIGJvdW5kcyBmcm9tIHJpZ2h0IHRvIGxlZnQgc28gd2UgZG9uJ3QgaGF2ZSB0byByZWdlbmVyYXRlIHRoZW0gZWFjaCB0aW1lXG5cdFx0XHRcdFx0Y29uc3QgbGFzdEJpbiA9IHNhaEJpbnNbIEJJTl9DT1VOVCAtIDEgXTtcblx0XHRcdFx0XHRjb3B5Qm91bmRzKCBsYXN0QmluLmJvdW5kcywgbGFzdEJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBCSU5fQ09VTlQgLSAyOyBpID49IDA7IGkgLS0gKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG5leHRCaW4gPSBzYWhCaW5zWyBpICsgMSBdO1xuXHRcdFx0XHRcdFx0dW5pb25Cb3VuZHMoIGJpbi5ib3VuZHMsIG5leHRCaW4ucmlnaHRDYWNoZUJvdW5kcywgYmluLnJpZ2h0Q2FjaGVCb3VuZHMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBsZWZ0Q291bnQgPSAwO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IEJJTl9DT1VOVCAtIDE7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHNhaEJpbnNbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGJpbkNvdW50ID0gYmluLmNvdW50O1xuXHRcdFx0XHRcdFx0Y29uc3QgYm91bmRzID0gYmluLmJvdW5kcztcblxuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEJpbiA9IHNhaEJpbnNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IG5leHRCaW4ucmlnaHRDYWNoZUJvdW5kcztcblxuXHRcdFx0XHRcdFx0Ly8gZG9uJ3QgZG8gYW55dGhpbmcgd2l0aCB0aGUgYm91bmRzIGlmIHRoZSBuZXcgYm91bmRzIGhhdmUgbm8gdHJpYW5nbGVzXG5cdFx0XHRcdFx0XHRpZiAoIGJpbkNvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbGVmdENvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29weUJvdW5kcyggYm91bmRzLCBsZWZ0Qm91bmRzICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHVuaW9uQm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bGVmdENvdW50ICs9IGJpbkNvdW50O1xuXG5cdFx0XHRcdFx0XHQvLyBjaGVjayB0aGUgY29zdCBvZiB0aGlzIHNwbGl0XG5cdFx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdFx0bGV0IHJpZ2h0UHJvYiA9IDA7XG5cblx0XHRcdFx0XHRcdGlmICggbGVmdENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGxlZnRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBsZWZ0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRDb3VudCA9IGNvdW50IC0gbGVmdENvdW50O1xuXHRcdFx0XHRcdFx0aWYgKCByaWdodENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdHJpZ2h0UHJvYiA9IGNvbXB1dGVTdXJmYWNlQXJlYSggcmlnaHRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBjb3N0ID0gVFJBVkVSU0FMX0NPU1QgKyBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIChcblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgKiBsZWZ0Q291bnQgKyByaWdodFByb2IgKiByaWdodENvdW50XG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvc3QgPCBiZXN0Q29zdCApIHtcblxuXHRcdFx0XHRcdFx0XHRheGlzID0gYTtcblx0XHRcdFx0XHRcdFx0YmVzdENvc3QgPSBjb3N0O1xuXHRcdFx0XHRcdFx0XHRwb3MgPSBiaW4uY2FuZGlkYXRlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oIGBNZXNoQlZIOiBJbnZhbGlkIGJ1aWxkIHN0cmF0ZWd5IHZhbHVlICR7IHN0cmF0ZWd5IH0gdXNlZC5gICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4geyBheGlzLCBwb3MgfTtcblxuXHR9XG5cblx0Ly8gcmV0dXJucyB0aGUgYXZlcmFnZSBjb29yZGluYXRlIG9uIHRoZSBzcGVjaWZpZWQgYXhpcyBvZiB0aGUgYWxsIHRoZSBwcm92aWRlZCB0cmlhbmdsZXNcblx0ZnVuY3Rpb24gZ2V0QXZlcmFnZSggdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIGF4aXMgKSB7XG5cblx0XHRsZXQgYXZnID0gMDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGF2ZyArPSB0cmlhbmdsZUJvdW5kc1sgaSAqIDYgKyBheGlzICogMiBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF2ZyAvIGNvdW50O1xuXG5cdH1cblxuXHRjbGFzcyBNZXNoQlZITm9kZSB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0Ly8gaW50ZXJuYWwgbm9kZXMgaGF2ZSBib3VuZGluZ0RhdGEsIGxlZnQsIHJpZ2h0LCBhbmQgc3BsaXRBeGlzXG5cdFx0XHQvLyBsZWFmIG5vZGVzIGhhdmUgb2Zmc2V0IGFuZCBjb3VudCAocmVmZXJyaW5nIHRvIHByaW1pdGl2ZXMgaW4gdGhlIG1lc2ggZ2VvbWV0cnkpXG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwic29ydFV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0Ly8gcmVvcmRlcnMgYHRyaXNgIHN1Y2ggdGhhdCBmb3IgYGNvdW50YCBlbGVtZW50cyBhZnRlciBgb2Zmc2V0YCwgZWxlbWVudHMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc3BsaXRcblx0Ly8gd2lsbCBiZSBvbiB0aGUgbGVmdCBhbmQgZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0IHdpbGwgYmUgb24gdGhlIHJpZ2h0LiByZXR1cm5zIHRoZSBpbmRleFxuXHQvLyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvbiB0aGUgcmlnaHQgc2lkZSwgb3Igb2Zmc2V0ICsgY291bnQgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlLlxuXHRmdW5jdGlvbiBwYXJ0aXRpb24oIGluZGlyZWN0QnVmZmVyLCBpbmRleCwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHNwbGl0ICkge1xuXG5cdFx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdFx0bGV0IHJpZ2h0ID0gb2Zmc2V0ICsgY291bnQgLSAxO1xuXHRcdGNvbnN0IHBvcyA9IHNwbGl0LnBvcztcblx0XHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0XHQvLyBob2FyZSBwYXJ0aXRpb25pbmcsIHNlZSBlLmcuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1aWNrc29ydCNIb2FyZV9wYXJ0aXRpb25fc2NoZW1lXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRcdGxlZnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgYSB0cmlhbmdsZSBjZW50ZXIgbGllcyBvbiB0aGUgcGFydGl0aW9uIHBsYW5lIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHRcdHdoaWxlICggbGVmdCA8PSByaWdodCAmJiB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgYXhpc09mZnNldCBdID49IHBvcyApIHtcblxuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxlZnQgPCByaWdodCApIHtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHN3YXAgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHRyaWFuZ2xlcyBhdCBpbmRleFxuXHRcdFx0XHQvLyBsZWZ0IGFuZCByaWdodDsgdGhhdCdzIHRoZSB2ZXJ0cyBpbiB0aGUgZ2VvbWV0cnkgaW5kZXgsIHRoZSBib3VuZHMsXG5cdFx0XHRcdC8vIGFuZCBwZXJoYXBzIHRoZSBTQUggcGxhbmVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0MCA9IGluZGV4WyBsZWZ0ICogMyArIGkgXTtcblx0XHRcdFx0XHRpbmRleFsgbGVmdCAqIDMgKyBpIF0gPSBpbmRleFsgcmlnaHQgKiAzICsgaSBdO1xuXHRcdFx0XHRcdGluZGV4WyByaWdodCAqIDMgKyBpIF0gPSB0MDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBzd2FwIGJvdW5kc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IHRiID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXSA9IHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF07XG5cdFx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXSA9IHRiO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZWZ0ICsrO1xuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbGVmdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInNvcnRVdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8vIHJlb3JkZXJzIGB0cmlzYCBzdWNoIHRoYXQgZm9yIGBjb3VudGAgZWxlbWVudHMgYWZ0ZXIgYG9mZnNldGAsIGVsZW1lbnRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdC8vIHdpbGwgYmUgb24gdGhlIGxlZnQgYW5kIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdCB3aWxsIGJlIG9uIHRoZSByaWdodC4gcmV0dXJucyB0aGUgaW5kZXhcblx0Ly8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cblx0ZnVuY3Rpb24gcGFydGl0aW9uX2luZGlyZWN0KCBpbmRpcmVjdEJ1ZmZlciwgaW5kZXgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApIHtcblxuXHRcdGxldCBsZWZ0ID0gb2Zmc2V0O1xuXHRcdGxldCByaWdodCA9IG9mZnNldCArIGNvdW50IC0gMTtcblx0XHRjb25zdCBwb3MgPSBzcGxpdC5wb3M7XG5cdFx0Y29uc3QgYXhpc09mZnNldCA9IHNwbGl0LmF4aXMgKiAyO1xuXG5cdFx0Ly8gaG9hcmUgcGFydGl0aW9uaW5nLCBzZWUgZS5nLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NvcnQjSG9hcmVfcGFydGl0aW9uX3NjaGVtZVxuXHRcdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGF4aXNPZmZzZXQgXSA8IHBvcyApIHtcblxuXHRcdFx0XHRsZWZ0ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGEgdHJpYW5nbGUgY2VudGVyIGxpZXMgb24gdGhlIHBhcnRpdGlvbiBwbGFuZSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGF4aXNPZmZzZXQgXSA+PSBwb3MgKSB7XG5cblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBsZWZ0IDwgcmlnaHQgKSB7XG5cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBzd2FwIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlhbmdsZXMgYXQgaW5kZXhcblx0XHRcdFx0Ly8gbGVmdCBhbmQgcmlnaHQ7IHRoYXQncyB0aGUgdmVydHMgaW4gdGhlIGdlb21ldHJ5IGluZGV4LCB0aGUgYm91bmRzLFxuXHRcdFx0XHQvLyBhbmQgcGVyaGFwcyB0aGUgU0FIIHBsYW5lc1xuXHRcdFx0XHRsZXQgdCA9IGluZGlyZWN0QnVmZmVyWyBsZWZ0IF07XG5cdFx0XHRcdGluZGlyZWN0QnVmZmVyWyBsZWZ0IF0gPSBpbmRpcmVjdEJ1ZmZlclsgcmlnaHQgXTtcblx0XHRcdFx0aW5kaXJlY3RCdWZmZXJbIHJpZ2h0IF0gPSB0O1xuXG5cblx0XHRcdFx0Ly8gc3dhcCBib3VuZHNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0YiA9IHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXTtcblx0XHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF0gPSB0YjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGVmdCArKztcblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciggZ2VvbWV0cnksIHVzZVNoYXJlZEFycmF5QnVmZmVyICkge1xuXG5cdFx0Y29uc3QgdHJpQ291bnQgPSAoIGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguY291bnQgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICkgLyAzO1xuXHRcdGNvbnN0IHVzZVVpbnQzMiA9IHRyaUNvdW50ID4gMiAqKiAxNjtcblx0XHRjb25zdCBieXRlQ291bnQgPSB1c2VVaW50MzIgPyA0IDogMjtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHVzZVNoYXJlZEFycmF5QnVmZmVyID8gbmV3IFNoYXJlZEFycmF5QnVmZmVyKCB0cmlDb3VudCAqIGJ5dGVDb3VudCApIDogbmV3IEFycmF5QnVmZmVyKCB0cmlDb3VudCAqIGJ5dGVDb3VudCApO1xuXHRcdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gdXNlVWludDMyID8gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKSA6IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aW5kaXJlY3RCdWZmZXJbIGkgXSA9IGk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW5kaXJlY3RCdWZmZXI7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkVHJlZSggYnZoLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gQ29tcHV0ZSB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdlb21ldHJ5IGF0IHRoZSBzYW1lIHRpbWUgYXMgdHJpYW5nbGUgYm91bmRzIGJlY2F1c2Vcblx0XHQvLyB3ZSdsbCBuZWVkIGl0IGZvciB0aGUgcm9vdCBib3VuZHMgaW4gdGhlIGNhc2Ugd2l0aCBubyBncm91cHMgYW5kIGl0IHNob3VsZCBiZSBmYXN0IGhlcmUuXG5cdFx0Ly8gV2UgY2FuJ3QgdXNlIHRoZSBnZW9tZXRyeSBib3VuZGluZyBib3ggaWYgaXQncyBhdmFpbGFibGUgYmVjYXVzZSBpdCBtYXkgYmUgb3V0IG9mIGRhdGUuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaW5kZXhBcnJheSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRcdGNvbnN0IG1heERlcHRoID0gb3B0aW9ucy5tYXhEZXB0aDtcblx0XHRjb25zdCB2ZXJib3NlID0gb3B0aW9ucy52ZXJib3NlO1xuXHRcdGNvbnN0IG1heExlYWZUcmlzID0gb3B0aW9ucy5tYXhMZWFmVHJpcztcblx0XHRjb25zdCBzdHJhdGVneSA9IG9wdGlvbnMuc3RyYXRlZ3k7XG5cdFx0Y29uc3Qgb25Qcm9ncmVzcyA9IG9wdGlvbnMub25Qcm9ncmVzcztcblx0XHRjb25zdCB0b3RhbFRyaWFuZ2xlcyA9IGdldFRyaUNvdW50KCBnZW9tZXRyeSApO1xuXHRcdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gYnZoLl9pbmRpcmVjdEJ1ZmZlcjtcblx0XHRsZXQgcmVhY2hlZE1heERlcHRoID0gZmFsc2U7XG5cblx0XHRjb25zdCBmdWxsQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXHRcdGNvbnN0IGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cdFx0Y29uc3QgdHJpYW5nbGVCb3VuZHMgPSBjb21wdXRlVHJpYW5nbGVCb3VuZHMoIGdlb21ldHJ5LCBmdWxsQm91bmRzICk7XG5cdFx0Y29uc3QgcGFydGlvbkZ1bmMgPSBvcHRpb25zLmluZGlyZWN0ID8gcGFydGl0aW9uX2luZGlyZWN0IDogcGFydGl0aW9uO1xuXG5cdFx0Y29uc3Qgcm9vdHMgPSBbXTtcblx0XHRjb25zdCByYW5nZXMgPSBvcHRpb25zLmluZGlyZWN0ID8gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlb21ldHJ5ICkgOiBnZXRSb290SW5kZXhSYW5nZXMoIGdlb21ldHJ5ICk7XG5cblx0XHRpZiAoIHJhbmdlcy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdGNvbnN0IHJhbmdlID0gcmFuZ2VzWyAwIF07XG5cdFx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRyb290LmJvdW5kaW5nRGF0YSA9IGZ1bGxCb3VuZHM7XG5cdFx0XHRnZXRDZW50cm9pZEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblxuXHRcdFx0c3BsaXROb2RlKCByb290LCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cdFx0XHRyb290cy5wdXNoKCByb290ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBsZXQgcmFuZ2Ugb2YgcmFuZ2VzICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSBuZXcgTWVzaEJWSE5vZGUoKTtcblx0XHRcdFx0cm9vdC5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIHJvb3QuYm91bmRpbmdEYXRhLCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cblx0XHRcdFx0c3BsaXROb2RlKCByb290LCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cdFx0XHRcdHJvb3RzLnB1c2goIHJvb3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJvb3RzO1xuXG5cdFx0ZnVuY3Rpb24gdHJpZ2dlclByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgKSB7XG5cblx0XHRcdGlmICggb25Qcm9ncmVzcyApIHtcblxuXHRcdFx0XHRvblByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgLyB0b3RhbFRyaWFuZ2xlcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBlaXRoZXIgcmVjdXJzaXZlbHkgc3BsaXRzIHRoZSBnaXZlbiBub2RlLCBjcmVhdGluZyBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBmb3IgaXQsIG9yIG1ha2VzIGl0IGEgbGVhZiBub2RlLFxuXHRcdC8vIHJlY29yZGluZyB0aGUgb2Zmc2V0IGFuZCBjb3VudCBvZiBpdHMgdHJpYW5nbGVzIGFuZCB3cml0aW5nIHRoZW0gaW50byB0aGUgcmVvcmRlcmVkIGdlb21ldHJ5IGluZGV4LlxuXHRcdGZ1bmN0aW9uIHNwbGl0Tm9kZSggbm9kZSwgb2Zmc2V0LCBjb3VudCwgY2VudHJvaWRCb3VuZGluZ0RhdGEgPSBudWxsLCBkZXB0aCA9IDAgKSB7XG5cblx0XHRcdGlmICggISByZWFjaGVkTWF4RGVwdGggJiYgZGVwdGggPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0cmVhY2hlZE1heERlcHRoID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCB2ZXJib3NlICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBgTWVzaEJWSDogTWF4IGRlcHRoIG9mICR7IG1heERlcHRoIH0gcmVhY2hlZCB3aGVuIGdlbmVyYXRpbmcgQlZILiBDb25zaWRlciBpbmNyZWFzaW5nIG1heERlcHRoLmAgKTtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oIGdlb21ldHJ5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVhcmx5IG91dCBpZiB3ZSd2ZSBtZXQgb3VyIGNhcGFjaXR5XG5cdFx0XHRpZiAoIGNvdW50IDw9IG1heExlYWZUcmlzIHx8IGRlcHRoID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmluZCB3aGVyZSB0byBzcGxpdCB0aGUgdm9sdW1lXG5cdFx0XHRjb25zdCBzcGxpdCA9IGdldE9wdGltYWxTcGxpdCggbm9kZS5ib3VuZGluZ0RhdGEsIGNlbnRyb2lkQm91bmRpbmdEYXRhLCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3RyYXRlZ3kgKTtcblx0XHRcdGlmICggc3BsaXQuYXhpcyA9PT0gLSAxICkge1xuXG5cdFx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3BsaXRPZmZzZXQgPSBwYXJ0aW9uRnVuYyggaW5kaXJlY3RCdWZmZXIsIGluZGV4QXJyYXksIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApO1xuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIHR3byBuZXcgY2hpbGQgbm9kZXNcblx0XHRcdGlmICggc3BsaXRPZmZzZXQgPT09IG9mZnNldCB8fCBzcGxpdE9mZnNldCA9PT0gb2Zmc2V0ICsgY291bnQgKSB7XG5cblx0XHRcdFx0dHJpZ2dlclByb2dyZXNzKCBvZmZzZXQgKyBjb3VudCApO1xuXHRcdFx0XHRub2RlLm9mZnNldCA9IG9mZnNldDtcblx0XHRcdFx0bm9kZS5jb3VudCA9IGNvdW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdG5vZGUuc3BsaXRBeGlzID0gc3BsaXQuYXhpcztcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIGxlZnQgY2hpbGQgYW5kIGNvbXB1dGUgaXRzIGJvdW5kaW5nIGJveFxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRcdGNvbnN0IGxzdGFydCA9IG9mZnNldDtcblx0XHRcdFx0Y29uc3QgbGNvdW50ID0gc3BsaXRPZmZzZXQgLSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUubGVmdCA9IGxlZnQ7XG5cdFx0XHRcdGxlZnQuYm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIGxzdGFydCwgbGNvdW50LCBsZWZ0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0XHRzcGxpdE5vZGUoIGxlZnQsIGxzdGFydCwgbGNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhLCBkZXB0aCArIDEgKTtcblxuXHRcdFx0XHQvLyByZXBlYXQgZm9yIHJpZ2h0XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRcdGNvbnN0IHJzdGFydCA9IHNwbGl0T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCByY291bnQgPSBjb3VudCAtIGxjb3VudDtcblx0XHRcdFx0bm9kZS5yaWdodCA9IHJpZ2h0O1xuXHRcdFx0XHRyaWdodC5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0XHRcdFx0Z2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgcnN0YXJ0LCByY291bnQsIHJpZ2h0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0XHRzcGxpdE5vZGUoIHJpZ2h0LCByc3RhcnQsIHJjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJ1aWxkUGFja2VkVHJlZSggYnZoLCBvcHRpb25zICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0aWYgKCBvcHRpb25zLmluZGlyZWN0ICkge1xuXG5cdFx0XHRidmguX2luZGlyZWN0QnVmZmVyID0gZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciggZ2VvbWV0cnksIG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgKTtcblxuXHRcdFx0aWYgKCBoYXNHcm91cEdhcHMoIGdlb21ldHJ5ICkgJiYgISBvcHRpb25zLnZlcmJvc2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XHRcdCdNZXNoQlZIOiBQcm92aWRlZCBnZW9tZXRyeSBjb250YWlucyBncm91cHMgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSBcImluZGlyZWN0XCIgb3B0aW9uLiAnICtcblx0XHRcdFx0XHQnQlZIIG1heSBpbmNvcnJlY3RseSByZXBvcnQgaW50ZXJzZWN0aW9ucyBvbiB1bnJlbmRlcmVkIHBvcnRpb25zIG9mIHRoZSBnZW9tZXRyeS4nXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggISBidmguX2luZGlyZWN0QnVmZmVyICkge1xuXG5cdFx0XHRlbnN1cmVJbmRleCggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHRcdH1cblxuXHRcdC8vIGJvdW5kaW5nRGF0YSAgXHRcdFx0XHQ6IDYgZmxvYXQzMlxuXHRcdC8vIHJpZ2h0IC8gb2Zmc2V0IFx0XHRcdFx0OiAxIHVpbnQzMlxuXHRcdC8vIHNwbGl0QXhpcyAvIGlzTGVhZiArIGNvdW50IFx0OiAxIHVpbnQzMiAvIDIgdWludDE2XG5cdFx0Y29uc3Qgcm9vdHMgPSBidWlsZFRyZWUoIGJ2aCwgb3B0aW9ucyApO1xuXG5cdFx0bGV0IGZsb2F0MzJBcnJheTtcblx0XHRsZXQgdWludDMyQXJyYXk7XG5cdFx0bGV0IHVpbnQxNkFycmF5O1xuXHRcdGNvbnN0IHBhY2tlZFJvb3RzID0gW107XG5cdFx0Y29uc3QgQnVmZmVyQ29uc3RydWN0b3IgPSBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcjtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCByb290cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdFx0bGV0IG5vZGVDb3VudCA9IGNvdW50Tm9kZXMoIHJvb3QgKTtcblxuXHRcdFx0Y29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlckNvbnN0cnVjdG9yKCBCWVRFU19QRVJfTk9ERSAqIG5vZGVDb3VudCApO1xuXHRcdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHR1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRwb3B1bGF0ZUJ1ZmZlciggMCwgcm9vdCApO1xuXHRcdFx0cGFja2VkUm9vdHMucHVzaCggYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRidmguX3Jvb3RzID0gcGFja2VkUm9vdHM7XG5cdFx0cmV0dXJuO1xuXG5cdFx0ZnVuY3Rpb24gY291bnROb2Rlcyggbm9kZSApIHtcblxuXHRcdFx0aWYgKCBub2RlLmNvdW50ICkge1xuXG5cdFx0XHRcdHJldHVybiAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiAxICsgY291bnROb2Rlcyggbm9kZS5sZWZ0ICkgKyBjb3VudE5vZGVzKCBub2RlLnJpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICkge1xuXG5cdFx0XHRjb25zdCBzdHJpZGU0T2Zmc2V0ID0gYnl0ZU9mZnNldCAvIDQ7XG5cdFx0XHRjb25zdCBzdHJpZGUyT2Zmc2V0ID0gYnl0ZU9mZnNldCAvIDI7XG5cdFx0XHRjb25zdCBpc0xlYWYgPSAhICEgbm9kZS5jb3VudDtcblx0XHRcdGNvbnN0IGJvdW5kaW5nRGF0YSA9IG5vZGUuYm91bmRpbmdEYXRhO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyBpIF0gPSBib3VuZGluZ0RhdGFbIGkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBub2RlLm9mZnNldDtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBub2RlLmNvdW50O1xuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG9mZnNldDtcblx0XHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNCBdID0gY291bnQ7XG5cdFx0XHRcdHVpbnQxNkFycmF5WyBzdHJpZGUyT2Zmc2V0ICsgMTUgXSA9IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdHJldHVybiBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUubGVmdDtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBub2RlLnNwbGl0QXhpcztcblxuXHRcdFx0XHRsZXQgbmV4dFVudXNlZFBvaW50ZXI7XG5cdFx0XHRcdG5leHRVbnVzZWRQb2ludGVyID0gcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQgKyBCWVRFU19QRVJfTk9ERSwgbGVmdCApO1xuXG5cdFx0XHRcdGlmICggKCBuZXh0VW51c2VkUG9pbnRlciAvIDQgKSA+IE1hdGgucG93KCAyLCAzMiApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogQ2Fubm90IHN0b3JlIGNoaWxkIHBvaW50ZXIgZ3JlYXRlciB0aGFuIDMyIGJpdHMuJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG5leHRVbnVzZWRQb2ludGVyIC8gNDtcblx0XHRcdFx0bmV4dFVudXNlZFBvaW50ZXIgPSBwb3B1bGF0ZUJ1ZmZlciggbmV4dFVudXNlZFBvaW50ZXIsIHJpZ2h0ICk7XG5cblx0XHRcdFx0dWludDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyA3IF0gPSBzcGxpdEF4aXM7XG5cdFx0XHRcdHJldHVybiBuZXh0VW51c2VkUG9pbnRlcjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBTZXBhcmF0aW5nQXhpc0JvdW5kcyB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0dGhpcy5taW4gPSBJbmZpbml0eTtcblx0XHRcdHRoaXMubWF4ID0gLSBJbmZpbml0eTtcblxuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCBmaWVsZCApIHtcblxuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHZhbCA9IHBbIGZpZWxkIF07XG5cdFx0XHRcdG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcblx0XHRcdFx0bWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluID0gbWluO1xuXHRcdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0XHR9XG5cblx0XHRzZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKSB7XG5cblx0XHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXggPSAtIEluZmluaXR5O1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0XHRtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG5cdFx0XHRcdG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdFx0fVxuXG5cdFx0aXNTZXBhcmF0ZWQoIG90aGVyICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5taW4gPiBvdGhlci5tYXggfHwgb3RoZXIubWluID4gdGhpcy5tYXg7XG5cblx0XHR9XG5cblx0fVxuXG5cdFNlcGFyYXRpbmdBeGlzQm91bmRzLnByb3RvdHlwZS5zZXRGcm9tQm94ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBwID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUJveCggYXhpcywgYm94ICkge1xuXG5cdFx0XHRjb25zdCBib3hNaW4gPSBib3gubWluO1xuXHRcdFx0Y29uc3QgYm94TWF4ID0gYm94Lm1heDtcblx0XHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRcdGxldCBtYXggPSAtIEluZmluaXR5O1xuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IDE7IHkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdFx0cC54ID0gYm94TWluLnggKiB4ICsgYm94TWF4LnggKiAoIDEgLSB4ICk7XG5cdFx0XHRcdFx0XHRwLnkgPSBib3hNaW4ueSAqIHkgKyBib3hNYXgueSAqICggMSAtIHkgKTtcblx0XHRcdFx0XHRcdHAueiA9IGJveE1pbi56ICogeiArIGJveE1heC56ICogKCAxIC0geiApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2YWwgPSBheGlzLmRvdCggcCApO1xuXHRcdFx0XHRcdFx0bWluID0gTWF0aC5taW4oIHZhbCwgbWluICk7XG5cdFx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCggdmFsLCBtYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgYXJlSW50ZXJzZWN0aW5nID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBjYWNoZVNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBhcmVJbnRlcnNlY3RpbmcoIHNoYXBlMSwgc2hhcGUyICkge1xuXG5cdFx0XHRjb25zdCBwb2ludHMxID0gc2hhcGUxLnBvaW50cztcblx0XHRcdGNvbnN0IHNhdEF4ZXMxID0gc2hhcGUxLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMxID0gc2hhcGUxLnNhdEJvdW5kcztcblxuXHRcdFx0Y29uc3QgcG9pbnRzMiA9IHNoYXBlMi5wb2ludHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzMiA9IHNoYXBlMi5zYXRBeGVzO1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IHNoYXBlMi5zYXRCb3VuZHM7XG5cblx0XHRcdC8vIGNoZWNrIGF4ZXMgb2YgdGhlIGZpcnN0IHNoYXBlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMVsgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMyICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgc2Vjb25kIHNoYXBlXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMlsgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMyWyBpIF07XG5cdFx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMxICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgY2xvc2VzdFBvaW50TGluZVRvTGluZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2p1ai9NYXRoR2VvTGliL2Jsb2IvbWFzdGVyL3NyYy9HZW9tZXRyeS9MaW5lLmNwcCNMNTZcblx0XHRjb25zdCBkaXIxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCB2MDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRMaW5lVG9MaW5lKCBsMSwgbDIsIHJlc3VsdCApIHtcblxuXHRcdFx0Y29uc3QgdjAgPSBsMS5zdGFydDtcblx0XHRcdGNvbnN0IHYxMCA9IGRpcjE7XG5cdFx0XHRjb25zdCB2MiA9IGwyLnN0YXJ0O1xuXHRcdFx0Y29uc3QgdjMyID0gZGlyMjtcblxuXHRcdFx0djAyLnN1YlZlY3RvcnMoIHYwLCB2MiApO1xuXHRcdFx0ZGlyMS5zdWJWZWN0b3JzKCBsMS5lbmQsIGwxLnN0YXJ0ICk7XG5cdFx0XHRkaXIyLnN1YlZlY3RvcnMoIGwyLmVuZCwgbDIuc3RhcnQgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDAyMzIgPSB2MDIuRG90KHYzMik7XG5cdFx0XHRjb25zdCBkMDIzMiA9IHYwMi5kb3QoIHYzMiApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMzIxMCA9IHYzMi5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQzMjEwID0gdjMyLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGQzMjMyID0gdjMyLkRvdCh2MzIpO1xuXHRcdFx0Y29uc3QgZDMyMzIgPSB2MzIuZG90KCB2MzIgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDAyMTAgPSB2MDIuRG90KHYxMCk7XG5cdFx0XHRjb25zdCBkMDIxMCA9IHYwMi5kb3QoIHYxMCApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMTAxMCA9IHYxMC5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQxMDEwID0gdjEwLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGRlbm9tID0gZDEwMTAqZDMyMzIgLSBkMzIxMCpkMzIxMDtcblx0XHRcdGNvbnN0IGRlbm9tID0gZDEwMTAgKiBkMzIzMiAtIGQzMjEwICogZDMyMTA7XG5cblx0XHRcdGxldCBkLCBkMjtcblx0XHRcdGlmICggZGVub20gIT09IDAgKSB7XG5cblx0XHRcdFx0ZCA9ICggZDAyMzIgKiBkMzIxMCAtIGQwMjEwICogZDMyMzIgKSAvIGRlbm9tO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGQyID0gKCBkMDIzMiArIGQgKiBkMzIxMCApIC8gZDMyMzI7XG5cblx0XHRcdHJlc3VsdC54ID0gZDtcblx0XHRcdHJlc3VsdC55ID0gZDI7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNvbnN0IGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmVTZWdtZW50LmNwcCNMMTg3XG5cdFx0Y29uc3QgcGFyYW1SZXN1bHQgPSBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXHRcdGNvbnN0IHRlbXAxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCB0ZW1wMiA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHRhcmdldDEsIHRhcmdldDIgKSB7XG5cblx0XHRcdGNsb3Nlc3RQb2ludExpbmVUb0xpbmUoIGwxLCBsMiwgcGFyYW1SZXN1bHQgKTtcblxuXHRcdFx0bGV0IGQgPSBwYXJhbVJlc3VsdC54O1xuXHRcdFx0bGV0IGQyID0gcGFyYW1SZXN1bHQueTtcblx0XHRcdGlmICggZCA+PSAwICYmIGQgPD0gMSAmJiBkMiA+PSAwICYmIGQyIDw9IDEgKSB7XG5cblx0XHRcdFx0bDEuYXQoIGQsIHRhcmdldDEgKTtcblx0XHRcdFx0bDIuYXQoIGQyLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkID49IDAgJiYgZCA8PSAxICkge1xuXG5cdFx0XHRcdC8vIE9ubHkgZDIgaXMgb3V0IG9mIGJvdW5kcy5cblx0XHRcdFx0aWYgKCBkMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRsMi5hdCggMCwgdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsMi5hdCggMSwgdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsMS5jbG9zZXN0UG9pbnRUb1BvaW50KCB0YXJnZXQyLCB0cnVlLCB0YXJnZXQxICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIGlmICggZDIgPj0gMCAmJiBkMiA8PSAxICkge1xuXG5cdFx0XHRcdC8vIE9ubHkgZCBpcyBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRpZiAoIGQgPCAwICkge1xuXG5cdFx0XHRcdFx0bDEuYXQoIDAsIHRhcmdldDEgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bDEuYXQoIDEsIHRhcmdldDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGFyZ2V0MSwgdHJ1ZSwgdGFyZ2V0MiApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQm90aCB1IGFuZCB1MiBhcmUgb3V0IG9mIGJvdW5kcy5cblx0XHRcdFx0bGV0IHA7XG5cdFx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0XHRwID0gbDEuc3RhcnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHAgPSBsMS5lbmQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBwMjtcblx0XHRcdFx0aWYgKCBkMiA8IDAgKSB7XG5cblx0XHRcdFx0XHRwMiA9IGwyLnN0YXJ0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwMiA9IGwyLmVuZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50ID0gdGVtcDE7XG5cdFx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDIgPSB0ZW1wMjtcblx0XHRcdFx0bDEuY2xvc2VzdFBvaW50VG9Qb2ludCggcDIsIHRydWUsIHRlbXAxICk7XG5cdFx0XHRcdGwyLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHAsIHRydWUsIHRlbXAyICk7XG5cblx0XHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICkgPD0gY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcCApICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0MS5jb3B5KCBjbG9zZXN0UG9pbnQgKTtcblx0XHRcdFx0XHR0YXJnZXQyLmNvcHkoIHAyICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0YXJnZXQxLmNvcHkoIHAgKTtcblx0XHRcdFx0XHR0YXJnZXQyLmNvcHkoIGNsb3Nlc3RQb2ludDIgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cblx0Y29uc3Qgc3BoZXJlSW50ZXJzZWN0VHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM0MDQzOTU1L2RldGVjdC1jb2xsaXNpb24tYmV0d2Vlbi1zcGhlcmUtYW5kLXRyaWFuZ2xlLWluLXRocmVlLWpzXG5cdFx0Y29uc3QgY2xvc2VzdFBvaW50VGVtcCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgcHJvamVjdGVkUG9pbnRUZW1wID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwbGFuZVRlbXAgPSBuZXcgdGhyZWUuUGxhbmUoKTtcblx0XHRjb25zdCBsaW5lVGVtcCA9IG5ldyB0aHJlZS5MaW5lMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0cmlhbmdsZSApIHtcblxuXHRcdFx0Y29uc3QgeyByYWRpdXMsIGNlbnRlciB9ID0gc3BoZXJlO1xuXHRcdFx0Y29uc3QgeyBhLCBiLCBjIH0gPSB0cmlhbmdsZTtcblxuXHRcdFx0Ly8gcGhhc2UgMVxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBhO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYjtcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDEgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50MS5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBhO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYztcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDIgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50Mi5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0bGluZVRlbXAuc3RhcnQgPSBiO1xuXHRcdFx0bGluZVRlbXAuZW5kID0gYztcblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludDMgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRcdGlmICggY2xvc2VzdFBvaW50My5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gcGhhc2UgMlxuXHRcdFx0Y29uc3QgcGxhbmUgPSB0cmlhbmdsZS5nZXRQbGFuZSggcGxhbmVUZW1wICk7XG5cdFx0XHRjb25zdCBkcCA9IE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApICk7XG5cdFx0XHRpZiAoIGRwIDw9IHJhZGl1cyApIHtcblxuXHRcdFx0XHRjb25zdCBwcCA9IHBsYW5lLnByb2plY3RQb2ludCggY2VudGVyLCBwcm9qZWN0ZWRQb2ludFRlbXAgKTtcblx0XHRcdFx0Y29uc3QgY3AgPSB0cmlhbmdsZS5jb250YWluc1BvaW50KCBwcCApO1xuXHRcdFx0XHRpZiAoIGNwICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBaRVJPX0VQU0lMT04gPSAxZS0xNTtcblx0ZnVuY3Rpb24gaXNOZWFyWmVybyggdmFsdWUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHZhbHVlICkgPCBaRVJPX0VQU0lMT047XG5cblx0fVxuXG5cdGNsYXNzIEV4dGVuZGVkVHJpYW5nbGUgZXh0ZW5kcyB0aHJlZS5UcmlhbmdsZSB7XG5cblx0XHRjb25zdHJ1Y3RvciggLi4uYXJncyApIHtcblxuXHRcdFx0c3VwZXIoIC4uLmFyZ3MgKTtcblxuXHRcdFx0dGhpcy5pc0V4dGVuZGVkVHJpYW5nbGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5zYXRBeGVzID0gbmV3IEFycmF5KCA0ICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBbIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgXTtcblx0XHRcdHRoaXMuc3BoZXJlID0gbmV3IHRocmVlLlNwaGVyZSgpO1xuXHRcdFx0dGhpcy5wbGFuZSA9IG5ldyB0aHJlZS5QbGFuZSgpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRcdHJldHVybiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cblx0XHRcdGNvbnN0IGEgPSB0aGlzLmE7XG5cdFx0XHRjb25zdCBiID0gdGhpcy5iO1xuXHRcdFx0Y29uc3QgYyA9IHRoaXMuYztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cblx0XHRcdGNvbnN0IGF4aXMwID0gc2F0QXhlc1sgMCBdO1xuXHRcdFx0Y29uc3Qgc2FiMCA9IHNhdEJvdW5kc1sgMCBdO1xuXHRcdFx0dGhpcy5nZXROb3JtYWwoIGF4aXMwICk7XG5cdFx0XHRzYWIwLnNldEZyb21Qb2ludHMoIGF4aXMwLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczEgPSBzYXRBeGVzWyAxIF07XG5cdFx0XHRjb25zdCBzYWIxID0gc2F0Qm91bmRzWyAxIF07XG5cdFx0XHRheGlzMS5zdWJWZWN0b3JzKCBhLCBiICk7XG5cdFx0XHRzYWIxLnNldEZyb21Qb2ludHMoIGF4aXMxLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczIgPSBzYXRBeGVzWyAyIF07XG5cdFx0XHRjb25zdCBzYWIyID0gc2F0Qm91bmRzWyAyIF07XG5cdFx0XHRheGlzMi5zdWJWZWN0b3JzKCBiLCBjICk7XG5cdFx0XHRzYWIyLnNldEZyb21Qb2ludHMoIGF4aXMyLCBwb2ludHMgKTtcblxuXHRcdFx0Y29uc3QgYXhpczMgPSBzYXRBeGVzWyAzIF07XG5cdFx0XHRjb25zdCBzYWIzID0gc2F0Qm91bmRzWyAzIF07XG5cdFx0XHRheGlzMy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0XHRzYWIzLnNldEZyb21Qb2ludHMoIGF4aXMzLCBwb2ludHMgKTtcblxuXHRcdFx0dGhpcy5zcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy5wb2ludHMgKTtcblx0XHRcdHRoaXMucGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIGF4aXMwLCBhICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmNsb3Nlc3RQb2ludFRvU2VnbWVudCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgcG9pbnQxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGVkZ2UgPSBuZXcgdGhyZWUuTGluZTMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvU2VnbWVudCggc2VnbWVudCwgdGFyZ2V0MSA9IG51bGwsIHRhcmdldDIgPSBudWxsICkge1xuXG5cdFx0XHRjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlZ21lbnQ7XG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGxldCBkaXN0U3E7XG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgdGhlIHRyaWFuZ2xlIGVkZ2VzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG5leHRpID0gKCBpICsgMSApICUgMztcblx0XHRcdFx0ZWRnZS5zdGFydC5jb3B5KCBwb2ludHNbIGkgXSApO1xuXHRcdFx0XHRlZGdlLmVuZC5jb3B5KCBwb2ludHNbIG5leHRpIF0gKTtcblxuXHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggZWRnZSwgc2VnbWVudCwgcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0XHRkaXN0U3EgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBlbmQgcG9pbnRzXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHN0YXJ0LCBwb2ludDEgKTtcblx0XHRcdGRpc3RTcSA9IHN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDEgKTtcblx0XHRcdGlmICggZGlzdFNxIDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggc3RhcnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGVuZCwgcG9pbnQxICk7XG5cdFx0XHRkaXN0U3EgPSBlbmQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBlbmQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHNhVHJpMiA9IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdFx0Y29uc3QgYXJyMSA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGFycjIgPSBuZXcgQXJyYXkoIDMgKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMyID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0Y29uc3QgY2FjaGVkQXhpcyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZGlyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCB0ZW1wRGlyID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBlZGdlID0gbmV3IHRocmVlLkxpbmUzKCk7XG5cdFx0Y29uc3QgZWRnZTEgPSBuZXcgdGhyZWUuTGluZTMoKTtcblx0XHRjb25zdCBlZGdlMiA9IG5ldyB0aHJlZS5MaW5lMygpO1xuXHRcdGNvbnN0IHRlbXBQb2ludCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiB0cmlJbnRlcnNlY3RQbGFuZSggdHJpLCBwbGFuZSwgdGFyZ2V0RWRnZSApIHtcblxuXHRcdFx0Ly8gZmluZCB0aGUgZWRnZSB0aGF0IGludGVyc2VjdHMgdGhlIG90aGVyIHRyaWFuZ2xlIHBsYW5lXG5cdFx0XHRjb25zdCBwb2ludHMgPSB0cmkucG9pbnRzO1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdGxldCBzdGFydFBvaW50SW50ZXJzZWN0aW9uID0gLSAxO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGVkZ2U7XG5cdFx0XHRcdHN0YXJ0LmNvcHkoIHBvaW50c1sgaSBdICk7XG5cdFx0XHRcdGVuZC5jb3B5KCBwb2ludHNbICggaSArIDEgKSAlIDMgXSApO1xuXHRcdFx0XHRlZGdlLmRlbHRhKCBkaXIgKTtcblxuXHRcdFx0XHRjb25zdCBzdGFydEludGVyc2VjdHMgPSBpc05lYXJaZXJvKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHN0YXJ0ICkgKTtcblx0XHRcdFx0aWYgKCBpc05lYXJaZXJvKCBwbGFuZS5ub3JtYWwuZG90KCBkaXIgKSApICYmIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBlZGdlIGxpZXMgb24gdGhlIHBsYW5lIHRoZW4gdGFrZSB0aGUgbGluZVxuXHRcdFx0XHRcdHRhcmdldEVkZ2UuY29weSggZWRnZSApO1xuXHRcdFx0XHRcdGNvdW50ID0gMjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHN0YXJ0IHBvaW50IGlzIG5lYXIgdGhlIHBsYW5lIGJlY2F1c2UgXCJpbnRlcnNlY3RMaW5lXCIgaXMgbm90IHJvYnVzdCB0byB0aGF0IGNhc2Vcblx0XHRcdFx0Y29uc3QgZG9lc0ludGVyc2VjdCA9IHBsYW5lLmludGVyc2VjdExpbmUoIGVkZ2UsIHRlbXBQb2ludCApO1xuXHRcdFx0XHRpZiAoICEgZG9lc0ludGVyc2VjdCAmJiBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0XHR0ZW1wUG9pbnQuY29weSggc3RhcnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWdub3JlIHRoZSBlbmQgcG9pbnRcblx0XHRcdFx0aWYgKCAoIGRvZXNJbnRlcnNlY3QgfHwgc3RhcnRJbnRlcnNlY3RzICkgJiYgISBpc05lYXJaZXJvKCB0ZW1wUG9pbnQuZGlzdGFuY2VUbyggZW5kICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY291bnQgPD0gMSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gYXNzaWduIHRvIHRoZSBzdGFydCBvciBlbmQgcG9pbnQgYW5kIHNhdmUgd2hpY2ggaW5kZXggd2FzIHNuYXBwZWQgdG9cblx0XHRcdFx0XHRcdC8vIHRoZSBzdGFydCBwb2ludCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gY291bnQgPT09IDEgPyB0YXJnZXRFZGdlLnN0YXJ0IDogdGFyZ2V0RWRnZS5lbmQ7XG5cdFx0XHRcdFx0XHRwb2ludC5jb3B5KCB0ZW1wUG9pbnQgKTtcblx0XHRcdFx0XHRcdGlmICggc3RhcnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPSBjb3VudDtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY291bnQgPj0gMiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UncmUgaGVyZSB0aGF0IG1lYW5zIHRoYXQgdGhlcmUgbXVzdCBoYXZlIGJlZW4gb25lIHBvaW50IHRoYXQgaGFkXG5cdFx0XHRcdFx0XHQvLyBzbmFwcGVkIHRvIHRoZSBzdGFydCBwb2ludCBzbyByZXBsYWNlIGl0IGhlcmVcblx0XHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gc3RhcnRQb2ludEludGVyc2VjdGlvbiA9PT0gMSA/IHRhcmdldEVkZ2Uuc3RhcnQgOiB0YXJnZXRFZGdlLmVuZDtcblx0XHRcdFx0XHRcdHBvaW50LmNvcHkoIHRlbXBQb2ludCApO1xuXHRcdFx0XHRcdFx0Y291bnQgPSAyO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb3VudCArKztcblx0XHRcdFx0XHRpZiAoIGNvdW50ID09PSAyICYmIHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPT09IC0gMSApIHtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3VudDtcblxuXHRcdH1cblxuXHRcdC8vIFRPRE86IElmIHRoZSB0cmlhbmdsZXMgYXJlIGNvcGxhbmFyIGFuZCBpbnRlcnNlY3RpbmcgdGhlIHRhcmdldCBpcyBub25zZW5zaWNhbC4gSXQgc2hvdWxkIGF0IGxlYXN0XG5cdFx0Ly8gYmUgYSBsaW5lIGNvbnRhaW5lZCBieSBib3RoIHRyaWFuZ2xlcyBpZiBub3QgYSBkaWZmZXJlbnQgc3BlY2lhbCBjYXNlIHNvbWVob3cgcmVwcmVzZW50ZWQgaW4gdGhlIHJldHVybiByZXN1bHQuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggb3RoZXIsIHRhcmdldCA9IG51bGwsIHN1cHByZXNzTG9nID0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISBvdGhlci5pc0V4dGVuZGVkVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0c2FUcmkyLmNvcHkoIG90aGVyICk7XG5cdFx0XHRcdHNhVHJpMi51cGRhdGUoKTtcblx0XHRcdFx0b3RoZXIgPSBzYVRyaTI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG90aGVyLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdG90aGVyLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBsYW5lMSA9IHRoaXMucGxhbmU7XG5cdFx0XHRjb25zdCBwbGFuZTIgPSBvdGhlci5wbGFuZTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggcGxhbmUxLm5vcm1hbC5kb3QoIHBsYW5lMi5ub3JtYWwgKSApID4gMS4wIC0gMWUtMTAgKSB7XG5cblx0XHRcdFx0Ly8gcGVyZm9ybSBzZXBhcmF0aW5nIGF4aXMgaW50ZXJzZWN0aW9uIHRlc3Qgb25seSBmb3IgY29wbGFuYXIgdHJpYW5nbGVzXG5cdFx0XHRcdGNvbnN0IHNhdEJvdW5kczEgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdFx0Y29uc3Qgc2F0QXhlczEgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRcdGFycjJbIDAgXSA9IG90aGVyLmE7XG5cdFx0XHRcdGFycjJbIDEgXSA9IG90aGVyLmI7XG5cdFx0XHRcdGFycjJbIDIgXSA9IG90aGVyLmM7XG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kczFbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBhcnIyICk7XG5cdFx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNhdEJvdW5kczIgPSBvdGhlci5zYXRCb3VuZHM7XG5cdFx0XHRcdGNvbnN0IHNhdEF4ZXMyID0gb3RoZXIuc2F0QXhlcztcblx0XHRcdFx0YXJyMVsgMCBdID0gdGhpcy5hO1xuXHRcdFx0XHRhcnIxWyAxIF0gPSB0aGlzLmI7XG5cdFx0XHRcdGFycjFbIDIgXSA9IHRoaXMuYztcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMlsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIGFycjEgKTtcblx0XHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY2hlY2sgY3Jvc3NlZCBheGVzXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBzYTEgPSBzYXRBeGVzMVsgaSBdO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDwgNDsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHNhMiA9IHNhdEF4ZXMyWyBpMiBdO1xuXHRcdFx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgYXJyMSApO1xuXHRcdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIyICk7XG5cdFx0XHRcdFx0XHRpZiAoIGNhY2hlZFNhdEJvdW5kcy5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzMiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdC8vIFRPRE8gZmluZCB0d28gcG9pbnRzIHRoYXQgaW50ZXJzZWN0IG9uIHRoZSBlZGdlcyBhbmQgbWFrZSB0aGF0IHRoZSByZXN1bHRcblx0XHRcdFx0XHRpZiAoICEgc3VwcHJlc3NMb2cgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ0V4dGVuZGVkVHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlOiBUcmlhbmdsZXMgYXJlIGNvcGxhbmFyIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgYW4gb3V0cHV0IGVkZ2UuIFNldHRpbmcgZWRnZSB0byAwLCAwLCAwLicgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldC5zdGFydC5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0XHR0YXJnZXQuZW5kLnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBmaW5kIHRoZSBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGUgb3RoZXIgdHJpYW5nbGUgcGxhbmVcblx0XHRcdFx0Y29uc3QgY291bnQxID0gdHJpSW50ZXJzZWN0UGxhbmUoIHRoaXMsIHBsYW5lMiwgZWRnZTEgKTtcblx0XHRcdFx0aWYgKCBjb3VudDEgPT09IDEgJiYgb3RoZXIuY29udGFpbnNQb2ludCggZWRnZTEuZW5kICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UxLmVuZCApO1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MSAhPT0gMiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluZCB0aGUgb3RoZXIgdHJpYW5nbGVzIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoaXMgcGxhbmVcblx0XHRcdFx0Y29uc3QgY291bnQyID0gdHJpSW50ZXJzZWN0UGxhbmUoIG90aGVyLCBwbGFuZTEsIGVkZ2UyICk7XG5cdFx0XHRcdGlmICggY291bnQyID09PSAxICYmIHRoaXMuY29udGFpbnNQb2ludCggZWRnZTIuZW5kICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UyLmVuZCApO1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MiAhPT0gMiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluZCBzd2FwIHRoZSBzZWNvbmQgZWRnZSBzbyBib3RoIGxpbmVzIGFyZSBydW5uaW5nIHRoZSBzYW1lIGRpcmVjdGlvblxuXHRcdFx0XHRlZGdlMS5kZWx0YSggZGlyMSApO1xuXHRcdFx0XHRlZGdlMi5kZWx0YSggZGlyMiApO1xuXG5cdFx0XHRcdGlmICggZGlyMS5kb3QoIGRpcjIgKSA8IDAgKSB7XG5cblx0XHRcdFx0XHRsZXQgdG1wID0gZWRnZTIuc3RhcnQ7XG5cdFx0XHRcdFx0ZWRnZTIuc3RhcnQgPSBlZGdlMi5lbmQ7XG5cdFx0XHRcdFx0ZWRnZTIuZW5kID0gdG1wO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgZWRnZXMgYXJlIG92ZXJsYXBwaW5nXG5cdFx0XHRcdGNvbnN0IHMxID0gZWRnZTEuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IGUxID0gZWRnZTEuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBzMiA9IGVkZ2UyLnN0YXJ0LmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBlMiA9IGVkZ2UyLmVuZC5kb3QoIGRpcjEgKTtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdGVkMSA9IGUxIDwgczI7XG5cdFx0XHRcdGNvbnN0IHNlcGFyYXRlZDIgPSBzMSA8IGUyO1xuXG5cdFx0XHRcdGlmICggczEgIT09IGUyICYmIHMyICE9PSBlMSAmJiBzZXBhcmF0ZWQxID09PSBzZXBhcmF0ZWQyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBhc3NpZ24gdGhlIHRhcmdldCBvdXRwdXRcblx0XHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0XHR0ZW1wRGlyLnN1YlZlY3RvcnMoIGVkZ2UxLnN0YXJ0LCBlZGdlMi5zdGFydCApO1xuXHRcdFx0XHRcdGlmICggdGVtcERpci5kb3QoIGRpcjEgKSA+IDAgKSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldC5zdGFydC5jb3B5KCBlZGdlMS5zdGFydCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UyLnN0YXJ0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0ZW1wRGlyLnN1YlZlY3RvcnMoIGVkZ2UxLmVuZCwgZWRnZTIuZW5kICk7XG5cdFx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApIDwgMCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMS5lbmQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRhcmdldC5lbmQuY29weSggZWRnZTIuZW5kICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cblx0RXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgKTtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKCB0YXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5kaXN0YW5jZVRvVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGNvcm5lckZpZWxkcyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXHRcdGNvbnN0IGxpbmUxID0gbmV3IHRocmVlLkxpbmUzKCk7XG5cdFx0Y29uc3QgbGluZTIgPSBuZXcgdGhyZWUuTGluZTMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvVHJpYW5nbGUoIG90aGVyLCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IGxpbmVUYXJnZXQgPSB0YXJnZXQxIHx8IHRhcmdldDIgPyBsaW5lMSA6IG51bGw7XG5cdFx0XHRpZiAoIHRoaXMuaW50ZXJzZWN0c1RyaWFuZ2xlKCBvdGhlciwgbGluZVRhcmdldCApICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0MSB8fCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgbGluZVRhcmdldC5nZXRDZW50ZXIoIHRhcmdldDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgYWxsIHBvaW50IGRpc3RhbmNlc1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRsZXQgZGlzdDtcblx0XHRcdFx0Y29uc3QgZmllbGQgPSBjb3JuZXJGaWVsZHNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgb3RoZXJWZWMgPSBvdGhlclsgZmllbGQgXTtcblx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBvdGhlclZlYywgcG9pbnQgKTtcblxuXHRcdFx0XHRkaXN0ID0gb3RoZXJWZWMuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludCApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggb3RoZXJWZWMgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRjb25zdCB0aGlzVmVjID0gdGhpc1sgZmllbGQgXTtcblx0XHRcdFx0b3RoZXIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGhpc1ZlYywgcG9pbnQgKTtcblxuXHRcdFx0XHRkaXN0ID0gdGhpc1ZlYy5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHRoaXNWZWMgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgZjExID0gY29ybmVyRmllbGRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGYxMiA9IGNvcm5lckZpZWxkc1sgKCBpICsgMSApICUgMyBdO1xuXHRcdFx0XHRsaW5lMS5zZXQoIHRoaXNbIGYxMSBdLCB0aGlzWyBmMTIgXSApO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDM7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgZjIxID0gY29ybmVyRmllbGRzWyBpMiBdO1xuXHRcdFx0XHRcdGNvbnN0IGYyMiA9IGNvcm5lckZpZWxkc1sgKCBpMiArIDEgKSAlIDMgXTtcblx0XHRcdFx0XHRsaW5lMi5zZXQoIG90aGVyWyBmMjEgXSwgb3RoZXJbIGYyMiBdICk7XG5cblx0XHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggbGluZTEsIGxpbmUyLCBwb2ludCwgcG9pbnQyICk7XG5cblx0XHRcdFx0XHRjb25zdCBkaXN0ID0gcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjbGFzcyBPcmllbnRlZEJveCB7XG5cblx0XHRjb25zdHJ1Y3RvciggbWluLCBtYXgsIG1hdHJpeCApIHtcblxuXHRcdFx0dGhpcy5pc09yaWVudGVkQm94ID0gdHJ1ZTtcblx0XHRcdHRoaXMubWluID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRcdHRoaXMubWF4ID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRcdHRoaXMubWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuaW52TWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMucG9pbnRzID0gbmV3IEFycmF5KCA4ICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRBeGVzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IHRocmVlLlZlY3RvcjMoKSApO1xuXHRcdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5hbGlnbmVkU2F0Qm91bmRzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCkgKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0aWYgKCBtaW4gKSB0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHRcdGlmICggbWF4ICkgdGhpcy5tYXguY29weSggbWF4ICk7XG5cdFx0XHRpZiAoIG1hdHJpeCApIHRoaXMubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXG5cdFx0fVxuXG5cdFx0c2V0KCBtaW4sIG1heCwgbWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weSggbWF0cml4ICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvcHkoIG90aGVyICkge1xuXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBvdGhlci5taW4gKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIG90aGVyLm1heCApO1xuXHRcdFx0dGhpcy5tYXRyaXguY29weSggb3RoZXIubWF0cml4ICk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdFx0Y29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG5cdFx0XHRjb25zdCBtaW4gPSB0aGlzLm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHogPSAwOyB6IDw9IDE7IHogKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGkgPSAoICggMSA8PCAwICkgKiB4ICkgfCAoICggMSA8PCAxICkgKiB5ICkgfCAoICggMSA8PCAyICkgKiB6ICk7XG5cdFx0XHRcdFx0XHRjb25zdCB2ID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdFx0XHR2LnggPSB4ID8gbWF4LnggOiBtaW4ueDtcblx0XHRcdFx0XHRcdHYueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdFx0di56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHRcdHYuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgbWluVmVjID0gcG9pbnRzWyAwIF07XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gMSA8PCBpO1xuXHRcdFx0XHRjb25zdCBwaSA9IHBvaW50c1sgaW5kZXggXTtcblxuXHRcdFx0XHRheGlzLnN1YlZlY3RvcnMoIG1pblZlYywgcGkgKTtcblx0XHRcdFx0c2Iuc2V0RnJvbVBvaW50cyggYXhpcywgcG9pbnRzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYWxpZ25lZFNhdEJvdW5kcyA9IHRoaXMuYWxpZ25lZFNhdEJvdW5kcztcblx0XHRcdGFsaWduZWRTYXRCb3VuZHNbIDAgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3gnICk7XG5cdFx0XHRhbGlnbmVkU2F0Qm91bmRzWyAxIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd5JyApO1xuXHRcdFx0YWxpZ25lZFNhdEJvdW5kc1sgMiBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneicgKTtcblxuXHRcdFx0dGhpcy5pbnZNYXRyaXguY29weSggdGhpcy5tYXRyaXggKS5pbnZlcnQoKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmludGVyc2VjdHNCb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IGFhYmJCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0XHQvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBkb2luZyBTQVQgYWdhaW5zdCB0aGUgQUFCQj9cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBtYXggPSBib3gubWF4O1xuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgYWxpZ25lZFNhdEJvdW5kcyA9IHRoaXMuYWxpZ25lZFNhdEJvdW5kcztcblxuXHRcdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4ueDtcblx0XHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lng7XG5cdFx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDAgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi55O1xuXHRcdFx0YWFiYkJvdW5kcy5tYXggPSBtYXgueTtcblx0XHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMSBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGFhYmJCb3VuZHMubWluID0gbWluLno7XG5cdFx0XHRhYWJiQm91bmRzLm1heCA9IG1heC56O1xuXHRcdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAyIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBheGlzID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0XHRhYWJiQm91bmRzLnNldEZyb21Cb3goIGF4aXMsIGJveCApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5pbnRlcnNlY3RzVHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHNhVHJpID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0XHRjb25zdCBwb2ludHNBcnIgPSBuZXcgQXJyYXkoIDMgKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRTYXRCb3VuZHMyID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0Y29uc3QgY2FjaGVkQXhpcyA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISB0cmlhbmdsZS5pc0V4dGVuZGVkVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0c2FUcmkuY29weSggdHJpYW5nbGUgKTtcblx0XHRcdFx0c2FUcmkudXBkYXRlKCk7XG5cdFx0XHRcdHRyaWFuZ2xlID0gc2FUcmk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRyaWFuZ2xlLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRyaWFuZ2xlLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNhdEJvdW5kcyA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblxuXHRcdFx0cG9pbnRzQXJyWyAwIF0gPSB0cmlhbmdsZS5hO1xuXHRcdFx0cG9pbnRzQXJyWyAxIF0gPSB0cmlhbmdsZS5iO1xuXHRcdFx0cG9pbnRzQXJyWyAyIF0gPSB0cmlhbmdsZS5jO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50c0FyciApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmlTYXRCb3VuZHMgPSB0cmlhbmdsZS5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCB0cmlTYXRBeGVzID0gdHJpYW5nbGUuc2F0QXhlcztcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBzYiA9IHRyaVNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHRyaVNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgY3Jvc3NlZCBheGVzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNhMSA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCA0OyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhMiA9IHRyaVNhdEF4ZXNbIGkyIF07XG5cdFx0XHRcdFx0Y2FjaGVkQXhpcy5jcm9zc1ZlY3RvcnMoIHNhMSwgc2EyICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIHBvaW50c0FyciApO1xuXHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kczIuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzICk7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRTYXRCb3VuZHMuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kczIgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldDEgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldDFcblx0XHRcdFx0LmNvcHkoIHBvaW50IClcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggdGhpcy5pbnZNYXRyaXggKVxuXHRcdFx0XHQuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApXG5cdFx0XHRcdC5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdHJldHVybiB0YXJnZXQxO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuZGlzdGFuY2VUb1BvaW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgKTtcblx0XHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKCB0YXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmRpc3RhbmNlVG9Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHh5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuXHRcdGNvbnN0IHNlZ21lbnRzMSA9IG5ldyBBcnJheSggMTIgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgdGhyZWUuTGluZTMoKSApO1xuXHRcdGNvbnN0IHNlZ21lbnRzMiA9IG5ldyBBcnJheSggMTIgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgdGhyZWUuTGluZTMoKSApO1xuXG5cdFx0Y29uc3QgcG9pbnQxID0gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwb2ludDIgPSBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXG5cdFx0Ly8gZWFybHkgb3V0IGlmIHdlIGZpbmQgYSB2YWx1ZSBiZWxvdyB0aHJlc2hvbGRcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb0JveCggYm94LCB0aHJlc2hvbGQgPSAwLCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKSApIHtcblxuXHRcdFx0XHRpZiAoIHRhcmdldDEgfHwgdGFyZ2V0MiApIHtcblxuXHRcdFx0XHRcdGJveC5nZXRDZW50ZXIoIHBvaW50MiApO1xuXHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQyLCBwb2ludDEgKTtcblx0XHRcdFx0XHRib3guY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdGhyZXNob2xkMiA9IHRocmVzaG9sZCAqIHRocmVzaG9sZDtcblx0XHRcdGNvbnN0IG1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBtYXggPSBib3gubWF4O1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2UgYW5kIGNvbXBhcmUgZGlzdGFuY2VzXG5cdFx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdFx0Ly8gY2hlY2sgb3ZlciBhbGwgdGhlc2UgcG9pbnRzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0cG9pbnQyLmNvcHkoIHAgKS5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0XHRjb25zdCBkaXN0ID0gcC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBhbmQgY2hlY2sgYWxsIGxpbmUgc2VnbWVudCBkaXN0YW5jZXNcblx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpMSA9IDA7IGkxIDw9IDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPD0gMTsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleCA9ICggaSArIDEgKSAlIDM7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXgyID0gKCBpICsgMiApICUgMztcblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IG9iYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGkxIDw8IG5leHRJbmRleCB8IGkyIDw8IG5leHRJbmRleDI7XG5cdFx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAxIDw8IGkgfCBpMSA8PCBuZXh0SW5kZXggfCBpMiA8PCBuZXh0SW5kZXgyO1xuXHRcdFx0XHRcdFx0Y29uc3QgcDEgPSBwb2ludHNbIGluZGV4IF07XG5cdFx0XHRcdFx0XHRjb25zdCBwMiA9IHBvaW50c1sgaW5kZXgyIF07XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lMSA9IHNlZ21lbnRzMVsgY291bnQgXTtcblx0XHRcdFx0XHRcdGxpbmUxLnNldCggcDEsIHAyICk7XG5cblxuXHRcdFx0XHRcdFx0Ly8gZ2V0IGFhYmIgbGluZSBzZWdtZW50c1xuXHRcdFx0XHRcdFx0Y29uc3QgZjEgPSB4eXpGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGYyID0geHl6RmllbGRzWyBuZXh0SW5kZXggXTtcblx0XHRcdFx0XHRcdGNvbnN0IGYzID0geHl6RmllbGRzWyBuZXh0SW5kZXgyIF07XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lMiA9IHNlZ21lbnRzMlsgY291bnQgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHN0YXJ0ID0gbGluZTIuc3RhcnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBlbmQgPSBsaW5lMi5lbmQ7XG5cblx0XHRcdFx0XHRcdHN0YXJ0WyBmMSBdID0gbWluWyBmMSBdO1xuXHRcdFx0XHRcdFx0c3RhcnRbIGYyIF0gPSBpMSA/IG1pblsgZjIgXSA6IG1heFsgZjIgXTtcblx0XHRcdFx0XHRcdHN0YXJ0WyBmMyBdID0gaTIgPyBtaW5bIGYzIF0gOiBtYXhbIGYyIF07XG5cblx0XHRcdFx0XHRcdGVuZFsgZjEgXSA9IG1heFsgZjEgXTtcblx0XHRcdFx0XHRcdGVuZFsgZjIgXSA9IGkxID8gbWluWyBmMiBdIDogbWF4WyBmMiBdO1xuXHRcdFx0XHRcdFx0ZW5kWyBmMyBdID0gaTIgPyBtaW5bIGYzIF0gOiBtYXhbIGYyIF07XG5cblx0XHRcdFx0XHRcdGNvdW50ICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBhbGwgdGhlIG90aGVyIGJveGVzIHBvaW50XG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gMTsgeCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0XHRwb2ludDIueCA9IHggPyBtYXgueCA6IG1pbi54O1xuXHRcdFx0XHRcdFx0cG9pbnQyLnkgPSB5ID8gbWF4LnkgOiBtaW4ueTtcblx0XHRcdFx0XHRcdHBvaW50Mi56ID0geiA/IG1heC56IDogbWluLno7XG5cblx0XHRcdFx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQyLCBwb2ludDEgKTtcblx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMTI7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbDEgPSBzZWdtZW50czFbIGkgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCAxMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsMiA9IHNlZ21lbnRzMlsgaTIgXTtcblx0XHRcdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggbDEsIGwyLCBwb2ludDEsIHBvaW50MiApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgdGhyZXNob2xkMiApIHJldHVybiBNYXRoLnNxcnQoIGRpc3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y2xhc3MgUHJpbWl0aXZlUG9vbCB7XG5cblx0XHRjb25zdHJ1Y3RvciggZ2V0TmV3UHJpbWl0aXZlICkge1xuXG5cdFx0XHR0aGlzLl9nZXROZXdQcmltaXRpdmUgPSBnZXROZXdQcmltaXRpdmU7XG5cdFx0XHR0aGlzLl9wcmltaXRpdmVzID0gW107XG5cblx0XHR9XG5cblx0XHRnZXRQcmltaXRpdmUoKSB7XG5cblx0XHRcdGNvbnN0IHByaW1pdGl2ZXMgPSB0aGlzLl9wcmltaXRpdmVzO1xuXHRcdFx0aWYgKCBwcmltaXRpdmVzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fZ2V0TmV3UHJpbWl0aXZlKCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIHByaW1pdGl2ZXMucG9wKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJlbGVhc2VQcmltaXRpdmUoIHByaW1pdGl2ZSApIHtcblxuXHRcdFx0dGhpcy5fcHJpbWl0aXZlcy5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlIGV4dGVuZHMgUHJpbWl0aXZlUG9vbCB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0c3VwZXIoICgpID0+IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGVQb29sQmFzZSgpO1xuXG5cdGZ1bmN0aW9uIElTX0xFQUYoIG4xNiwgdWludDE2QXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE1IF0gPT09IDB4RkZGRjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gT0ZGU0VUKCBuMzIsIHVpbnQzMkFycmF5ICkge1xuXG5cdFx0cmV0dXJuIHVpbnQzMkFycmF5WyBuMzIgKyA2IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIENPVU5UKCBuMTYsIHVpbnQxNkFycmF5ICkge1xuXG5cdFx0cmV0dXJuIHVpbnQxNkFycmF5WyBuMTYgKyAxNCBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBMRUZUX05PREUoIG4zMiApIHtcblxuXHRcdHJldHVybiBuMzIgKyA4O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBSSUdIVF9OT0RFKCBuMzIsIHVpbnQzMkFycmF5ICkge1xuXG5cdFx0cmV0dXJuIHVpbnQzMkFycmF5WyBuMzIgKyA2IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFNQTElUX0FYSVMoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDcgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQk9VTkRJTkdfREFUQV9JTkRFWCggbjMyICkge1xuXG5cdFx0cmV0dXJuIG4zMjtcblxuXHR9XG5cblx0Y2xhc3MgX0J1ZmZlclN0YWNrIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHR0aGlzLnVpbnQxNkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0XHRjb25zdCBzdGFjayA9IFtdO1xuXHRcdFx0bGV0IHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXRCdWZmZXIgPSBidWZmZXIgPT4ge1xuXG5cdFx0XHRcdGlmICggcHJldkJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIHByZXZCdWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldkJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdFx0dGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdFx0dGhpcy51aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmNsZWFyQnVmZmVyID0gKCkgPT4ge1xuXG5cdFx0XHRcdHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHRcdHRoaXMudWludDE2QXJyYXkgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnVpbnQzMkFycmF5ID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHRoaXMuc2V0QnVmZmVyKCBzdGFjay5wb3AoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgQnVmZmVyU3RhY2sgPSBuZXcgX0J1ZmZlclN0YWNrKCk7XG5cblx0bGV0IF9ib3gxJDEsIF9ib3gyJDE7XG5cdGNvbnN0IGJveFN0YWNrID0gW107XG5cdGNvbnN0IGJveFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyB0aHJlZS5Cb3gzKCkgKTtcblxuXHRmdW5jdGlvbiBzaGFwZWNhc3QoIGJ2aCwgcm9vdCwgaW50ZXJzZWN0c0JvdW5kcywgaW50ZXJzZWN0c1JhbmdlLCBib3VuZHNUcmF2ZXJzZU9yZGVyLCBieXRlT2Zmc2V0ICkge1xuXG5cdFx0Ly8gc2V0dXBcblx0XHRfYm94MSQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRfYm94MiQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRib3hTdGFjay5wdXNoKCBfYm94MSQxLCBfYm94MiQxICk7XG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHNoYXBlY2FzdFRyYXZlcnNlKCAwLCBidmguZ2VvbWV0cnksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdFx0Ly8gY2xlYW51cFxuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MSQxICk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MiQxICk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cblx0XHRjb25zdCBsZW5ndGggPSBib3hTdGFjay5sZW5ndGg7XG5cdFx0aWYgKCBsZW5ndGggPiAwICkge1xuXG5cdFx0XHRfYm94MiQxID0gYm94U3RhY2tbIGxlbmd0aCAtIDEgXTtcblx0XHRcdF9ib3gxJDEgPSBib3hTdGFja1sgbGVuZ3RoIC0gMiBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2hhcGVjYXN0VHJhdmVyc2UoXG5cdFx0bm9kZUluZGV4MzIsXG5cdFx0Z2VvbWV0cnksXG5cdFx0aW50ZXJzZWN0c0JvdW5kc0Z1bmMsXG5cdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRub2RlU2NvcmVGdW5jID0gbnVsbCxcblx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0ID0gMCwgLy8gb2Zmc2V0IGZvciB1bmlxdWUgbm9kZSBpZGVudGlmaWVyXG5cdFx0ZGVwdGggPSAwXG5cdCkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgX2JveDEkMSApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIGZhbHNlLCBkZXB0aCwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIG5vZGVJbmRleDMyLCBfYm94MSQxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgcmlnaHQgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGxldCBjMSA9IGxlZnQ7XG5cdFx0XHRsZXQgYzIgPSByaWdodDtcblxuXHRcdFx0bGV0IHNjb3JlMSwgc2NvcmUyO1xuXHRcdFx0bGV0IGJveDEsIGJveDI7XG5cdFx0XHRpZiAoIG5vZGVTY29yZUZ1bmMgKSB7XG5cblx0XHRcdFx0Ym94MSA9IF9ib3gxJDE7XG5cdFx0XHRcdGJveDIgPSBfYm94MiQxO1xuXG5cdFx0XHRcdC8vIGJvdW5kaW5nIGRhdGEgaXMgbm90IG9mZnNldFxuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzIgKSwgZmxvYXQzMkFycmF5LCBib3gyICk7XG5cblx0XHRcdFx0c2NvcmUxID0gbm9kZVNjb3JlRnVuYyggYm94MSApO1xuXHRcdFx0XHRzY29yZTIgPSBub2RlU2NvcmVGdW5jKCBib3gyICk7XG5cblx0XHRcdFx0aWYgKCBzY29yZTIgPCBzY29yZTEgKSB7XG5cblx0XHRcdFx0XHRjMSA9IHJpZ2h0O1xuXHRcdFx0XHRcdGMyID0gbGVmdDtcblxuXHRcdFx0XHRcdGNvbnN0IHRlbXAgPSBzY29yZTE7XG5cdFx0XHRcdFx0c2NvcmUxID0gc2NvcmUyO1xuXHRcdFx0XHRcdHNjb3JlMiA9IHRlbXA7XG5cblx0XHRcdFx0XHRib3gxID0gYm94Mjtcblx0XHRcdFx0XHQvLyBib3gyIGlzIGFsd2F5cyBzZXQgYmVmb3JlIHVzZSBiZWxvd1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBib3ggMSBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggISBib3gxICkge1xuXG5cdFx0XHRcdGJveDEgPSBfYm94MSQxO1xuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpc0MxTGVhZiA9IElTX0xFQUYoIGMxICogMiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0c0JvdW5kc0Z1bmMoIGJveDEsIGlzQzFMZWFmLCBzY29yZTEsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxICk7XG5cblx0XHRcdGxldCBjMVN0b3BUcmF2ZXJzYWw7XG5cdFx0XHRpZiAoIGMxSW50ZXJzZWN0aW9uID09PSBDT05UQUlORUQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2V0TGVmdE9mZnNldCggYzEgKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMxICk7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZW5kIC0gb2Zmc2V0O1xuXG5cdFx0XHRcdGMxU3RvcFRyYXZlcnNhbCA9IGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIHRydWUsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxLCBib3gxICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzFTdG9wVHJhdmVyc2FsID1cblx0XHRcdFx0XHRjMUludGVyc2VjdGlvbiAmJlxuXHRcdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdFx0YzEsXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRcdFx0XHRcdG5vZGVTY29yZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdFx0ZGVwdGggKyAxXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGMxU3RvcFRyYXZlcnNhbCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBib3ggMiBpbnRlcnNlY3Rpb25cblx0XHRcdC8vIGNhY2hlZCBib3gyIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IHByZXZpb3VzIHRyYXZlcnNhbFxuXHRcdFx0Ym94MiA9IF9ib3gyJDE7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMiApLCBmbG9hdDMyQXJyYXksIGJveDIgKTtcblxuXHRcdFx0Y29uc3QgaXNDMkxlYWYgPSBJU19MRUFGKCBjMiAqIDIsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gyLCBpc0MyTGVhZiwgc2NvcmUyLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiApO1xuXG5cdFx0XHRsZXQgYzJTdG9wVHJhdmVyc2FsO1xuXHRcdFx0aWYgKCBjMkludGVyc2VjdGlvbiA9PT0gQ09OVEFJTkVEICkge1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMyICk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFJpZ2h0RW5kT2Zmc2V0KCBjMiApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGVuZCAtIG9mZnNldDtcblxuXHRcdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiwgYm94MiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGMyU3RvcFRyYXZlcnNhbCA9XG5cdFx0XHRcdFx0YzJJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0XHRzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdFx0XHRcdGMyLFxuXHRcdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZUluZGV4Qnl0ZU9mZnNldCxcblx0XHRcdFx0XHRcdGRlcHRoICsgMVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjMlN0b3BUcmF2ZXJzYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBEZWZpbmUgdGhlc2UgaW5zaWRlIHRoZSBmdW5jdGlvbiBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBsb2NhbCB2YXJpYWJsZXMgbmVlZGVkXG5cdFx0XHQvLyB3aGVuIGNvbnZlcnRpbmcgdG8gdGhlIGJ1ZmZlciBlcXVpdmFsZW50c1xuXHRcdFx0ZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdFx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFJpZ2h0RW5kT2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0XHRjb25zdCB7IHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0XHR3aGlsZSAoICEgSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBhZGp1c3Qgb2Zmc2V0IHRvIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0XHRub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBlbmQgb2Zmc2V0IG9mIHRoZSB0cmlhbmdsZSByYW5nZVxuXHRcdFx0XHRyZXR1cm4gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSArIENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCB0ZW1wID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXAxJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KFxuXHRcdGJ2aCxcblx0XHRwb2ludCxcblx0XHR0YXJnZXQgPSB7IH0sXG5cdFx0bWluVGhyZXNob2xkID0gMCxcblx0XHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcblx0KSB7XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgdW5kZXIgbWluVGhyZXNob2xkXG5cdFx0Ly8gc2tpcCBjaGVja2luZyBpZiBvdmVyIG1heFRocmVzaG9sZFxuXHRcdC8vIHNldCBtaW5UaHJlc2hvbGQgPSBtYXhUaHJlc2hvbGQgdG8gcXVpY2tseSBjaGVjayBpZiBhIHBvaW50IGlzIHdpdGhpbiBhIHRocmVzaG9sZFxuXHRcdC8vIHJldHVybnMgSW5maW5pdHkgaWYgbm8gdmFsdWUgZm91bmRcblx0XHRjb25zdCBtaW5UaHJlc2hvbGRTcSA9IG1pblRocmVzaG9sZCAqIG1pblRocmVzaG9sZDtcblx0XHRjb25zdCBtYXhUaHJlc2hvbGRTcSA9IG1heFRocmVzaG9sZCAqIG1heFRocmVzaG9sZDtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGJ2aC5zaGFwZWNhc3QoXG5cblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0dGVtcC5jb3B5KCBwb2ludCApLmNsYW1wKCBib3gubWluLCBib3gubWF4ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXAuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZVNxICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkU3E7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggdHJpLCB0cmlJbmRleCApID0+IHtcblxuXHRcdFx0XHRcdHRyaS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGVtcCApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3RTcSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0ZW1wICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0dGVtcDEkMi5jb3B5KCB0ZW1wICk7XG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gdHJpSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA8IG1pblRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHR9XG5cblx0XHQpO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2VTcSA9PT0gSW5maW5pdHkgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IGNsb3Nlc3REaXN0YW5jZSA9IE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRcdGlmICggISB0YXJnZXQucG9pbnQgKSB0YXJnZXQucG9pbnQgPSB0ZW1wMSQyLmNsb25lKCk7XG5cdFx0ZWxzZSB0YXJnZXQucG9pbnQuY29weSggdGVtcDEkMiApO1xuXHRcdHRhcmdldC5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvLyBSaXBwZWQgYW5kIG1vZGlmaWVkIEZyb20gVEhSRUUuanMgTWVzaCByYXljYXN0XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDExNVxuXHRjb25zdCBfdkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgX3ZCID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF92QyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXG5cdGNvbnN0IF91dkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjIoKTtcblx0Y29uc3QgX3V2QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXHRjb25zdCBfdXZDID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cblx0Y29uc3QgX25vcm1hbEEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEMgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgcEEsIHBCLCBwQywgcG9pbnQsIHNpZGUgKSB7XG5cblx0XHRsZXQgaW50ZXJzZWN0O1xuXHRcdGlmICggc2lkZSA9PT0gdGhyZWUuQmFja1NpZGUgKSB7XG5cblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgc2lkZSAhPT0gdGhyZWUuRG91YmxlU2lkZSwgcG9pbnQgKTtcblxuXHRcdH1cblxuXHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cblx0XHRjb25zdCBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiBwb2ludC5jbG9uZSgpLFxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggcmF5LCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxLCBhLCBiLCBjLCBzaWRlICkge1xuXG5cdFx0X3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBhICk7XG5cdFx0X3ZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBiICk7XG5cdFx0X3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBjICk7XG5cblx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggcmF5LCBfdkEsIF92QiwgX3ZDLCBfaW50ZXJzZWN0aW9uUG9pbnQsIHNpZGUgKTtcblxuXHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRpZiAoIHV2ICkge1xuXG5cdFx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGEgKTtcblx0XHRcdFx0X3V2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYiApO1xuXHRcdFx0XHRfdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdGhyZWUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfdXZBLCBfdXZCLCBfdXZDLCBuZXcgdGhyZWUuVmVjdG9yMigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1djEgKSB7XG5cblx0XHRcdFx0X3V2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1djEsIGEgKTtcblx0XHRcdFx0X3V2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1djEsIGIgKTtcblx0XHRcdFx0X3V2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1djEsIGMgKTtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24udXYxID0gdGhyZWUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfdXZBLCBfdXZCLCBfdXZDLCBuZXcgdGhyZWUuVmVjdG9yMigpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub3JtYWwgKSB7XG5cblx0XHRcdFx0X25vcm1hbEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBhICk7XG5cdFx0XHRcdF9ub3JtYWxCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYiApO1xuXHRcdFx0XHRfbm9ybWFsQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGMgKTtcblxuXHRcdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsID0gdGhyZWUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfbm9ybWFsQSwgX25vcm1hbEIsIF9ub3JtYWxDLCBuZXcgdGhyZWUuVmVjdG9yMygpICk7XG5cdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLm5vcm1hbC5kb3QoIHJheS5kaXJlY3Rpb24gKSA+IDAgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsLm11bHRpcGx5U2NhbGFyKCAtIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZmFjZSA9IHtcblx0XHRcdFx0YTogYSxcblx0XHRcdFx0YjogYixcblx0XHRcdFx0YzogYyxcblx0XHRcdFx0bm9ybWFsOiBuZXcgdGhyZWUuVmVjdG9yMygpLFxuXHRcdFx0XHRtYXRlcmlhbEluZGV4OiAwXG5cdFx0XHR9O1xuXG5cdFx0XHR0aHJlZS5UcmlhbmdsZS5nZXROb3JtYWwoIF92QSwgX3ZCLCBfdkMsIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcblx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHR9XG5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iLzBhYTg3Yzk5OWZlNjFlMjE2YzExMzNmYmE3YTk1NzcyYjUwM2VkZGYvc3JjL29iamVjdHMvTWVzaC5qcyNMMjU4XG5cdGZ1bmN0aW9uIGludGVyc2VjdFRyaSggZ2VvLCBzaWRlLCByYXksIHRyaSwgaW50ZXJzZWN0aW9ucyApIHtcblxuXHRcdGNvbnN0IHRyaU9mZnNldCA9IHRyaSAqIDM7XG5cdFx0bGV0IGEgPSB0cmlPZmZzZXQgKyAwO1xuXHRcdGxldCBiID0gdHJpT2Zmc2V0ICsgMTtcblx0XHRsZXQgYyA9IHRyaU9mZnNldCArIDI7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlby5pbmRleDtcblx0XHRpZiAoIGdlby5pbmRleCApIHtcblxuXHRcdFx0YSA9IGluZGV4LmdldFgoIGEgKTtcblx0XHRcdGIgPSBpbmRleC5nZXRYKCBiICk7XG5cdFx0XHRjID0gaW5kZXguZ2V0WCggYyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxIH0gPSBnZW8uYXR0cmlidXRlcztcblx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCByYXksIHBvc2l0aW9uLCBub3JtYWwsIHV2LCB1djEsIGEsIGIsIGMsIHNpZGUgKTtcblxuXHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gdHJpO1xuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb25zICkgaW50ZXJzZWN0aW9ucy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblx0XHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0Ly8gc2V0cyB0aGUgdmVydGljZXMgb2YgdHJpYW5nbGUgYHRyaWAgd2l0aCB0aGUgMyB2ZXJ0aWNlcyBhZnRlciBpXG5cdGZ1bmN0aW9uIHNldFRyaWFuZ2xlKCB0cmksIGksIGluZGV4LCBwb3MgKSB7XG5cblx0XHRjb25zdCB0YSA9IHRyaS5hO1xuXHRcdGNvbnN0IHRiID0gdHJpLmI7XG5cdFx0Y29uc3QgdGMgPSB0cmkuYztcblxuXHRcdGxldCBpMCA9IGk7XG5cdFx0bGV0IGkxID0gaSArIDE7XG5cdFx0bGV0IGkyID0gaSArIDI7XG5cdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0aTAgPSBpbmRleC5nZXRYKCBpMCApO1xuXHRcdFx0aTEgPSBpbmRleC5nZXRYKCBpMSApO1xuXHRcdFx0aTIgPSBpbmRleC5nZXRYKCBpMiApO1xuXG5cdFx0fVxuXG5cdFx0dGEueCA9IHBvcy5nZXRYKCBpMCApO1xuXHRcdHRhLnkgPSBwb3MuZ2V0WSggaTAgKTtcblx0XHR0YS56ID0gcG9zLmdldFooIGkwICk7XG5cblx0XHR0Yi54ID0gcG9zLmdldFgoIGkxICk7XG5cdFx0dGIueSA9IHBvcy5nZXRZKCBpMSApO1xuXHRcdHRiLnogPSBwb3MuZ2V0WiggaTEgKTtcblxuXHRcdHRjLnggPSBwb3MuZ2V0WCggaTIgKTtcblx0XHR0Yy55ID0gcG9zLmdldFkoIGkyICk7XG5cdFx0dGMueiA9IHBvcy5nZXRaKCBpMiApO1xuXG5cdH1cblxuXHRjb25zdCB0ZW1wVjEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcFYyID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wVVYxID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cdGNvbnN0IHRlbXBVVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjIoKTtcblx0Y29uc3QgdGVtcFVWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMigpO1xuXG5cdGZ1bmN0aW9uIGdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvKCBwb2ludCwgZ2VvbWV0cnksIHRyaWFuZ2xlSW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpLmFycmF5O1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdGNvbnN0IHV2cyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3V2JyApO1xuXG5cdFx0Y29uc3QgYSA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzIF07XG5cdFx0Y29uc3QgYiA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzICsgMSBdO1xuXHRcdGNvbnN0IGMgPSBpbmRpY2VzWyB0cmlhbmdsZUluZGV4ICogMyArIDIgXTtcblxuXHRcdHRlbXBWMS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGEgKTtcblx0XHR0ZW1wVjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBiICk7XG5cdFx0dGVtcFYzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYyApO1xuXG5cdFx0Ly8gZmluZCB0aGUgYXNzb2NpYXRlZCBtYXRlcmlhbCBpbmRleFxuXHRcdGxldCBtYXRlcmlhbEluZGV4ID0gMDtcblx0XHRjb25zdCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0Y29uc3QgZmlyc3RWZXJ0ZXhJbmRleCA9IHRyaWFuZ2xlSW5kZXggKiAzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Y29uc3QgeyBzdGFydCwgY291bnQgfSA9IGdyb3VwO1xuXHRcdFx0aWYgKCBmaXJzdFZlcnRleEluZGV4ID49IHN0YXJ0ICYmIGZpcnN0VmVydGV4SW5kZXggPCBzdGFydCArIGNvdW50ICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBncm91cC5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZXh0cmFjdCB1dnNcblx0XHRsZXQgdXYgPSBudWxsO1xuXHRcdGlmICggdXZzICkge1xuXG5cdFx0XHR0ZW1wVVYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYSApO1xuXHRcdFx0dGVtcFVWMi5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGIgKTtcblx0XHRcdHRlbXBVVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBjICk7XG5cblx0XHRcdGlmICggdGFyZ2V0ICYmIHRhcmdldC51diApIHV2ID0gdGFyZ2V0LnV2O1xuXHRcdFx0ZWxzZSB1diA9IG5ldyB0aHJlZS5WZWN0b3IyKCk7XG5cblx0XHRcdHRocmVlLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCB0ZW1wVVYxLCB0ZW1wVVYyLCB0ZW1wVVYzLCB1diApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYWRqdXN0IHRoZSBwcm92aWRlZCB0YXJnZXQgb3IgY3JlYXRlIGEgbmV3IG9uZVxuXHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0LmZhY2UgKSB0YXJnZXQuZmFjZSA9IHsgfTtcblx0XHRcdHRhcmdldC5mYWNlLmEgPSBhO1xuXHRcdFx0dGFyZ2V0LmZhY2UuYiA9IGI7XG5cdFx0XHR0YXJnZXQuZmFjZS5jID0gYztcblx0XHRcdHRhcmdldC5mYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXHRcdFx0aWYgKCAhIHRhcmdldC5mYWNlLm5vcm1hbCApIHRhcmdldC5mYWNlLm5vcm1hbCA9IG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdFx0XHR0aHJlZS5UcmlhbmdsZS5nZXROb3JtYWwoIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRhcmdldC5mYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpZiAoIHV2ICkgdGFyZ2V0LnV2ID0gdXY7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRmYWNlOiB7XG5cdFx0XHRcdFx0YTogYSxcblx0XHRcdFx0XHRiOiBiLFxuXHRcdFx0XHRcdGM6IGMsXG5cdFx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCxcblx0XHRcdFx0XHRub3JtYWw6IHRocmVlLlRyaWFuZ2xlLmdldE5vcm1hbCggdGVtcFYxLCB0ZW1wVjIsIHRlbXBWMywgbmV3IHRocmVlLlZlY3RvcjMoKSApXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHV2OiB1dlxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcIml0ZXJhdGlvblV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmlzKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucyApIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnksIF9pbmRpcmVjdEJ1ZmZlciB9ID0gYnZoO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXG5cdFx0XHRpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIGksIGludGVyc2VjdGlvbnMgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnksIF9pbmRpcmVjdEJ1ZmZlciB9ID0gYnZoO1xuXHRcdGxldCBkaXN0ID0gSW5maW5pdHk7XG5cdFx0bGV0IHJlcyA9IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0XHRsZXQgaW50ZXJzZWN0aW9uO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIGkgKTtcblxuXG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24uZGlzdGFuY2UgPCBkaXN0ICkge1xuXG5cdFx0XHRcdHJlcyA9IGludGVyc2VjdGlvbjtcblx0XHRcdFx0ZGlzdCA9IGludGVyc2VjdGlvbi5kaXN0YW5jZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZU92ZXJUcmlhbmdsZXMoXG5cdFx0b2Zmc2V0LFxuXHRcdGNvdW50LFxuXHRcdGJ2aCxcblx0XHRpbnRlcnNlY3RzVHJpYW5nbGVGdW5jLFxuXHRcdGNvbnRhaW5lZCxcblx0XHRkZXB0aCxcblx0XHR0cmlhbmdsZVxuXHQpIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ2aDtcblx0XHRjb25zdCB7IGluZGV4IH0gPSBnZW9tZXRyeTtcblx0XHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gY291bnQgKyBvZmZzZXQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRsZXQgdHJpO1xuXG5cdFx0XHR0cmkgPSBpO1xuXG5cdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIHRyaSAqIDMsIGluZGV4LCBwb3MgKTtcblx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVGdW5jKCB0cmlhbmdsZSwgdHJpLCBjb250YWluZWQsIGRlcHRoICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJlZml0LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJlZml0KCBidmgsIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdGlmICggbm9kZUluZGljZXMgJiYgQXJyYXkuaXNBcnJheSggbm9kZUluZGljZXMgKSApIHtcblxuXHRcdFx0bm9kZUluZGljZXMgPSBuZXcgU2V0KCBub2RlSW5kaWNlcyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaW5kZXhBcnIgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCBwb3NBdHRyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGxldCBidWZmZXIsIHVpbnQzMkFycmF5LCB1aW50MTZBcnJheSwgZmxvYXQzMkFycmF5O1xuXHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0YnVmZmVyID0gcm9vdHNbIGkgXTtcblx0XHRcdHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRcdGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHRfdHJhdmVyc2UoIDAsIGJ5dGVPZmZzZXQgKTtcblx0XHRcdGJ5dGVPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfdHJhdmVyc2UoIG5vZGUzMkluZGV4LCBieXRlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlICkge1xuXG5cdFx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblxuXHRcdFx0XHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWlueiA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHogPSAtIEluZmluaXR5O1xuXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAzICogb2Zmc2V0LCBsID0gMyAqICggb2Zmc2V0ICsgY291bnQgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRsZXQgaW5kZXggPSBpbmRleEFyclsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IHggPSBwb3NBdHRyLmdldFgoIGluZGV4ICk7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IHBvc0F0dHIuZ2V0WSggaW5kZXggKTtcblx0XHRcdFx0XHRjb25zdCB6ID0gcG9zQXR0ci5nZXRaKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0aWYgKCB4IDwgbWlueCApIG1pbnggPSB4O1xuXHRcdFx0XHRcdGlmICggeCA+IG1heHggKSBtYXh4ID0geDtcblxuXHRcdFx0XHRcdGlmICggeSA8IG1pbnkgKSBtaW55ID0geTtcblx0XHRcdFx0XHRpZiAoIHkgPiBtYXh5ICkgbWF4eSA9IHk7XG5cblx0XHRcdFx0XHRpZiAoIHogPCBtaW56ICkgbWlueiA9IHo7XG5cdFx0XHRcdFx0aWYgKCB6ID4gbWF4eiApIG1heHogPSB6O1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdICE9PSBtaW54IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSAhPT0gbWlueSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gIT09IG1pbnogfHxcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gIT09IG1heHggfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdICE9PSBtYXh5IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSAhPT0gbWF4elxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gPSBtaW54O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gPSBtaW55O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gPSBtaW56O1xuXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSA9IG1heHg7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSA9IG1heHk7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSA9IG1heHo7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyA4O1xuXHRcdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblxuXHRcdFx0XHQvLyB0aGUgaWRlbnRpZnlpbmcgbm9kZSBpbmRpY2VzIHByb3ZpZGVkIGJ5IHRoZSBzaGFwZWNhc3QgZnVuY3Rpb24gaW5jbHVkZSBvZmZzZXRzIG9mIGFsbFxuXHRcdFx0XHQvLyByb290IGJ1ZmZlcnMgdG8gZ3VhcmFudGVlIHRoZXkncmUgdW5pcXVlIGJldHdlZW4gcm9vdHMgc28gb2Zmc2V0IGxlZnQgYW5kIHJpZ2h0IGluZGljZXMgaGVyZS5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0TGVmdCA9IGxlZnQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBvZmZzZXRSaWdodCA9IHJpZ2h0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGZvcmNlQ2hpbGRyZW4gPSBmb3JjZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzTGVmdCA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgaW5jbHVkZXNSaWdodCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggbm9kZUluZGljZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSBzZWUgdGhhdCBuZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IGNoaWxkIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2V0IHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkXG5cdFx0XHRcdFx0Ly8gdGhlbiB3ZSBhc3N1bWUgdGhhdCBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdFx0XHRcdGlmICggISBmb3JjZUNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldExlZnQgKTtcblx0XHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldFJpZ2h0ICk7XG5cdFx0XHRcdFx0XHRmb3JjZUNoaWxkcmVuID0gISBpbmNsdWRlc0xlZnQgJiYgISBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSB0cnVlO1xuXHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0cmF2ZXJzZUxlZnQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzTGVmdDtcblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VSaWdodCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRsZXQgbGVmdENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlTGVmdCApIHtcblxuXHRcdFx0XHRcdGxlZnRDaGFuZ2UgPSBfdHJhdmVyc2UoIGxlZnQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHJpZ2h0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdHJhdmVyc2VSaWdodCApIHtcblxuXHRcdFx0XHRcdHJpZ2h0Q2hhbmdlID0gX3RyYXZlcnNlKCByaWdodCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkaWRDaGFuZ2UgPSBsZWZ0Q2hhbmdlIHx8IHJpZ2h0Q2hhbmdlO1xuXHRcdFx0XHRpZiAoIGRpZENoYW5nZSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRpID0gbGVmdCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodGkgPSByaWdodCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCBtaW5MZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhMZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpICsgMyBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluUmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhSaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgKyAzIF07XG5cblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpIF0gPSBtaW5MZWZ0VmFsdWUgPCBtaW5SaWdodFZhbHVlID8gbWluTGVmdFZhbHVlIDogbWluUmlnaHRWYWx1ZTtcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpICsgMyBdID0gbWF4TGVmdFZhbHVlID4gbWF4UmlnaHRWYWx1ZSA/IG1heExlZnRWYWx1ZSA6IG1heFJpZ2h0VmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkaWRDaGFuZ2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2JvdW5kaW5nQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5Cb3gzKCk7XG5cdGZ1bmN0aW9uIGludGVyc2VjdFJheSggbm9kZUluZGV4MzIsIGFycmF5LCByYXksIHRhcmdldCApIHtcblxuXHRcdGFycmF5VG9Cb3goIG5vZGVJbmRleDMyLCBhcnJheSwgX2JvdW5kaW5nQm94ICk7XG5cdFx0cmV0dXJuIHJheS5pbnRlcnNlY3RCb3goIF9ib3VuZGluZ0JveCwgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJpdGVyYXRpb25VdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0VHJpc19pbmRpcmVjdCggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdGlvbnMgKSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGxldCB2aSA9IF9pbmRpcmVjdEJ1ZmZlciA/IF9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaTtcblx0XHRcdGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgdmksIGludGVyc2VjdGlvbnMgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnksIF9pbmRpcmVjdEJ1ZmZlciB9ID0gYnZoO1xuXHRcdGxldCBkaXN0ID0gSW5maW5pdHk7XG5cdFx0bGV0IHJlcyA9IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0XHRsZXQgaW50ZXJzZWN0aW9uO1xuXHRcdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0VHJpKCBnZW9tZXRyeSwgc2lkZSwgcmF5LCBfaW5kaXJlY3RCdWZmZXIgPyBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGkgKTtcblxuXG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24uZGlzdGFuY2UgPCBkaXN0ICkge1xuXG5cdFx0XHRcdHJlcyA9IGludGVyc2VjdGlvbjtcblx0XHRcdFx0ZGlzdCA9IGludGVyc2VjdGlvbi5kaXN0YW5jZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QoXG5cdFx0b2Zmc2V0LFxuXHRcdGNvdW50LFxuXHRcdGJ2aCxcblx0XHRpbnRlcnNlY3RzVHJpYW5nbGVGdW5jLFxuXHRcdGNvbnRhaW5lZCxcblx0XHRkZXB0aCxcblx0XHR0cmlhbmdsZVxuXHQpIHtcblxuXHRcdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ2aDtcblx0XHRjb25zdCB7IGluZGV4IH0gPSBnZW9tZXRyeTtcblx0XHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gY291bnQgKyBvZmZzZXQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRsZXQgdHJpO1xuXHRcdFx0dHJpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cblx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgdHJpICogMywgaW5kZXgsIHBvcyApO1xuXHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZUZ1bmMoIHRyaWFuZ2xlLCB0cmksIGNvbnRhaW5lZCwgZGVwdGggKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgX2JveEludGVyc2VjdGlvbiQzID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGZ1bmN0aW9uIHJheWNhc3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICkge1xuXG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0XHRfcmF5Y2FzdCQxKCAwLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9yYXljYXN0JDEoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblxuXHRcdFx0aW50ZXJzZWN0VHJpcyggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMgKTtcblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgbGVmdEluZGV4ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0aWYgKCBpbnRlcnNlY3RSYXkoIGxlZnRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24kMyApICkge1xuXG5cdFx0XHRcdF9yYXljYXN0JDEoIGxlZnRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByaWdodEluZGV4ID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggcmlnaHRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24kMyApICkge1xuXG5cdFx0XHRcdF9yYXljYXN0JDEoIHJpZ2h0SW5kZXgsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0Rmlyc3QudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRjb25zdCBfYm94SW50ZXJzZWN0aW9uJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgX3h5ekZpZWxkcyQxID0gWyAneCcsICd5JywgJ3onIF07XG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdCggYnZoLCByb290LCBzaWRlLCByYXkgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdGNvbnN0IHJlc3VsdCA9IF9yYXljYXN0Rmlyc3QkMSggMCwgYnZoLCBzaWRlLCByYXkgKTtcblx0XHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3JheWNhc3RGaXJzdCQxKCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXkgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjb25zaWRlciB0aGUgcG9zaXRpb24gb2YgdGhlIHNwbGl0IHBsYW5lIHdpdGggcmVzcGVjdCB0byB0aGUgb25jb21pbmcgcmF5OyB3aGljaGV2ZXIgZGlyZWN0aW9uXG5cdFx0XHQvLyB0aGUgcmF5IGlzIGNvbWluZyBmcm9tLCBsb29rIGZvciBhbiBpbnRlcnNlY3Rpb24gYW1vbmcgdGhhdCBzaWRlIG9mIHRoZSB0cmVlIGZpcnN0XG5cdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBTUExJVF9BWElTKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IHh5ekF4aXMgPSBfeHl6RmllbGRzJDFbIHNwbGl0QXhpcyBdO1xuXHRcdFx0Y29uc3QgcmF5RGlyID0gcmF5LmRpcmVjdGlvblsgeHl6QXhpcyBdO1xuXHRcdFx0Y29uc3QgbGVmdFRvUmlnaHQgPSByYXlEaXIgPj0gMDtcblxuXHRcdFx0Ly8gYzEgaXMgdGhlIGNoaWxkIHRvIGNoZWNrIGZpcnN0XG5cdFx0XHRsZXQgYzEsIGMyO1xuXHRcdFx0aWYgKCBsZWZ0VG9SaWdodCApIHtcblxuXHRcdFx0XHRjMSA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdFx0YzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjMSA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0XHRjMiA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzEsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uJDIgKTtcblx0XHRcdGNvbnN0IGMxUmVzdWx0ID0gYzFJbnRlcnNlY3Rpb24gPyBfcmF5Y2FzdEZpcnN0JDEoIGMxLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiQyICk7XG5cdFx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCQxKCBjMiwgYnZoLCBzaWRlLCByYXkgKSA6IG51bGw7XG5cblx0XHRcdGlmICggYzFSZXN1bHQgJiYgYzJSZXN1bHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQgfHwgYzJSZXN1bHQgfHwgbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcImludGVyc2VjdHNHZW9tZXRyeS50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5cdGNvbnN0IGJvdW5kaW5nQm94JDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLkJveDMoKTtcblx0Y29uc3QgdHJpYW5nbGUkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRjb25zdCB0cmlhbmdsZTIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRjb25zdCBpbnZlcnRlZE1hdCQxID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cblx0Y29uc3Qgb2JiJDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IG9iYjIkMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzR2VvbWV0cnkoIGJ2aCwgcm9vdCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX2ludGVyc2VjdHNHZW9tZXRyeSQxKCAwLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmggKTtcblx0XHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX2ludGVyc2VjdHNHZW9tZXRyeSQxKCBub2RlSW5kZXgzMiwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgPSBudWxsICkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0aWYgKCBjYWNoZWRPYmIgPT09IG51bGwgKSB7XG5cblx0XHRcdGlmICggISBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94ICkge1xuXG5cdFx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JiJDQuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdGNhY2hlZE9iYiA9IG9iYiQ0O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IHRoaXNHZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHRoaXNJbmRleCA9IHRoaXNHZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHRoaXNQb3MgPSB0aGlzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0Y29uc3QgaW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdC8vIGdldCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2VvbWV0cnkgbWF0cml4IHNvIHdlIGNhbiB0cmFuc2Zvcm0gb3VyIHRyaWFuZ2xlcyBpbnRvIHRoZVxuXHRcdFx0Ly8gZ2VvbWV0cnkgc3BhY2Ugd2UncmUgdHJ5aW5nIHRvIHRlc3QuIFdlIGFzc3VtZSB0aGVyZSBhcmUgZmV3ZXIgdHJpYW5nbGVzIGJlaW5nIGNoZWNrZWRcblx0XHRcdC8vIGhlcmUuXG5cdFx0XHRpbnZlcnRlZE1hdCQxLmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblxuXHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUncyBhIGJvdW5kcyB0cmVlXG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgb2JiMiQzICk7XG5cdFx0XHRcdG9iYjIkMy5tYXRyaXguY29weSggaW52ZXJ0ZWRNYXQkMSApO1xuXHRcdFx0XHRvYmIyJDMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIFRPRE86IHVzZSBhIHRyaWFuZ2xlIGl0ZXJhdGlvbiBmdW5jdGlvbiBoZXJlXG5cdFx0XHRcdGNvbnN0IHJlcyA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZS5zaGFwZWNhc3QoIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIyJDMuaW50ZXJzZWN0c0JveCggYm94ICksXG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB7XG5cblx0XHRcdFx0XHRcdHRyaS5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiAzLCBsID0gKCBjb3VudCArIG9mZnNldCApICogMzsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiQxLCBpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyJDEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiQxICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdHJldHVybiByZXM7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gaWYgd2UncmUganVzdCBkZWFsaW5nIHdpdGggcmF3IGdlb21ldHJ5XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiAzLCBsID0gKCBjb3VudCArIG9mZnNldCApICogMzsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSQxLCBpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblxuXG5cdFx0XHRcdFx0dHJpYW5nbGUkMS5hLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQkMSApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlJDEuYi5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0JDEgKTtcblx0XHRcdFx0XHR0cmlhbmdsZSQxLmMuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCQxICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUkMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IGluZGV4LmNvdW50OyBpMiA8IGwyOyBpMiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyJDEsIGkyLCBpbmRleCwgcG9zICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIkMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggdHJpYW5nbGUkMS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiQxICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gbm9kZUluZGV4MzIgKyA4O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZUluZGV4MzIgKyA2IF07XG5cblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGxlZnQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCQyICk7XG5cdFx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0aW9uID1cblx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDIgKSAmJlxuXHRcdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIGxlZnQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggbGVmdEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCByaWdodCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDIgKTtcblx0XHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0aW9uID1cblx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDIgKSAmJlxuXHRcdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIHJpZ2h0LCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiApO1xuXG5cdFx0XHRpZiAoIHJpZ2h0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiY2xvc2VzdFBvaW50VG9HZW9tZXRyeS50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGNvbnN0IHRlbXBNYXRyaXgkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuTWF0cml4NCgpO1xuXHRjb25zdCBvYmIkMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiQyID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCB0ZW1wMSQxID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXAyJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDMkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wNCQxID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cblx0ZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9HZW9tZXRyeShcblx0XHRidmgsXG5cdFx0b3RoZXJHZW9tZXRyeSxcblx0XHRnZW9tZXRyeVRvQnZoLFxuXHRcdHRhcmdldDEgPSB7IH0sXG5cdFx0dGFyZ2V0MiA9IHsgfSxcblx0XHRtaW5UaHJlc2hvbGQgPSAwLFxuXHRcdG1heFRocmVzaG9sZCA9IEluZmluaXR5LFxuXHQpIHtcblxuXHRcdGlmICggISBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94ICkge1xuXG5cdFx0XHRvdGhlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0b2JiJDMuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0XHRvYmIkMy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3Qgb3RoZXJQb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3Qgb3RoZXJJbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgdHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRjb25zdCB0cmlhbmdsZTIgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblxuXHRcdGxldCB0ZW1wVGFyZ2V0MSA9IHRlbXAxJDE7XG5cdFx0bGV0IHRlbXBUYXJnZXREZXN0MSA9IHRlbXAyJDE7XG5cdFx0bGV0IHRlbXBUYXJnZXQyID0gbnVsbDtcblx0XHRsZXQgdGVtcFRhcmdldERlc3QyID0gbnVsbDtcblxuXHRcdGlmICggdGFyZ2V0MiApIHtcblxuXHRcdFx0dGVtcFRhcmdldDIgPSB0ZW1wMyQxO1xuXHRcdFx0dGVtcFRhcmdldERlc3QyID0gdGVtcDQkMTtcblxuXHRcdH1cblxuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gbnVsbDtcblx0XHR0ZW1wTWF0cml4JDEuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXHRcdG9iYjIkMi5tYXRyaXguY29weSggdGVtcE1hdHJpeCQxICk7XG5cdFx0YnZoLnNoYXBlY2FzdChcblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG9iYiQzLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoZSB0cmlhbmdsZXMgb2YgdGhpcyBib3VuZHMgd2lsbCBiZSBpbnRlcnNlY3RlZCBuZXh0IHRoZW5cblx0XHRcdFx0XHRcdC8vIHNhdmUgdGhlIGJvdW5kcyB0byB1c2UgZHVyaW5nIHRyaWFuZ2xlIGNoZWNrcy5cblx0XHRcdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iYjIkMi5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0XHRvYmIyJDIubWF4LmNvcHkoIGJveC5tYXggKTtcblx0XHRcdFx0XHRcdFx0b2JiMiQyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciBnZW9tZXRyeSBoYXMgYSBidmggdGhlbiB1c2UgdGhlIGFjY2VsZXJhdGVkIHBhdGggd2hlcmUgd2UgdXNlIHNoYXBlY2FzdCB0byBmaW5kXG5cdFx0XHRcdFx0XHQvLyB0aGUgY2xvc2VzdCBib3VuZHMgaW4gdGhlIG90aGVyIGdlb21ldHJ5IHRvIGNoZWNrLlxuXHRcdFx0XHRcdFx0Y29uc3Qgb3RoZXJCdmggPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3RoZXJCdmguc2hhcGVjYXN0KCB7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JiMiQyLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQ7XG5cblx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb3RoZXJPZmZzZXQsIG90aGVyQ291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvdGhlck9mZnNldCwgbDIgPSBvdGhlck9mZnNldCArIG90aGVyQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cblx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIDMgKiBpMiwgb3RoZXJJbmRleCwgb3RoZXJQb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiBpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIG5vIGJvdW5kcyB0cmVlIHRoZW4gd2UnbGwganVzdCBjaGVjayBldmVyeSB0cmlhbmdsZS5cblx0XHRcdFx0XHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIG90aGVyR2VvbWV0cnkgKTtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gdHJpQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIDMgKiBpMiwgb3RoZXJJbmRleCwgb3RoZXJQb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXG5cdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogaSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHR9XG5cblx0XHQpO1xuXG5cdFx0RXh0ZW5kZWRUcmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUgKTtcblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZTIgKTtcblxuXHRcdGlmICggY2xvc2VzdERpc3RhbmNlID09PSBJbmZpbml0eSApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRpZiAoICEgdGFyZ2V0MS5wb2ludCApIHtcblxuXHRcdFx0dGFyZ2V0MS5wb2ludCA9IHRlbXBUYXJnZXREZXN0MS5jbG9uZSgpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGFyZ2V0MS5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDEgKTtcblxuXHRcdH1cblxuXHRcdHRhcmdldDEuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdFx0dGFyZ2V0MS5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleDtcblxuXHRcdGlmICggdGFyZ2V0MiApIHtcblxuXHRcdFx0aWYgKCAhIHRhcmdldDIucG9pbnQgKSB0YXJnZXQyLnBvaW50ID0gdGVtcFRhcmdldERlc3QyLmNsb25lKCk7XG5cdFx0XHRlbHNlIHRhcmdldDIucG9pbnQuY29weSggdGVtcFRhcmdldERlc3QyICk7XG5cdFx0XHR0YXJnZXQyLnBvaW50LmFwcGx5TWF0cml4NCggdGVtcE1hdHJpeCQxICk7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4JDEgKTtcblx0XHRcdHRhcmdldDIuZGlzdGFuY2UgPSB0ZW1wVGFyZ2V0RGVzdDEuc3ViKCB0YXJnZXQyLnBvaW50ICkubGVuZ3RoKCk7XG5cdFx0XHR0YXJnZXQyLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXg7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0MTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJlZml0LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJlZml0X2luZGlyZWN0KCBidmgsIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdGlmICggbm9kZUluZGljZXMgJiYgQXJyYXkuaXNBcnJheSggbm9kZUluZGljZXMgKSApIHtcblxuXHRcdFx0bm9kZUluZGljZXMgPSBuZXcgU2V0KCBub2RlSW5kaWNlcyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaW5kZXhBcnIgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCBwb3NBdHRyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGxldCBidWZmZXIsIHVpbnQzMkFycmF5LCB1aW50MTZBcnJheSwgZmxvYXQzMkFycmF5O1xuXHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0YnVmZmVyID0gcm9vdHNbIGkgXTtcblx0XHRcdHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRcdGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHRfdHJhdmVyc2UoIDAsIGJ5dGVPZmZzZXQgKTtcblx0XHRcdGJ5dGVPZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBfdHJhdmVyc2UoIG5vZGUzMkluZGV4LCBieXRlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlICkge1xuXG5cdFx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblxuXHRcdFx0XHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWlueiA9IEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHogPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdCA9IDMgKiBidmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRsZXQgaW5kZXggPSB0ICsgajtcblx0XHRcdFx0XHRcdGluZGV4ID0gaW5kZXhBcnIgPyBpbmRleEFyclsgaW5kZXggXSA6IGluZGV4O1xuXG5cdFx0XHRcdFx0XHRjb25zdCB4ID0gcG9zQXR0ci5nZXRYKCBpbmRleCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgeSA9IHBvc0F0dHIuZ2V0WSggaW5kZXggKTtcblx0XHRcdFx0XHRcdGNvbnN0IHogPSBwb3NBdHRyLmdldFooIGluZGV4ICk7XG5cblx0XHRcdFx0XHRcdGlmICggeCA8IG1pbnggKSBtaW54ID0geDtcblx0XHRcdFx0XHRcdGlmICggeCA+IG1heHggKSBtYXh4ID0geDtcblxuXHRcdFx0XHRcdFx0aWYgKCB5IDwgbWlueSApIG1pbnkgPSB5O1xuXHRcdFx0XHRcdFx0aWYgKCB5ID4gbWF4eSApIG1heHkgPSB5O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHogPCBtaW56ICkgbWlueiA9IHo7XG5cdFx0XHRcdFx0XHRpZiAoIHogPiBtYXh6ICkgbWF4eiA9IHo7XG5cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDAgXSAhPT0gbWlueCB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdICE9PSBtaW56IHx8XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMyBdICE9PSBtYXh4IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gIT09IG1heHpcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMSBdID0gbWlueTtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdID0gbWluejtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA0IF0gPSBtYXh5O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gPSBtYXh6O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUzMkluZGV4ICsgODtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdFx0Ly8gdGhlIGlkZW50aWZ5aW5nIG5vZGUgaW5kaWNlcyBwcm92aWRlZCBieSB0aGUgc2hhcGVjYXN0IGZ1bmN0aW9uIGluY2x1ZGUgb2Zmc2V0cyBvZiBhbGxcblx0XHRcdFx0Ly8gcm9vdCBidWZmZXJzIHRvIGd1YXJhbnRlZSB0aGV5J3JlIHVuaXF1ZSBiZXR3ZWVuIHJvb3RzIHNvIG9mZnNldCBsZWZ0IGFuZCByaWdodCBpbmRpY2VzIGhlcmUuXG5cdFx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0UmlnaHQgPSByaWdodCArIGJ5dGVPZmZzZXQ7XG5cdFx0XHRcdGxldCBmb3JjZUNoaWxkcmVuID0gZm9yY2U7XG5cdFx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzUmlnaHQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIG5vZGVJbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHRcdC8vIHRoZW4gd2UgYXNzdW1lIHRoYXQgYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmUgdXBkYXRlZC5cblx0XHRcdFx0XHRpZiAoICEgZm9yY2VDaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRSaWdodCApO1xuXHRcdFx0XHRcdFx0Zm9yY2VDaGlsZHJlbiA9ICEgaW5jbHVkZXNMZWZ0ICYmICEgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gdHJ1ZTtcblx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VMZWZ0ID0gZm9yY2VDaGlsZHJlbiB8fCBpbmNsdWRlc0xlZnQ7XG5cdFx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0bGV0IGxlZnRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0cmF2ZXJzZUxlZnQgKSB7XG5cblx0XHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCByaWdodENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0XHRyaWdodENoYW5nZSA9IF90cmF2ZXJzZSggcmlnaHQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdFx0aWYgKCBkaWRDaGFuZ2UgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRpID0gcmlnaHQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluTGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG1pblJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4UmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSArIDMgXSA9IG1heExlZnRWYWx1ZSA+IG1heFJpZ2h0VmFsdWUgPyBtYXhMZWZ0VmFsdWUgOiBtYXhSaWdodFZhbHVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGlkQ2hhbmdlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJheWNhc3QudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRjb25zdCBfYm94SW50ZXJzZWN0aW9uJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblx0ZnVuY3Rpb24gcmF5Y2FzdF9pbmRpcmVjdCggYnZoLCByb290LCBzaWRlLCByYXksIGludGVyc2VjdHMgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdF9yYXljYXN0KCAwLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9yYXljYXN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRjb25zdCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cdFx0XHRpbnRlcnNlY3RUcmlzX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0cyApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiQxICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QoIGxlZnRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByaWdodEluZGV4ID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggcmlnaHRJbmRleCwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24kMSApICkge1xuXG5cdFx0XHRcdF9yYXljYXN0KCByaWdodEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdEZpcnN0LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0Y29uc3QgX2JveEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdF9pbmRpcmVjdCggYnZoLCByb290LCBzaWRlLCByYXkgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdGNvbnN0IHJlc3VsdCA9IF9yYXljYXN0Rmlyc3QoIDAsIGJ2aCwgc2lkZSwgcmF5ICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9yYXljYXN0Rmlyc3QoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjb25zaWRlciB0aGUgcG9zaXRpb24gb2YgdGhlIHNwbGl0IHBsYW5lIHdpdGggcmVzcGVjdCB0byB0aGUgb25jb21pbmcgcmF5OyB3aGljaGV2ZXIgZGlyZWN0aW9uXG5cdFx0XHQvLyB0aGUgcmF5IGlzIGNvbWluZyBmcm9tLCBsb29rIGZvciBhbiBpbnRlcnNlY3Rpb24gYW1vbmcgdGhhdCBzaWRlIG9mIHRoZSB0cmVlIGZpcnN0XG5cdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBTUExJVF9BWElTKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IHh5ekF4aXMgPSBfeHl6RmllbGRzWyBzcGxpdEF4aXMgXTtcblx0XHRcdGNvbnN0IHJheURpciA9IHJheS5kaXJlY3Rpb25bIHh5ekF4aXMgXTtcblx0XHRcdGNvbnN0IGxlZnRUb1JpZ2h0ID0gcmF5RGlyID49IDA7XG5cblx0XHRcdC8vIGMxIGlzIHRoZSBjaGlsZCB0byBjaGVjayBmaXJzdFxuXHRcdFx0bGV0IGMxLCBjMjtcblx0XHRcdGlmICggbGVmdFRvUmlnaHQgKSB7XG5cblx0XHRcdFx0YzEgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdGMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzEgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0YzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYzFJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMxLCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApO1xuXHRcdFx0Y29uc3QgYzFSZXN1bHQgPSBjMUludGVyc2VjdGlvbiA/IF9yYXljYXN0Rmlyc3QoIGMxLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApO1xuXHRcdFx0Y29uc3QgYzJSZXN1bHQgPSBjMkludGVyc2VjdGlvbiA/IF9yYXljYXN0Rmlyc3QoIGMyLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdFx0aWYgKCBjMVJlc3VsdCAmJiBjMlJlc3VsdCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQuZGlzdGFuY2UgPD0gYzJSZXN1bHQuZGlzdGFuY2UgPyBjMVJlc3VsdCA6IGMyUmVzdWx0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBjMVJlc3VsdCB8fCBjMlJlc3VsdCB8fCBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaW50ZXJzZWN0c0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cblx0Y29uc3QgYm91bmRpbmdCb3gkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCB0cmlhbmdsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRjb25zdCB0cmlhbmdsZTIgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0Y29uc3QgaW52ZXJ0ZWRNYXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLk1hdHJpeDQoKTtcblxuXHRjb25zdCBvYmIkMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiQxID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHNHZW9tZXRyeV9pbmRpcmVjdCggYnZoLCByb290LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICkge1xuXG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0XHRjb25zdCByZXN1bHQgPSBfaW50ZXJzZWN0c0dlb21ldHJ5KCAwLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmggKTtcblx0XHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX2ludGVyc2VjdHNHZW9tZXRyeSggbm9kZUluZGV4MzIsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdGlmICggY2FjaGVkT2JiID09PSBudWxsICkge1xuXG5cdFx0XHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdFx0XHRvdGhlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iYiQyLnNldCggb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5taW4sIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWF4LCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRjYWNoZWRPYmIgPSBvYmIkMjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCB0aGlzR2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCB0aGlzSW5kZXggPSB0aGlzR2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCB0aGlzUG9zID0gdGhpc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cdFx0XHQvLyBnZXQgdGhlIGludmVyc2Ugb2YgdGhlIGdlb21ldHJ5IG1hdHJpeCBzbyB3ZSBjYW4gdHJhbnNmb3JtIG91ciB0cmlhbmdsZXMgaW50byB0aGVcblx0XHRcdC8vIGdlb21ldHJ5IHNwYWNlIHdlJ3JlIHRyeWluZyB0byB0ZXN0LiBXZSBhc3N1bWUgdGhlcmUgYXJlIGZld2VyIHRyaWFuZ2xlcyBiZWluZyBjaGVja2VkXG5cdFx0XHQvLyBoZXJlLlxuXHRcdFx0aW52ZXJ0ZWRNYXQuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXG5cdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIGEgYm91bmRzIHRyZWVcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBvYmIyJDEgKTtcblx0XHRcdFx0b2JiMiQxLm1hdHJpeC5jb3B5KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHRvYmIyJDEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIFRPRE86IHVzZSBhIHRyaWFuZ2xlIGl0ZXJhdGlvbiBmdW5jdGlvbiBoZXJlXG5cdFx0XHRcdGNvbnN0IHJlcyA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZS5zaGFwZWNhc3QoIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIyJDEuaW50ZXJzZWN0c0JveCggYm94ICksXG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB7XG5cblx0XHRcdFx0XHRcdHRyaS5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gY291bnQgKyBvZmZzZXQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGlmIHdlJ3JlIGp1c3QgZGVhbGluZyB3aXRoIHJhdyBnZW9tZXRyeVxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogdGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXG5cblx0XHRcdFx0XHR0cmlhbmdsZS5hLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0XHR0cmlhbmdsZS5iLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0XHR0cmlhbmdsZS5jLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IGluZGV4LmNvdW50OyBpMiA8IGwyOyBpMiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpMiwgaW5kZXgsIHBvcyApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0cmlhbmdsZS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlSW5kZXgzMiArIDg7XG5cdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlSW5kZXgzMiArIDYgXTtcblxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDEgKTtcblx0XHRcdGNvbnN0IGxlZnRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3gkMSApICYmXG5cdFx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkoIGxlZnQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggbGVmdEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCByaWdodCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDEgKTtcblx0XHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0aW9uID1cblx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDEgKSAmJlxuXHRcdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5KCByaWdodCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdFx0aWYgKCByaWdodEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcImNsb3Nlc3RQb2ludFRvR2VvbWV0cnkudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRjb25zdCB0ZW1wTWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cdGNvbnN0IG9iYiQxID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCBvYmIyID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCB0ZW1wMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXG5cdGZ1bmN0aW9uIGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QoXG5cdFx0YnZoLFxuXHRcdG90aGVyR2VvbWV0cnksXG5cdFx0Z2VvbWV0cnlUb0J2aCxcblx0XHR0YXJnZXQxID0geyB9LFxuXHRcdHRhcmdldDIgPSB7IH0sXG5cdFx0bWluVGhyZXNob2xkID0gMCxcblx0XHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcblx0KSB7XG5cblx0XHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdG9iYiQxLnNldCggb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5taW4sIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWF4LCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0b2JiJDEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IG90aGVyUG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG90aGVySW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHRyaWFuZ2xlID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0Y29uc3QgdHJpYW5nbGUyID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cblx0XHRsZXQgdGVtcFRhcmdldDEgPSB0ZW1wMTtcblx0XHRsZXQgdGVtcFRhcmdldERlc3QxID0gdGVtcDI7XG5cdFx0bGV0IHRlbXBUYXJnZXQyID0gbnVsbDtcblx0XHRsZXQgdGVtcFRhcmdldERlc3QyID0gbnVsbDtcblxuXHRcdGlmICggdGFyZ2V0MiApIHtcblxuXHRcdFx0dGVtcFRhcmdldDIgPSB0ZW1wMztcblx0XHRcdHRlbXBUYXJnZXREZXN0MiA9IHRlbXA0O1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBudWxsO1xuXHRcdHRlbXBNYXRyaXguY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXHRcdG9iYjIubWF0cml4LmNvcHkoIHRlbXBNYXRyaXggKTtcblx0XHRidmguc2hhcGVjYXN0KFxuXHRcdFx0e1xuXG5cdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRyZXR1cm4gb2JiJDEuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdGlmICggc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGtub3cgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGJvdW5kcyB3aWxsIGJlIGludGVyc2VjdGVkIG5leHQgdGhlblxuXHRcdFx0XHRcdFx0Ly8gc2F2ZSB0aGUgYm91bmRzIHRvIHVzZSBkdXJpbmcgdHJpYW5nbGUgY2hlY2tzLlxuXHRcdFx0XHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JiMi5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0XHRvYmIyLm1heC5jb3B5KCBib3gubWF4ICk7XG5cdFx0XHRcdFx0XHRcdG9iYjIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG90aGVyIGdlb21ldHJ5IGhhcyBhIGJ2aCB0aGVuIHVzZSB0aGUgYWNjZWxlcmF0ZWQgcGF0aCB3aGVyZSB3ZSB1c2Ugc2hhcGVjYXN0IHRvIGZpbmRcblx0XHRcdFx0XHRcdC8vIHRoZSBjbG9zZXN0IGJvdW5kcyBpbiB0aGUgb3RoZXIgZ2VvbWV0cnkgdG8gY2hlY2suXG5cdFx0XHRcdFx0XHRjb25zdCBvdGhlckJ2aCA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdFx0XHRcdHJldHVybiBvdGhlckJ2aC5zaGFwZWNhc3QoIHtcblx0XHRcdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmIyLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQ7XG5cblx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb3RoZXJPZmZzZXQsIG90aGVyQ291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvdGhlck9mZnNldCwgbDIgPSBvdGhlck9mZnNldCArIG90aGVyQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aTIgPSBvdGhlckJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIDMgKiB0aTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0MS5jb3B5KCB0ZW1wVGFyZ2V0MSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IGkyO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgbWluVGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIG5vIGJvdW5kcyB0cmVlIHRoZW4gd2UnbGwganVzdCBjaGVjayBldmVyeSB0cmlhbmdsZS5cblx0XHRcdFx0XHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIG90aGVyR2VvbWV0cnkgKTtcblx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gdHJpQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIDMgKiBpMiwgb3RoZXJJbmRleCwgb3RoZXJQb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogdGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBpMjtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IG1pblRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0fVxuXG5cdFx0KTtcblxuXHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlICk7XG5cdFx0RXh0ZW5kZWRUcmlhbmdsZVBvb2wucmVsZWFzZVByaW1pdGl2ZSggdHJpYW5nbGUyICk7XG5cblx0XHRpZiAoIGNsb3Nlc3REaXN0YW5jZSA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIHRhcmdldDEucG9pbnQgKSB7XG5cblx0XHRcdHRhcmdldDEucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDEuY2xvbmUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRhcmdldDEucG9pbnQuY29weSggdGVtcFRhcmdldERlc3QxICk7XG5cblx0XHR9XG5cblx0XHR0YXJnZXQxLmRpc3RhbmNlID0gY2xvc2VzdERpc3RhbmNlLFxuXHRcdHRhcmdldDEuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0XHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHRcdGlmICggISB0YXJnZXQyLnBvaW50ICkgdGFyZ2V0Mi5wb2ludCA9IHRlbXBUYXJnZXREZXN0Mi5jbG9uZSgpO1xuXHRcdFx0ZWxzZSB0YXJnZXQyLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MiApO1xuXHRcdFx0dGFyZ2V0Mi5wb2ludC5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHRcdHRlbXBUYXJnZXREZXN0MS5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHRcdHRhcmdldDIuZGlzdGFuY2UgPSB0ZW1wVGFyZ2V0RGVzdDEuc3ViKCB0YXJnZXQyLnBvaW50ICkubGVuZ3RoKCk7XG5cdFx0XHR0YXJnZXQyLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXg7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0MTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclN1cHBvcnRlZCgpIHtcblxuXHRcdHJldHVybiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuXG5cdH1cblxuXHRjb25zdCBfYnVmZmVyU3RhY2sxID0gbmV3IEJ1ZmZlclN0YWNrLmNvbnN0cnVjdG9yKCk7XG5cdGNvbnN0IF9idWZmZXJTdGFjazIgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcblx0Y29uc3QgX2JveFBvb2wgPSBuZXcgUHJpbWl0aXZlUG9vbCggKCkgPT4gbmV3IHRocmVlLkJveDMoKSApO1xuXHRjb25zdCBfbGVmdEJveDEgPSBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfcmlnaHRCb3gxID0gbmV3IHRocmVlLkJveDMoKTtcblxuXHRjb25zdCBfbGVmdEJveDIgPSBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfcmlnaHRCb3gyID0gbmV3IHRocmVlLkJveDMoKTtcblxuXHRsZXQgX2FjdGl2ZSA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGJ2aGNhc3QoIGJ2aCwgb3RoZXJCdmgsIG1hdHJpeFRvTG9jYWwsIGludGVyc2VjdHNSYW5nZXMgKSB7XG5cblx0XHRpZiAoIF9hY3RpdmUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IFJlY3Vyc2l2ZSBjYWxscyB0byBidmhjYXN0IG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0X2FjdGl2ZSA9IHRydWU7XG5cblx0XHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cdFx0Y29uc3Qgb3RoZXJSb290cyA9IG90aGVyQnZoLl9yb290cztcblx0XHRsZXQgcmVzdWx0O1xuXHRcdGxldCBvZmZzZXQxID0gMDtcblx0XHRsZXQgb2Zmc2V0MiA9IDA7XG5cdFx0Y29uc3QgaW52TWF0ID0gbmV3IHRocmVlLk1hdHJpeDQoKS5jb3B5KCBtYXRyaXhUb0xvY2FsICkuaW52ZXJ0KCk7XG5cblx0XHQvLyBpdGVyYXRlIG92ZXIgdGhlIGZpcnN0IHNldCBvZiByb290c1xuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSByb290cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0X2J1ZmZlclN0YWNrMS5zZXRCdWZmZXIoIHJvb3RzWyBpIF0gKTtcblx0XHRcdG9mZnNldDIgPSAwO1xuXG5cdFx0XHQvLyBwcmVwIHRoZSBpbml0aWFsIHJvb3QgYm94XG5cdFx0XHRjb25zdCBsb2NhbEJveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggMCApLCBfYnVmZmVyU3RhY2sxLmZsb2F0MzJBcnJheSwgbG9jYWxCb3ggKTtcblx0XHRcdGxvY2FsQm94LmFwcGx5TWF0cml4NCggaW52TWF0ICk7XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgc2Vjb25kIHNldCBvZiByb290c1xuXHRcdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG90aGVyUm9vdHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0X2J1ZmZlclN0YWNrMi5zZXRCdWZmZXIoIG90aGVyUm9vdHNbIGkgXSApO1xuXG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHQwLCAwLCBtYXRyaXhUb0xvY2FsLCBpbnZNYXQsIGludGVyc2VjdHNSYW5nZXMsXG5cdFx0XHRcdFx0b2Zmc2V0MSwgb2Zmc2V0MiwgMCwgMCxcblx0XHRcdFx0XHRsb2NhbEJveCxcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRfYnVmZmVyU3RhY2syLmNsZWFyQnVmZmVyKCk7XG5cdFx0XHRcdG9mZnNldDIgKz0gb3RoZXJSb290c1sgaiBdLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWxlYXNlIHN0YWNrIGluZm9cblx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIGxvY2FsQm94ICk7XG5cdFx0XHRfYnVmZmVyU3RhY2sxLmNsZWFyQnVmZmVyKCk7XG5cdFx0XHRvZmZzZXQxICs9IHJvb3RzWyBpIF0ubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0X2FjdGl2ZSA9IGZhbHNlO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF90cmF2ZXJzZShcblx0XHRub2RlMUluZGV4MzIsXG5cdFx0bm9kZTJJbmRleDMyLFxuXHRcdG1hdHJpeDJ0bzEsXG5cdFx0bWF0cml4MXRvMixcblx0XHRpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblxuXHRcdC8vIG9mZnNldHMgZm9yIGlkc1xuXHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0ID0gMCxcblx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCA9IDAsXG5cblx0XHQvLyB0cmVlIGRlcHRoXG5cdFx0ZGVwdGgxID0gMCxcblx0XHRkZXB0aDIgPSAwLFxuXG5cdFx0Y3VyckJveCA9IG51bGwsXG5cdFx0cmV2ZXJzZWQgPSBmYWxzZSxcblxuXHQpIHtcblxuXHRcdC8vIGdldCB0aGUgYnVmZmVyIHN0YWNrcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgaW5kaWNlc1xuXHRcdGxldCBidWZmZXJTdGFjazEsIGJ1ZmZlclN0YWNrMjtcblx0XHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0XHRidWZmZXJTdGFjazEgPSBfYnVmZmVyU3RhY2syO1xuXHRcdFx0YnVmZmVyU3RhY2syID0gX2J1ZmZlclN0YWNrMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJ1ZmZlclN0YWNrMSA9IF9idWZmZXJTdGFjazE7XG5cdFx0XHRidWZmZXJTdGFjazIgPSBfYnVmZmVyU3RhY2syO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IHRoZSBsb2NhbCBpbnN0YW5jZXMgb2YgdGhlIHR5cGVkIGJ1ZmZlcnNcblx0XHRjb25zdFxuXHRcdFx0ZmxvYXQzMkFycmF5MSA9IGJ1ZmZlclN0YWNrMS5mbG9hdDMyQXJyYXksXG5cdFx0XHR1aW50MzJBcnJheTEgPSBidWZmZXJTdGFjazEudWludDMyQXJyYXksXG5cdFx0XHR1aW50MTZBcnJheTEgPSBidWZmZXJTdGFjazEudWludDE2QXJyYXksXG5cdFx0XHRmbG9hdDMyQXJyYXkyID0gYnVmZmVyU3RhY2syLmZsb2F0MzJBcnJheSxcblx0XHRcdHVpbnQzMkFycmF5MiA9IGJ1ZmZlclN0YWNrMi51aW50MzJBcnJheSxcblx0XHRcdHVpbnQxNkFycmF5MiA9IGJ1ZmZlclN0YWNrMi51aW50MTZBcnJheTtcblxuXHRcdGNvbnN0IG5vZGUxSW5kZXgxNiA9IG5vZGUxSW5kZXgzMiAqIDI7XG5cdFx0Y29uc3Qgbm9kZTJJbmRleDE2ID0gbm9kZTJJbmRleDMyICogMjtcblx0XHRjb25zdCBpc0xlYWYxID0gSVNfTEVBRiggbm9kZTFJbmRleDE2LCB1aW50MTZBcnJheTEgKTtcblx0XHRjb25zdCBpc0xlYWYyID0gSVNfTEVBRiggbm9kZTJJbmRleDE2LCB1aW50MTZBcnJheTIgKTtcblx0XHRsZXQgcmVzdWx0ID0gZmFsc2U7XG5cdFx0aWYgKCBpc0xlYWYyICYmIGlzTGVhZjEgKSB7XG5cblx0XHRcdC8vIGlmIGJvdGggYm91bmRzIGFyZSBsZWFmIG5vZGVzIHRoZW4gZmlyZSB0aGUgY2FsbGJhY2sgaWYgdGhlIGJveGVzIGludGVyc2VjdFxuXHRcdFx0aWYgKCByZXZlcnNlZCApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzUmFuZ2VzRnVuYyhcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICksIENPVU5UKCBub2RlMUluZGV4MzIgKiAyLCB1aW50MTZBcnJheTEgKSxcblx0XHRcdFx0XHRkZXB0aDIsIG5vZGUySW5kZXhCeXRlT2Zmc2V0ICsgbm9kZTJJbmRleDMyLFxuXHRcdFx0XHRcdGRlcHRoMSwgbm9kZTFJbmRleEJ5dGVPZmZzZXQgKyBub2RlMUluZGV4MzIsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c1Jhbmdlc0Z1bmMoXG5cdFx0XHRcdFx0T0ZGU0VUKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApLCBDT1VOVCggbm9kZTFJbmRleDMyICogMiwgdWludDE2QXJyYXkxICksXG5cdFx0XHRcdFx0T0ZGU0VUKCBub2RlMkluZGV4MzIsIHVpbnQzMkFycmF5MiApLCBDT1VOVCggbm9kZTJJbmRleDMyICogMiwgdWludDE2QXJyYXkyICksXG5cdFx0XHRcdFx0ZGVwdGgxLCBub2RlMUluZGV4Qnl0ZU9mZnNldCArIG5vZGUxSW5kZXgzMixcblx0XHRcdFx0XHRkZXB0aDIsIG5vZGUySW5kZXhCeXRlT2Zmc2V0ICsgbm9kZTJJbmRleDMyLFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBpc0xlYWYyICkge1xuXG5cdFx0XHQvLyBTV0FQXG5cdFx0XHQvLyBJZiB3ZSd2ZSB0cmF2ZXJzZWQgdG8gdGhlIGxlYWYgbm9kZSBvbiB0aGUgb3RoZXIgYnZoIHRoZW4gd2UgbmVlZCB0byBzd2FwIG92ZXJcblx0XHRcdC8vIHRvIHRyYXZlcnNlIGRvd24gdGhlIGZpcnN0IG9uZVxuXG5cdFx0XHQvLyBnZXQgdGhlIG5ldyBib3ggdG8gdXNlXG5cdFx0XHRjb25zdCBuZXdCb3ggPSBfYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGUySW5kZXgzMiApLCBmbG9hdDMyQXJyYXkyLCBuZXdCb3ggKTtcblx0XHRcdG5ld0JveC5hcHBseU1hdHJpeDQoIG1hdHJpeDJ0bzEgKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBjaGlsZCBib3VuZHMgdG8gY2hlY2sgYmVmb3JlIHRyYXZlcnNhbFxuXHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdGNvbnN0IGNyMSA9IFJJR0hUX05PREUoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjbDEgKSwgZmxvYXQzMkFycmF5MSwgX2xlZnRCb3gxICk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHQvLyBwcmVjb21wdXRlIHRoZSBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZSB0aGUgZ2xvYmFsIGJveGVzIHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRyYXZlcnNhbFxuXHRcdFx0Y29uc3QgaW50ZXJzZWN0Q2wxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9sZWZ0Qm94MSApO1xuXHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdHJlc3VsdCA9IChcblx0XHRcdFx0aW50ZXJzZWN0Q2wxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMkluZGV4MzIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0XHQpXG5cdFx0XHQpIHx8IChcblx0XHRcdFx0aW50ZXJzZWN0Q3IxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMkluZGV4MzIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXG5cdFx0XHRfYm94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBuZXdCb3ggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlmIG5laXRoZXIgYXJlIGxlYXZlcyB0aGVuIHdlIHNob3VsZCBzd2FwIGlmIG9uZSBvZiB0aGUgY2hpbGRyZW4gZG9lcyBub3Rcblx0XHRcdC8vIGludGVyc2VjdCB3aXRoIHRoZSBjdXJyZW50IGJvdW5kc1xuXG5cdFx0XHQvLyBnZXQgdGhlIGNoaWxkIGJvdW5kcyB0byBjaGVja1xuXHRcdFx0Y29uc3QgY2wyID0gTEVGVF9OT0RFKCBub2RlMkluZGV4MzIgKTtcblx0XHRcdGNvbnN0IGNyMiA9IFJJR0hUX05PREUoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjbDIgKSwgZmxvYXQzMkFycmF5MiwgX2xlZnRCb3gyICk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjIgKSwgZmxvYXQzMkFycmF5MiwgX3JpZ2h0Qm94MiApO1xuXG5cdFx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0cyA9IGN1cnJCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gyICk7XG5cdFx0XHRjb25zdCByaWdodEludGVyc2VjdHMgPSBjdXJyQm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDIgKTtcblx0XHRcdGlmICggbGVmdEludGVyc2VjdHMgJiYgcmlnaHRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdC8vIGNvbnRpbnVlIHRvIHRyYXZlcnNlIGJvdGggY2hpbGRyZW4gaWYgdGhleSBib3RoIGludGVyc2VjdFxuXHRcdFx0XHRyZXN1bHQgPSBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0bm9kZTFJbmRleDMyLCBjbDIsIG1hdHJpeDJ0bzEsIG1hdHJpeDF0bzIsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRcdGN1cnJCb3gsIHJldmVyc2VkLFxuXHRcdFx0XHQpIHx8IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNyMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxlZnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdGlmICggaXNMZWFmMSApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleDMyLCBjbDIsIG1hdHJpeDJ0bzEsIG1hdHJpeDF0bzIsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBTV0FQXG5cdFx0XHRcdFx0Ly8gaWYgb25seSBvbmUgYm94IGludGVyc2VjdHMgdGhlbiB3ZSBoYXZlIHRvIHN3YXAgdG8gdGhlIG90aGVyIGJ2aCB0byBjb250aW51ZVxuXHRcdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRcdG5ld0JveC5jb3B5KCBfbGVmdEJveDIgKS5hcHBseU1hdHJpeDQoIG1hdHJpeDJ0bzEgKTtcblxuXHRcdFx0XHRcdGNvbnN0IGNsMSA9IExFRlRfTk9ERSggbm9kZTFJbmRleDMyICk7XG5cdFx0XHRcdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjbDEgKSwgZmxvYXQzMkFycmF5MSwgX2xlZnRCb3gxICk7XG5cdFx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY3IxICksIGZsb2F0MzJBcnJheTEsIF9yaWdodEJveDEgKTtcblxuXHRcdFx0XHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q2wxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9sZWZ0Qm94MSApO1xuXHRcdFx0XHRcdGNvbnN0IGludGVyc2VjdENyMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gxICk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gKFxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0Q2wxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0XHRcdFx0Y2wyLCBjbDEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCkgfHwgKFxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0Q3IxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0XHRcdFx0Y2wyLCBjcjEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRfYm94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBuZXdCb3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHJpZ2h0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRpZiAoIGlzTGVhZjEgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgY3VycmVudCBib3ggaXMgYSBsZWFmIHRoZW4ganVzdCBjb250aW51ZVxuXHRcdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRcdG5vZGUxSW5kZXgzMiwgY3IyLCBtYXRyaXgydG8xLCBtYXRyaXgxdG8yLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gU1dBUFxuXHRcdFx0XHRcdC8vIGlmIG9ubHkgb25lIGJveCBpbnRlcnNlY3RzIHRoZW4gd2UgaGF2ZSB0byBzd2FwIHRvIHRoZSBvdGhlciBidmggdG8gY29udGludWVcblx0XHRcdFx0XHRjb25zdCBuZXdCb3ggPSBfYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdFx0XHRuZXdCb3guY29weSggX3JpZ2h0Qm94MiApLmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdFx0XHRjb25zdCBjcjEgPSBSSUdIVF9OT0RFKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHRcdFx0Ly8gcHJlY29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9ucyBvdGhlcndpc2UgdGhlIGdsb2JhbCBib3hlcyB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0cmF2ZXJzYWxcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjcjIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB8fCAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjcjIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0Y29uc3Qgb2JiID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCB0ZW1wQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5Cb3gzKCk7XG5cblx0Y2xhc3MgTWVzaEJWSCB7XG5cblx0XHRzdGF0aWMgc2VyaWFsaXplKCBidmgsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0Y2xvbmVCdWZmZXJzOiB0cnVlLFxuXHRcdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCByb290RGF0YSA9IGJ2aC5fcm9vdHM7XG5cdFx0XHRjb25zdCBpbmRpcmVjdEJ1ZmZlciA9IGJ2aC5faW5kaXJlY3RCdWZmZXI7XG5cdFx0XHRjb25zdCBpbmRleEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0aWYgKCBvcHRpb25zLmNsb25lQnVmZmVycyApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLm1hcCggcm9vdCA9PiByb290LnNsaWNlKCkgKSxcblx0XHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcblx0XHRcdFx0XHRpbmRpcmVjdEJ1ZmZlcjogaW5kaXJlY3RCdWZmZXIgPyBpbmRpcmVjdEJ1ZmZlci5zbGljZSgpIDogbnVsbCxcblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLFxuXHRcdFx0XHRcdGluZGV4OiBpbmRleEF0dHJpYnV0ZS5hcnJheSxcblx0XHRcdFx0XHRpbmRpcmVjdEJ1ZmZlcjogaW5kaXJlY3RCdWZmZXIsXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdHN0YXRpYyBkZXNlcmlhbGl6ZSggZGF0YSwgZ2VvbWV0cnksIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0c2V0SW5kZXg6IHRydWUsXG5cdFx0XHRcdGluZGlyZWN0OiBCb29sZWFuKCBkYXRhLmluZGlyZWN0QnVmZmVyICksXG5cdFx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCB7IGluZGV4LCByb290cywgaW5kaXJlY3RCdWZmZXIgfSA9IGRhdGE7XG5cdFx0XHRjb25zdCBidmggPSBuZXcgTWVzaEJWSCggZ2VvbWV0cnksIHsgLi4ub3B0aW9ucywgWyBTS0lQX0dFTkVSQVRJT04gXTogdHJ1ZSB9ICk7XG5cdFx0XHRidmguX3Jvb3RzID0gcm9vdHM7XG5cdFx0XHRidmguX2luZGlyZWN0QnVmZmVyID0gaW5kaXJlY3RCdWZmZXIgfHwgbnVsbDtcblxuXHRcdFx0aWYgKCBvcHRpb25zLnNldEluZGV4ICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGV4QXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRcdFx0aWYgKCBpbmRleEF0dHJpYnV0ZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG5ld0luZGV4ID0gbmV3IHRocmVlLkJ1ZmZlckF0dHJpYnV0ZSggZGF0YS5pbmRleCwgMSwgZmFsc2UgKTtcblx0XHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3SW5kZXggKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbmRleEF0dHJpYnV0ZS5hcnJheSAhPT0gaW5kZXggKSB7XG5cblx0XHRcdFx0XHRpbmRleEF0dHJpYnV0ZS5hcnJheS5zZXQoIGluZGV4ICk7XG5cdFx0XHRcdFx0aW5kZXhBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnZoO1xuXG5cdFx0fVxuXG5cdFx0Z2V0IGluZGlyZWN0KCkge1xuXG5cdFx0XHRyZXR1cm4gISAhIHRoaXMuX2luZGlyZWN0QnVmZmVyO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3RydWN0b3IoIGdlb21ldHJ5LCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdGlmICggISBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IE9ubHkgQnVmZmVyR2VvbWV0cmllcyBhcmUgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaW5kZXggJiYgZ2VvbWV0cnkuaW5kZXguaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgaW5kZXggYXR0cmlidXRlLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZhdWx0IG9wdGlvbnNcblx0XHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7XG5cblx0XHRcdFx0c3RyYXRlZ3k6IENFTlRFUixcblx0XHRcdFx0bWF4RGVwdGg6IDQwLFxuXHRcdFx0XHRtYXhMZWFmVHJpczogMTAsXG5cdFx0XHRcdHZlcmJvc2U6IHRydWUsXG5cdFx0XHRcdHVzZVNoYXJlZEFycmF5QnVmZmVyOiBmYWxzZSxcblx0XHRcdFx0c2V0Qm91bmRpbmdCb3g6IHRydWUsXG5cdFx0XHRcdG9uUHJvZ3Jlc3M6IG51bGwsXG5cdFx0XHRcdGluZGlyZWN0OiBmYWxzZSxcblxuXHRcdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc2tpcCBnZW5lcmF0aW5nIHRoZSB0cmVlLiBVc2VkIGZvciBkZXNlcmlhbGl6YXRpb24uXG5cdFx0XHRcdFsgU0tJUF9HRU5FUkFUSU9OIF06IGZhbHNlLFxuXG5cdFx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRcdGlmICggb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciAmJiAhIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gcmVmZXJlbmNlcyB0byB0aGUgZ2VvbWV0cnkgc28gd2UgY2FuIHVzZSB0aGVtIGl0IHdpdGhvdXQgaGF2aW5nIHRvXG5cdFx0XHQvLyB0YWtlIGEgZ2VvbWV0cnkgcmVmZXJlbmNlIGluIGV2ZXJ5IGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBudWxsO1xuXHRcdFx0dGhpcy5faW5kaXJlY3RCdWZmZXIgPSBudWxsO1xuXHRcdFx0aWYgKCAhIG9wdGlvbnNbIFNLSVBfR0VORVJBVElPTiBdICkge1xuXG5cdFx0XHRcdGJ1aWxkUGFja2VkVHJlZSggdGhpcywgb3B0aW9ucyApO1xuXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5ib3VuZGluZ0JveCAmJiBvcHRpb25zLnNldEJvdW5kaW5nQm94ICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCBuZXcgdGhyZWUuQm94MygpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHsgX2luZGlyZWN0QnVmZmVyIH0gPSB0aGlzO1xuXHRcdFx0dGhpcy5yZXNvbHZlVHJpYW5nbGVJbmRleCA9IG9wdGlvbnMuaW5kaXJlY3QgPyBpID0+IF9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaSA9PiBpO1xuXG5cdFx0fVxuXG5cdFx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcmVmaXRGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJlZml0X2luZGlyZWN0IDogcmVmaXQ7XG5cdFx0XHRyZXR1cm4gcmVmaXRGdW5jKCB0aGlzLCBub2RlSW5kaWNlcyApO1xuXG5cdFx0fVxuXG5cdFx0dHJhdmVyc2UoIGNhbGxiYWNrLCByb290SW5kZXggPSAwICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLl9yb290c1sgcm9vdEluZGV4IF07XG5cdFx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHRjb25zdCB1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRfdHJhdmVyc2UoIDAgKTtcblxuXHRcdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUxNkluZGV4ID0gbm9kZTMySW5kZXggKiAyO1xuXHRcdFx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGRlcHRoLCBpc0xlYWYsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciwgbm9kZTMySW5kZXggKiA0LCA2ICksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETzogdXNlIG5vZGUgZnVuY3Rpb25zIGhlcmVcblx0XHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyBCWVRFU19QRVJfTk9ERSAvIDQ7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNyBdO1xuXHRcdFx0XHRcdGNvbnN0IHN0b3BUcmF2ZXJzYWwgPSBjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgc3BsaXRBeGlzICk7XG5cblx0XHRcdFx0XHRpZiAoICEgc3RvcFRyYXZlcnNhbCApIHtcblxuXHRcdFx0XHRcdFx0X3RyYXZlcnNlKCBsZWZ0LCBkZXB0aCArIDEgKTtcblx0XHRcdFx0XHRcdF90cmF2ZXJzZSggcmlnaHQsIGRlcHRoICsgMSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyogQ29yZSBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRcdHJheWNhc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSB0aHJlZS5Gcm9udFNpZGUgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBpbnRlcnNlY3RzID0gW107XG5cdFx0XHRjb25zdCBpc01hdGVyaWFsID0gbWF0ZXJpYWxPclNpZGUuaXNNYXRlcmlhbDtcblx0XHRcdGNvbnN0IGlzQXJyYXlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsT3JTaWRlICk7XG5cblx0XHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRcdGNvbnN0IHNpZGUgPSBpc01hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGUuc2lkZSA6IG1hdGVyaWFsT3JTaWRlO1xuXHRcdFx0Y29uc3QgcmF5Y2FzdEZ1bmMgPSB0aGlzLmluZGlyZWN0ID8gcmF5Y2FzdF9pbmRpcmVjdCA6IHJheWNhc3Q7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IG1hdGVyaWFsU2lkZSA9IGlzQXJyYXlNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlWyBncm91cHNbIGkgXS5tYXRlcmlhbEluZGV4IF0uc2lkZSA6IHNpZGU7XG5cdFx0XHRcdGNvbnN0IHN0YXJ0Q291bnQgPSBpbnRlcnNlY3RzLmxlbmd0aDtcblxuXHRcdFx0XHRyYXljYXN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0XHRpZiAoIGlzQXJyYXlNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1hdGVyaWFsSW5kZXggPSBncm91cHNbIGkgXS5tYXRlcmlhbEluZGV4O1xuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnRDb3VudCwgamwgPSBpbnRlcnNlY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzWyBqIF0uZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHR9XG5cblx0XHRyYXljYXN0Rmlyc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSB0aHJlZS5Gcm9udFNpZGUgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBpc01hdGVyaWFsID0gbWF0ZXJpYWxPclNpZGUuaXNNYXRlcmlhbDtcblx0XHRcdGNvbnN0IGlzQXJyYXlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsT3JTaWRlICk7XG5cblx0XHRcdGxldCBjbG9zZXN0UmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRjb25zdCByYXljYXN0Rmlyc3RGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJheWNhc3RGaXJzdF9pbmRpcmVjdCA6IHJheWNhc3RGaXJzdDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxTaWRlID0gaXNBcnJheU1hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGVbIGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXggXS5zaWRlIDogc2lkZTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gcmF5Y2FzdEZpcnN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXkgKTtcblx0XHRcdFx0aWYgKCByZXN1bHQgIT0gbnVsbCAmJiAoIGNsb3Nlc3RSZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQuZGlzdGFuY2UgPCBjbG9zZXN0UmVzdWx0LmRpc3RhbmNlICkgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0UmVzdWx0ID0gcmVzdWx0O1xuXHRcdFx0XHRcdGlmICggaXNBcnJheU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRyZXN1bHQuZmFjZS5tYXRlcmlhbEluZGV4ID0gZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNsb3Nlc3RSZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRpbnRlcnNlY3RzR2VvbWV0cnkoIG90aGVyR2VvbWV0cnksIGdlb21Ub01lc2ggKSB7XG5cblx0XHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRjb25zdCBpbnRlcnNlY3RzR2VvbWV0cnlGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGludGVyc2VjdHNHZW9tZXRyeV9pbmRpcmVjdCA6IGludGVyc2VjdHNHZW9tZXRyeTtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c0dlb21ldHJ5RnVuYyggdGhpcywgaSwgb3RoZXJHZW9tZXRyeSwgZ2VvbVRvTWVzaCApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRzaGFwZWNhc3QoIGNhbGxiYWNrcyApIHtcblxuXHRcdFx0Y29uc3QgdHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdGNvbnN0IGl0ZXJhdGVGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IDogaXRlcmF0ZU92ZXJUcmlhbmdsZXM7XG5cdFx0XHRsZXQge1xuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyLFxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzLFxuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UsXG5cdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZSxcblx0XHRcdH0gPSBjYWxsYmFja3M7XG5cblx0XHRcdC8vIHdyYXAgdGhlIGludGVyc2VjdHNSYW5nZSBmdW5jdGlvblxuXHRcdFx0aWYgKCBpbnRlcnNlY3RzUmFuZ2UgJiYgaW50ZXJzZWN0c1RyaWFuZ2xlICkge1xuXG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlID0gaW50ZXJzZWN0c1JhbmdlO1xuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCwgZGVwdGgsIG5vZGVJbmRleCApID0+IHtcblxuXHRcdFx0XHRcdGlmICggISBvcmlnaW5hbEludGVyc2VjdHNSYW5nZSggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCwgbm9kZUluZGV4ICkgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBpdGVyYXRlRnVuYyggb2Zmc2V0LCBjb3VudCwgdGhpcywgaW50ZXJzZWN0c1RyaWFuZ2xlLCBjb250YWluZWQsIGRlcHRoLCB0cmlhbmdsZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0fSBlbHNlIGlmICggISBpbnRlcnNlY3RzUmFuZ2UgKSB7XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCwgZGVwdGggKSA9PiB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBpdGVyYXRlRnVuYyggb2Zmc2V0LCBjb3VudCwgdGhpcywgaW50ZXJzZWN0c1RyaWFuZ2xlLCBjb250YWluZWQsIGRlcHRoLCB0cmlhbmdsZSApO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlID0gKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBjb250YWluZWQ7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBydW4gc2hhcGVjYXN0XG5cdFx0XHRsZXQgcmVzdWx0ID0gZmFsc2U7XG5cdFx0XHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdFx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCByb290ID0gcm9vdHNbIGkgXTtcblx0XHRcdFx0cmVzdWx0ID0gc2hhcGVjYXN0KCB0aGlzLCBpLCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRieXRlT2Zmc2V0ICs9IHJvb3QuYnl0ZUxlbmd0aDtcblxuXHRcdFx0fVxuXG5cdFx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fVxuXG5cdFx0YnZoY2FzdCggb3RoZXJCdmgsIG1hdHJpeFRvTG9jYWwsIGNhbGxiYWNrcyApIHtcblxuXHRcdFx0bGV0IHtcblx0XHRcdFx0aW50ZXJzZWN0c1Jhbmdlcyxcblx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlcyxcblx0XHRcdH0gPSBjYWxsYmFja3M7XG5cblx0XHRcdGNvbnN0IHRyaWFuZ2xlMSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgaW5kZXhBdHRyMSA9IHRoaXMuZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3NpdGlvbkF0dHIxID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgYXNzaWduVHJpYW5nbGUxID0gdGhpcy5pbmRpcmVjdCA/XG5cdFx0XHRcdGkxID0+IHtcblxuXG5cdFx0XHRcdFx0Y29uc3QgdGkgPSB0aGlzLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpMSApO1xuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTEsIHRpICogMywgaW5kZXhBdHRyMSwgcG9zaXRpb25BdHRyMSApO1xuXG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRpMSA9PiB7XG5cblx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUxLCBpMSAqIDMsIGluZGV4QXR0cjEsIHBvc2l0aW9uQXR0cjEgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRjb25zdCB0cmlhbmdsZTIgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRcdGNvbnN0IGluZGV4QXR0cjIgPSBvdGhlckJ2aC5nZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cjIgPSBvdGhlckJ2aC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgYXNzaWduVHJpYW5nbGUyID0gb3RoZXJCdmguaW5kaXJlY3QgP1xuXHRcdFx0XHRpMiA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCB0aTIgPSBvdGhlckJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTIgKTtcblx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCB0aTIgKiAzLCBpbmRleEF0dHIyLCBwb3NpdGlvbkF0dHIyICk7XG5cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIGkyICogMywgaW5kZXhBdHRyMiwgcG9zaXRpb25BdHRyMiApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRyaWFuZ2xlIGNhbGxiYWNrIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzID0gKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgPT4ge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gb2Zmc2V0MiwgbDIgPSBvZmZzZXQyICsgY291bnQyOyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0YXNzaWduVHJpYW5nbGUyKCBpMiApO1xuXG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIG1hdHJpeFRvTG9jYWwgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBtYXRyaXhUb0xvY2FsICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTEgPSBvZmZzZXQxLCBsMSA9IG9mZnNldDEgKyBjb3VudDE7IGkxIDwgbDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGFzc2lnblRyaWFuZ2xlMSggaTEgKTtcblxuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTEubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyggdHJpYW5nbGUxLCB0cmlhbmdsZTIsIGkxLCBpMiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmICggaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlcyA9IGludGVyc2VjdHNSYW5nZXM7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGZ1bmN0aW9uICggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1Jhbmdlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBpdGVyYXRlT3ZlckRvdWJsZVRyaWFuZ2xlcyggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYnZoY2FzdCggdGhpcywgb3RoZXJCdmgsIG1hdHJpeFRvTG9jYWwsIGludGVyc2VjdHNSYW5nZXMgKTtcblxuXHRcdH1cblxuXG5cdFx0LyogRGVyaXZlZCBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRcdGludGVyc2VjdHNCb3goIGJveCwgYm94VG9NZXNoICkge1xuXG5cdFx0XHRvYmIuc2V0KCBib3gubWluLCBib3gubWF4LCBib3hUb01lc2ggKTtcblx0XHRcdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdHJldHVybiB0aGlzLnNoYXBlY2FzdChcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4gb2JiLmludGVyc2VjdHNUcmlhbmdsZSggdHJpIClcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IHNwaGVyZS5pbnRlcnNlY3RzQm94KCBib3ggKSxcblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB0cmkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlIClcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGNsb3Nlc3RQb2ludFRvR2VvbWV0cnkoIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIHRhcmdldDEgPSB7IH0sIHRhcmdldDIgPSB7IH0sIG1pblRocmVzaG9sZCA9IDAsIG1heFRocmVzaG9sZCA9IEluZmluaXR5ICkge1xuXG5cdFx0XHRjb25zdCBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0IDogY2xvc2VzdFBvaW50VG9HZW9tZXRyeTtcblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5RnVuYyhcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0b3RoZXJHZW9tZXRyeSxcblx0XHRcdFx0Z2VvbWV0cnlUb0J2aCxcblx0XHRcdFx0dGFyZ2V0MSxcblx0XHRcdFx0dGFyZ2V0Mixcblx0XHRcdFx0bWluVGhyZXNob2xkLFxuXHRcdFx0XHRtYXhUaHJlc2hvbGQsXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCA9IHsgfSwgbWluVGhyZXNob2xkID0gMCwgbWF4VGhyZXNob2xkID0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnRUb1BvaW50KFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRwb2ludCxcblx0XHRcdFx0dGFyZ2V0LFxuXHRcdFx0XHRtaW5UaHJlc2hvbGQsXG5cdFx0XHRcdG1heFRocmVzaG9sZCxcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xuXG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRyb290cy5mb3JFYWNoKCBidWZmZXIgPT4ge1xuXG5cdFx0XHRcdGFycmF5VG9Cb3goIDAsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApLCB0ZW1wQm94ICk7XG5cdFx0XHRcdHRhcmdldC51bmlvbiggdGVtcEJveCApO1xuXG5cdFx0XHR9ICk7XG5cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGJvdW5kaW5nQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5Cb3gzKCk7XG5cdGNsYXNzIE1lc2hCVkhSb290VmlzdWFsaXplciBleHRlbmRzIHRocmVlLk9iamVjdDNEIHtcblxuXHRcdGdldCBpc01lc2goKSB7XG5cblx0XHRcdHJldHVybiAhIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0IGlzTGluZVNlZ21lbnRzKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwbGF5RWRnZXM7XG5cblx0XHR9XG5cblx0XHRnZXQgaXNMaW5lKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwbGF5RWRnZXM7XG5cblx0XHR9XG5cblx0XHRjb25zdHJ1Y3RvciggbWVzaCwgbWF0ZXJpYWwsIGRlcHRoID0gMTAsIGdyb3VwID0gMCApIHtcblxuXHRcdFx0c3VwZXIoKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyB0aHJlZS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJ01lc2hCVkhSb290VmlzdWFsaXplcic7XG5cdFx0XHR0aGlzLmRlcHRoID0gZGVwdGg7XG5cdFx0XHR0aGlzLmRpc3BsYXlQYXJlbnRzID0gZmFsc2U7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXHRcdFx0dGhpcy5kaXNwbGF5RWRnZXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblxuXHRcdH1cblxuXHRcdHJheWNhc3QoKSB7fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBib3VuZHNUcmVlID0gdGhpcy5tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRjb25zdCBncm91cCA9IHRoaXMuX2dyb3VwO1xuXHRcdFx0Z2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAoIGJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiBib3VuZHMgcmVxdWlyZWRcblx0XHRcdFx0Y29uc3QgdGFyZ2V0RGVwdGggPSB0aGlzLmRlcHRoIC0gMTtcblx0XHRcdFx0Y29uc3QgZGlzcGxheVBhcmVudHMgPSB0aGlzLmRpc3BsYXlQYXJlbnRzO1xuXHRcdFx0XHRsZXQgYm91bmRzQ291bnQgPSAwO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoID09PSB0YXJnZXREZXB0aCB8fCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdGJvdW5kc0NvdW50ICsrO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBkaXNwbGF5UGFyZW50cyApIHtcblxuXHRcdFx0XHRcdFx0Ym91bmRzQ291bnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSwgZ3JvdXAgKTtcblxuXHRcdFx0XHQvLyBmaWxsIGluIHRoZSBwb3NpdGlvbiBidWZmZXIgd2l0aCB0aGUgYm91bmRzIGNvcm5lcnNcblx0XHRcdFx0bGV0IHBvc0luZGV4ID0gMDtcblx0XHRcdFx0Y29uc3QgcG9zaXRpb25BcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKiAzICogYm91bmRzQ291bnQgKTtcblx0XHRcdFx0Ym91bmRzVHJlZS50cmF2ZXJzZSggKCBkZXB0aCwgaXNMZWFmLCBib3VuZGluZ0RhdGEgKSA9PiB7XG5cblx0XHRcdFx0XHRjb25zdCB0ZXJtaW5hdGUgPSBkZXB0aCA9PT0gdGFyZ2V0RGVwdGggfHwgaXNMZWFmO1xuXHRcdFx0XHRcdGlmICggdGVybWluYXRlIHx8IGRpc3BsYXlQYXJlbnRzICkge1xuXG5cdFx0XHRcdFx0XHRhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIGJvdW5kaW5nQm94ICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHsgbWluLCBtYXggfSA9IGJvdW5kaW5nQm94O1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IHggPSAtIDE7IHggPD0gMTsgeCArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHhWYWwgPSB4IDwgMCA/IG1pbi54IDogbWF4Lng7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCB5ID0gLSAxOyB5IDw9IDE7IHkgKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHlWYWwgPSB5IDwgMCA/IG1pbi55IDogbWF4Lnk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IHogPSAtIDE7IHogPD0gMTsgeiArPSAyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB6VmFsID0geiA8IDAgPyBtaW4ueiA6IG1heC56O1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAwIF0gPSB4VmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAxIF0gPSB5VmFsO1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb25BcnJheVsgcG9zSW5kZXggKyAyIF0gPSB6VmFsO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NJbmRleCArPSAzO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVybWluYXRlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sIGdyb3VwICk7XG5cblx0XHRcdFx0bGV0IGluZGV4QXJyYXk7XG5cdFx0XHRcdGxldCBpbmRpY2VzO1xuXHRcdFx0XHRpZiAoIHRoaXMuZGlzcGxheUVkZ2VzICkge1xuXG5cdFx0XHRcdFx0Ly8gZmlsbCBpbiB0aGUgaW5kZXggYnVmZmVyIHRvIHBvaW50IHRvIHRoZSBjb3JuZXIgcG9pbnRzXG5cdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KCBbXG5cdFx0XHRcdFx0XHQvLyB4IGF4aXNcblx0XHRcdFx0XHRcdDAsIDQsXG5cdFx0XHRcdFx0XHQxLCA1LFxuXHRcdFx0XHRcdFx0MiwgNixcblx0XHRcdFx0XHRcdDMsIDcsXG5cblx0XHRcdFx0XHRcdC8vIHkgYXhpc1xuXHRcdFx0XHRcdFx0MCwgMixcblx0XHRcdFx0XHRcdDEsIDMsXG5cdFx0XHRcdFx0XHQ0LCA2LFxuXHRcdFx0XHRcdFx0NSwgNyxcblxuXHRcdFx0XHRcdFx0Ly8geiBheGlzXG5cdFx0XHRcdFx0XHQwLCAxLFxuXHRcdFx0XHRcdFx0MiwgMyxcblx0XHRcdFx0XHRcdDQsIDUsXG5cdFx0XHRcdFx0XHQ2LCA3LFxuXHRcdFx0XHRcdF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KCBbXG5cblx0XHRcdFx0XHRcdC8vIFgtLCBYK1xuXHRcdFx0XHRcdFx0MCwgMSwgMixcblx0XHRcdFx0XHRcdDIsIDEsIDMsXG5cblx0XHRcdFx0XHRcdDQsIDYsIDUsXG5cdFx0XHRcdFx0XHQ2LCA3LCA1LFxuXG5cdFx0XHRcdFx0XHQvLyBZLSwgWStcblx0XHRcdFx0XHRcdDEsIDQsIDUsXG5cdFx0XHRcdFx0XHQwLCA0LCAxLFxuXG5cdFx0XHRcdFx0XHQyLCAzLCA2LFxuXHRcdFx0XHRcdFx0MywgNywgNixcblxuXHRcdFx0XHRcdFx0Ly8gWi0sIForXG5cdFx0XHRcdFx0XHQwLCAyLCA0LFxuXHRcdFx0XHRcdFx0MiwgNiwgNCxcblxuXHRcdFx0XHRcdFx0MSwgNSwgMyxcblx0XHRcdFx0XHRcdDMsIDUsIDcsXG5cblx0XHRcdFx0XHRdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggcG9zaXRpb25BcnJheS5sZW5ndGggPiA2NTUzNSApIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGluZGljZXMubGVuZ3RoICogYm91bmRzQ291bnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5kZXhBcnJheSA9IG5ldyBVaW50MTZBcnJheSggaW5kaWNlcy5sZW5ndGggKiBib3VuZHNDb3VudCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBpbmRleExlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBib3VuZHNDb3VudDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc09mZnNldCA9IGkgKiA4O1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4T2Zmc2V0ID0gaSAqIGluZGV4TGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGluZGV4TGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbmRleEFycmF5WyBpbmRleE9mZnNldCArIGogXSA9IHBvc09mZnNldCArIGluZGljZXNbIGogXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBnZW9tZXRyeVxuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleChcblx0XHRcdFx0XHRuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBpbmRleEFycmF5LCAxLCBmYWxzZSApLFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J3Bvc2l0aW9uJyxcblx0XHRcdFx0XHRuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkFycmF5LCAzLCBmYWxzZSApLFxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhWaXN1YWxpemVyIGV4dGVuZHMgdGhyZWUuR3JvdXAge1xuXG5cdFx0Z2V0IGNvbG9yKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5lZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHR9XG5cblx0XHRnZXQgb3BhY2l0eSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZWRnZU1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHR9XG5cblx0XHRzZXQgb3BhY2l0eSggdiApIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwub3BhY2l0eSA9IHY7XG5cdFx0XHR0aGlzLm1lc2hNYXRlcmlhbC5vcGFjaXR5ID0gdjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoLCBkZXB0aCA9IDEwICkge1xuXG5cdFx0XHRzdXBlcigpO1xuXG5cdFx0XHR0aGlzLm5hbWUgPSAnTWVzaEJWSFZpc3VhbGl6ZXInO1xuXHRcdFx0dGhpcy5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0dGhpcy5tZXNoID0gbWVzaDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGxheUVkZ2VzID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3Jvb3RzID0gW107XG5cblx0XHRcdGNvbnN0IGVkZ2VNYXRlcmlhbCA9IG5ldyB0aHJlZS5MaW5lQmFzaWNNYXRlcmlhbCgge1xuXHRcdFx0XHRjb2xvcjogMHgwMEZGODgsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjMsXG5cdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRjb25zdCBtZXNoTWF0ZXJpYWwgPSBuZXcgdGhyZWUuTWVzaEJhc2ljTWF0ZXJpYWwoIHtcblx0XHRcdFx0Y29sb3I6IDB4MDBGRjg4LFxuXHRcdFx0XHR0cmFuc3BhcmVudDogdHJ1ZSxcblx0XHRcdFx0b3BhY2l0eTogMC4zLFxuXHRcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcblx0XHRcdH0gKTtcblxuXHRcdFx0bWVzaE1hdGVyaWFsLmNvbG9yID0gZWRnZU1hdGVyaWFsLmNvbG9yO1xuXG5cdFx0XHR0aGlzLmVkZ2VNYXRlcmlhbCA9IGVkZ2VNYXRlcmlhbDtcblx0XHRcdHRoaXMubWVzaE1hdGVyaWFsID0gbWVzaE1hdGVyaWFsO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBidmggPSB0aGlzLm1lc2guZ2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdGNvbnN0IHRvdGFsUm9vdHMgPSBidmggPyBidmguX3Jvb3RzLmxlbmd0aCA6IDA7XG5cdFx0XHR3aGlsZSAoIHRoaXMuX3Jvb3RzLmxlbmd0aCA+IHRvdGFsUm9vdHMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RzLnBvcCgpO1xuXHRcdFx0XHRyb290Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcblx0XHRcdFx0dGhpcy5yZW1vdmUoIHJvb3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0b3RhbFJvb3RzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggaSA+PSB0aGlzLl9yb290cy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhSb290VmlzdWFsaXplciggdGhpcy5tZXNoLCB0aGlzLmVkZ2VNYXRlcmlhbCwgdGhpcy5kZXB0aCwgaSApO1xuXHRcdFx0XHRcdHRoaXMuYWRkKCByb290ICk7XG5cdFx0XHRcdFx0dGhpcy5fcm9vdHMucHVzaCggcm9vdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByb290ID0gdGhpcy5fcm9vdHNbIGkgXTtcblx0XHRcdFx0cm9vdC5kZXB0aCA9IHRoaXMuZGVwdGg7XG5cdFx0XHRcdHJvb3QubWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdFx0cm9vdC5kaXNwbGF5UGFyZW50cyA9IHRoaXMuZGlzcGxheVBhcmVudHM7XG5cdFx0XHRcdHJvb3QuZGlzcGxheUVkZ2VzID0gdGhpcy5kaXNwbGF5RWRnZXM7XG5cdFx0XHRcdHJvb3QubWF0ZXJpYWwgPSB0aGlzLmRpc3BsYXlFZGdlcyA/IHRoaXMuZWRnZU1hdGVyaWFsIDogdGhpcy5tZXNoTWF0ZXJpYWw7XG5cdFx0XHRcdHJvb3QudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHVwZGF0ZU1hdHJpeFdvcmxkKCAuLi5hcmdzICkge1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHRoaXMubWVzaC5wb3NpdGlvbiApO1xuXHRcdFx0dGhpcy5yb3RhdGlvbi5jb3B5KCB0aGlzLm1lc2gucm90YXRpb24gKTtcblx0XHRcdHRoaXMuc2NhbGUuY29weSggdGhpcy5tZXNoLnNjYWxlICk7XG5cblx0XHRcdHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKCAuLi5hcmdzICk7XG5cblx0XHR9XG5cblx0XHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRcdHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG5cdFx0XHR0aGlzLm1lc2ggPSBzb3VyY2UubWVzaDtcblxuXHRcdH1cblxuXHRcdGNsb25lKCkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IE1lc2hCVkhWaXN1YWxpemVyKCB0aGlzLm1lc2gsIHRoaXMuZGVwdGggKTtcblxuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cblx0XHRcdHRoaXMuZWRnZU1hdGVyaWFsLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMubWVzaE1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjaGlsZHJlblsgaSBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBfYm94MSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfYm94MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuQm94MygpO1xuXHRjb25zdCBfdmVjID0gLyogQF9fUFVSRV9fICovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cblx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTI0ODMwMi9ob3ctdG8tZ2V0LXRoZS1zaXplLW9mLWEtamF2YXNjcmlwdC1vYmplY3Rcblx0ZnVuY3Rpb24gZ2V0UHJpbWl0aXZlU2l6ZSggZWwgKSB7XG5cblx0XHRzd2l0Y2ggKCB0eXBlb2YgZWwgKSB7XG5cblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdHJldHVybiA4O1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIGVsLmxlbmd0aCAqIDI7XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIDQ7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNUeXBlZEFycmF5KCBhcnIgKSB7XG5cblx0XHRjb25zdCByZWdleCA9IC8oVWludHxJbnR8RmxvYXQpKDh8MTZ8MzIpQXJyYXkvO1xuXHRcdHJldHVybiByZWdleC50ZXN0KCBhcnIuY29uc3RydWN0b3IubmFtZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRSb290RXh0cmVtZXMoIGJ2aCwgZ3JvdXAgKSB7XG5cblx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRub2RlQ291bnQ6IDAsXG5cdFx0XHRsZWFmTm9kZUNvdW50OiAwLFxuXG5cdFx0XHRkZXB0aDoge1xuXHRcdFx0XHRtaW46IEluZmluaXR5LCBtYXg6IC0gSW5maW5pdHlcblx0XHRcdH0sXG5cdFx0XHR0cmlzOiB7XG5cdFx0XHRcdG1pbjogSW5maW5pdHksIG1heDogLSBJbmZpbml0eVxuXHRcdFx0fSxcblx0XHRcdHNwbGl0czogWyAwLCAwLCAwIF0sXG5cdFx0XHRzdXJmYWNlQXJlYVNjb3JlOiAwLFxuXHRcdH07XG5cblx0XHRidmgudHJhdmVyc2UoICggZGVwdGgsIGlzTGVhZiwgYm91bmRpbmdEYXRhLCBvZmZzZXRPclNwbGl0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgbDAgPSBib3VuZGluZ0RhdGFbIDAgKyAzIF0gLSBib3VuZGluZ0RhdGFbIDAgXTtcblx0XHRcdGNvbnN0IGwxID0gYm91bmRpbmdEYXRhWyAxICsgMyBdIC0gYm91bmRpbmdEYXRhWyAxIF07XG5cdFx0XHRjb25zdCBsMiA9IGJvdW5kaW5nRGF0YVsgMiArIDMgXSAtIGJvdW5kaW5nRGF0YVsgMiBdO1xuXG5cdFx0XHRjb25zdCBzdXJmYWNlQXJlYSA9IDIgKiAoIGwwICogbDEgKyBsMSAqIGwyICsgbDIgKiBsMCApO1xuXG5cdFx0XHRyZXN1bHQubm9kZUNvdW50ICsrO1xuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0cmVzdWx0LmxlYWZOb2RlQ291bnQgKys7XG5cblx0XHRcdFx0cmVzdWx0LmRlcHRoLm1pbiA9IE1hdGgubWluKCBkZXB0aCwgcmVzdWx0LmRlcHRoLm1pbiApO1xuXHRcdFx0XHRyZXN1bHQuZGVwdGgubWF4ID0gTWF0aC5tYXgoIGRlcHRoLCByZXN1bHQuZGVwdGgubWF4ICk7XG5cblx0XHRcdFx0cmVzdWx0LnRyaXMubWluID0gTWF0aC5taW4oIGNvdW50LCByZXN1bHQudHJpcy5taW4gKTtcblx0XHRcdFx0cmVzdWx0LnRyaXMubWF4ID0gTWF0aC5tYXgoIGNvdW50LCByZXN1bHQudHJpcy5tYXggKTtcblxuXHRcdFx0XHRyZXN1bHQuc3VyZmFjZUFyZWFTY29yZSArPSBzdXJmYWNlQXJlYSAqIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogY291bnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0LnNwbGl0c1sgb2Zmc2V0T3JTcGxpdCBdICsrO1xuXG5cdFx0XHRcdHJlc3VsdC5zdXJmYWNlQXJlYVNjb3JlICs9IHN1cmZhY2VBcmVhICogVFJBVkVSU0FMX0NPU1Q7XG5cblx0XHRcdH1cblxuXHRcdH0sIGdyb3VwICk7XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gbGVhZiBub2RlcyBiZWNhdXNlIHRoZSB0cmVlIGhhc24ndCBmaW5pc2hlZCBnZW5lcmF0aW5nIHlldC5cblx0XHRpZiAoIHJlc3VsdC50cmlzLm1pbiA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJlc3VsdC50cmlzLm1pbiA9IDA7XG5cdFx0XHRyZXN1bHQudHJpcy5tYXggPSAwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZXN1bHQuZGVwdGgubWluID09PSBJbmZpbml0eSApIHtcblxuXHRcdFx0cmVzdWx0LmRlcHRoLm1pbiA9IDA7XG5cdFx0XHRyZXN1bHQuZGVwdGgubWF4ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJWSEV4dHJlbWVzKCBidmggKSB7XG5cblx0XHRyZXR1cm4gYnZoLl9yb290cy5tYXAoICggcm9vdCwgaSApID0+IGdldFJvb3RFeHRyZW1lcyggYnZoLCBpICkgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZXN0aW1hdGVNZW1vcnlJbkJ5dGVzKCBvYmogKSB7XG5cblx0XHRjb25zdCB0cmF2ZXJzZWQgPSBuZXcgU2V0KCk7XG5cdFx0Y29uc3Qgc3RhY2sgPSBbIG9iaiBdO1xuXHRcdGxldCBieXRlcyA9IDA7XG5cblx0XHR3aGlsZSAoIHN0YWNrLmxlbmd0aCApIHtcblxuXHRcdFx0Y29uc3QgY3VyciA9IHN0YWNrLnBvcCgpO1xuXHRcdFx0aWYgKCB0cmF2ZXJzZWQuaGFzKCBjdXJyICkgKSB7XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dHJhdmVyc2VkLmFkZCggY3VyciApO1xuXG5cdFx0XHRmb3IgKCBsZXQga2V5IGluIGN1cnIgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGN1cnIuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ5dGVzICs9IGdldFByaW1pdGl2ZVNpemUoIGtleSApO1xuXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gY3Vyclsga2V5IF07XG5cdFx0XHRcdGlmICggdmFsdWUgJiYgKCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc1R5cGVkQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRcdFx0XHRcdGJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkKCkgJiYgdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdFx0Ynl0ZXMgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRcdGJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRzdGFjay5wdXNoKCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRieXRlcyArPSBnZXRQcmltaXRpdmVTaXplKCB2YWx1ZSApO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYnl0ZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQm91bmRzKCBidmggKSB7XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCBkZXB0aFN0YWNrID0gW107XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXHRcdGxldCBwYXNzZXMgPSB0cnVlO1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdFx0ZGVwdGgsXG5cdFx0XHRcdGlzTGVhZixcblx0XHRcdFx0Ym91bmRpbmdEYXRhLFxuXHRcdFx0XHRvZmZzZXQsXG5cdFx0XHRcdGNvdW50LFxuXHRcdFx0fTtcblx0XHRcdGRlcHRoU3RhY2tbIGRlcHRoIF0gPSBpbmZvO1xuXG5cdFx0XHRhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIF9ib3gxICk7XG5cdFx0XHRjb25zdCBwYXJlbnQgPSBkZXB0aFN0YWNrWyBkZXB0aCAtIDEgXTtcblxuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgdHJpYW5nbGVzXG5cdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0ICogMywgbCA9ICggb2Zmc2V0ICsgY291bnQgKSAqIDM7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBpMCA9IGluZGV4LmdldFgoIGkgKTtcblx0XHRcdFx0XHRjb25zdCBpMSA9IGluZGV4LmdldFgoIGkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgaTIgPSBpbmRleC5nZXRYKCBpICsgMiApO1xuXG5cdFx0XHRcdFx0bGV0IGlzQ29udGFpbmVkO1xuXG5cdFx0XHRcdFx0X3ZlYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaTAgKTtcblx0XHRcdFx0XHRpc0NvbnRhaW5lZCA9IF9ib3gxLmNvbnRhaW5zUG9pbnQoIF92ZWMgKTtcblxuXHRcdFx0XHRcdF92ZWMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkxICk7XG5cdFx0XHRcdFx0aXNDb250YWluZWQgPSBpc0NvbnRhaW5lZCAmJiBfYm94MS5jb250YWluc1BvaW50KCBfdmVjICk7XG5cblx0XHRcdFx0XHRfdmVjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpMiApO1xuXHRcdFx0XHRcdGlzQ29udGFpbmVkID0gaXNDb250YWluZWQgJiYgX2JveDEuY29udGFpbnNQb2ludCggX3ZlYyApO1xuXG5cdFx0XHRcdFx0Y29uc29sZS5hc3NlcnQoIGlzQ29udGFpbmVkLCAnTGVhZiBib3VuZHMgZG9lcyBub3QgZnVsbHkgY29udGFpbiB0cmlhbmdsZS4nICk7XG5cdFx0XHRcdFx0cGFzc2VzID0gcGFzc2VzICYmIGlzQ29udGFpbmVkO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiBteSBib3VuZHMgZml0IGluIG15IHBhcmVudHNcblx0XHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBfYm94MiApO1xuXG5cdFx0XHRcdGNvbnN0IGlzQ29udGFpbmVkID0gX2JveDIuY29udGFpbnNCb3goIF9ib3gxICk7XG5cdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KCBpc0NvbnRhaW5lZCwgJ1BhcmVudCBib3VuZHMgZG9lcyBub3QgZnVsbHkgY29udGFpbiBjaGlsZC4nICk7XG5cdFx0XHRcdHBhc3NlcyA9IHBhc3NlcyAmJiBpc0NvbnRhaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHBhc3NlcztcblxuXHR9XG5cblx0Ly8gUmV0dXJucyBhIHNpbXBsZSwgaHVtYW4gcmVhZGFibGUgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgQlZILlxuXHRmdW5jdGlvbiBnZXRKU09OU3RydWN0dXJlKCBidmggKSB7XG5cblx0XHRjb25zdCBkZXB0aFN0YWNrID0gW107XG5cblx0XHRidmgudHJhdmVyc2UoICggZGVwdGgsIGlzTGVhZiwgYm91bmRpbmdEYXRhLCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRjb25zdCBpbmZvID0ge1xuXHRcdFx0XHRib3VuZHM6IGFycmF5VG9Cb3goIDAsIGJvdW5kaW5nRGF0YSwgbmV3IHRocmVlLkJveDMoKSApLFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0aW5mby5jb3VudCA9IGNvdW50O1xuXHRcdFx0XHRpbmZvLm9mZnNldCA9IG9mZnNldDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpbmZvLmxlZnQgPSBudWxsO1xuXHRcdFx0XHRpbmZvLnJpZ2h0ID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHRkZXB0aFN0YWNrWyBkZXB0aCBdID0gaW5mbztcblxuXHRcdFx0Ly8gdHJhdmVyc2FsIGhpdHMgdGhlIGxlZnQgdGhlbiByaWdodCBub2RlXG5cdFx0XHRjb25zdCBwYXJlbnQgPSBkZXB0aFN0YWNrWyBkZXB0aCAtIDEgXTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdGlmICggcGFyZW50LmxlZnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRwYXJlbnQubGVmdCA9IGluZm87XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHBhcmVudC5yaWdodCA9IGluZm87XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gZGVwdGhTdGFja1sgMCBdO1xuXG5cdH1cblxuXHQvLyBjb252ZXJ0cyB0aGUgZ2l2ZW4gQlZIIHJheWNhc3QgaW50ZXJzZWN0aW9uIHRvIGFsaWduIHdpdGggdGhlIHRocmVlLmpzIHJheWNhc3Rcblx0Ly8gc3RydWN0dXJlIChpbmNsdWRlIG9iamVjdCwgd29ybGQgc3BhY2UgZGlzdGFuY2UgYW5kIHBvaW50KS5cblx0ZnVuY3Rpb24gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGhpdCwgb2JqZWN0LCByYXljYXN0ZXIgKSB7XG5cblx0XHRpZiAoIGhpdCA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHRoaXQucG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblx0XHRoaXQuZGlzdGFuY2UgPSBoaXQucG9pbnQuZGlzdGFuY2VUbyggcmF5Y2FzdGVyLnJheS5vcmlnaW4gKTtcblx0XHRoaXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0aWYgKCBoaXQuZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBoaXQuZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBoaXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IHJheSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdGhyZWUuUmF5KCk7XG5cdGNvbnN0IHRtcEludmVyc2VNYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0Y29uc3Qgb3JpZ01lc2hSYXljYXN0RnVuYyA9IHRocmVlLk1lc2gucHJvdG90eXBlLnJheWNhc3Q7XG5cblx0ZnVuY3Rpb24gYWNjZWxlcmF0ZWRSYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHRtcEludmVyc2VNYXRyaXguY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIHRtcEludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0Y29uc3QgYnZoID0gdGhpcy5nZW9tZXRyeS5ib3VuZHNUcmVlO1xuXHRcdFx0aWYgKCByYXljYXN0ZXIuZmlyc3RIaXRPbmx5ID09PSB0cnVlICkge1xuXG5cdFx0XHRcdGNvbnN0IGhpdCA9IGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBidmgucmF5Y2FzdEZpcnN0KCByYXksIHRoaXMubWF0ZXJpYWwgKSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRcdGlmICggaGl0ICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBoaXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgaGl0cyA9IGJ2aC5yYXljYXN0KCByYXksIHRoaXMubWF0ZXJpYWwgKTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGl0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGhpdHNbIGkgXSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRcdFx0aWYgKCBoaXQgKSB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcmlnTWVzaFJheWNhc3RGdW5jLmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQm91bmRzVHJlZSggb3B0aW9ucyApIHtcblxuXHRcdHRoaXMuYm91bmRzVHJlZSA9IG5ldyBNZXNoQlZIKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0cmV0dXJuIHRoaXMuYm91bmRzVHJlZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGlzcG9zZUJvdW5kc1RyZWUoKSB7XG5cblx0XHR0aGlzLmJvdW5kc1RyZWUgPSBudWxsO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjb3VudFRvU3RyaW5nRm9ybWF0KCBjb3VudCApIHtcblxuXHRcdHN3aXRjaCAoIGNvdW50ICkge1xuXG5cdFx0XHRjYXNlIDE6IHJldHVybiAnUic7XG5cdFx0XHRjYXNlIDI6IHJldHVybiAnUkcnO1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gJ1JHQkEnO1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gJ1JHQkEnO1xuXG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9Gb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIHRocmVlLlJlZEZvcm1hdDtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRocmVlLlJHRm9ybWF0O1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhyZWUuUkdCQUZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIHRocmVlLlJHQkFGb3JtYXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9JbnRGb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIHRocmVlLlJlZEludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aHJlZS5SR0ludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aHJlZS5SR0JBSW50ZWdlckZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIHRocmVlLlJHQkFJbnRlZ2VyRm9ybWF0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIGV4dGVuZHMgdGhyZWUuRGF0YVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IHRocmVlLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IHRocmVlLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5vdmVycmlkZUl0ZW1TaXplID0gbnVsbDtcblx0XHRcdHRoaXMuX2ZvcmNlZFR5cGUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlRnJvbSggYXR0ciApIHtcblxuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVJdGVtU2l6ZSA9IHRoaXMub3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG9yaWdpbmFsSXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxDb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRpZiAoIG92ZXJyaWRlSXRlbVNpemUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCAoIG9yaWdpbmFsSXRlbVNpemUgKiBvcmlnaW5hbENvdW50ICkgJSBvdmVycmlkZUl0ZW1TaXplICE9PSAwLjAgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlOiBvdmVycmlkZUl0ZW1TaXplIG11c3QgZGl2aWRlIGV2ZW5seSBpbnRvIGJ1ZmZlciBsZW5ndGguJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhdHRyLml0ZW1TaXplID0gb3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdFx0YXR0ci5jb3VudCA9IG9yaWdpbmFsQ291bnQgKiBvcmlnaW5hbEl0ZW1TaXplIC8gb3ZlcnJpZGVJdGVtU2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG5cdFx0XHRjb25zdCBjb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxCdWZmZXJDb25zID0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGJ5dGVDb3VudCA9IG9yaWdpbmFsQnVmZmVyQ29ucy5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGxldCB0YXJnZXRUeXBlID0gdGhpcy5fZm9yY2VkVHlwZTtcblx0XHRcdGxldCBmaW5hbFN0cmlkZSA9IGl0ZW1TaXplO1xuXG5cdFx0XHQvLyBkZXJpdmUgdGhlIHR5cGUgb2YgdGV4dHVyZSB0aGlzIHNob3VsZCBiZSBpbiB0aGUgc2hhZGVyXG5cdFx0XHRpZiAoIHRhcmdldFR5cGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggb3JpZ2luYWxCdWZmZXJDb25zICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID0gdGhyZWUuRmxvYXRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdFx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9IHRocmVlLlVuc2lnbmVkSW50VHlwZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0XHRcdGNhc2UgSW50MzJBcnJheTpcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPSB0aHJlZS5JbnRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aGUgdGFyZ2V0IGZvcm1hdCB0byBzdG9yZSB0aGUgdGV4dHVyZSBhc1xuXHRcdFx0bGV0IHR5cGUsIGZvcm1hdCwgbm9ybWFsaXplVmFsdWUsIHRhcmdldEJ1ZmZlckNvbnM7XG5cdFx0XHRsZXQgaW50ZXJuYWxGb3JtYXQgPSBjb3VudFRvU3RyaW5nRm9ybWF0KCBpdGVtU2l6ZSApO1xuXHRcdFx0c3dpdGNoICggdGFyZ2V0VHlwZSApIHtcblxuXHRcdFx0XHRjYXNlIHRocmVlLkZsb2F0VHlwZTpcblx0XHRcdFx0XHRub3JtYWxpemVWYWx1ZSA9IDEuMDtcblx0XHRcdFx0XHRmb3JtYXQgPSBjb3VudFRvRm9ybWF0KCBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxpemVkICYmIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IG9yaWdpbmFsQnVmZmVyQ29ucztcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICc4JztcblxuXHRcdFx0XHRcdFx0aWYgKCBvcmlnaW5hbEJ1ZmZlckNvbnMgPT09IFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLlVuc2lnbmVkQnl0ZVR5cGU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLkJ5dGVUeXBlO1xuXHRcdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSAnX1NOT1JNJztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEZsb2F0MzJBcnJheTtcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICczMkYnO1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLkZsb2F0VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgdGhyZWUuSW50VHlwZTpcblx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSBieXRlQ291bnQgKiA4ICsgJ0knO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDhBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSB0aHJlZS5CeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDE2QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDMyQXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgdGhyZWUuVW5zaWduZWRJbnRUeXBlOlxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9IGJ5dGVDb3VudCAqIDggKyAnVUknO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQ4QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gdGhyZWUuVW5zaWduZWRCeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQxNkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLlVuc2lnbmVkU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQzMkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IHRocmVlLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZXJlIHdpbGwgYmUgYSBtaXNtYXRjaCBiZXR3ZWVuIGZvcm1hdCBsZW5ndGggYW5kIGZpbmFsIGxlbmd0aCBiZWNhdXNlXG5cdFx0XHQvLyBSR0JGb3JtYXQgYW5kIFJHQkludGVnZXJGb3JtYXQgd2FzIHJlbW92ZWRcblx0XHRcdGlmICggZmluYWxTdHJpZGUgPT09IDMgJiYgKCBmb3JtYXQgPT09IHRocmVlLlJHQkFGb3JtYXQgfHwgZm9ybWF0ID09PSB0aHJlZS5SR0JBSW50ZWdlckZvcm1hdCApICkge1xuXG5cdFx0XHRcdGZpbmFsU3RyaWRlID0gNDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBkYXRhIG92ZXIgdG8gdGhlIG5ldyB0ZXh0dXJlIGFycmF5XG5cdFx0XHRjb25zdCBkaW1lbnNpb24gPSBNYXRoLmNlaWwoIE1hdGguc3FydCggY291bnQgKSApO1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gZmluYWxTdHJpZGUgKiBkaW1lbnNpb24gKiBkaW1lbnNpb247XG5cdFx0XHRjb25zdCBkYXRhQXJyYXkgPSBuZXcgdGFyZ2V0QnVmZmVyQ29ucyggbGVuZ3RoICk7XG5cblx0XHRcdC8vIHRlbXBvcmFyaWx5IHNldCB0aGUgbm9ybWFsaXplZCBzdGF0ZSB0byBmYWxzZSBzaW5jZSB3ZSBoYXZlIGN1c3RvbSBub3JtYWxpemF0aW9uIGxvZ2ljXG5cdFx0XHRjb25zdCBvcmlnaW5hbE5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG5cdFx0XHRhdHRyLm5vcm1hbGl6ZWQgPSBmYWxzZTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGlpID0gZmluYWxTdHJpZGUgKiBpO1xuXHRcdFx0XHRkYXRhQXJyYXlbIGlpIF0gPSBhdHRyLmdldFgoIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMiApIHtcblxuXHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAxIF0gPSBhdHRyLmdldFkoIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDMgKSB7XG5cblx0XHRcdFx0XHRkYXRhQXJyYXlbIGlpICsgMiBdID0gYXR0ci5nZXRaKCBpICkgLyBub3JtYWxpemVWYWx1ZTtcblxuXHRcdFx0XHRcdGlmICggZmluYWxTdHJpZGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAzIF0gPSAxLjA7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gNCApIHtcblxuXHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAzIF0gPSBhdHRyLmdldFcoIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRhdHRyLm5vcm1hbGl6ZWQgPSBvcmlnaW5hbE5vcm1hbGl6ZWQ7XG5cblx0XHRcdHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBpbnRlcm5hbEZvcm1hdDtcblx0XHRcdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHRcdHRoaXMuaW1hZ2Uud2lkdGggPSBkaW1lbnNpb247XG5cdFx0XHR0aGlzLmltYWdlLmhlaWdodCA9IGRpbWVuc2lvbjtcblx0XHRcdHRoaXMuaW1hZ2UuZGF0YSA9IGRhdGFBcnJheTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cblx0XHRcdGF0dHIuaXRlbVNpemUgPSBvcmlnaW5hbEl0ZW1TaXplO1xuXHRcdFx0YXR0ci5jb3VudCA9IG9yaWdpbmFsQ291bnQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIGV4dGVuZHMgVmVydGV4QXR0cmlidXRlVGV4dHVyZSB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuX2ZvcmNlZFR5cGUgPSB0aHJlZS5VbnNpZ25lZEludFR5cGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIEludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IHRocmVlLkludFR5cGU7XG5cblx0XHR9XG5cblxuXHR9XG5cblx0Y2xhc3MgRmxvYXRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIGV4dGVuZHMgVmVydGV4QXR0cmlidXRlVGV4dHVyZSB7XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdFx0c3VwZXIoKTtcblx0XHRcdHRoaXMuX2ZvcmNlZFR5cGUgPSB0aHJlZS5GbG9hdFR5cGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhVbmlmb3JtU3RydWN0IHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3IFVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLnBvc2l0aW9uID0gbmV3IEZsb2F0VmVydGV4QXR0cmlidXRlVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5idmhCb3VuZHMgPSBuZXcgdGhyZWUuRGF0YVRleHR1cmUoKTtcblx0XHRcdHRoaXMuYnZoQ29udGVudHMgPSBuZXcgdGhyZWUuRGF0YVRleHR1cmUoKTtcblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9IG51bGw7XG5cblx0XHRcdHRoaXMuaW5kZXgub3ZlcnJpZGVJdGVtU2l6ZSA9IDM7XG5cblx0XHR9XG5cblx0XHR1cGRhdGVGcm9tKCBidmggKSB7XG5cblx0XHRcdGNvbnN0IHsgZ2VvbWV0cnkgfSA9IGJ2aDtcblx0XHRcdGJ2aFRvVGV4dHVyZXMoIGJ2aCwgdGhpcy5idmhCb3VuZHMsIHRoaXMuYnZoQ29udGVudHMgKTtcblxuXHRcdFx0dGhpcy5wb3NpdGlvbi51cGRhdGVGcm9tKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cblx0XHRcdC8vIGRlcmVmZXJlbmNlIGEgbmV3IGluZGV4IGF0dHJpYnV0ZSBpZiB3ZSdyZSB1c2luZyBpbmRpcmVjdCBzdG9yYWdlXG5cdFx0XHRpZiAoIGJ2aC5pbmRpcmVjdCApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRpcmVjdEJ1ZmZlciA9IGJ2aC5faW5kaXJlY3RCdWZmZXI7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleEF0dHIgPT09IG51bGwgfHxcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleEF0dHIuY291bnQgIT09IGluZGlyZWN0QnVmZmVyLmxlbmd0aFxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9IGdlb21ldHJ5LmluZGV4LmNsb25lKCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhcnJheSA9IGdldEluZGV4QXJyYXkoIGdldFZlcnRleENvdW50KCBnZW9tZXRyeSApICk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleEF0dHIgPSBuZXcgdGhyZWUuQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgMSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVyZWZlcmVuY2VJbmRleCggZ2VvbWV0cnksIGluZGlyZWN0QnVmZmVyLCB0aGlzLl9jYWNoZWRJbmRleEF0dHIgKTtcblx0XHRcdFx0dGhpcy5pbmRleC51cGRhdGVGcm9tKCB0aGlzLl9jYWNoZWRJbmRleEF0dHIgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmluZGV4LnVwZGF0ZUZyb20oIGdlb21ldHJ5LmluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpc3Bvc2UoKSB7XG5cblx0XHRcdGNvbnN0IHsgaW5kZXgsIHBvc2l0aW9uLCBidmhCb3VuZHMsIGJ2aENvbnRlbnRzIH0gPSB0aGlzO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkgaW5kZXguZGlzcG9zZSgpO1xuXHRcdFx0aWYgKCBwb3NpdGlvbiApIHBvc2l0aW9uLmRpc3Bvc2UoKTtcblx0XHRcdGlmICggYnZoQm91bmRzICkgYnZoQm91bmRzLmRpc3Bvc2UoKTtcblx0XHRcdGlmICggYnZoQ29udGVudHMgKSBidmhDb250ZW50cy5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlcmVmZXJlbmNlSW5kZXgoIGdlb21ldHJ5LCBpbmRpcmVjdEJ1ZmZlciwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgdW5wYWNrZWQgPSB0YXJnZXQuYXJyYXk7XG5cdFx0Y29uc3QgaW5kZXhBcnJheSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGlyZWN0QnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGkzID0gMyAqIGk7XG5cdFx0XHRjb25zdCB2MyA9IDMgKiBpbmRpcmVjdEJ1ZmZlclsgaSBdO1xuXHRcdFx0Zm9yICggbGV0IGMgPSAwOyBjIDwgMzsgYyArKyApIHtcblxuXHRcdFx0XHR1bnBhY2tlZFsgaTMgKyBjIF0gPSBpbmRleEFycmF5ID8gaW5kZXhBcnJheVsgdjMgKyBjIF0gOiB2MyArIGM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYnZoVG9UZXh0dXJlcyggYnZoLCBib3VuZHNUZXh0dXJlLCBjb250ZW50c1RleHR1cmUgKSB7XG5cblx0XHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cblx0XHRpZiAoIHJvb3RzLmxlbmd0aCAhPT0gMSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSFVuaWZvcm1TdHJ1Y3Q6IE11bHRpLXJvb3QgQlZIcyBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJvb3QgPSByb290c1sgMCBdO1xuXHRcdGNvbnN0IHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCByb290ICk7XG5cdFx0Y29uc3QgdWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIHJvb3QgKTtcblx0XHRjb25zdCBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCByb290ICk7XG5cblx0XHQvLyBCb3RoIGJvdW5kcyBuZWVkIHR3byBlbGVtZW50cyBwZXIgbm9kZSBzbyBjb21wdXRlIHRoZSBoZWlnaHQgc28gaXQncyB0d2ljZSBhcyBsb25nIGFzXG5cdFx0Ly8gdGhlIHdpZHRoIHNvIHdlIGNhbiBleHBhbmQgdGhlIHJvdyBieSB0d28gYW5kIHN0aWxsIGhhdmUgYSBzcXVhcmUgdGV4dHVyZVxuXHRcdGNvbnN0IG5vZGVDb3VudCA9IHJvb3QuYnl0ZUxlbmd0aCAvIEJZVEVTX1BFUl9OT0RFO1xuXHRcdGNvbnN0IGJvdW5kc0RpbWVuc2lvbiA9IDIgKiBNYXRoLmNlaWwoIE1hdGguc3FydCggbm9kZUNvdW50IC8gMiApICk7XG5cdFx0Y29uc3QgYm91bmRzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCA0ICogYm91bmRzRGltZW5zaW9uICogYm91bmRzRGltZW5zaW9uICk7XG5cblx0XHRjb25zdCBjb250ZW50c0RpbWVuc2lvbiA9IE1hdGguY2VpbCggTWF0aC5zcXJ0KCBub2RlQ291bnQgKSApO1xuXHRcdGNvbnN0IGNvbnRlbnRzQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBjb250ZW50c0RpbWVuc2lvbiAqIGNvbnRlbnRzRGltZW5zaW9uICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGVJbmRleDMyID0gaSAqIEJZVEVTX1BFUl9OT0RFIC8gNDtcblx0XHRcdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRcdFx0Y29uc3QgYm91bmRzSW5kZXggPSBCT1VORElOR19EQVRBX0lOREVYKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0Zm9yICggbGV0IGIgPSAwOyBiIDwgMzsgYiArKyApIHtcblxuXHRcdFx0XHRib3VuZHNBcnJheVsgOCAqIGkgKyAwICsgYiBdID0gZmxvYXQzMkFycmF5WyBib3VuZHNJbmRleCArIDAgKyBiIF07XG5cdFx0XHRcdGJvdW5kc0FycmF5WyA4ICogaSArIDQgKyBiIF0gPSBmbG9hdDMyQXJyYXlbIGJvdW5kc0luZGV4ICsgMyArIGIgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHRcdGNvbnN0IG1lcmdlZExlYWZDb3VudCA9IDB4ZmZmZjAwMDAgfCBjb3VudDtcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAwIF0gPSBtZXJnZWRMZWFmQ291bnQ7XG5cdFx0XHRcdGNvbnRlbnRzQXJyYXlbIGkgKiAyICsgMSBdID0gb2Zmc2V0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IHJpZ2h0SW5kZXggPSA0ICogUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICkgLyBCWVRFU19QRVJfTk9ERTtcblx0XHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAwIF0gPSBzcGxpdEF4aXM7XG5cdFx0XHRcdGNvbnRlbnRzQXJyYXlbIGkgKiAyICsgMSBdID0gcmlnaHRJbmRleDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ym91bmRzVGV4dHVyZS5pbWFnZS5kYXRhID0gYm91bmRzQXJyYXk7XG5cdFx0Ym91bmRzVGV4dHVyZS5pbWFnZS53aWR0aCA9IGJvdW5kc0RpbWVuc2lvbjtcblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLmhlaWdodCA9IGJvdW5kc0RpbWVuc2lvbjtcblx0XHRib3VuZHNUZXh0dXJlLmZvcm1hdCA9IHRocmVlLlJHQkFGb3JtYXQ7XG5cdFx0Ym91bmRzVGV4dHVyZS50eXBlID0gdGhyZWUuRmxvYXRUeXBlO1xuXHRcdGJvdW5kc1RleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSAnUkdCQTMyRic7XG5cdFx0Ym91bmRzVGV4dHVyZS5taW5GaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGJvdW5kc1RleHR1cmUubWFnRmlsdGVyID0gdGhyZWUuTmVhcmVzdEZpbHRlcjtcblx0XHRib3VuZHNUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdGJvdW5kc1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGJvdW5kc1RleHR1cmUuZGlzcG9zZSgpO1xuXG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLmRhdGEgPSBjb250ZW50c0FycmF5O1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbWFnZS53aWR0aCA9IGNvbnRlbnRzRGltZW5zaW9uO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBjb250ZW50c0RpbWVuc2lvbjtcblx0XHRjb250ZW50c1RleHR1cmUuZm9ybWF0ID0gdGhyZWUuUkdJbnRlZ2VyRm9ybWF0O1xuXHRcdGNvbnRlbnRzVGV4dHVyZS50eXBlID0gdGhyZWUuVW5zaWduZWRJbnRUeXBlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9ICdSRzMyVUknO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5taW5GaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5tYWdGaWx0ZXIgPSB0aHJlZS5OZWFyZXN0RmlsdGVyO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblx0XHRjb250ZW50c1RleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0fVxuXG5cdC8vIE5vdGUgdGhhdCBhIHN0cnVjdCBjYW5ub3QgYmUgdXNlZCBmb3IgdGhlIGhpdCByZWNvcmQgaW5jbHVkaW5nIGZhY2VJbmRpY2VzLCBmYWNlTm9ybWFsLCBiYXJ5Y29vcmQsXG5cdC8vIHNpZGUsIGFuZCBkaXN0IGJlY2F1c2Ugb24gc29tZSBtb2JpbGUgR1BVUyAoc3VjaCBhcyBBZHJlbm8pIG51bWJlcnMgYXJlIGFmZm9yZGVkIGxlc3MgcHJlY2lzaW9uIHNwZWNpZmljYWxseVxuXHQvLyB3aGVuIGluIGEgc3RydWN0IGxlYWRpbmcgdG8gaW5hY2N1cmF0ZSBoaXQgcmVzdWx0cy4gU2VlIEtocm9ub3NHcm91cC9XZWJHTCMzMzUxIGZvciBtb3JlIGRldGFpbHMuXG5cdGNvbnN0IHNoYWRlclN0cnVjdHMgPSAvKiBnbHNsICovYFxuI2lmbmRlZiBUUklfSU5URVJTRUNUX0VQU0lMT05cbiNkZWZpbmUgVFJJX0lOVEVSU0VDVF9FUFNJTE9OIDFlLTVcbiNlbmRpZlxuXG4jaWZuZGVmIElORklOSVRZXG4jZGVmaW5lIElORklOSVRZIDFlMjBcbiNlbmRpZlxuXG5zdHJ1Y3QgQlZIIHtcblxuXHR1c2FtcGxlcjJEIGluZGV4O1xuXHRzYW1wbGVyMkQgcG9zaXRpb247XG5cblx0c2FtcGxlcjJEIGJ2aEJvdW5kcztcblx0dXNhbXBsZXIyRCBidmhDb250ZW50cztcblxufTtcbmA7XG5cblx0Y29uc3Qgc2hhZGVySW50ZXJzZWN0RnVuY3Rpb24gPSAvKiBnbHNsICovYFxuXG4vLyBVdGlsaXRpZXNcbnV2ZWM0IHVUZXhlbEZldGNoMUQoIHVzYW1wbGVyMkQgdGV4LCB1aW50IGluZGV4ICkge1xuXG5cdHVpbnQgd2lkdGggPSB1aW50KCB0ZXh0dXJlU2l6ZSggdGV4LCAwICkueCApO1xuXHR1dmVjMiB1djtcblx0dXYueCA9IGluZGV4ICUgd2lkdGg7XG5cdHV2LnkgPSBpbmRleCAvIHdpZHRoO1xuXG5cdHJldHVybiB0ZXhlbEZldGNoKCB0ZXgsIGl2ZWMyKCB1diApLCAwICk7XG5cbn1cblxuaXZlYzQgaVRleGVsRmV0Y2gxRCggaXNhbXBsZXIyRCB0ZXgsIHVpbnQgaW5kZXggKSB7XG5cblx0dWludCB3aWR0aCA9IHVpbnQoIHRleHR1cmVTaXplKCB0ZXgsIDAgKS54ICk7XG5cdHV2ZWMyIHV2O1xuXHR1di54ID0gaW5kZXggJSB3aWR0aDtcblx0dXYueSA9IGluZGV4IC8gd2lkdGg7XG5cblx0cmV0dXJuIHRleGVsRmV0Y2goIHRleCwgaXZlYzIoIHV2ICksIDAgKTtcblxufVxuXG52ZWM0IHRleGVsRmV0Y2gxRCggc2FtcGxlcjJEIHRleCwgdWludCBpbmRleCApIHtcblxuXHR1aW50IHdpZHRoID0gdWludCggdGV4dHVyZVNpemUoIHRleCwgMCApLnggKTtcblx0dXZlYzIgdXY7XG5cdHV2LnggPSBpbmRleCAlIHdpZHRoO1xuXHR1di55ID0gaW5kZXggLyB3aWR0aDtcblxuXHRyZXR1cm4gdGV4ZWxGZXRjaCggdGV4LCBpdmVjMiggdXYgKSwgMCApO1xuXG59XG5cbnZlYzQgdGV4dHVyZVNhbXBsZUJhcnljb29yZCggc2FtcGxlcjJEIHRleCwgdmVjMyBiYXJ5Y29vcmQsIHV2ZWMzIGZhY2VJbmRpY2VzICkge1xuXG5cdHJldHVyblxuXHRcdGJhcnljb29yZC54ICogdGV4ZWxGZXRjaDFEKCB0ZXgsIGZhY2VJbmRpY2VzLnggKSArXG5cdFx0YmFyeWNvb3JkLnkgKiB0ZXhlbEZldGNoMUQoIHRleCwgZmFjZUluZGljZXMueSApICtcblx0XHRiYXJ5Y29vcmQueiAqIHRleGVsRmV0Y2gxRCggdGV4LCBmYWNlSW5kaWNlcy56ICk7XG5cbn1cblxudm9pZCBuZGNUb0NhbWVyYVJheShcblx0dmVjMiBjb29yZCwgbWF0NCBjYW1lcmFXb3JsZCwgbWF0NCBpbnZQcm9qZWN0aW9uTWF0cml4LFxuXHRvdXQgdmVjMyByYXlPcmlnaW4sIG91dCB2ZWMzIHJheURpcmVjdGlvblxuKSB7XG5cblx0Ly8gZ2V0IGNhbWVyYSBsb29rIGRpcmVjdGlvbiBhbmQgbmVhciBwbGFuZSBmb3IgY2FtZXJhIGNsaXBwaW5nXG5cdHZlYzQgbG9va0RpcmVjdGlvbiA9IGNhbWVyYVdvcmxkICogdmVjNCggMC4wLCAwLjAsIC0gMS4wLCAwLjAgKTtcblx0dmVjNCBuZWFyVmVjdG9yID0gaW52UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAtIDEuMCwgMS4wICk7XG5cdGZsb2F0IG5lYXIgPSBhYnMoIG5lYXJWZWN0b3IueiAvIG5lYXJWZWN0b3IudyApO1xuXG5cdC8vIGdldCB0aGUgY2FtZXJhIGRpcmVjdGlvbiBhbmQgcG9zaXRpb24gZnJvbSBjYW1lcmEgbWF0cmljZXNcblx0dmVjNCBvcmlnaW4gPSBjYW1lcmFXb3JsZCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHR2ZWM0IGRpcmVjdGlvbiA9IGludlByb2plY3Rpb25NYXRyaXggKiB2ZWM0KCBjb29yZCwgMC41LCAxLjAgKTtcblx0ZGlyZWN0aW9uIC89IGRpcmVjdGlvbi53O1xuXHRkaXJlY3Rpb24gPSBjYW1lcmFXb3JsZCAqIGRpcmVjdGlvbiAtIG9yaWdpbjtcblxuXHQvLyBzbGlkZSB0aGUgb3JpZ2luIGFsb25nIHRoZSByYXkgdW50aWwgaXQgc2l0cyBhdCB0aGUgbmVhciBjbGlwIHBsYW5lIHBvc2l0aW9uXG5cdG9yaWdpbi54eXogKz0gZGlyZWN0aW9uLnh5eiAqIG5lYXIgLyBkb3QoIGRpcmVjdGlvbiwgbG9va0RpcmVjdGlvbiApO1xuXG5cdHJheU9yaWdpbiA9IG9yaWdpbi54eXo7XG5cdHJheURpcmVjdGlvbiA9IGRpcmVjdGlvbi54eXo7XG5cbn1cblxuLy8gUmF5Y2FzdGluZ1xuZmxvYXQgaW50ZXJzZWN0c0JvdW5kcyggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXggKSB7XG5cblx0Ly8gaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL29wZW5nbC9jb21tZW50cy84bnR6ejUvZmFzdF9nbHNsX3JheV9ib3hfaW50ZXJzZWN0aW9uL1xuXHQvLyBodHRwczovL3RhdmlhbmF0b3IuY29tLzIwMTEvcmF5X2JveC5odG1sXG5cdHZlYzMgaW52RGlyID0gMS4wIC8gcmF5RGlyZWN0aW9uO1xuXG5cdC8vIGZpbmQgaW50ZXJzZWN0aW9uIGRpc3RhbmNlcyBmb3IgZWFjaCBwbGFuZVxuXHR2ZWMzIHRNaW5QbGFuZSA9IGludkRpciAqICggYm91bmRzTWluIC0gcmF5T3JpZ2luICk7XG5cdHZlYzMgdE1heFBsYW5lID0gaW52RGlyICogKCBib3VuZHNNYXggLSByYXlPcmlnaW4gKTtcblxuXHQvLyBnZXQgdGhlIG1pbiBhbmQgbWF4IGRpc3RhbmNlcyBmcm9tIGVhY2ggaW50ZXJzZWN0aW9uXG5cdHZlYzMgdE1pbkhpdCA9IG1pbiggdE1heFBsYW5lLCB0TWluUGxhbmUgKTtcblx0dmVjMyB0TWF4SGl0ID0gbWF4KCB0TWF4UGxhbmUsIHRNaW5QbGFuZSApO1xuXG5cdC8vIGdldCB0aGUgZnVydGhlc3QgaGl0IGRpc3RhbmNlXG5cdHZlYzIgdCA9IG1heCggdE1pbkhpdC54eCwgdE1pbkhpdC55eiApO1xuXHRmbG9hdCB0MCA9IG1heCggdC54LCB0LnkgKTtcblxuXHQvLyBnZXQgdGhlIG1pbmltdW0gaGl0IGRpc3RhbmNlXG5cdHQgPSBtaW4oIHRNYXhIaXQueHgsIHRNYXhIaXQueXogKTtcblx0ZmxvYXQgdDEgPSBtaW4oIHQueCwgdC55ICk7XG5cblx0Ly8gc2V0IGRpc3RhbmNlIHRvIDAuMCBpZiB0aGUgcmF5IHN0YXJ0cyBpbnNpZGUgdGhlIGJveFxuXHRmbG9hdCBkaXN0ID0gbWF4KCB0MCwgMC4wICk7XG5cblx0cmV0dXJuIHQxID49IGRpc3QgPyBkaXN0IDogSU5GSU5JVFk7XG5cbn1cblxuYm9vbCBpbnRlcnNlY3RzVHJpYW5nbGUoXG5cdHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgdmVjMyBhLCB2ZWMzIGIsIHZlYzMgYyxcblx0b3V0IHZlYzMgYmFyeWNvb3JkLCBvdXQgdmVjMyBub3JtLCBvdXQgZmxvYXQgZGlzdCwgb3V0IGZsb2F0IHNpZGVcbikge1xuXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyNzQwNzY1L2ludGVyc2VjdGlvbi1iZXR3ZWVuLWxpbmUtYW5kLXRyaWFuZ2xlLWluLTNkXG5cdHZlYzMgZWRnZTEgPSBiIC0gYTtcblx0dmVjMyBlZGdlMiA9IGMgLSBhO1xuXHRub3JtID0gY3Jvc3MoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdGZsb2F0IGRldCA9IC0gZG90KCByYXlEaXJlY3Rpb24sIG5vcm0gKTtcblx0ZmxvYXQgaW52ZGV0ID0gMS4wIC8gZGV0O1xuXG5cdHZlYzMgQU8gPSByYXlPcmlnaW4gLSBhO1xuXHR2ZWMzIERBTyA9IGNyb3NzKCBBTywgcmF5RGlyZWN0aW9uICk7XG5cblx0dmVjNCB1dnQ7XG5cdHV2dC54ID0gZG90KCBlZGdlMiwgREFPICkgKiBpbnZkZXQ7XG5cdHV2dC55ID0gLSBkb3QoIGVkZ2UxLCBEQU8gKSAqIGludmRldDtcblx0dXZ0LnogPSBkb3QoIEFPLCBub3JtICkgKiBpbnZkZXQ7XG5cdHV2dC53ID0gMS4wIC0gdXZ0LnggLSB1dnQueTtcblxuXHQvLyBzZXQgdGhlIGhpdCBpbmZvcm1hdGlvblxuXHRiYXJ5Y29vcmQgPSB1dnQud3h5OyAvLyBhcnJhbmdlZCBpbiBBLCBCLCBDIG9yZGVyXG5cdGRpc3QgPSB1dnQuejtcblx0c2lkZSA9IHNpZ24oIGRldCApO1xuXHRub3JtID0gc2lkZSAqIG5vcm1hbGl6ZSggbm9ybSApO1xuXG5cdC8vIGFkZCBhbiBlcHNpbG9uIHRvIGF2b2lkIG1pc3NlcyBiZXR3ZWVuIHRyaWFuZ2xlc1xuXHR1dnQgKz0gdmVjNCggVFJJX0lOVEVSU0VDVF9FUFNJTE9OICk7XG5cblx0cmV0dXJuIGFsbCggZ3JlYXRlclRoYW5FcXVhbCggdXZ0LCB2ZWM0KCAwLjAgKSApICk7XG5cbn1cblxuYm9vbCBpbnRlcnNlY3RUcmlhbmdsZXMoXG5cdEJWSCBidmgsIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsXG5cdGlub3V0IGZsb2F0IG1pbkRpc3RhbmNlLCBpbm91dCB1dmVjNCBmYWNlSW5kaWNlcywgaW5vdXQgdmVjMyBmYWNlTm9ybWFsLCBpbm91dCB2ZWMzIGJhcnljb29yZCxcblx0aW5vdXQgZmxvYXQgc2lkZSwgaW5vdXQgZmxvYXQgZGlzdFxuKSB7XG5cblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR2ZWMzIGxvY2FsQmFyeWNvb3JkLCBsb2NhbE5vcm1hbDtcblx0ZmxvYXQgbG9jYWxEaXN0LCBsb2NhbFNpZGU7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBidmguaW5kZXgsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBidmgucG9zaXRpb24sIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIGJ2aC5wb3NpdGlvbiwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggYnZoLnBvc2l0aW9uLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHRpZiAoXG5cdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGUoIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBhLCBiLCBjLCBsb2NhbEJhcnljb29yZCwgbG9jYWxOb3JtYWwsIGxvY2FsRGlzdCwgbG9jYWxTaWRlIClcblx0XHRcdCYmIGxvY2FsRGlzdCA8IG1pbkRpc3RhbmNlXG5cdFx0KSB7XG5cblx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdG1pbkRpc3RhbmNlID0gbG9jYWxEaXN0O1xuXG5cdFx0XHRmYWNlSW5kaWNlcyA9IHV2ZWM0KCBpbmRpY2VzLnh5eiwgaSApO1xuXHRcdFx0ZmFjZU5vcm1hbCA9IGxvY2FsTm9ybWFsO1xuXG5cdFx0XHRzaWRlID0gbG9jYWxTaWRlO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRkaXN0ID0gbG9jYWxEaXN0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZm91bmQ7XG5cbn1cblxuZmxvYXQgaW50ZXJzZWN0c0JWSE5vZGVCb3VuZHMoIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgQlZIIGJ2aCwgdWludCBjdXJyTm9kZUluZGV4ICkge1xuXG5cdHZlYzMgYm91bmRzTWluID0gdGV4ZWxGZXRjaDFEKCBidmguYnZoQm91bmRzLCBjdXJyTm9kZUluZGV4ICogMnUgKyAwdSApLnh5ejtcblx0dmVjMyBib3VuZHNNYXggPSB0ZXhlbEZldGNoMUQoIGJ2aC5idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXggKiAydSArIDF1ICkueHl6O1xuXHRyZXR1cm4gaW50ZXJzZWN0c0JvdW5kcyggcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGJvdW5kc01pbiwgYm91bmRzTWF4ICk7XG5cbn1cblxuYm9vbCBidmhJbnRlcnNlY3RGaXJzdEhpdChcblx0QlZIIGJ2aCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLFxuXG5cdC8vIG91dHB1dCB2YXJpYWJsZXNcblx0aW5vdXQgdXZlYzQgZmFjZUluZGljZXMsIGlub3V0IHZlYzMgZmFjZU5vcm1hbCwgaW5vdXQgdmVjMyBiYXJ5Y29vcmQsXG5cdGlub3V0IGZsb2F0IHNpZGUsIGlub3V0IGZsb2F0IGRpc3Rcbikge1xuXG5cdC8vIHN0YWNrIG5lZWRzIHRvIGJlIHR3aWNlIGFzIGxvbmcgYXMgdGhlIGRlZXBlc3QgdHJlZSB3ZSBleHBlY3QgYmVjYXVzZVxuXHQvLyB3ZSBwdXNoIGJvdGggdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkIG9udG8gdGhlIHN0YWNrIGV2ZXJ5IHRyYXZlcnNhbFxuXHRpbnQgcHRyID0gMDtcblx0dWludCBzdGFja1sgNjAgXTtcblx0c3RhY2tbIDAgXSA9IDB1O1xuXG5cdGZsb2F0IHRyaWFuZ2xlRGlzdGFuY2UgPSAxZTIwO1xuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHdoaWxlICggcHRyID4gLSAxICYmIHB0ciA8IDYwICkge1xuXG5cdFx0dWludCBjdXJyTm9kZUluZGV4ID0gc3RhY2tbIHB0ciBdO1xuXHRcdHB0ciAtLTtcblxuXHRcdC8vIGNoZWNrIGlmIHdlIGludGVyc2VjdCB0aGUgY3VycmVudCBib3VuZHNcblx0XHRmbG9hdCBib3VuZHNIaXREaXN0YW5jZSA9IGludGVyc2VjdHNCVkhOb2RlQm91bmRzKCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgYnZoLCBjdXJyTm9kZUluZGV4ICk7XG5cdFx0aWYgKCBib3VuZHNIaXREaXN0YW5jZSA9PSBJTkZJTklUWSB8fCBib3VuZHNIaXREaXN0YW5jZSA+IHRyaWFuZ2xlRGlzdGFuY2UgKSB7XG5cblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0fVxuXG5cdFx0dXZlYzIgYm91bmRzSW5mbyA9IHVUZXhlbEZldGNoMUQoIGJ2aC5idmhDb250ZW50cywgY3Vyck5vZGVJbmRleCApLnh5O1xuXHRcdGJvb2wgaXNMZWFmID0gYm9vbCggYm91bmRzSW5mby54ICYgMHhmZmZmMDAwMHUgKTtcblxuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblxuXHRcdFx0Zm91bmQgPSBpbnRlcnNlY3RUcmlhbmdsZXMoXG5cdFx0XHRcdGJ2aCwgcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG9mZnNldCwgY291bnQsIHRyaWFuZ2xlRGlzdGFuY2UsXG5cdFx0XHRcdGZhY2VJbmRpY2VzLCBmYWNlTm9ybWFsLCBiYXJ5Y29vcmQsIHNpZGUsIGRpc3Rcblx0XHRcdCkgfHwgZm91bmQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSByYXlEaXJlY3Rpb25bIHNwbGl0QXhpcyBdID49IDAuMDtcblx0XHRcdHVpbnQgYzEgPSBsZWZ0VG9SaWdodCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG5cdFx0XHR1aW50IGMyID0gbGVmdFRvUmlnaHQgPyByaWdodEluZGV4IDogbGVmdEluZGV4O1xuXG5cdFx0XHQvLyBzZXQgYzIgaW4gdGhlIHN0YWNrIHNvIHdlIHRyYXZlcnNlIGl0IGxhdGVyLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgYSBwb2ludGVyIGluXG5cdFx0XHQvLyB0aGUgc3RhY2sgd2hpbGUgd2UgdHJhdmVyc2UuIFRoZSBzZWNvbmQgcG9pbnRlciBhZGRlZCBpcyB0aGUgb25lIHRoYXQgd2lsbCBiZVxuXHRcdFx0Ly8gdHJhdmVyc2VkIGZpcnN0XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMjtcblxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmb3VuZDtcblxufVxuYDtcblxuXHQvLyBEaXN0YW5jZSB0byBQb2ludFxuXHRjb25zdCBzaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gLyogZ2xzbCAqL2BcblxuZmxvYXQgZG90MiggdmVjMyB2ICkge1xuXG5cdHJldHVybiBkb3QoIHYsIHYgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvdHRmR1dsXG52ZWMzIGNsb3Nlc3RQb2ludFRvVHJpYW5nbGUoIHZlYzMgcCwgdmVjMyB2MCwgdmVjMyB2MSwgdmVjMyB2Miwgb3V0IHZlYzMgYmFyeWNvb3JkICkge1xuXG4gICAgdmVjMyB2MTAgPSB2MSAtIHYwO1xuICAgIHZlYzMgdjIxID0gdjIgLSB2MTtcbiAgICB2ZWMzIHYwMiA9IHYwIC0gdjI7XG5cblx0dmVjMyBwMCA9IHAgLSB2MDtcblx0dmVjMyBwMSA9IHAgLSB2MTtcblx0dmVjMyBwMiA9IHAgLSB2MjtcblxuICAgIHZlYzMgbm9yID0gY3Jvc3MoIHYxMCwgdjAyICk7XG5cbiAgICAvLyBtZXRob2QgMiwgaW4gYmFyeWNlbnRyaWMgc3BhY2VcbiAgICB2ZWMzICBxID0gY3Jvc3MoIG5vciwgcDAgKTtcbiAgICBmbG9hdCBkID0gMS4wIC8gZG90Miggbm9yICk7XG4gICAgZmxvYXQgdSA9IGQgKiBkb3QoIHEsIHYwMiApO1xuICAgIGZsb2F0IHYgPSBkICogZG90KCBxLCB2MTAgKTtcbiAgICBmbG9hdCB3ID0gMS4wIC0gdSAtIHY7XG5cblx0aWYoIHUgPCAwLjAgKSB7XG5cblx0XHR3ID0gY2xhbXAoIGRvdCggcDIsIHYwMiApIC8gZG90MiggdjAyICksIDAuMCwgMS4wICk7XG5cdFx0dSA9IDAuMDtcblx0XHR2ID0gMS4wIC0gdztcblxuXHR9IGVsc2UgaWYoIHYgPCAwLjAgKSB7XG5cblx0XHR1ID0gY2xhbXAoIGRvdCggcDAsIHYxMCApIC8gZG90MiggdjEwICksIDAuMCwgMS4wICk7XG5cdFx0diA9IDAuMDtcblx0XHR3ID0gMS4wIC0gdTtcblxuXHR9IGVsc2UgaWYoIHcgPCAwLjAgKSB7XG5cblx0XHR2ID0gY2xhbXAoIGRvdCggcDEsIHYyMSApIC8gZG90MiggdjIxICksIDAuMCwgMS4wICk7XG5cdFx0dyA9IDAuMDtcblx0XHR1ID0gMS4wLXY7XG5cblx0fVxuXG5cdGJhcnljb29yZCA9IHZlYzMoIHUsIHYsIHcgKTtcbiAgICByZXR1cm4gdSAqIHYxICsgdiAqIHYyICsgdyAqIHYwO1xuXG59XG5cbmZsb2F0IGRpc3RhbmNlVG9UcmlhbmdsZXMoXG5cdEJWSCBidmgsIHZlYzMgcG9pbnQsIHVpbnQgb2Zmc2V0LCB1aW50IGNvdW50LCBmbG9hdCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkLFxuXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLCBpbm91dCBmbG9hdCBzaWRlLCBpbm91dCB2ZWMzIG91dFBvaW50XG4pIHtcblxuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHV2ZWMzIGxvY2FsSW5kaWNlcztcblx0dmVjMyBsb2NhbEJhcnljb29yZDtcblx0dmVjMyBsb2NhbE5vcm1hbDtcblx0Zm9yICggdWludCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dXZlYzMgaW5kaWNlcyA9IHVUZXhlbEZldGNoMUQoIGJ2aC5pbmRleCwgaSApLnh5ejtcblx0XHR2ZWMzIGEgPSB0ZXhlbEZldGNoMUQoIGJ2aC5wb3NpdGlvbiwgaW5kaWNlcy54ICkucmdiO1xuXHRcdHZlYzMgYiA9IHRleGVsRmV0Y2gxRCggYnZoLnBvc2l0aW9uLCBpbmRpY2VzLnkgKS5yZ2I7XG5cdFx0dmVjMyBjID0gdGV4ZWxGZXRjaDFEKCBidmgucG9zaXRpb24sIGluZGljZXMueiApLnJnYjtcblxuXHRcdC8vIGdldCB0aGUgY2xvc2VzdCBwb2ludCBhbmQgYmFyeWNvb3JkXG5cdFx0dmVjMyBjbG9zZXN0UG9pbnQgPSBjbG9zZXN0UG9pbnRUb1RyaWFuZ2xlKCBwb2ludCwgYSwgYiwgYywgbG9jYWxCYXJ5Y29vcmQgKTtcblx0XHR2ZWMzIGRlbHRhID0gcG9pbnQgLSBjbG9zZXN0UG9pbnQ7XG5cdFx0ZmxvYXQgc3FEaXN0ID0gZG90MiggZGVsdGEgKTtcblx0XHRpZiAoIHNxRGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgKSB7XG5cblx0XHRcdC8vIHNldCB0aGUgb3V0cHV0IHJlc3VsdHNcblx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBzcURpc3Q7XG5cdFx0XHRmYWNlSW5kaWNlcyA9IHV2ZWM0KCBpbmRpY2VzLnh5eiwgaSApO1xuXHRcdFx0ZmFjZU5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGEgLSBiLCBiIC0gYyApICk7XG5cdFx0XHRiYXJ5Y29vcmQgPSBsb2NhbEJhcnljb29yZDtcblx0XHRcdG91dFBvaW50ID0gY2xvc2VzdFBvaW50O1xuXHRcdFx0c2lkZSA9IHNpZ24oIGRvdCggZmFjZU5vcm1hbCwgZGVsdGEgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gY2xvc2VzdERpc3RhbmNlU3F1YXJlZDtcblxufVxuXG5mbG9hdCBkaXN0YW5jZVNxVG9Cb3VuZHMoIHZlYzMgcG9pbnQsIHZlYzMgYm91bmRzTWluLCB2ZWMzIGJvdW5kc01heCApIHtcblxuXHR2ZWMzIGNsYW1wZWRQb2ludCA9IGNsYW1wKCBwb2ludCwgYm91bmRzTWluLCBib3VuZHNNYXggKTtcblx0dmVjMyBkZWx0YSA9IHBvaW50IC0gY2xhbXBlZFBvaW50O1xuXHRyZXR1cm4gZG90KCBkZWx0YSwgZGVsdGEgKTtcblxufVxuXG5mbG9hdCBkaXN0YW5jZVNxVG9CVkhOb2RlQm91bmRzUG9pbnQoIHZlYzMgcG9pbnQsIEJWSCBidmgsIHVpbnQgY3Vyck5vZGVJbmRleCApIHtcblxuXHR2ZWMzIGJvdW5kc01pbiA9IHRleGVsRmV0Y2gxRCggYnZoLmJ2aEJvdW5kcywgY3Vyck5vZGVJbmRleCAqIDJ1ICsgMHUgKS54eXo7XG5cdHZlYzMgYm91bmRzTWF4ID0gdGV4ZWxGZXRjaDFEKCBidmguYnZoQm91bmRzLCBjdXJyTm9kZUluZGV4ICogMnUgKyAxdSApLnh5ejtcblx0cmV0dXJuIGRpc3RhbmNlU3FUb0JvdW5kcyggcG9pbnQsIGJvdW5kc01pbiwgYm91bmRzTWF4ICk7XG5cbn1cblxuZmxvYXQgYnZoQ2xvc2VzdFBvaW50VG9Qb2ludChcblx0QlZIIGJ2aCwgdmVjMyBwb2ludCxcblxuXHQvLyBvdXRwdXQgdmFyaWFibGVzXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLFxuXHRpbm91dCBmbG9hdCBzaWRlLCBpbm91dCB2ZWMzIG91dFBvaW50XG4gKSB7XG5cblx0Ly8gc3RhY2sgbmVlZHMgdG8gYmUgdHdpY2UgYXMgbG9uZyBhcyB0aGUgZGVlcGVzdCB0cmVlIHdlIGV4cGVjdCBiZWNhdXNlXG5cdC8vIHdlIHB1c2ggYm90aCB0aGUgbGVmdCBhbmQgcmlnaHQgY2hpbGQgb250byB0aGUgc3RhY2sgZXZlcnkgdHJhdmVyc2FsXG5cdGludCBwdHIgPSAwO1xuXHR1aW50IHN0YWNrWyA2MCBdO1xuXHRzdGFja1sgMCBdID0gMHU7XG5cdGZsb2F0IGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBwb3coIDEwMDAwMC4wLCAyLjAgKTtcblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR3aGlsZSAoIHB0ciA+IC0gMSAmJiBwdHIgPCA2MCApIHtcblxuXHRcdHVpbnQgY3Vyck5vZGVJbmRleCA9IHN0YWNrWyBwdHIgXTtcblx0XHRwdHIgLS07XG5cblx0XHQvLyBjaGVjayBpZiB3ZSBpbnRlcnNlY3QgdGhlIGN1cnJlbnQgYm91bmRzXG5cdFx0ZmxvYXQgYm91bmRzSGl0RGlzdGFuY2UgPSBkaXN0YW5jZVNxVG9CVkhOb2RlQm91bmRzUG9pbnQoIHBvaW50LCBidmgsIGN1cnJOb2RlSW5kZXggKTtcblx0XHRpZiAoIGJvdW5kc0hpdERpc3RhbmNlID4gY2xvc2VzdERpc3RhbmNlU3F1YXJlZCApIHtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHR1dmVjMiBib3VuZHNJbmZvID0gdVRleGVsRmV0Y2gxRCggYnZoLmJ2aENvbnRlbnRzLCBjdXJyTm9kZUluZGV4ICkueHk7XG5cdFx0Ym9vbCBpc0xlYWYgPSBib29sKCBib3VuZHNJbmZvLnggJiAweGZmZmYwMDAwdSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHRcdFx0XHRidmgsIHBvaW50LCBvZmZzZXQsIGNvdW50LCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkLFxuXG5cdFx0XHRcdC8vIG91dHB1dHNcblx0XHRcdFx0ZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgb3V0UG9pbnRcblx0XHRcdCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cdFx0XHRib29sIGxlZnRUb1JpZ2h0ID0gZGlzdGFuY2VTcVRvQlZITm9kZUJvdW5kc1BvaW50KCBwb2ludCwgYnZoLCBsZWZ0SW5kZXggKSA8IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aCwgcmlnaHRJbmRleCApOy8vcmF5RGlyZWN0aW9uWyBzcGxpdEF4aXMgXSA+PSAwLjA7XG5cdFx0XHR1aW50IGMxID0gbGVmdFRvUmlnaHQgPyBsZWZ0SW5kZXggOiByaWdodEluZGV4O1xuXHRcdFx0dWludCBjMiA9IGxlZnRUb1JpZ2h0ID8gcmlnaHRJbmRleCA6IGxlZnRJbmRleDtcblxuXHRcdFx0Ly8gc2V0IGMyIGluIHRoZSBzdGFjayBzbyB3ZSB0cmF2ZXJzZSBpdCBsYXRlci4gV2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGEgcG9pbnRlciBpblxuXHRcdFx0Ly8gdGhlIHN0YWNrIHdoaWxlIHdlIHRyYXZlcnNlLiBUaGUgc2Vjb25kIHBvaW50ZXIgYWRkZWQgaXMgdGhlIG9uZSB0aGF0IHdpbGwgYmVcblx0XHRcdC8vIHRyYXZlcnNlZCBmaXJzdFxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzI7XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgKTtcblxufVxuYDtcblxuXHRjb25zdCBfcG9zaXRpb25WZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF9ub3JtYWxWZWN0b3IgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3IzKCk7XG5cdGNvbnN0IF90YW5nZW50VmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGFuZ2VudFZlY3RvcjQgPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5WZWN0b3I0KCk7XG5cblx0Y29uc3QgX21vcnBoVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGVtcCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfc2tpbkluZGV4ID0gLypAX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yNCgpO1xuXHRjb25zdCBfc2tpbldlaWdodCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjQoKTtcblx0Y29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0Y29uc3QgX2JvbmVNYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG5cblx0Ly8gQ29uZmlybXMgdGhhdCB0aGUgdHdvIHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIGNvbXBhdGlibGVcblx0ZnVuY3Rpb24gdmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyMSwgYXR0cjIgKSB7XG5cblx0XHRpZiAoICEgYXR0cjEgJiYgISBhdHRyMiApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2FtZUNvdW50ID0gYXR0cjEuY291bnQgPT09IGF0dHIyLmNvdW50O1xuXHRcdGNvbnN0IHNhbWVOb3JtYWxpemVkID0gYXR0cjEubm9ybWFsaXplZCA9PT0gYXR0cjIubm9ybWFsaXplZDtcblx0XHRjb25zdCBzYW1lVHlwZSA9IGF0dHIxLmFycmF5LmNvbnN0cnVjdG9yID09PSBhdHRyMi5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCBzYW1lSXRlbVNpemUgPSBhdHRyMS5pdGVtU2l6ZSA9PT0gYXR0cjIuaXRlbVNpemU7XG5cblx0XHRpZiAoICEgc2FtZUNvdW50IHx8ICEgc2FtZU5vcm1hbGl6ZWQgfHwgISBzYW1lVHlwZSB8fCAhIHNhbWVJdGVtU2l6ZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIENsb25lcyB0aGUgZ2l2ZW4gYXR0cmlidXRlIHdpdGggYSBuZXcgY29tcGF0aWJsZSBidWZmZXIgYXR0cmlidXRlIGJ1dCBubyBkYXRhXG5cdGZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyLCBjb3VudE92ZXJyaWRlID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IGNvbnMgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG5cdFx0Y29uc3QgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdGNvbnN0IGNvdW50ID0gY291bnRPdmVycmlkZSA9PT0gbnVsbCA/IGF0dHIuY291bnQgOiBjb3VudE92ZXJyaWRlO1xuXG5cdFx0cmV0dXJuIG5ldyB0aHJlZS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBjb25zKCBpdGVtU2l6ZSAqIGNvdW50ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG5cdC8vIHRhcmdldCBvZmZzZXQgaXMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdGFyZ2V0IGJ1ZmZlciBzdHJpZGUgdG8gc2tpcCBiZWZvcmUgY29weWluZyB0aGVcblx0Ly8gYXR0cmlidXRlcyBjb250ZW50cyBpbiB0by5cblx0ZnVuY3Rpb24gY29weUF0dHJpYnV0ZUNvbnRlbnRzKCBhdHRyLCB0YXJnZXQsIHRhcmdldE9mZnNldCA9IDAgKSB7XG5cblx0XHRpZiAoIGF0dHIuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc3QgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ci5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaW8gPSBpICsgdGFyZ2V0T2Zmc2V0O1xuXHRcdFx0XHR0YXJnZXQuc2V0WCggaW8sIGF0dHIuZ2V0WCggaSApICk7XG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMiApIHRhcmdldC5zZXRZKCBpbywgYXR0ci5nZXRZKCBpICkgKTtcblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAzICkgdGFyZ2V0LnNldFooIGlvLCBhdHRyLmdldFooIGkgKSApO1xuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDQgKSB0YXJnZXQuc2V0VyggaW8sIGF0dHIuZ2V0VyggaSApICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGFycmF5ID0gdGFyZ2V0LmFycmF5O1xuXHRcdFx0Y29uc3QgY29ucyA9IGFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdFx0Y29uc3QgYnl0ZU9mZnNldCA9IGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogYXR0ci5pdGVtU2l6ZSAqIHRhcmdldE9mZnNldDtcblx0XHRcdGNvbnN0IHRlbXAgPSBuZXcgY29ucyggYXJyYXkuYnVmZmVyLCBieXRlT2Zmc2V0LCBhdHRyLmFycmF5Lmxlbmd0aCApO1xuXHRcdFx0dGVtcC5zZXQoIGF0dHIuYXJyYXkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkcyB0aGUgXCJtYXRyaXhcIiBtdWx0aXBsaWVkIGJ5IFwic2NhbGVcIiB0byBcInRhcmdldFwiXG5cdGZ1bmN0aW9uIGFkZFNjYWxlZE1hdHJpeCggdGFyZ2V0LCBtYXRyaXgsIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGFyZ2V0QXJyYXkgPSB0YXJnZXQuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWF0cml4QXJyYXkgPSBtYXRyaXguZWxlbWVudHM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWF0cml4QXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGFyZ2V0QXJyYXlbIGkgXSArPSBtYXRyaXhBcnJheVsgaSBdICogc2NhbGU7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEEgdmVyc2lvbiBvZiBcIlNraW5uZWRNZXNoLmJvbmVUcmFuc2Zvcm1cIiBmb3Igbm9ybWFsc1xuXHRmdW5jdGlvbiBib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpbmRleCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRjb25zdCBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xuXHRcdGNvbnN0IGJvbmVJbnZlcnNlcyA9IHNrZWxldG9uLmJvbmVJbnZlcnNlcztcblxuXHRcdF9za2luSW5kZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luSW5kZXgsIGluZGV4ICk7XG5cdFx0X3NraW5XZWlnaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0LCBpbmRleCApO1xuXG5cdFx0X21hdHJpeC5lbGVtZW50cy5maWxsKCAwICk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRjb25zdCB3ZWlnaHQgPSBfc2tpbldlaWdodC5nZXRDb21wb25lbnQoIGkgKTtcblxuXHRcdFx0aWYgKCB3ZWlnaHQgIT09IDAgKSB7XG5cblx0XHRcdFx0Y29uc3QgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoIGkgKTtcblx0XHRcdFx0X2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggYm9uZXNbIGJvbmVJbmRleCBdLm1hdHJpeFdvcmxkLCBib25lSW52ZXJzZXNbIGJvbmVJbmRleCBdICk7XG5cblx0XHRcdFx0YWRkU2NhbGVkTWF0cml4KCBfbWF0cml4LCBfYm9uZU1hdHJpeCwgd2VpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF9tYXRyaXgubXVsdGlwbHkoIG1lc2guYmluZE1hdHJpeCApLnByZW11bHRpcGx5KCBtZXNoLmJpbmRNYXRyaXhJbnZlcnNlICk7XG5cdFx0dGFyZ2V0LnRyYW5zZm9ybURpcmVjdGlvbiggX21hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Ly8gQXBwbGllcyB0aGUgbW9ycGggdGFyZ2V0IGRhdGEgdG8gdGhlIHRhcmdldCB2ZWN0b3Jcblx0ZnVuY3Rpb24gYXBwbHlNb3JwaFRhcmdldCggbW9ycGhEYXRhLCBtb3JwaEluZmx1ZW5jZXMsIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLCBpLCB0YXJnZXQgKSB7XG5cblx0XHRfbW9ycGhWZWN0b3Iuc2V0KCAwLCAwLCAwICk7XG5cdFx0Zm9yICggbGV0IGogPSAwLCBqbCA9IG1vcnBoRGF0YS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyBqIF07XG5cdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoRGF0YVsgaiBdO1xuXG5cdFx0XHRpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHRfdGVtcC5mcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSwgaSApO1xuXG5cdFx0XHRpZiAoIG1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdF9tb3JwaFZlY3Rvci5hZGRTY2FsZWRWZWN0b3IoIF90ZW1wLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfbW9ycGhWZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcC5zdWIoIHRhcmdldCApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0LmFkZCggX21vcnBoVmVjdG9yICk7XG5cblx0fVxuXG5cdC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgQnVmZmVyR2VvbWV0cnlVdGlscy5tZXJnZUJ1ZmZlckdlb21ldHJpZXMgdGhhdCBpZ25vcmVzIG1vcnBoIHRhcmdldHMgYW5kIHVwZGF0ZXMgYSBhdHRyaWJ1dGVzIGluIHBsYWNlXG5cdGZ1bmN0aW9uIG1lcmdlQnVmZmVyR2VvbWV0cmllcyggZ2VvbWV0cmllcywgb3B0aW9ucyA9IHsgdXNlR3JvdXBzOiBmYWxzZSwgdXBkYXRlSW5kZXg6IGZhbHNlLCBza2lwQXR0cmlidXRlczogW10gfSwgdGFyZ2V0R2VvbWV0cnkgPSBuZXcgdGhyZWUuQnVmZmVyR2VvbWV0cnkoKSApIHtcblxuXHRcdGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbIDAgXS5pbmRleCAhPT0gbnVsbDtcblx0XHRjb25zdCB7IHVzZUdyb3VwcyA9IGZhbHNlLCB1cGRhdGVJbmRleCA9IGZhbHNlLCBza2lwQXR0cmlidXRlcyA9IFtdIH0gPSBvcHRpb25zO1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KCBPYmplY3Qua2V5cyggZ2VvbWV0cmllc1sgMCBdLmF0dHJpYnV0ZXMgKSApO1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdGxldCBvZmZzZXQgPSAwO1xuXG5cdFx0dGFyZ2V0R2VvbWV0cnkuY2xlYXJHcm91cHMoKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpIF07XG5cdFx0XHRsZXQgYXR0cmlidXRlc0NvdW50ID0gMDtcblxuXHRcdFx0Ly8gZW5zdXJlIHRoYXQgYWxsIGdlb21ldHJpZXMgYXJlIGluZGV4ZWQsIG9yIG5vbmVcblx0XHRcdGlmICggaXNJbmRleGVkICE9PSAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdhdGhlciBhdHRyaWJ1dGVzLCBleGl0IGVhcmx5IGlmIHRoZXkncmUgZGlmZmVyZW50XG5cdFx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0aWYgKCAhIGF0dHJpYnV0ZXNVc2VkLmhhcyggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBcIicgKyBuYW1lICsgJ1wiIGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdLnB1c2goIGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xuXHRcdFx0XHRhdHRyaWJ1dGVzQ291bnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlc1xuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU3RhdGljR2VvbWV0cnlHZW5lcmF0b3I6IE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHVzZUdyb3VwcyApIHtcblxuXHRcdFx0XHRsZXQgY291bnQ7XG5cdFx0XHRcdGlmICggaXNJbmRleGVkICkge1xuXG5cdFx0XHRcdFx0Y291bnQgPSBnZW9tZXRyeS5pbmRleC5jb3VudDtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb3VudCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZScgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuYWRkR3JvdXAoIG9mZnNldCwgY291bnQsIGkgKTtcblx0XHRcdFx0b2Zmc2V0ICs9IGNvdW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBtZXJnZSBpbmRpY2VzXG5cdFx0aWYgKCBpc0luZGV4ZWQgKSB7XG5cblx0XHRcdGxldCBmb3JjZVVwZGF0ZUluZGV4ID0gZmFsc2U7XG5cdFx0XHRpZiAoICEgdGFyZ2V0R2VvbWV0cnkuaW5kZXggKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4Q291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdGluZGV4Q291bnQgKz0gZ2VvbWV0cmllc1sgaSBdLmluZGV4LmNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRJbmRleCggbmV3IHRocmVlLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBpbmRleENvdW50ICksIDEsIGZhbHNlICkgKTtcblx0XHRcdFx0Zm9yY2VVcGRhdGVJbmRleCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1cGRhdGVJbmRleCB8fCBmb3JjZVVwZGF0ZUluZGV4ICkge1xuXG5cdFx0XHRcdGNvbnN0IHRhcmdldEluZGV4ID0gdGFyZ2V0R2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGxldCB0YXJnZXRPZmZzZXQgPSAwO1xuXHRcdFx0XHRsZXQgaW5kZXhPZmZzZXQgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdFx0aWYgKCBza2lwQXR0cmlidXRlc1sgaSBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpbmRleC5jb3VudDsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0XHR0YXJnZXRJbmRleC5zZXRYKCB0YXJnZXRPZmZzZXQsIGluZGV4LmdldFgoIGogKSArIGluZGV4T2Zmc2V0ICk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldE9mZnNldCArKztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5kZXhPZmZzZXQgKz0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIG1lcmdlIGF0dHJpYnV0ZXNcblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJMaXN0ID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdFx0aWYgKCAhICggbmFtZSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkgKSB7XG5cblx0XHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdFx0Zm9yICggY29uc3Qga2V5IGluIGF0dHJMaXN0ICkge1xuXG5cdFx0XHRcdFx0Y291bnQgKz0gYXR0ckxpc3RbIGtleSBdLmNvdW50O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoIG5hbWUsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzWyBuYW1lIF1bIDAgXSwgY291bnQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZSA9IHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdGxldCBvZmZzZXQgPSAwO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyID0gYXR0ckxpc3RbIGkgXTtcblx0XHRcdFx0aWYgKCBza2lwQXR0cmlidXRlc1sgaSBdICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Y29weUF0dHJpYnV0ZUNvbnRlbnRzKCBhdHRyLCB0YXJnZXRBdHRyaWJ1dGUsIG9mZnNldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvZmZzZXQgKz0gYXR0ci5jb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldEdlb21ldHJ5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggYSwgYiApIHtcblxuXHRcdGlmICggYSA9PT0gbnVsbCB8fCBiID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gYSA9PT0gYjtcblxuXHRcdH1cblxuXHRcdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggYVsgaSBdICE9PSBiWyBpIF0gKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0Ly8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdlb21ldHJ5IGNoYW5nZWQgYmV0d2VlbiB0aGlzIGFuZCBsYXN0IGV2YWx1YXRpb25cblx0Y2xhc3MgR2VvbWV0cnlEaWZmIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoICkge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IHRocmVlLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuZ2VvbWV0cnlIYXNoID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSAtIDE7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgcHJpbWl0aXZlQ291bnQgPSAoIGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguY291bnQgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICkgLyAzO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5SGFzaCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbjtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSBwcmltaXRpdmVDb3VudDtcblxuXHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHQvLyBlbnN1cmUgdGhlIGJvbmUgbWF0cml4IGFycmF5IGlzIHVwZGF0ZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGxlbmd0aFxuXHRcdFx0XHRpZiAoICEgc2tlbGV0b24uYm9uZVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0Ly8gY29weSBkYXRhIGlmIHBvc3NpYmxlIG90aGVyd2lzZSBjbG9uZSBpdFxuXHRcdFx0XHRjb25zdCBib25lTWF0cmljZXMgPSBza2VsZXRvbi5ib25lTWF0cmljZXM7XG5cdFx0XHRcdGlmICggISB0aGlzLmJvbmVNYXRyaWNlcyB8fCB0aGlzLmJvbmVNYXRyaWNlcy5sZW5ndGggIT09IGJvbmVNYXRyaWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcy5zbGljZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcy5zZXQoIGJvbmVNYXRyaWNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpZENoYW5nZSgpIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gKCBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmNvdW50IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCApIC8gMztcblx0XHRcdGNvbnN0IGlkZW50aWNhbCA9XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZXF1YWxzKCBtZXNoLm1hdHJpeFdvcmxkICkgJiZcblx0XHRcdFx0dGhpcy5nZW9tZXRyeUhhc2ggPT09IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbiAmJlxuXHRcdFx0XHRjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggbWVzaC5za2VsZXRvbiAmJiBtZXNoLnNrZWxldG9uLmJvbmVNYXRyaWNlcyB8fCBudWxsLCB0aGlzLmJvbmVNYXRyaWNlcyApICYmXG5cdFx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPT09IHByaW1pdGl2ZUNvdW50O1xuXG5cdFx0XHRyZXR1cm4gISBpZGVudGljYWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoZXMgKSB7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBtZXNoZXMgKSApIHtcblxuXHRcdFx0XHRtZXNoZXMgPSBbIG1lc2hlcyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpbmFsTWVzaGVzID0gW107XG5cdFx0XHRtZXNoZXMuZm9yRWFjaCggb2JqZWN0ID0+IHtcblxuXHRcdFx0XHRvYmplY3QudHJhdmVyc2VWaXNpYmxlKCBjID0+IHtcblxuXHRcdFx0XHRcdGlmICggYy5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRcdGZpbmFsTWVzaGVzLnB1c2goIGMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5tZXNoZXMgPSBmaW5hbE1lc2hlcztcblx0XHRcdHRoaXMudXNlR3JvdXBzID0gdHJ1ZTtcblx0XHRcdHRoaXMuYXBwbHlXb3JsZFRyYW5zZm9ybXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gWyAncG9zaXRpb24nLCAnbm9ybWFsJywgJ2NvbG9yJywgJ3RhbmdlbnQnLCAndXYnLCAndXYyJyBdO1xuXHRcdFx0dGhpcy5faW50ZXJtZWRpYXRlR2VvbWV0cnkgPSBuZXcgQXJyYXkoIGZpbmFsTWVzaGVzLmxlbmd0aCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyB0aHJlZS5CdWZmZXJHZW9tZXRyeSgpICk7XG5cdFx0XHR0aGlzLl9kaWZmTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdH1cblxuXHRcdGdldE1hdGVyaWFscygpIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gW107XG5cdFx0XHR0aGlzLm1lc2hlcy5mb3JFYWNoKCBtZXNoID0+IHtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCAuLi5tZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fVxuXG5cdFx0Z2VuZXJhdGUoIHRhcmdldEdlb21ldHJ5ID0gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdC8vIHRyYWNrIHdoaWNoIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgYW5kIHdoaWNoIHRvIHNraXAgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYXR0cmlidXRlIGNvcGllc1xuXHRcdFx0bGV0IHNraXBBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCB7IG1lc2hlcywgdXNlR3JvdXBzLCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIF9kaWZmTWFwIH0gPSB0aGlzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IG1lc2hlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBnZW9tID0gX2ludGVybWVkaWF0ZUdlb21ldHJ5WyBpIF07XG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBfZGlmZk1hcC5nZXQoIG1lc2ggKTtcblx0XHRcdFx0aWYgKCAhIGRpZmYgfHwgZGlmZi5kaWRDaGFuZ2UoIG1lc2ggKSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NvbnZlcnRUb1N0YXRpY0dlb21ldHJ5KCBtZXNoLCBnZW9tICk7XG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggISBkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRfZGlmZk1hcC5zZXQoIG1lc2gsIG5ldyBHZW9tZXRyeURpZmYoIG1lc2ggKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlmZi51cGRhdGUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRtZXJnZUJ1ZmZlckdlb21ldHJpZXMoIF9pbnRlcm1lZGlhdGVHZW9tZXRyeSwgeyB1c2VHcm91cHMsIHNraXBBdHRyaWJ1dGVzIH0sIHRhcmdldEdlb21ldHJ5ICk7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRfY29udmVydFRvU3RhdGljR2VvbWV0cnkoIG1lc2gsIHRhcmdldEdlb21ldHJ5ID0gbmV3IHRocmVlLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGFwcGx5V29ybGRUcmFuc2Zvcm1zID0gdGhpcy5hcHBseVdvcmxkVHJhbnNmb3Jtcztcblx0XHRcdGNvbnN0IGluY2x1ZGVOb3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMuaW5jbHVkZXMoICdub3JtYWwnICk7XG5cdFx0XHRjb25zdCBpbmNsdWRlVGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy5pbmNsdWRlcyggJ3RhbmdlbnQnICk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZXMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIHRoZSBhdHRyaWJ1dGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3Rcblx0XHRcdGlmICggISB0YXJnZXRHZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5jbHVkZU5vcm1hbCAmJiAhIHRhcmdldEF0dHJpYnV0ZXMubm9ybWFsICYmIGF0dHJpYnV0ZXMubm9ybWFsICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzLm5vcm1hbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmNsdWRlVGFuZ2VudCAmJiAhIHRhcmdldEF0dHJpYnV0ZXMudGFuZ2VudCAmJiBhdHRyaWJ1dGVzLnRhbmdlbnQgKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAndGFuZ2VudCcsIGNyZWF0ZUF0dHJpYnV0ZUNsb25lKCBhdHRyaWJ1dGVzLnRhbmdlbnQgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSB0aGUgYXR0cmlidXRlcyBhcmUgY29uc2lzdGVudFxuXHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBnZW9tZXRyeS5pbmRleCwgdGFyZ2V0R2VvbWV0cnkuaW5kZXggKTtcblx0XHRcdHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cmlidXRlcy5wb3NpdGlvbiwgdGFyZ2V0QXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXG5cdFx0XHRpZiAoIGluY2x1ZGVOb3JtYWwgKSB7XG5cblx0XHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLm5vcm1hbCwgdGFyZ2V0QXR0cmlidXRlcy5ub3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluY2x1ZGVUYW5nZW50ICkge1xuXG5cdFx0XHRcdHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cmlidXRlcy50YW5nZW50LCB0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm1lZCB2ZXJ0ZXggYXR0cmlidXRlIGRhdGFcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG5vcm1hbCA9IGluY2x1ZGVOb3JtYWwgPyBhdHRyaWJ1dGVzLm5vcm1hbCA6IG51bGw7XG5cdFx0XHRjb25zdCB0YW5nZW50ID0gaW5jbHVkZVRhbmdlbnQgPyBhdHRyaWJ1dGVzLnRhbmdlbnQgOiBudWxsO1xuXHRcdFx0Y29uc3QgbW9ycGhQb3NpdGlvbiA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdGNvbnN0IG1vcnBoTm9ybWFsID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbDtcblx0XHRcdGNvbnN0IG1vcnBoVGFuZ2VudCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy50YW5nZW50O1xuXHRcdFx0Y29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblx0XHRcdGNvbnN0IG1vcnBoSW5mbHVlbmNlcyA9IG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXHRcdFx0Y29uc3Qgbm9ybWFsTWF0cml4ID0gbmV3IHRocmVlLk1hdHJpeDMoKTtcblx0XHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG1lc2gubWF0cml4V29ybGQgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3I0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRhbmdlbnQsIGkgKTtcblx0XHRcdFx0XHRfdGFuZ2VudFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0YW5nZW50LCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IG1vcnBoIHRhcmdldCB0cmFuc2Zvcm1cblx0XHRcdFx0aWYgKCBtb3JwaEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoUG9zaXRpb24sIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9wb3NpdGlvblZlY3RvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0YXBwbHlNb3JwaFRhcmdldCggbW9ycGhOb3JtYWwsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9ub3JtYWxWZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbW9ycGhUYW5nZW50ICkge1xuXG5cdFx0XHRcdFx0XHRhcHBseU1vcnBoVGFyZ2V0KCBtb3JwaFRhbmdlbnQsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IGJvbmUgdHJhbnNmb3JtXG5cdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0bWVzaC5hcHBseUJvbmVUcmFuc2Zvcm0oIGksIF9wb3NpdGlvblZlY3RvciApO1xuXHRcdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpLCBfbm9ybWFsVmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRhbmdlbnQgKSB7XG5cblx0XHRcdFx0XHRcdGJvbmVOb3JtYWxUcmFuc2Zvcm0oIG1lc2gsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgdmVjdG9ycyBvZiB0aGUgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGFwcGx5V29ybGRUcmFuc2Zvcm1zICkge1xuXG5cdFx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmFwcGx5TWF0cml4NCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWiggaSwgX3Bvc2l0aW9uVmVjdG9yLngsIF9wb3NpdGlvblZlY3Rvci55LCBfcG9zaXRpb25WZWN0b3IueiApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbC5zZXRYWVooIGksIF9ub3JtYWxWZWN0b3IueCwgX25vcm1hbFZlY3Rvci55LCBfbm9ybWFsVmVjdG9yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQuc2V0WFlaVyggaSwgX3RhbmdlbnRWZWN0b3IueCwgX3RhbmdlbnRWZWN0b3IueSwgX3RhbmdlbnRWZWN0b3IueiwgX3RhbmdlbnRWZWN0b3I0LncgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBvdGhlciBhdHRyaWJ1dGVzIG92ZXJcblx0XHRcdGZvciAoIGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IHRoaXMuYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICd0YW5nZW50JyB8fCBrZXkgPT09ICdub3JtYWwnIHx8ICEgKCBrZXkgaW4gYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sga2V5IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXHRcdFx0XHRjb3B5QXR0cmlidXRlQ29udGVudHMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0YXJnZXRHZW9tZXRyeTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZXhwb3J0cy5BVkVSQUdFID0gQVZFUkFHRTtcblx0ZXhwb3J0cy5DRU5URVIgPSBDRU5URVI7XG5cdGV4cG9ydHMuQ09OVEFJTkVEID0gQ09OVEFJTkVEO1xuXHRleHBvcnRzLkV4dGVuZGVkVHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlO1xuXHRleHBvcnRzLkZsb2F0VmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IEZsb2F0VmVydGV4QXR0cmlidXRlVGV4dHVyZTtcblx0ZXhwb3J0cy5JTlRFUlNFQ1RFRCA9IElOVEVSU0VDVEVEO1xuXHRleHBvcnRzLkludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLk1lc2hCVkggPSBNZXNoQlZIO1xuXHRleHBvcnRzLk1lc2hCVkhVbmlmb3JtU3RydWN0ID0gTWVzaEJWSFVuaWZvcm1TdHJ1Y3Q7XG5cdGV4cG9ydHMuTWVzaEJWSFZpc3VhbGl6ZXIgPSBNZXNoQlZIVmlzdWFsaXplcjtcblx0ZXhwb3J0cy5OT1RfSU5URVJTRUNURUQgPSBOT1RfSU5URVJTRUNURUQ7XG5cdGV4cG9ydHMuT3JpZW50ZWRCb3ggPSBPcmllbnRlZEJveDtcblx0ZXhwb3J0cy5TQUggPSBTQUg7XG5cdGV4cG9ydHMuU3RhdGljR2VvbWV0cnlHZW5lcmF0b3IgPSBTdGF0aWNHZW9tZXRyeUdlbmVyYXRvcjtcblx0ZXhwb3J0cy5VSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IFVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLlZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlO1xuXHRleHBvcnRzLmFjY2VsZXJhdGVkUmF5Y2FzdCA9IGFjY2VsZXJhdGVkUmF5Y2FzdDtcblx0ZXhwb3J0cy5jb21wdXRlQm91bmRzVHJlZSA9IGNvbXB1dGVCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmRpc3Bvc2VCb3VuZHNUcmVlID0gZGlzcG9zZUJvdW5kc1RyZWU7XG5cdGV4cG9ydHMuZXN0aW1hdGVNZW1vcnlJbkJ5dGVzID0gZXN0aW1hdGVNZW1vcnlJbkJ5dGVzO1xuXHRleHBvcnRzLmdldEJWSEV4dHJlbWVzID0gZ2V0QlZIRXh0cmVtZXM7XG5cdGV4cG9ydHMuZ2V0SlNPTlN0cnVjdHVyZSA9IGdldEpTT05TdHJ1Y3R1cmU7XG5cdGV4cG9ydHMuZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8gPSBnZXRUcmlhbmdsZUhpdFBvaW50SW5mbztcblx0ZXhwb3J0cy5zaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gc2hhZGVyRGlzdGFuY2VGdW5jdGlvbjtcblx0ZXhwb3J0cy5zaGFkZXJJbnRlcnNlY3RGdW5jdGlvbiA9IHNoYWRlckludGVyc2VjdEZ1bmN0aW9uO1xuXHRleHBvcnRzLnNoYWRlclN0cnVjdHMgPSBzaGFkZXJTdHJ1Y3RzO1xuXHRleHBvcnRzLnZhbGlkYXRlQm91bmRzID0gdmFsaWRhdGVCb3VuZHM7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LnVtZC5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/build/index.umd.cjs\n");

/***/ })

};
;